/* Generated automatically with "cito". Do not edit. */
#include <stdlib.h>
#include <string.h>
#include "ManicDigger.h"
typedef struct DictionaryStringByteArray DictionaryStringByteArray;
typedef struct NotifyMapAction NotifyMapAction;
typedef struct StringByteArray StringByteArray;

struct Acceleration {
	float acceleration1;
	float acceleration2;
	float acceleration3;
};
static void Acceleration_Construct(Acceleration *self);

typedef struct {
	void (*run)(Action_ *self);
}
Action_Vtbl;
struct Action_ {
	const Action_Vtbl *vtbl;
};
static void Action__Construct(Action_ *self, const Action_Vtbl *vtbl);

static int AngleInterpolation_NormalizeAngle256(int v);
static float AngleInterpolation_NormalizeAngle360(GamePlatform const *platform, float v);

struct AnimatedModel {
	int animationsCount;
	int keyframesCount;
	int nodesCount;
	Animation **animations;
	AnimationGlobal *global;
	Keyframe **keyframes;
	Node **nodes;
};
static void AnimatedModel_Construct(AnimatedModel *self);

typedef struct {
	void (*get)(TableBinding *self, const char *table, int index, DictionaryStringString const *items);
	void (*set)(TableBinding *self, const char *table, int index, const char *column, const char *value);
}
TableBindingVtbl;
struct TableBinding {
	const TableBindingVtbl *vtbl;
};
static void TableBinding_Construct(TableBinding *self, const TableBindingVtbl *vtbl);

struct AnimatedModelBinding {
	TableBinding base;
	AnimatedModel *m;
	GamePlatform const *p;
};
static void AnimatedModelBinding_Construct(AnimatedModelBinding *self, const TableBindingVtbl *vtbl);
static float AnimatedModelBinding_FloatParse(AnimatedModelBinding const *self, const char *s);
static int AnimatedModelBinding_IntParse(AnimatedModelBinding const *self, const char *s);
static const TableBindingVtbl CiVtbl_AnimatedModelBinding = {
	(void (*)(TableBinding *self, const char *table, int index, DictionaryStringString const *items)) AnimatedModelBinding_Get,
	(void (*)(TableBinding *self, const char *table, int index, const char *column, const char *value)) AnimatedModelBinding_Set
};

struct AnimatedModelRenderer {
	int anim;
	float frame;
	Game const *game;
	AnimatedModel const *m;
	float one;
	float *tempVec3;
	Keyframe const **tempframes;
	IntRef *tempframesCount;
};
static void AnimatedModelRenderer_Construct(AnimatedModelRenderer *self);
static void AnimatedModelRenderer_DrawNode(AnimatedModelRenderer const *self, const char *parent, float headDeg, float light);
static void AnimatedModelRenderer_GetAnimation(AnimatedModelRenderer const *self, Node const *node, float *ret, int type);
static void AnimatedModelRenderer_GetDefaultFrame(AnimatedModelRenderer const *self, Node const *node, int type, float *ret);
static int AnimatedModelRenderer_GetFrameCurrent(AnimatedModelRenderer const *self, Keyframe const *const *frames, int framesCount);
static void AnimatedModelRenderer_GetFrames(AnimatedModelRenderer const *self, const char *nodeName, int type, Keyframe const **frames, IntRef *count);
static cibool AnimatedModelRenderer_IsZero(AnimatedModelRenderer const *self, float const *vec);
static float AnimatedModelRenderer_Lerp(AnimatedModelRenderer const *self, float v0, float v1, float t);


struct Animation {
	int length;
	const char *name;
};

struct AnimationGlobal {
	int texh;
	int texw;
};

struct AnimationHint {
	cibool inVehicle;
	cibool leanleft;
	cibool leanright;
	float drawFixX;
	float drawFixY;
	float drawFixZ;
};

struct AnimationState {
	cibool fullbodyrotate;
	float bodyrotation;
	float headbodydelta;
	float interp;
	float lastheading;
	float light;
	float speed;
};
static void AnimationState_Construct(AnimationState *self);

struct Asset {
	int dataLength;
	unsigned char const *data;
	const char *md5;
	const char *name;
};

struct AssetList {
	int count;
	Asset const **items;
};


struct AudioControl {
	int soundsCount;
	Sound_ **sounds;
};
static void AudioControl_Construct(AudioControl *self);



typedef struct {
	void (*addFrame)(AviWriterCi *self, BitmapCi const *bitmap);
	void (*close)(AviWriterCi *self);
	void (*open)(AviWriterCi *self, const char *filename, int framerate, int width, int height);
}
AviWriterCiVtbl;
struct AviWriterCi {
	const AviWriterCiVtbl *vtbl;
};
static void AviWriterCi_Construct(AviWriterCi *self, const AviWriterCiVtbl *vtbl);

struct BackgroundAction {
	Action_ base;
	cibool active;
	cibool finished;
	int i;
	float dt;
	Game const *game;
};
static void BackgroundAction_Construct(BackgroundAction *self, const Action_Vtbl *vtbl);
static const Action_Vtbl CiVtbl_BackgroundAction = {
	(void (*)(Action_ *self)) BackgroundAction_Run
};


typedef struct {
	void (*dispose)(BitmapCi *self);
}
BitmapCiVtbl;
struct BitmapCi {
	const BitmapCiVtbl *vtbl;
};
static void BitmapCi_Construct(BitmapCi *self, const BitmapCiVtbl *vtbl);
static const BitmapCiVtbl CiVtbl_BitmapCi = {
	BitmapCi_Dispose
};

struct BitmapData_ {
	int height;
	int width;
	int *argb;
};

struct BlockOctreeSearcher {
	int lCount;
	int listpool_i;
	int pool_i;
	Box3D const *startBox;
	float *currentHit;
	Line3D const *currentLine;
	Intersection const *intersection;
	BlockPosSide const **l;
	ListBox3d **listpool;
	GamePlatform const *platform;
	Box3D const **pool;
};
static void BlockOctreeSearcher_Construct(BlockOctreeSearcher *self);
static ListBox3d *BlockOctreeSearcher_Children(BlockOctreeSearcher *self, Box3D const *box);
static ListBox3d const *BlockOctreeSearcher_Search(BlockOctreeSearcher *self, PredicateBox3D const *query);
static ListBox3d *BlockOctreeSearcher_SearchPrivate(BlockOctreeSearcher *self, PredicateBox3D const *query, Box3D const *box);
static Box3D *BlockOctreeSearcher_newBox3d(BlockOctreeSearcher *self);
static ListBox3d *BlockOctreeSearcher_newListBox3d(BlockOctreeSearcher *self);
static void BlockOctreeSearcher_recycleListBox3d(BlockOctreeSearcher *self, ListBox3d *l);

struct BlockPosSide {
	float *blockPos;
	float const *collisionPos;
};
static void BlockPosSide_Construct(BlockPosSide *self);

struct BlockRendererTorch {
	int sideTexture;
	int topTexture;
};

struct BlockTypeSimple {
	Packet_BlockType *block;
};
static void BlockTypeSimple_Construct(BlockTypeSimple *self);

struct BoolRef {
	cibool value;
};

struct Box3D {
	float *maxEdge;
	float *minEdge;
};
static Box3D const *Box3D_Create(int x, int y, int z, int size);

struct Bullet_ {
	float fromX;
	float fromY;
	float fromZ;
	float progress;
	float speed;
	float toX;
	float toY;
	float toZ;
};

struct Button {
	int fontcolor;
	int fontcolorselected;
	int fontsize;
	int height;
	cibool selected;
	int width;
	int x;
	int y;
	const char *text;
};
static void Button_Construct(Button *self);

struct ByteArray {
	int length;
	unsigned char *data;
};

struct CachedTextTexture {
	Text_ const *text;
	CachedTexture const *texture;
};

struct CachedTexture {
	int lastuseMilliseconds;
	int textureId;
	float sizeX;
	float sizeY;
};

struct CameraMove {
	cibool angleDown;
	cibool angleUp;
	cibool distanceDown;
	cibool distanceUp;
	int moveX;
	int moveY;
	cibool turnLeft;
	cibool turnRight;
	float distance;
};

struct CameraPoint {
	float orientationGlX;
	float orientationGlY;
	float orientationGlZ;
	float positionGlX;
	float positionGlY;
	float positionGlZ;
};

struct Chatline {
	cibool clickable;
	int timeMilliseconds;
	const char *linkTarget;
	const char *text;
};
static Chatline const *Chatline_Create(const char *text_, int timeMilliseconds_);
static Chatline const *Chatline_CreateClickable(const char *text_, int timeMilliseconds_, const char *linkTarget_);

struct Chunk {
	cibool baseLightDirty;
	unsigned char *baseLight;
	unsigned char *data;
	int *dataInt;
	RenderedChunk *rendered;
};
static void Chunk_Construct(Chunk *self);


struct ChunkSimple {
	int const *data;
};

typedef struct {
	cibool (*canSeek)(CitoStream *self);
	int (*position)(CitoStream *self);
	int (*read)(CitoStream *self, unsigned char const *buffer, int read, int p);
	int (*readByte)(CitoStream *self);
	void (*seek)(CitoStream *self, int length, CitoSeekOrigin seekOrigin);
	void (*seek_)(CitoStream *self, int p, CitoSeekOrigin seekOrigin);
	void (*write)(CitoStream *self, unsigned char const *val, int p, int p_3);
	void (*writeByte)(CitoStream *self, unsigned char p);
}
CitoStreamVtbl;
struct CitoStream {
	const CitoStreamVtbl *vtbl;
};
static void CitoStream_Construct(CitoStream *self, const CitoStreamVtbl *vtbl);

struct CitoMemoryStream {
	CitoStream base;
	int bufferlength;
	int count_;
	int position_;
	unsigned char *buffer_;
};
static void CitoMemoryStream_Construct(CitoMemoryStream *self, const CitoStreamVtbl *vtbl);
static const CitoStreamVtbl CiVtbl_CitoMemoryStream = {
	(cibool (*)(CitoStream *self)) CitoMemoryStream_CanSeek,
	(int (*)(CitoStream *self)) CitoMemoryStream_Position,
	(int (*)(CitoStream *self, unsigned char const *buffer, int read, int p)) CitoMemoryStream_Read,
	(int (*)(CitoStream *self)) CitoMemoryStream_ReadByte,
	(void (*)(CitoStream *self, int length, CitoSeekOrigin seekOrigin)) CitoMemoryStream_Seek,
	(void (*)(CitoStream *self, int p, CitoSeekOrigin seekOrigin)) CitoMemoryStream_Seek_,
	(void (*)(CitoStream *self, unsigned char const *val, int p, int p_3)) CitoMemoryStream_Write,
	(void (*)(CitoStream *self, unsigned char p)) CitoMemoryStream_WriteByte
};

struct ClientCommandArgs {
	const char *arguments;
	const char *command;
};

typedef struct {
	void (*inventoryClick)(IInventoryController *self, Packet_InventoryPosition const *pos);
	void (*moveToInventory)(IInventoryController *self, Packet_InventoryPosition const *from);
	void (*wearItem)(IInventoryController *self, Packet_InventoryPosition const *from, Packet_InventoryPosition const *to);
}
IInventoryControllerVtbl;
struct IInventoryController {
	const IInventoryControllerVtbl *vtbl;
};
static void IInventoryController_Construct(IInventoryController *self, const IInventoryControllerVtbl *vtbl);

struct ClientInventoryController {
	IInventoryController base;
	Game const *g;
};
static void ClientInventoryController_Construct(ClientInventoryController *self, const IInventoryControllerVtbl *vtbl);
static const IInventoryControllerVtbl CiVtbl_ClientInventoryController = {
	(void (*)(IInventoryController *self, Packet_InventoryPosition const *pos)) ClientInventoryController_InventoryClick,
	(void (*)(IInventoryController *self, Packet_InventoryPosition const *from)) ClientInventoryController_MoveToInventory,
	(void (*)(IInventoryController *self, Packet_InventoryPosition const *from, Packet_InventoryPosition const *to)) ClientInventoryController_WearItem
};

typedef struct {
	void (*dispose)(ClientMod *self, Game const *game);
	void (*onBeforeNewFrameDraw3d)(ClientMod *self, Game const *game, float deltaTime);
	cibool (*onClientCommand)(ClientMod *self, Game const *game, ClientCommandArgs const *args);
	void (*onHitEntity)(ClientMod *self, Game const *game, OnUseEntityArgs const *e);
	void (*onKeyDown)(ClientMod *self, Game const *game, KeyEventArgs const *args);
	void (*onKeyPress)(ClientMod *self, Game const *game, KeyPressEventArgs const *args);
	void (*onKeyUp)(ClientMod *self, Game const *game, KeyEventArgs const *args);
	void (*onMouseDown)(ClientMod *self, Game const *game, MouseEventArgs const *args);
	void (*onMouseMove)(ClientMod *self, Game const *game, MouseEventArgs const *args);
	void (*onMouseUp)(ClientMod *self, Game const *game, MouseEventArgs const *args);
	void (*onMouseWheelChanged)(ClientMod *self, Game const *game, MouseWheelEventArgs const *args);
	void (*onNewFrame)(ClientMod *self, Game const *game, NewFrameEventArgs const *args);
	void (*onNewFrameDraw2d)(ClientMod *self, Game const *game, float deltaTime);
	void (*onNewFrameDraw3d)(ClientMod *self, Game const *game, float deltaTime);
	void (*onNewFrameFixed)(ClientMod *self, Game const *game, NewFrameEventArgs const *args);
	void (*onNewFrameReadOnlyMainThread)(ClientMod *self, Game const *game, float deltaTime);
	void (*onReadOnlyBackgroundThread)(ClientMod *self, Game const *game, float dt);
	void (*onReadOnlyMainThread)(ClientMod *self, Game const *game, float dt);
	void (*onReadWriteMainThread)(ClientMod *self, Game const *game, float dt);
	void (*onTouchEnd)(ClientMod *self, Game const *game, TouchEventArgs const *e);
	void (*onTouchMove)(ClientMod *self, Game const *game, TouchEventArgs const *e);
	void (*onTouchStart)(ClientMod *self, Game const *game, TouchEventArgs const *e);
	void (*onUseEntity)(ClientMod *self, Game const *game, OnUseEntityArgs const *e);
	void (*start)(ClientMod *self, ClientModManager const *modmanager);
}
ClientModVtbl;
struct ClientMod {
	const ClientModVtbl *vtbl;
};
static void ClientMod_Construct(ClientMod *self, const ClientModVtbl *vtbl);
static const ClientModVtbl CiVtbl_ClientMod = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

typedef struct {
	AviWriterCi const *(*aviWriterCreate)(ClientModManager *self);
	void (*displayNotification)(ClientModManager *self, const char *message);
	void (*draw2dText)(ClientModManager *self, const char *text, float x, float y, float fontsize);
	void (*draw2dTexture)(ClientModManager *self, int textureid, float x1, float y1, float width, float height, IntRef const *inAtlasId, int color);
	void (*draw2dTextures)(ClientModManager *self, Draw2dData const *const *todraw, int todrawLength, int textureId);
	void (*enableCameraControl)(ClientModManager *self, cibool enable);
	int (*getFreemove)(ClientModManager *self);
	float (*getLocalOrientationX)(ClientModManager *self);
	float (*getLocalOrientationY)(ClientModManager *self);
	float (*getLocalOrientationZ)(ClientModManager *self);
	float (*getLocalPositionX)(ClientModManager *self);
	float (*getLocalPositionY)(ClientModManager *self);
	float (*getLocalPositionZ)(ClientModManager *self);
	DictionaryStringString const *(*getPerformanceInfo)(ClientModManager *self);
	GamePlatform const *(*getPlatform)(ClientModManager *self);
	int (*getWindowHeight)(ClientModManager *self);
	int (*getWindowWidth)(ClientModManager *self);
	BitmapCi const *(*grabScreenshot)(ClientModManager *self);
	cibool (*isFreemoveAllowed)(ClientModManager *self);
	void (*makeScreenshot)(ClientModManager *self);
	void (*orthoMode)(ClientModManager *self);
	void (*perspectiveMode)(ClientModManager *self);
	void (*sendChatMessage)(ClientModManager *self, const char *message);
	void (*setFreemove)(ClientModManager *self, int level);
	void (*setLocalOrientation)(ClientModManager *self, float glx, float gly, float glz);
	void (*setLocalPosition)(ClientModManager *self, float glx, float gly, float glz);
	void (*showGui)(ClientModManager *self, int level);
	int (*whiteTexture)(ClientModManager *self);
}
ClientModManagerVtbl;
struct ClientModManager {
	const ClientModManagerVtbl *vtbl;
};
static void ClientModManager_Construct(ClientModManager *self, const ClientModManagerVtbl *vtbl);

struct ClientModManager1 {
	ClientModManager base;
	Game *game;
};
static void ClientModManager1_Construct(ClientModManager1 *self, const ClientModManagerVtbl *vtbl);
static const ClientModManagerVtbl CiVtbl_ClientModManager1 = {
	(AviWriterCi const *(*)(ClientModManager *self)) ClientModManager1_AviWriterCreate,
	(void (*)(ClientModManager *self, const char *message)) ClientModManager1_DisplayNotification,
	(void (*)(ClientModManager *self, const char *text, float x, float y, float fontsize)) ClientModManager1_Draw2dText,
	(void (*)(ClientModManager *self, int textureid, float x1, float y1, float width, float height, IntRef const *inAtlasId, int color)) ClientModManager1_Draw2dTexture,
	(void (*)(ClientModManager *self, Draw2dData const *const *todraw, int todrawLength, int textureId)) ClientModManager1_Draw2dTextures,
	(void (*)(ClientModManager *self, cibool enable)) ClientModManager1_EnableCameraControl,
	(int (*)(ClientModManager *self)) ClientModManager1_GetFreemove,
	(float (*)(ClientModManager *self)) ClientModManager1_GetLocalOrientationX,
	(float (*)(ClientModManager *self)) ClientModManager1_GetLocalOrientationY,
	(float (*)(ClientModManager *self)) ClientModManager1_GetLocalOrientationZ,
	(float (*)(ClientModManager *self)) ClientModManager1_GetLocalPositionX,
	(float (*)(ClientModManager *self)) ClientModManager1_GetLocalPositionY,
	(float (*)(ClientModManager *self)) ClientModManager1_GetLocalPositionZ,
	(DictionaryStringString const *(*)(ClientModManager *self)) ClientModManager1_GetPerformanceInfo,
	(GamePlatform const *(*)(ClientModManager *self)) ClientModManager1_GetPlatform,
	(int (*)(ClientModManager *self)) ClientModManager1_GetWindowHeight,
	(int (*)(ClientModManager *self)) ClientModManager1_GetWindowWidth,
	(BitmapCi const *(*)(ClientModManager *self)) ClientModManager1_GrabScreenshot,
	(cibool (*)(ClientModManager *self)) ClientModManager1_IsFreemoveAllowed,
	(void (*)(ClientModManager *self)) ClientModManager1_MakeScreenshot,
	(void (*)(ClientModManager *self)) ClientModManager1_OrthoMode,
	(void (*)(ClientModManager *self)) ClientModManager1_PerspectiveMode,
	(void (*)(ClientModManager *self, const char *message)) ClientModManager1_SendChatMessage,
	(void (*)(ClientModManager *self, int level)) ClientModManager1_SetFreemove,
	(void (*)(ClientModManager *self, float glx, float gly, float glz)) ClientModManager1_SetLocalOrientation,
	(void (*)(ClientModManager *self, float glx, float gly, float glz)) ClientModManager1_SetLocalPosition,
	(void (*)(ClientModManager *self, int level)) ClientModManager1_ShowGui,
	(int (*)(ClientModManager *self)) ClientModManager1_WhiteTexture
};

typedef struct {
	void (*handle)(ClientPacketHandler *self, Game const *game, Packet_Server const *packet);
}
ClientPacketHandlerVtbl;
struct ClientPacketHandler {
	const ClientPacketHandlerVtbl *vtbl;
	float one;
};
static void ClientPacketHandler_Construct(ClientPacketHandler *self, const ClientPacketHandlerVtbl *vtbl);

struct ClientPacketHandlerDialog {
	ClientPacketHandler base;
};
static void ClientPacketHandlerDialog_Construct(ClientPacketHandlerDialog *self, const ClientPacketHandlerVtbl *vtbl);
static GameScreen *ClientPacketHandlerDialog_ConvertDialog(ClientPacketHandlerDialog const *self, Game const *game, Packet_Dialog const *p);
static const ClientPacketHandlerVtbl CiVtbl_ClientPacketHandlerDialog = {
	(void (*)(ClientPacketHandler *self, Game const *game, Packet_Server const *packet)) ClientPacketHandlerDialog_Handle
};

struct ClientPacketHandlerEntityDespawn {
	ClientPacketHandler base;
};
static void ClientPacketHandlerEntityDespawn_Construct(ClientPacketHandlerEntityDespawn *self, const ClientPacketHandlerVtbl *vtbl);
static const ClientPacketHandlerVtbl CiVtbl_ClientPacketHandlerEntityDespawn = {
	(void (*)(ClientPacketHandler *self, Game const *game, Packet_Server const *packet)) ClientPacketHandlerEntityDespawn_Handle
};

struct ClientPacketHandlerEntityPosition {
	ClientPacketHandler base;
};
static void ClientPacketHandlerEntityPosition_Construct(ClientPacketHandlerEntityPosition *self, const ClientPacketHandlerVtbl *vtbl);
static const ClientPacketHandlerVtbl CiVtbl_ClientPacketHandlerEntityPosition = {
	(void (*)(ClientPacketHandler *self, Game const *game, Packet_Server const *packet)) ClientPacketHandlerEntityPosition_Handle
};

struct ClientPacketHandlerEntitySpawn {
	ClientPacketHandler base;
};
static void ClientPacketHandlerEntitySpawn_Construct(ClientPacketHandlerEntitySpawn *self, const ClientPacketHandlerVtbl *vtbl);
static const ClientPacketHandlerVtbl CiVtbl_ClientPacketHandlerEntitySpawn = {
	(void (*)(ClientPacketHandler *self, Game const *game, Packet_Server const *packet)) ClientPacketHandlerEntitySpawn_Handle
};

static Packet_Client const *ClientPackets_HitEntity(int entityId);
static Packet_Client const *ClientPackets_UseEntity(int entityId);

struct ClientSimple {
	cibool connected;
	cibool inventoryDirty;
	int pingLastMilliseconds;
	NetConnection const *connection;
	NetServer const *mainSocket;
	const char *name;
	cibool **chunksseen;
	float glX;
	float glY;
	float glZ;
	Packet_Inventory *inventory;
	Action_ const *notifyMapAction;
};
static void ClientSimple_Construct(ClientSimple *self);


struct Config3d {
	cibool eNABLE_BACKFACECULLING;
	cibool eNABLE_MIPMAPS;
	cibool eNABLE_TRANSPARENCY;
	cibool eNABLE_VISIBILITY_CULLING;
	float viewdistance;
};
static void Config3d_Construct(Config3d *self);

struct ConnectData {
	cibool isServePasswordProtected;
	int port;
	const char *auth;
	const char *ip;
	const char *serverPassword;
	const char *username;
};

struct ConnectedPlayer {
	int id;
	int ping;
	const char *name;
};

struct Controls {
	cibool freemove;
	cibool movedown;
	cibool moveup;
	cibool noclip;
	cibool shiftkeydown;
	cibool wantsjump;
	cibool wantsjumphalf;
	float movedx;
	float movedy;
};


struct CraftingTableTool {
	GameData const *d_Data;
	IMapStorage2 const *d_Map;
};
static cibool CraftingTableTool_Vector3IntRefArrayContains(CraftingTableTool const *self, Vector3IntRef const *const *l, int lCount, Vector3IntRef const *p);

static const int CubeModelData_cubeVertices[72] = { -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1,
	1, -1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1,
	1, 1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1,
	1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1, -1, -1,
	-1, 1, -1, 1, 1, -1, 1, -1 };
static const int CubeModelData_cubeTextureCoords[48] = { 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0,
	0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0,
	1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1 };
static const int CubeModelData_cubeVertexIndices[36] = { 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8,
	10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21,
	22, 20, 22, 23 };


typedef struct {
	float (*getBlockHeight)(DelegateGetBlockHeight *self, int x, int y, int z);
}
DelegateGetBlockHeightVtbl;
struct DelegateGetBlockHeight {
	const DelegateGetBlockHeightVtbl *vtbl;
};
static void DelegateGetBlockHeight_Construct(DelegateGetBlockHeight *self, const DelegateGetBlockHeightVtbl *vtbl);

typedef struct {
	cibool (*isBlockEmpty)(DelegateIsBlockEmpty *self, int x, int y, int z);
}
DelegateIsBlockEmptyVtbl;
struct DelegateIsBlockEmpty {
	const DelegateIsBlockEmptyVtbl *vtbl;
};
static void DelegateIsBlockEmpty_Construct(DelegateIsBlockEmpty *self, const DelegateIsBlockEmptyVtbl *vtbl);

typedef struct {
	void (*dispose)(ClientMod *self, Game const *game);
	void (*onBeforeNewFrameDraw3d)(ClientMod *self, Game const *game, float deltaTime);
	cibool (*onClientCommand)(ClientMod *self, Game const *game, ClientCommandArgs const *args);
	void (*onHitEntity)(ClientMod *self, Game const *game, OnUseEntityArgs const *e);
	void (*onKeyDown)(ClientMod *self, Game const *game, KeyEventArgs const *args);
	void (*onKeyPress)(ClientMod *self, Game const *game, KeyPressEventArgs const *args);
	void (*onKeyUp)(ClientMod *self, Game const *game, KeyEventArgs const *args);
	void (*onMouseDown)(ClientMod *self, Game const *game, MouseEventArgs const *args);
	void (*onMouseMove)(ClientMod *self, Game const *game, MouseEventArgs const *args);
	void (*onMouseUp)(ClientMod *self, Game const *game, MouseEventArgs const *args);
	void (*onMouseWheelChanged)(ClientMod *self, Game const *game, MouseWheelEventArgs const *args);
	void (*onNewFrame)(ClientMod *self, Game const *game, NewFrameEventArgs const *args);
	void (*onNewFrameDraw2d)(ClientMod *self, Game const *game, float deltaTime);
	void (*onNewFrameDraw3d)(ClientMod *self, Game const *game, float deltaTime);
	void (*onNewFrameFixed)(ClientMod *self, Game const *game, NewFrameEventArgs const *args);
	void (*onNewFrameReadOnlyMainThread)(ClientMod *self, Game const *game, float deltaTime);
	void (*onReadOnlyBackgroundThread)(ClientMod *self, Game const *game, float dt);
	void (*onReadOnlyMainThread)(ClientMod *self, Game const *game, float dt);
	void (*onReadWriteMainThread)(ClientMod *self, Game const *game, float dt);
	void (*onTouchEnd)(ClientMod *self, Game const *game, TouchEventArgs const *e);
	void (*onTouchMove)(ClientMod *self, Game const *game, TouchEventArgs const *e);
	void (*onTouchStart)(ClientMod *self, Game const *game, TouchEventArgs const *e);
	void (*onUseEntity)(ClientMod *self, Game const *game, OnUseEntityArgs const *e);
	void (*start)(ClientMod *self, ClientModManager const *modmanager);
	void (*onBackPressed)(GameScreen *self);
	void (*onButton)(GameScreen *self, MenuWidget const *w);
	void (*onMouseWheel)(GameScreen *self, MouseWheelEventArgs const *e);
}
GameScreenVtbl;
struct GameScreen {
	ClientMod base;
	int widgetCount;
	int screenx;
	int screeny;
	Game *game;
	MenuWidget **widgets;
};
static void GameScreen_Construct(GameScreen *self, const ClientModVtbl *vtbl);
static void GameScreen_KeyDown(GameScreen const *self, KeyEventArgs const *e);
static void GameScreen_KeyPress(GameScreen const *self, KeyPressEventArgs const *e);
static cibool GameScreen_MouseDown(GameScreen const *self, int x, int y);
static void GameScreen_MouseMove(GameScreen const *self, MouseEventArgs const *e);
static void GameScreen_MouseUp(GameScreen const *self, int x, int y);
static cibool GameScreen_pointInRect(GameScreen const *self, float x, float y, float rx, float ry, float rw, float rh);
static const GameScreenVtbl CiVtbl_GameScreen = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	(void (*)(ClientMod *self, Game const *game, KeyEventArgs const *args)) GameScreen_OnKeyDown,
	(void (*)(ClientMod *self, Game const *game, KeyPressEventArgs const *args)) GameScreen_OnKeyPress,
	ClientMod_OnKeyUp,
	(void (*)(ClientMod *self, Game const *game, MouseEventArgs const *args)) GameScreen_OnMouseDown,
	(void (*)(ClientMod *self, Game const *game, MouseEventArgs const *args)) GameScreen_OnMouseMove,
	(void (*)(ClientMod *self, Game const *game, MouseEventArgs const *args)) GameScreen_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	(void (*)(ClientMod *self, Game const *game, TouchEventArgs const *e)) GameScreen_OnTouchEnd,
	ClientMod_OnTouchMove,
	(void (*)(ClientMod *self, Game const *game, TouchEventArgs const *e)) GameScreen_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start,
	GameScreen_OnBackPressed,
	GameScreen_OnButton,
	GameScreen_OnMouseWheel
};

struct DialogScreen {
	GameScreen base;
};
static void DialogScreen_Construct(DialogScreen *self, const ClientModVtbl *vtbl);
static const GameScreenVtbl CiVtbl_DialogScreen = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	(void (*)(ClientMod *self, Game const *game, KeyEventArgs const *args)) GameScreen_OnKeyDown,
	(void (*)(ClientMod *self, Game const *game, KeyPressEventArgs const *args)) GameScreen_OnKeyPress,
	ClientMod_OnKeyUp,
	(void (*)(ClientMod *self, Game const *game, MouseEventArgs const *args)) GameScreen_OnMouseDown,
	(void (*)(ClientMod *self, Game const *game, MouseEventArgs const *args)) GameScreen_OnMouseMove,
	(void (*)(ClientMod *self, Game const *game, MouseEventArgs const *args)) GameScreen_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	(void (*)(ClientMod *self, Game const *game, TouchEventArgs const *e)) GameScreen_OnTouchEnd,
	ClientMod_OnTouchMove,
	(void (*)(ClientMod *self, Game const *game, TouchEventArgs const *e)) GameScreen_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start,
	GameScreen_OnBackPressed,
	(void (*)(GameScreen *self, MenuWidget const *w)) DialogScreen_OnButton,
	GameScreen_OnMouseWheel
};

struct DictionaryStringAudioData {
	const char **keys;
	AudioData const **values;
};
static void DictionaryStringAudioData_Construct(DictionaryStringAudioData *self);
static cibool DictionaryStringAudioData_Contains(DictionaryStringAudioData const *self, const char *key);
static AudioData const *DictionaryStringAudioData_GetById(DictionaryStringAudioData const *self, int id);
static int DictionaryStringAudioData_GetId(DictionaryStringAudioData const *self, const char *key);
static int DictionaryStringAudioData_Set(DictionaryStringAudioData const *self, const char *key, AudioData const *bmp);

struct DictionaryStringAudioSample {
	int count;
	int max;
	const char **keys;
	AudioSampleCi const **values;
};
static void DictionaryStringAudioSample_Construct(DictionaryStringAudioSample *self);

struct DictionaryStringByteArray {
	int itemsCount;
	StringByteArray **items;
};
static void DictionaryStringByteArray_Construct(DictionaryStringByteArray *self);
static unsigned char const *DictionaryStringByteArray_Get(DictionaryStringByteArray const *self, const char *name);
static void DictionaryStringByteArray_Set(DictionaryStringByteArray const *self, const char *name, unsigned char const *value);

struct DictionaryStringInt1024 {
	int count;
	KeyValueStringInt **items;
};
static void DictionaryStringInt1024_Construct(DictionaryStringInt1024 *self);
static cibool DictionaryStringInt1024_Contains(DictionaryStringInt1024 const *self, const char *key);
static int DictionaryStringInt1024_Get(DictionaryStringInt1024 const *self, const char *key);

struct DictionaryStringString {
	int count;
	KeyValueStringString **items;
};
static void DictionaryStringString_Construct(DictionaryStringString *self);
static cibool DictionaryStringString_ContainsKey(DictionaryStringString const *self, const char *key);
static const char *DictionaryStringString_Get(DictionaryStringString const *self, const char *key);
static void DictionaryStringString_Remove(DictionaryStringString const *self, const char *key);

struct DictionaryVector3Float {
	int itemsCount;
	Vector3Float **items;
};
static void DictionaryVector3Float_Construct(DictionaryVector3Float *self);
static void DictionaryVector3Float_Clear(DictionaryVector3Float const *self);
static cibool DictionaryVector3Float_ContainsKey(DictionaryVector3Float const *self, int x, int y, int z);
static int DictionaryVector3Float_Count(DictionaryVector3Float const *self);
static float DictionaryVector3Float_Get(DictionaryVector3Float const *self, int x, int y, int z);
static int DictionaryVector3Float_ItemIndex(DictionaryVector3Float const *self, int x, int y, int z);
static void DictionaryVector3Float_Remove(DictionaryVector3Float const *self, int x, int y, int z);
static void DictionaryVector3Float_Set(DictionaryVector3Float const *self, int x, int y, int z, float value);


struct DisplayResolutionCi {
	int bitsPerPixel;
	int height;
	int width;
	float refreshRate;
};

struct Draw2dData {
	int color;
	float height;
	IntRef const *inAtlasId;
	float width;
	float x1;
	float y1;
};


struct DrawName {
	cibool clientAutoComplete;
	cibool drawHealth;
	cibool onlyWhenSelected;
	float health;
	const char *name;
	float textX;
	float textY;
	float textZ;
};

struct DrawWireframeCube {
	float one;
	Model const *wireframeCube;
};
static void DrawWireframeCube_Construct(DrawWireframeCube *self);

typedef struct {
	const char *(*addressToString)(IPEndPointCi *self);
}
IPEndPointCiVtbl;
struct IPEndPointCi {
	const IPEndPointCiVtbl *vtbl;
};
static void IPEndPointCi_Construct(IPEndPointCi *self, const IPEndPointCiVtbl *vtbl);

struct DummyIpEndPoint {
	IPEndPointCi base;
};
static void DummyIpEndPoint_Construct(DummyIpEndPoint *self, const IPEndPointCiVtbl *vtbl);
static const IPEndPointCiVtbl CiVtbl_DummyIpEndPoint = {
	(const char *(*)(IPEndPointCi *self)) DummyIpEndPoint_AddressToString
};

typedef struct {
	NetConnection const *(*connect)(NetClient *self, const char *ip, int port);
	NetIncomingMessage const *(*readMessage)(NetClient *self);
	void (*sendMessage)(NetClient *self, INetOutgoingMessage const *message, MyNetDeliveryMethod method);
	void (*start)(NetClient *self);
}
NetClientVtbl;
struct NetClient {
	const NetClientVtbl *vtbl;
};
static void NetClient_Construct(NetClient *self, const NetClientVtbl *vtbl);

struct DummyNetClient {
	NetClient base;
	DummyNetwork const *network;
	GamePlatform const *platform;
};
static void DummyNetClient_Construct(DummyNetClient *self, const NetClientVtbl *vtbl);
static const NetClientVtbl CiVtbl_DummyNetClient = {
	(NetConnection const *(*)(NetClient *self, const char *ip, int port)) DummyNetClient_Connect,
	(NetIncomingMessage const *(*)(NetClient *self)) DummyNetClient_ReadMessage,
	(void (*)(NetClient *self, INetOutgoingMessage const *message, MyNetDeliveryMethod method)) DummyNetClient_SendMessage,
	(void (*)(NetClient *self)) DummyNetClient_Start
};

typedef struct {
	cibool (*equalsConnection)(NetConnection *self, NetConnection const *connection);
	IPEndPointCi const *(*remoteEndPoint)(NetConnection *self);
	void (*sendMessage)(NetConnection *self, INetOutgoingMessage const *msg, MyNetDeliveryMethod method, int sequenceChannel);
	void (*update)(NetConnection *self);
}
NetConnectionVtbl;
struct NetConnection {
	const NetConnectionVtbl *vtbl;
};
static void NetConnection_Construct(NetConnection *self, const NetConnectionVtbl *vtbl);

struct DummyNetConnection {
	NetConnection base;
	DummyNetwork const *network;
	GamePlatform const *platform;
};
static void DummyNetConnection_Construct(DummyNetConnection *self, const NetConnectionVtbl *vtbl);
static const NetConnectionVtbl CiVtbl_DummyNetConnection = {
	(cibool (*)(NetConnection *self, NetConnection const *connection)) DummyNetConnection_EqualsConnection,
	(IPEndPointCi const *(*)(NetConnection *self)) DummyNetConnection_RemoteEndPoint,
	(void (*)(NetConnection *self, INetOutgoingMessage const *msg, MyNetDeliveryMethod method, int sequenceChannel)) DummyNetConnection_SendMessage,
	(void (*)(NetConnection *self)) DummyNetConnection_Update
};

struct INetOutgoingMessage {
	int messageLength;
	unsigned char *message;
};

struct DummyNetOutgoingMessage {
	INetOutgoingMessage base;
};

typedef struct {
	NetIncomingMessage const *(*readMessage)(NetServer *self);
	void (*setPort)(NetServer *self, int port);
	void (*start)(NetServer *self);
}
NetServerVtbl;
struct NetServer {
	const NetServerVtbl *vtbl;
};
static void NetServer_Construct(NetServer *self, const NetServerVtbl *vtbl);

struct DummyNetServer {
	NetServer base;
	cibool receivedAnyMessage;
	DummyNetConnection *connectedClient;
	DummyNetwork const *network;
	GamePlatform const *platform;
};
static void DummyNetServer_Construct(DummyNetServer *self, const NetServerVtbl *vtbl);
static const NetServerVtbl CiVtbl_DummyNetServer = {
	(NetIncomingMessage const *(*)(NetServer *self)) DummyNetServer_ReadMessage,
	(void (*)(NetServer *self, int port)) DummyNetServer_SetPort,
	(void (*)(NetServer *self)) DummyNetServer_Start
};

struct DummyNetwork {
	QueueByteArray *clientReceiveBuffer;
	MonitorObject const *clientReceiveBufferLock;
	QueueByteArray *serverReceiveBuffer;
	MonitorObject const *serverReceiveBufferLock;
};
static void DummyNetwork_Construct(DummyNetwork *self);

typedef struct {
	EnetPacket const *(*packet)(EnetEvent *self);
	EnetPeer const *(*peer)(EnetEvent *self);
	EnetEventType (*type)(EnetEvent *self);
}
EnetEventVtbl;
struct EnetEvent {
	const EnetEventVtbl *vtbl;
};
static void EnetEvent_Construct(EnetEvent *self, const EnetEventVtbl *vtbl);

struct EnetEventRef {
	EnetEvent const *e;
};


struct EnetNetClient {
	NetClient base;
	cibool connected;
	cibool connected2;
	EnetHost const *host;
	QueueNetIncomingMessage *messages;
	EnetPeer const *peer;
	GamePlatform const *platform;
	QueueINetOutgoingMessage *tosend;
};
static void EnetNetClient_Construct(EnetNetClient *self, const NetClientVtbl *vtbl);
static void EnetNetClient_DoSendPacket(EnetNetClient const *self, INetOutgoingMessage const *msg);
static const NetClientVtbl CiVtbl_EnetNetClient = {
	(NetConnection const *(*)(NetClient *self, const char *ip, int port)) EnetNetClient_Connect,
	(NetIncomingMessage const *(*)(NetClient *self)) EnetNetClient_ReadMessage,
	(void (*)(NetClient *self, INetOutgoingMessage const *message, MyNetDeliveryMethod method)) EnetNetClient_SendMessage,
	(void (*)(NetClient *self)) EnetNetClient_Start
};

struct EnetNetConnection {
	NetConnection base;
	EnetPeer const *peer;
	GamePlatform const *platform;
};
static void EnetNetConnection_Construct(EnetNetConnection *self, const NetConnectionVtbl *vtbl);
static const NetConnectionVtbl CiVtbl_EnetNetConnection = {
	(cibool (*)(NetConnection *self, NetConnection const *connection)) EnetNetConnection_EqualsConnection,
	(IPEndPointCi const *(*)(NetConnection *self)) EnetNetConnection_RemoteEndPoint,
	(void (*)(NetConnection *self, INetOutgoingMessage const *msg, MyNetDeliveryMethod method, int sequenceChannel)) EnetNetConnection_SendMessage,
	(void (*)(NetConnection *self)) EnetNetConnection_Update
};

struct EnetNetServer {
	NetServer base;
	int port;
	int clientid;
	EnetEventRef const *event_;
	EnetHost const *host;
	QueueNetIncomingMessage *messages;
	GamePlatform const *platform;
};
static void EnetNetServer_Construct(EnetNetServer *self, const NetServerVtbl *vtbl);
static const NetServerVtbl CiVtbl_EnetNetServer = {
	(NetIncomingMessage const *(*)(NetServer *self)) EnetNetServer_ReadMessage,
	(void (*)(NetServer *self, int port)) EnetNetServer_SetPort,
	(void (*)(NetServer *self)) EnetNetServer_Start
};

typedef struct {
	void (*dispose)(EnetPacket *self);
	unsigned char *(*getBytes)(EnetPacket *self);
	int (*getBytesCount)(EnetPacket *self);
}
EnetPacketVtbl;
struct EnetPacket {
	const EnetPacketVtbl *vtbl;
};
static void EnetPacket_Construct(EnetPacket *self, const EnetPacketVtbl *vtbl);


typedef struct {
	IPEndPointCi const *(*getRemoteAddress)(EnetPeer *self);
	void (*setUserData)(EnetPeer *self, int value);
	int (*userData)(EnetPeer *self);
}
EnetPeerVtbl;
struct EnetPeer {
	const EnetPeerVtbl *vtbl;
};
static void EnetPeer_Construct(EnetPeer *self, const EnetPeerVtbl *vtbl);

struct Entity {
	int scriptsCount;
	cibool usable;
	Bullet_ *bullet;
	EntityDrawArea *drawArea;
	EntityDrawModel *drawModel;
	DrawName *drawName;
	EntityDrawText *drawText;
	Expires *expires;
	Grenade_ *grenade;
	Minecart *minecart;
	EntityPosition_ *networkPosition;
	PlayerDrawInfo *playerDrawInfo;
	Packet_ServerPlayerStats const *playerStats;
	EntityPosition_ *position;
	Packet_ServerExplosion *push;
	EntityScript const **scripts;
	Sprite *sprite;
};
static void Entity_Construct(Entity *self);

struct EntityDrawArea {
	int sizex;
	int sizey;
	int sizez;
	cibool visible;
	int x;
	int y;
	int z;
};

struct EntityDrawModel {
	int currentTexture;
	cibool downloadSkin;
	float modelHeight;
	const char *model_;
	HttpResponseCi const *skinDownloadResponse;
	const char *texture_;
	float eyeHeight;
	AnimatedModelRenderer *renderer;
};
static void EntityDrawModel_Construct(EntityDrawModel *self);

struct EntityDrawText {
	float dx;
	float dy;
	float dz;
	float rotx;
	float roty;
	float rotz;
	const char *text;
};

struct EntityPosition_ {
	int lastUpdateMilliseconds;
	cibool positionLoaded;
	float rotx;
	float roty;
	float rotz;
	float x;
	float y;
	float z;
};

typedef struct {
	void (*onNewFrameFixed)(EntityScript *self, Game const *game, int entity, float dt);
}
EntityScriptVtbl;
struct EntityScript {
	const EntityScriptVtbl *vtbl;
};
static void EntityScript_Construct(EntityScript *self, const EntityScriptVtbl *vtbl);
static const EntityScriptVtbl CiVtbl_EntityScript = {
	EntityScript_OnNewFrameFixed
};

struct Expires {
	float timeLeft;
	float totalTime;
};
static Expires *Expires_Create(float p);

struct FastQueueInt {
	int count;
	int end;
	int maxCount;
	int start;
	int *values;
};

struct FastStackInt {
	int count;
	int valuesLength;
	int *values;
};
static int FastStackInt_Count_(FastStackInt const *self);

struct FloatRef {
	float value;
};

struct FontCi {
	int style;
	const char *family;
	float size;
};
static FontCi const *FontCi_Create(const char *family_, float size_, int style_);


struct FrustumCulling {
	IGetCameraMatrix const *d_GetCameraMatrix;
	float frustum00;
	float frustum01;
	float frustum02;
	float frustum03;
	float frustum10;
	float frustum11;
	float frustum12;
	float frustum13;
	float frustum20;
	float frustum21;
	float frustum22;
	float frustum23;
	float frustum30;
	float frustum31;
	float frustum32;
	float frustum33;
	float frustum40;
	float frustum41;
	float frustum42;
	float frustum43;
	float frustum50;
	float frustum51;
	float frustum52;
	float frustum53;
	GamePlatform const *platform;
};

struct Game {
	unsigned char localstance;
	int activeMaterial;
	cibool allowFreemove;
	int allowedFontsCount;
	cibool audioEnabled;
	cibool autoJumpEnabled;
	int chatLineLength;
	int chatLinesCount;
	int chatLinesMax;
	cibool eNABLE_DRAW2D;
	cibool eNABLE_DRAWPOSITION;
	cibool eNABLE_DRAW_TEST_CHARACTER;
	int eNABLE_LAG;
	cibool eNABLE_TPP_VIEW;
	cibool eNABLE_ZFAR;
	int font;
	TypingState guiTyping;
	cibool ironSights;
	cibool isShiftPressed;
	cibool isTeamchat;
	cibool isTyping;
	int lastReceivedMilliseconds;
	int localPlayerId;
	int receivedMapLength;
	int selectedBlockPositionX;
	int selectedBlockPositionY;
	int selectedBlockPositionZ;
	int selectedEntityId;
	cibool skySphereNight;
	int tPP_CAMERA_DISTANCE_MAX;
	int tPP_CAMERA_DISTANCE_MIN;
	cibool ammostarted;
	int cachedTextTexturesMax;
	CameraType cameratype;
	int clientmodsCount;
	cibool currentMatrixModeProjection;
	int currentTimeMilliseconds;
	int currentlyAttackedEntity;
	int dialogsCount;
	cibool drawblockinfo;
	cibool enableCameraControl;
	cibool enable_move;
	int entitiesCount;
	cibool escapeMenuRestart;
	cibool exitToMainMenu;
	cibool fancySkysphere;
	int fillAreaLimit;
	int grenadecookingstartMilliseconds;
	GuiState guistate;
	cibool handRedraw;
	cibool handSetAttackBuild;
	cibool handSetAttackDestroy;
	int handTexture;
	cibool isNight;
	cibool isplayeronground;
	cibool issingleplayer;
	int lastHeight;
	int lastOxygenTickMilliseconds;
	int lastWidth;
	int lastironsightschangeMilliseconds;
	int lastplacedblockX;
	int lastplacedblockY;
	int lastplacedblockZ;
	int lastpositionsentMilliseconds;
	cibool leftpressedpicking;
	int maxTextureSize;
	int maxdrawdistance;
	int mouseCurrentX;
	int mouseCurrentY;
	cibool mouseLeft;
	cibool mouseMiddle;
	cibool mousePointerLockShouldBe;
	cibool mouseRight;
	cibool mouseSmoothing;
	cibool mouseleftclick;
	cibool mouseleftdeclick;
	cibool mouserightclick;
	cibool mouserightdeclick;
	cibool overheadcamera;
	int pistolcycle;
	int playertexturedefault;
	cibool reachedHalfBlock;
	cibool reachedwall;
	cibool reachedwall_1blockhigh;
	cibool reconnect;
	int reloadblock;
	int reloadstartMilliseconds;
	int selectedmodelid;
	cibool sendResize;
	cibool shadowssimple;
	cibool shouldRedrawAllBlocks;
	cibool spawned;
	int speculativeCount;
	cibool startedconnecting;
	cibool stopPlayerMove;
	int sunlight_;
	int terrainTexture;
	int terrainTexturesPerAtlas;
	int totaltimeMilliseconds;
	int typinglogCount;
	int typinglogpos;
	cibool wasmouseleft;
	cibool wasmouseright;
	int whitetexture;
	const char **allowedFonts;
	float cameraEyeX;
	float cameraEyeY;
	float cameraEyeZ;
	GetCameraMatrix *cameraMatrix;
	Chatline const **chatLines;
	const char *follow;
	float *gLRotateTempVec3;
	float *gLScaleTempVec3;
	float *gLTranslateTempVec3;
	const char *guiTypingBuffer;
	int *loadedAmmo;
	Packet_BlockType const **newBlockTypes;
	int const *nightLevels;
	float pICK_DISTANCE;
	float playerPushDistance;
	Packet_ServerPlayerStats *playerStats;
	float radiusWhenMoving;
	ServerInformation *serverInfo;
	float *set3dProjectionTempMat4;
	int **textureId;
	int *textureIdForInventory;
	int *totalAmmo;
	AnimationState const *a;
	float accumulator;
	AssetList *assets;
	FloatRef const *assetsLoadProgress;
	AudioControl *audio;
	float basemovespeed;
	CitoMemoryStream *blobdownload;
	const char *blobdownloadmd5;
	const char *blobdownloadname;
	DictionaryVector3Float const *blockHealth;
	Packet_BlockType const *const *blocktypes;
	CachedTextTexture const **cachedTextTextures;
	float const *camera;
	ModelData *circleModelData;
	ClientMod const **clientmods;
	ListAction *commitActions;
	ConnectData const *connectdata;
	float constRotationSpeed;
	float constWallDistance;
	Controls *controls;
	Vector3IntRef const *currentAttackedBlock;
	MeshBatcher *d_Batcher;
	Config3d *d_Config3d;
	GameData *d_Data;
	GameDataMonsters const *d_DataMonsters;
	GameExit const *d_Exit;
	FrustumCulling *d_FrustumCulling;
	InfiniteMapChunked2d *d_Heightmap;
	Packet_Inventory const *d_Inventory;
	InventoryUtilClient *d_InventoryUtil;
	SunMoonRenderer *d_SunMoonRenderer;
	TerrainChunkTesselatorCi *d_TerrainChunkTesselator;
	ITerrainTextures const *d_TerrainTextures;
	TextureAtlasConverter const *d_TextureAtlasConverter;
	VisibleDialog const **dialogs;
	Entity **entities;
	FontCi const *fontMapLoading;
	float fov;
	const char **getAsset;
	float grenadetime;
	float const *identityMatrix;
	const char *invalidVersionDrawMessage;
	Packet_Server const *invalidVersionPacketIdentification;
	cibool *keyboardState;
	cibool *keyboardStateRaw;
	Language *language;
	float lastplayerpositionX;
	float lastplayerpositionY;
	float lastplayerpositionZ;
	AnimationState const *localplayeranim;
	AnimationHint *localplayeranimationhint;
	float *mLightLevels;
	NetClient const *main;
	Map *map;
	MapLoadingProgressEventArgs *maploadingprogress;
	int const *materialSlots;
	MenuState const *menustate;
	float const *modelViewInverted;
	ClientModManager1 *modmanager;
	float moonPositionX;
	float moonPositionY;
	float moonPositionZ;
	float mouseDeltaX;
	float mouseDeltaY;
	float mouseSmoothingAccum;
	float mouseSmoothingVelX;
	float mouseSmoothingVelY;
	float movedz;
	float movespeed;
	StackMatrix4 *mvMatrix;
	float one;
	OptionsCi *options;
	Kamera *overheadcameraK;
	float overheadcameradistance;
	StackMatrix4 *pMatrix;
	ClientPacketHandler const **packetHandlers;
	IntRef *packetLen;
	ModDrawParticleEffectBlockBreak const *particleEffectBlockBreak;
	DictionaryStringString const *performanceinfo;
	GamePlatform const *platform;
	Entity *player;
	float playerPositionSpawnX;
	float playerPositionSpawnY;
	float playerPositionSpawnZ;
	Vector3Ref const *playerdestination;
	Vector3Ref *playervelocity;
	float pushX;
	float pushY;
	float pushZ;
	Model const *quadModel;
	Packet_ServerRedirect const *redirectTo;
	RandomCi const *rnd;
	float rotationspeed;
	BlockOctreeSearcher *s;
	const char *serverGameVersion;
	ModSkySphereStatic const *skysphere;
	BoolRef *soundnow;
	Speculative const **speculative;
	float sunPositionX;
	float sunPositionY;
	float sunPositionZ;
	TaskScheduler *taskScheduler;
	int const *terrainTextures1d;
	TextColorRenderer *textColorRenderer;
	DictionaryStringInt1024 *textures;
	float touchMoveDx;
	float touchMoveDy;
	float touchOrientationDx;
	float touchOrientationDy;
	float tppcameradistance;
	const char **typinglog;
	float znear;
};
static void Game_Construct(Game *self);
static void Game_AddSpeculative(Game *self, Speculative const *s_);
static float Game_Angle256ToRad(int value);
static void Game_ApplyDamageToPlayer(Game const *self, int damage, int damageSource, int sourceId);
static IntRef const *Game_BlockInHand(Game const *self);
static int Game_BlockUnderPlayer(Game const *self);
static void Game_CacheAsset(Game const *self, Asset const *asset);
static void Game_ChatLinesAdd(Game *self, Chatline const *chatline);
static void Game_ChatLog(Game const *self, const char *p);
static void Game_ClientCommand(Game *self, const char *s_);
static void Game_Connect(Game const *self, const char *serverAddress, int port, const char *username, const char *auth);
static void Game_Connect_(Game const *self, const char *serverAddress, int port, const char *username, const char *auth, const char *serverPassword);
static void Game_Connect__(Game *self);
static Entity *Game_CreateBulletEntity(Game const *self, float fromX, float fromY, float fromZ, float toX, float toY, float toZ, float speed);
static float Game_CurrentAimRadius(Game const *self);
static float Game_CurrentRecoil(Game const *self);
static cibool Game_DeleteTexture(Game const *self, const char *name);
static float Game_DeserializeFloat(Game const *self, int value);
static int Game_DialogsCount_(Game const *self);
static void Game_Draw2d(Game *self, float dt);
static void Game_Draw2dText1(Game *self, const char *text, int x, int y, int fontsize, IntRef const *color, cibool enabledepthtest);
static void Game_Draw2dTextureInAtlas(Game const *self, int textureid, float x1, float y1, float width, float height, IntRef const *inAtlasId, int atlastextures, int color, cibool enabledepthtest);
static void Game_Draw2dTextureSimple(Game *self, int textureid, float x1, float y1, float width, float height, cibool enabledepthtest);
static cibool Game_EnablePlayerUpdatePosition(Game const *self, int kKey);
static cibool Game_EnablePlayerUpdatePositionContainsKey(Game const *self, int kKey);
static void Game_EntityAddLocal(Game *self, Entity *entity);
static void Game_ExitAndSwitchServer(Game *self, Packet_ServerRedirect const *newServer);
static void Game_ExitToMainMenu_(Game *self);
static float Game_FloorFloat(Game const *self, float a);
static IntRef const *Game_FollowId(Game const *self);
static void Game_FrameTick(Game *self, float dt);
static CachedTexture *Game_GetCachedTextTexture(Game const *self, Text_ const *t);
static int Game_GetCameraBlock(Game const *self);
static float Game_GetCharacterEyesHeight(Game const *self);
static float Game_GetCurrentBlockHealth(Game const *self, int x, int y, int z);
static int Game_GetDialogId(Game const *self, const char *name);
static unsigned char const *Game_GetFile(Game const *self, const char *p);
static int Game_GetFileLength(Game const *self, const char *p);
static int Game_GetKey(Game const *self, int key);
static int Game_GetPlayerEyesBlock(Game const *self);
static Packet_ServerRedirect const *Game_GetRedirect(Game const *self);
static int Game_GetTexture(Game const *self, const char *p);
static int Game_GetTextureOrLoad(Game const *self, const char *name, BitmapCi const *bmp);
static void Game_GotoDraw2d(Game *self, float dt);
static void Game_GuiStateBackToGame(Game *self);
static void Game_HandleMaterialKeys(Game *self, int eKey);
static cibool Game_HasAsset(Game const *self, const char *md5, const char *name);
static void Game_InvalidVersionAllow(Game *self);
static void Game_InventoryClick(Game const *self, Packet_InventoryPosition *pos);
static Packet_InventoryPosition *Game_InventoryPositionMainArea(Game const *self, int x, int y);
static Packet_InventoryPosition *Game_InventoryPositionMaterialSelector(Game const *self, int materialId);
static void Game_InvokeMapLoadingProgress(Game *self, int progressPercent, int progressBytes, const char *status);
static cibool Game_IsAnyPlayerInPos(Game const *self, int blockposX, int blockposY, int blockposZ);
static cibool Game_IsFillBlock(Game const *self, int blocktype);
static cibool Game_IsLava(Game const *self, int blockType);
static cibool Game_IsPlayerInPos(Game const *self, float playerposX, float playerposY, float playerposZ, int blockposX, int blockposY, int blockposZ, float playerHeight);
static cibool Game_IsTileEmptyForPhysics(Game const *self, int x, int y, int z);
static cibool Game_IsTileEmptyForPhysicsClose(Game const *self, int x, int y, int z);
static cibool Game_IsUsableBlock(Game const *self, int blocktype);
static cibool Game_IsValid(Game const *self, int blocktype);
static cibool Game_IsWater(Game const *self, int blockType);
static cibool Game_IsWearingWeapon(Game const *self);
static void Game_KeyDown(Game *self, int eKey);
static void Game_KeyPress(Game const *self, int eKeyChar);
static void Game_KeyUp(Game *self, int eKey);
static cibool Game_LavaSwimmingCamera(Game const *self);
static float Game_Length(Game const *self, float x, float y, float z);
static void Game_Log(Game *self, const char *p);
static void Game_MainThreadOnRenderFrame(Game *self, float deltaTime);
static CachedTexture *Game_MakeTextTexture(Game const *self, Text_ const *t);
static void Game_MapLoaded(Game *self);
static void Game_MouseDown(Game *self, MouseEventArgs const *args);
static void Game_MouseUp(Game *self, MouseEventArgs const *args);
static void Game_MouseWheelChanged(Game *self, MouseWheelEventArgs const *e);
static float Game_MoveSpeedNow(Game const *self);
static void Game_MoveToInventory(Game const *self, Packet_InventoryPosition *from);
static BlockPosSide const *Game_Nearest(Game const *self, BlockPosSide const *const *pick2, int pick2Count, float x, float y, float z);
static void Game_OnFocusChanged(Game *self);
static void Game_OnResize(Game *self);
static void Game_PickSort(Game const *self, BlockPosSide const **pick, int pickCount, float x, float y, float z);
static void Game_ProcessServerIdentification(Game *self, Packet_Server const *packet);
static float Game_RadToAngle256(float value);
static void Game_Reconnect(Game *self);
static void Game_RedrawAllBlocks(Game *self);
static void Game_RedrawBlock(Game const *self, int x, int y, int z);
static void Game_Respawn(Game *self);
static void Game_RevertSpeculative(Game const *self, float dt);
static void Game_SendChat(Game const *self, const char *s);
static void Game_SendFillArea(Game const *self, int startx, int starty, int startz, int endx, int endy, int endz, int blockType);
static void Game_SendGameResolution(Game const *self);
static void Game_SendLeave(Game const *self, int reason);
static void Game_SendPingReply(Game const *self);
static void Game_SendRequestBlob(Game const *self, const char **required, int requiredCount);
static void Game_SendSetBlock(Game const *self, int x, int y, int z, int mode, int type, int materialslot);
static void Game_SendSetBlockAndUpdateSpeculative(Game *self, int material, int x, int y, int z, int mode);
static void Game_Set3dProjection1(Game *self, float zfar_);
static void Game_Set3dProjection2(Game *self);
static void Game_SetAmbientLight(Game const *self, int color);
static void Game_SetBlock(Game *self, int x, int y, int z, int tileType);
static void Game_SetCamera(Game *self, CameraType type);
static void Game_SetCharacterEyesHeight(Game const *self, float value);
static void Game_SetFog(Game const *self);
static void Game_SetTileAndUpdate(Game *self, int x, int y, int z, int type);
static void Game_ShadowsOnSetBlock(Game const *self, int x, int y, int z);
static cibool Game_SwimmingBody(Game const *self);
static cibool Game_SwimmingEyes(Game const *self);
static int Game_TextSizeHeight(Game const *self, const char *s, int size);
static int Game_TextSizeWidth(Game const *self, const char *s, int size);
static void Game_ToggleVsync(Game *self);
static void Game_UpdateColumnHeight(Game const *self, int x, int y);
static void Game_UpdateMouseViewportControl(Game *self, float dt);
static void Game_UpdateResize(Game *self);
static void Game_UseInventory(Game *self, Packet_Inventory const *packet_Inventory);
static void Game_UseTerrainTextureAtlas2d(Game *self, BitmapCi const *atlas2d, int atlas2dWidth);
static void Game_UseTerrainTextures(Game *self, const char *const *textureIds, int textureIdsCount);
static void Game_UseVsync(Game const *self);
static const char *Game_ValidFont(Game const *self, const char *family);
static float Game_VectorAngleGet(Game const *self, float qX, float qY, float qZ);
static cibool Game_WaterSwimmingCamera(Game const *self);
static cibool Game_WaterSwimmingEyes(Game const *self);
static void Game_WearItem(Game const *self, Packet_InventoryPosition *from, Packet_InventoryPosition *to);
static int Game_atlas1dheight(Game const *self);
static int Game_atlas2dtiles(Game const *self);
static float Game_currentfov(Game const *self);
static int Game_terraincolor(Game const *self);
static int Game_texturesPacked(Game const *self);
static int Game_xcenter(Game const *self, float width);
static int Game_ycenter(Game const *self, float height);
static float Game_zfar(Game const *self);

struct GameData {
	int mBlockIdAdminium;
	int mBlockIdCompass;
	int mBlockIdCraftingTable;
	int mBlockIdCuboid;
	int mBlockIdDirt;
	int mBlockIdEmpty;
	int mBlockIdEmptyHand;
	int mBlockIdFillArea;
	int mBlockIdFillStart;
	int mBlockIdLadder;
	int mBlockIdLava;
	int mBlockIdMinecart;
	int mBlockIdRailstart;
	int mBlockIdSponge;
	int mBlockIdStationaryLava;
	int mBlockIdTrampoline;
	const char *const **mBreakSound;
	const char *const **mBuildSound;
	const char *const **mCloneSound;
	int const *mDamageToPlayer;
	int const *mDefaultMaterialSlots;
	cibool const *mIsFlower;
	cibool const *mIsSlipperyWalk;
	int const *mLightRadius;
	int const *mRail;
	int const *mStartInventoryAmount;
	float const *mStrength;
	const char *const **mWalkSound;
	float *mWalkSpeed;
	int const *mWalkableType;
	int *mWhenPlayerPlacesGetsConvertedTo;
};
static void GameData_Construct(GameData *self);
static float GameData_DeserializeFloat(GameData const *self, int p);
static void GameData_Initialize(GameData *self, int count);

struct GameDataItemsClient {
	Game const *game;
};

struct GameDataMonsters {
	const char **monsterCode;
	const char **monsterName;
	const char **monsterSkin;
};
static void GameDataMonsters_Construct(GameDataMonsters *self);

struct GameExit {
	cibool exit;
	cibool restart;
};

typedef struct {
	void (*addOnCrash)(GamePlatform *self, OnCrashHandler const *handler);
	void (*addOnKeyEvent)(GamePlatform *self, KeyEventHandler const *handler);
	void (*addOnMouseEvent)(GamePlatform *self, MouseEventHandler const *handler);
	void (*addOnNewFrame)(GamePlatform *self, NewFrameHandler const *handler);
	void (*addOnTouchEvent)(GamePlatform *self, TouchEventHandler const *handler);
	void (*applicationDoEvents)(GamePlatform *self);
	AudioCi const *(*audioCreate)(GamePlatform *self, AudioData const *data);
	AudioData const *(*audioDataCreate)(GamePlatform *self, unsigned char const *data, int dataLength);
	cibool (*audioDataLoaded)(GamePlatform *self, AudioData const *data);
	void (*audioDelete)(GamePlatform *self, AudioCi const *audioCi);
	cibool (*audioFinished)(GamePlatform *self, AudioCi const *audio);
	void (*audioPause)(GamePlatform *self, AudioCi const *audio);
	void (*audioPlay)(GamePlatform *self, AudioCi const *audio);
	void (*audioSetPosition)(GamePlatform *self, AudioCi const *audio, float x, float y, float z);
	void (*audioUpdateListener)(GamePlatform *self, float posX, float posY, float posZ, float orientX, float orientY, float orientZ);
	AviWriterCi const *(*aviWriterCreate)(GamePlatform *self);
	void (*bindTexture2d)(GamePlatform *self, int texture);
	BitmapCi const *(*bitmapCreate)(GamePlatform *self, int width, int height);
	BitmapCi const *(*bitmapCreateFromPng)(GamePlatform *self, unsigned char const *data, int dataLength);
	void (*bitmapDelete)(GamePlatform *self, BitmapCi const *bmp);
	float (*bitmapGetHeight)(GamePlatform *self, BitmapCi const *bmp);
	void (*bitmapGetPixelsArgb)(GamePlatform *self, BitmapCi const *bitmap, int const *bmpPixels);
	float (*bitmapGetWidth)(GamePlatform *self, BitmapCi const *bmp);
	void (*bitmapSetPixelsArgb)(GamePlatform *self, BitmapCi const *bmp, int const *pixels);
	int (*byteArrayLength)(GamePlatform *self, unsigned char const *arr);
	EnetNetConnection const *(*castToEnetNetConnection)(GamePlatform *self, NetConnection const *connection);
	PlayerInterpolationState *(*castToPlayerInterpolationState)(GamePlatform *self, InterpolatedObject const *a);
	void (*changeResolution)(GamePlatform *self, int width, int height, int bitsPerPixel, float refreshRate);
	const char *(*charArrayToString)(GamePlatform *self, int const *charArray, int length);
	cibool (*chatLog)(GamePlatform *self, const char *servername, const char *p);
	cibool (*clipboardContainsText)(GamePlatform *self);
	const char *(*clipboardGetText)(GamePlatform *self);
	void (*clipboardSetText)(GamePlatform *self, const char *s);
	void (*consoleWriteLine)(GamePlatform *self, const char *p);
	Model const *(*createModel)(GamePlatform *self, ModelData const *modelData);
	BitmapCi const *(*createTextTexture)(GamePlatform *self, Text_ const *t);
	const char *(*decodeHTMLEntities)(GamePlatform *self, const char *htmlencodedstring);
	void (*deleteModel)(GamePlatform *self, Model const *model);
	const char *const *(*directoryGetFiles)(GamePlatform *self, const char *path, IntRef const *length);
	void (*drawModel)(GamePlatform *self, Model const *model);
	void (*drawModelData)(GamePlatform *self, ModelData const *data);
	void (*drawModels)(GamePlatform *self, Model const *const *model, int count);
	cibool (*enetAvailable)(GamePlatform *self);
	EnetHost const *(*enetCreateHost)(GamePlatform *self);
	cibool (*enetHostCheckEvents)(GamePlatform *self, EnetHost const *host, EnetEventRef const *event_);
	EnetPeer const *(*enetHostConnect)(GamePlatform *self, EnetHost const *host, const char *hostName, int port, int data, int channelLimit);
	void (*enetHostInitialize)(GamePlatform *self, EnetHost const *host, IPEndPointCi const *address, int peerLimit, int channelLimit, int incomingBandwidth, int outgoingBandwidth);
	void (*enetHostInitializeServer)(GamePlatform *self, EnetHost const *host, int port, int peerLimit);
	cibool (*enetHostService)(GamePlatform *self, EnetHost const *host, int timeout, EnetEventRef const *enetEvent);
	void (*enetPeerSend)(GamePlatform *self, EnetPeer const *peer, unsigned char channelID, unsigned char const *data, int dataLength, int flags);
	void (*exit)(GamePlatform *self);
	cibool (*exitAvailable)(GamePlatform *self);
	void (*exitMousePointerLock)(GamePlatform *self);
	const char *(*fileName)(GamePlatform *self, const char *fullpath);
	const char *(*fileOpenDialog)(GamePlatform *self, const char *extension, const char *extensionName, const char *initialDirectory);
	const char *const *(*fileReadAllLines)(GamePlatform *self, const char *path, IntRef const *length);
	float (*floatModulo)(GamePlatform *self, float a, int b);
	float (*floatParse)(GamePlatform *self, const char *value);
	int (*floatToInt)(GamePlatform *self, float value);
	const char *(*floatToString)(GamePlatform *self, float value);
	cibool (*floatTryParse)(GamePlatform *self, const char *s, FloatRef const *ret);
	cibool (*focused)(GamePlatform *self);
	void (*gLDeleteTexture)(GamePlatform *self, int id);
	void (*gLDisableAlphaTest)(GamePlatform *self);
	void (*gLEnableAlphaTest)(GamePlatform *self);
	void (*gLLineWidth)(GamePlatform *self, int width);
	int (*getCanvasHeight)(GamePlatform *self);
	int (*getCanvasWidth)(GamePlatform *self);
	DisplayResolutionCi const *(*getDisplayResolutionDefault)(GamePlatform *self);
	DisplayResolutionCi const *const *(*getDisplayResolutions)(GamePlatform *self, IntRef const *resolutionsCount);
	const char *(*getGameVersion)(GamePlatform *self);
	const char *(*getLanguageIso6391)(GamePlatform *self);
	Preferences const *(*getPreferences)(GamePlatform *self);
	WindowState (*getWindowState)(GamePlatform *self);
	void (*glClearColorBufferAndDepthBuffer)(GamePlatform *self);
	void (*glClearColorRgbaf)(GamePlatform *self, float r, float g, float b, float a);
	void (*glClearDepthBuffer)(GamePlatform *self);
	void (*glColorMaterialFrontAndBackAmbientAndDiffuse)(GamePlatform *self);
	void (*glCullFaceBack)(GamePlatform *self);
	void (*glDepthMask)(GamePlatform *self, cibool flag);
	void (*glDisableCullFace)(GamePlatform *self);
	void (*glDisableDepthTest)(GamePlatform *self);
	void (*glDisableFog)(GamePlatform *self);
	void (*glEnableColorMaterial)(GamePlatform *self);
	void (*glEnableCullFace)(GamePlatform *self);
	void (*glEnableDepthTest)(GamePlatform *self);
	void (*glEnableFog)(GamePlatform *self);
	void (*glEnableLighting)(GamePlatform *self);
	void (*glEnableTexture2d)(GamePlatform *self);
	void (*glFogFogColor)(GamePlatform *self, int r, int g, int b, int a);
	void (*glFogFogDensity)(GamePlatform *self, float density);
	void (*glFogFogModeExp2)(GamePlatform *self);
	int (*glGetMaxTextureSize)(GamePlatform *self);
	void (*glHintFogHintNicest)(GamePlatform *self);
	void (*glLightModelAmbient)(GamePlatform *self, int r, int g, int b);
	void (*glShadeModelSmooth)(GamePlatform *self);
	void (*glViewport)(GamePlatform *self, int x, int y, int width, int height);
	BitmapCi const *(*grabScreenshot)(GamePlatform *self);
	unsigned char const *(*gzipCompress)(GamePlatform *self, unsigned char const *data, int dataLength, IntRef const *retLength);
	void (*gzipDecompress)(GamePlatform *self, unsigned char const *compressed, int compressedLength, unsigned char const *ret);
	void (*initShaders)(GamePlatform *self);
	int (*intParse)(GamePlatform *self, const char *value);
	const char *(*intToString)(GamePlatform *self, int value);
	cibool (*isCached)(GamePlatform *self, const char *md5);
	cibool (*isChecksum)(GamePlatform *self, const char *checksum);
	cibool (*isDebuggerAttached)(GamePlatform *self);
	cibool (*isFastSystem)(GamePlatform *self);
	cibool (*isMousePointerLocked)(GamePlatform *self);
	cibool (*isSmallScreen)(GamePlatform *self);
	cibool (*isValidTypingChar)(GamePlatform *self, int c);
	const char *(*keyName)(GamePlatform *self, int key);
	Asset const *(*loadAssetFromCache)(GamePlatform *self, const char *md5);
	void (*loadAssetsAsyc)(GamePlatform *self, AssetList const *list, FloatRef const *progress);
	int (*loadTextureFromBitmap)(GamePlatform *self, BitmapCi const *bmp);
	float (*mathAcos)(GamePlatform *self, float p);
	float (*mathCos)(GamePlatform *self, float a);
	float (*mathSin)(GamePlatform *self, float a);
	float (*mathSqrt)(GamePlatform *self, float value);
	float (*mathTan)(GamePlatform *self, float p);
	void (*messageBoxShowError)(GamePlatform *self, const char *text, const char *caption);
	MonitorObject const *(*monitorCreate)(GamePlatform *self);
	void (*monitorEnter)(GamePlatform *self, MonitorObject const *monitorObject);
	void (*monitorExit)(GamePlatform *self, MonitorObject const *monitorObject);
	cibool (*mouseCursorIsVisible)(GamePlatform *self);
	void (*mouseCursorSetVisible)(GamePlatform *self, cibool value);
	cibool (*multithreadingAvailable)(GamePlatform *self);
	void (*openLinkInBrowser)(GamePlatform *self, const char *url);
	UriCi const *(*parseUri)(GamePlatform *self, const char *uri);
	const char *(*pathCombine)(GamePlatform *self, const char *part1, const char *part2);
	const char *(*pathSavegames)(GamePlatform *self);
	const char *(*pathStorage)(GamePlatform *self);
	const char *(*queryStringValue)(GamePlatform *self, const char *key);
	void (*queueUserWorkItem)(GamePlatform *self, Action_ const *action);
	RandomCi const *(*randomCreate)(GamePlatform *self);
	const char *const *(*readAllLines)(GamePlatform *self, const char *p, IntRef const *retCount);
	void (*requestMousePointerLock)(GamePlatform *self);
	void (*restoreWindowCursor)(GamePlatform *self);
	void (*saveAssetToCache)(GamePlatform *self, Asset const *tosave);
	void (*saveScreenshot)(GamePlatform *self);
	void (*setMatrixUniformModelView)(GamePlatform *self, float const *mvMatrix);
	void (*setMatrixUniformProjection)(GamePlatform *self, float const *pMatrix);
	void (*setPreferences)(GamePlatform *self, Preferences const *preferences);
	void (*setTextRendererFont)(GamePlatform *self, int fontID);
	void (*setTitle)(GamePlatform *self, const char *applicationname);
	void (*setVSync)(GamePlatform *self, cibool enabled);
	void (*setWindowCursor)(GamePlatform *self, int hotx, int hoty, int sizex, int sizey, unsigned char const *imgdata, int imgdataLength);
	void (*setWindowState)(GamePlatform *self, WindowState value);
	void (*showKeyboard)(GamePlatform *self, cibool show);
	cibool (*singlePlayerServerAvailable)(GamePlatform *self);
	void (*singlePlayerServerDisable)(GamePlatform *self);
	void (*singlePlayerServerExit)(GamePlatform *self);
	DummyNetwork *(*singlePlayerServerGetNetwork)(GamePlatform *self);
	cibool (*singlePlayerServerLoaded)(GamePlatform *self);
	void (*singlePlayerServerStart)(GamePlatform *self, const char *saveFilename);
	cibool (*stringContains)(GamePlatform *self, const char *a, const char *b);
	cibool (*stringEmpty)(GamePlatform *self, const char *data);
	const char *(*stringFormat)(GamePlatform *self, const char *format, const char *arg0);
	const char *(*stringFormat2)(GamePlatform *self, const char *format, const char *arg0, const char *arg1);
	const char *(*stringFormat3)(GamePlatform *self, const char *format, const char *arg0, const char *arg1, const char *arg2);
	const char *(*stringFormat4)(GamePlatform *self, const char *format, const char *arg0, const char *arg1, const char *arg2, const char *arg3);
	const char *(*stringFromUtf8ByteArray)(GamePlatform *self, unsigned char const *value, int valueLength);
	int (*stringIndexOf)(GamePlatform *self, const char *s, const char *p);
	const char *(*stringJoin)(GamePlatform *self, const char *const *value, const char *separator);
	const char *(*stringReplace)(GamePlatform *self, const char *s, const char *from, const char *to);
	const char **(*stringSplit)(GamePlatform *self, const char *value, const char *separator, IntRef const *returnLength);
	cibool (*stringStartsWithIgnoreCase)(GamePlatform *self, const char *a, const char *b);
	int const *(*stringToCharArray)(GamePlatform *self, const char *s, IntRef const *length);
	const char *(*stringToLower)(GamePlatform *self, const char *p);
	unsigned char const *(*stringToUtf8ByteArray)(GamePlatform *self, const char *s, IntRef const *retLength);
	const char *(*stringTrim)(GamePlatform *self, const char *value);
	cibool (*tcpAvailable)(GamePlatform *self);
	void (*tcpConnect)(GamePlatform *self, const char *ip, int port, BoolRef const *connected);
	int (*tcpReceive)(GamePlatform *self, unsigned char const *data, int dataLength);
	void (*tcpSend)(GamePlatform *self, unsigned char const *data, int length);
	void (*textSize)(GamePlatform *self, const char *text, float fontSize, IntRef const *outWidth, IntRef const *outHeight);
	void (*threadSpinWait)(GamePlatform *self, int iterations);
	void (*throwException)(GamePlatform *self, const char *message);
	void (*thumbnailDownloadAsync)(GamePlatform *self, const char *ip, int port, ThumbnailResponseCi const *response);
	int (*timeMillisecondsFromStart)(GamePlatform *self);
	const char *(*timestamp)(GamePlatform *self);
	void (*webClientDownloadDataAsync)(GamePlatform *self, const char *url, HttpResponseCi const *response);
	void (*webClientUploadDataAsync)(GamePlatform *self, const char *url, unsigned char const *data, int dataLength, HttpResponseCi const *response);
	cibool (*webSocketAvailable)(GamePlatform *self);
	void (*webSocketConnect)(GamePlatform *self, const char *ip, int port);
	int (*webSocketReceive)(GamePlatform *self, unsigned char const *data, int dataLength);
	void (*webSocketSend)(GamePlatform *self, unsigned char const *data, int dataLength);
	void (*windowExit)(GamePlatform *self);
}
GamePlatformVtbl;
struct GamePlatform {
	const GamePlatformVtbl *vtbl;
};
static void GamePlatform_Construct(GamePlatform *self, const GamePlatformVtbl *vtbl);

static int GameVersionHelper_DateToInt(int year, int month, int day);
static cibool GameVersionHelper_IsVersionDate(GamePlatform const *platform, const char *version);
static int GameVersionHelper_VersionToInt(GamePlatform const *platform, const char *version);

struct GetBlockHeight_ {
	DelegateGetBlockHeight base;
	Game const *w;
};
static void GetBlockHeight__Construct(GetBlockHeight_ *self, const DelegateGetBlockHeightVtbl *vtbl);
static const DelegateGetBlockHeightVtbl CiVtbl_GetBlockHeight_ = {
	(float (*)(DelegateGetBlockHeight *self, int x, int y, int z)) GetBlockHeight__GetBlockHeight
};

typedef struct {
	float const *(*getModelViewMatrix)(IGetCameraMatrix *self);
	float const *(*getProjectionMatrix)(IGetCameraMatrix *self);
}
IGetCameraMatrixVtbl;
struct IGetCameraMatrix {
	const IGetCameraMatrixVtbl *vtbl;
};
static void IGetCameraMatrix_Construct(IGetCameraMatrix *self, const IGetCameraMatrixVtbl *vtbl);

struct GetCameraMatrix {
	IGetCameraMatrix base;
	float const *lastmvmatrix;
	float const *lastpmatrix;
};
static void GetCameraMatrix_Construct(GetCameraMatrix *self, const IGetCameraMatrixVtbl *vtbl);
static const IGetCameraMatrixVtbl CiVtbl_GetCameraMatrix = {
	(float const *(*)(IGetCameraMatrix *self)) GetCameraMatrix_GetModelViewMatrix,
	(float const *(*)(IGetCameraMatrix *self)) GetCameraMatrix_GetProjectionMatrix
};




struct Grenade_ {
	int block;
	int sourcePlayer;
	float velocityX;
	float velocityY;
	float velocityZ;
};

struct HashSetVector3IntRef {
	int max;
	Vector3IntRef const **values;
};
static void HashSetVector3IntRef_Construct(HashSetVector3IntRef *self);

struct HttpResponseCi {
	cibool done;
	cibool error;
	int valueLength;
	unsigned char const *value;
};
static const char *HttpResponseCi_GetString(HttpResponseCi const *self, GamePlatform const *platform);

typedef struct {
	InterpolatedObject const *(*interpolate)(IInterpolation *self, InterpolatedObject const *a, InterpolatedObject const *b, float progress);
}
IInterpolationVtbl;
struct IInterpolation {
	const IInterpolationVtbl *vtbl;
};
static void IInterpolation_Construct(IInterpolation *self, const IInterpolationVtbl *vtbl);

typedef struct {
	int (*getBlock)(IMapStorage2 *self, int x, int y, int z);
	int (*getMapSizeX)(IMapStorage2 *self);
	int (*getMapSizeY)(IMapStorage2 *self);
	int (*getMapSizeZ)(IMapStorage2 *self);
	void (*setBlock)(IMapStorage2 *self, int x, int y, int z, int tileType);
}
IMapStorage2Vtbl;
struct IMapStorage2 {
	const IMapStorage2Vtbl *vtbl;
};
static void IMapStorage2_Construct(IMapStorage2 *self, const IMapStorage2Vtbl *vtbl);

typedef struct {
	void (*addNetworkPacket)(INetworkInterpolation *self, InterpolatedObject const *c, int timeMilliseconds);
	InterpolatedObject const *(*interpolatedState)(INetworkInterpolation *self, int timeMilliseconds);
}
INetworkInterpolationVtbl;
struct INetworkInterpolation {
	const INetworkInterpolationVtbl *vtbl;
};
static void INetworkInterpolation_Construct(INetworkInterpolation *self, const INetworkInterpolationVtbl *vtbl);

struct IPEndPointCiDefault {
	IPEndPointCi base;
	const char *address;
};
static void IPEndPointCiDefault_Construct(IPEndPointCiDefault *self, const IPEndPointCiVtbl *vtbl);
static const IPEndPointCiVtbl CiVtbl_IPEndPointCiDefault = {
	(const char *(*)(IPEndPointCi *self)) IPEndPointCiDefault_AddressToString
};

struct ITerrainTextures {
	Game const *game;
};

typedef struct {
	void (*onLoad)(ImageOnLoadHandler *self);
}
ImageOnLoadHandlerVtbl;
struct ImageOnLoadHandler {
	const ImageOnLoadHandlerVtbl *vtbl;
};
static void ImageOnLoadHandler_Construct(ImageOnLoadHandler *self, const ImageOnLoadHandlerVtbl *vtbl);

struct InfiniteMapChunked2d {
	int **chunks;
	Game const *d_Map;
};

struct IntRef {
	int value;
};



static void Intersection_Construct(Intersection *self);
static cibool Intersection_GetIntersection(float fDst1, float fDst2, float const *P1, float const *P2, float *Hit);
static cibool Intersection_InBox(float const *Hit, float const *B1, float const *B2, int Axis);

struct InventoryUtilClient {
	int cellCountX;
	int cellCountY;
	Packet_Inventory const *d_Inventory;
	GameDataItemsClient const *d_Items;
};
static void InventoryUtilClient_Construct(InventoryUtilClient *self);
static IntRef const *InventoryUtilClient_FreeHand(InventoryUtilClient const *self, int ActiveMaterial_);
static PointRef const *InventoryUtilClient_ItemAtCell(InventoryUtilClient const *self, PointRef const *p);
static Packet_Item const *InventoryUtilClient_ItemAtWearPlace(InventoryUtilClient const *self, int wearPlace, int activeMaterial);
static PointRef const *const *InventoryUtilClient_ItemsAtArea(InventoryUtilClient const *self, int pX, int pY, int sizeX, int sizeY, IntRef *retCount);

struct IsBlockEmpty_ {
	DelegateIsBlockEmpty base;
	Game const *w;
};
static void IsBlockEmpty__Construct(IsBlockEmpty_ *self, const DelegateIsBlockEmptyVtbl *vtbl);
static const DelegateIsBlockEmptyVtbl CiVtbl_IsBlockEmpty_ = {
	(cibool (*)(DelegateIsBlockEmpty *self, int x, int y, int z)) IsBlockEmpty__IsBlockEmpty
};

struct Kamera {
	int maximumAngle;
	int minimumAngle;
	float angle;
	Vector3Ref *center;
	float minimumDistance;
	float distance;
	float one;
	float tt;
};
static void Kamera_Construct(Kamera *self);
static float Kamera_GetCameraHeightFromCenter(Kamera const *self, GamePlatform const *platform);
static float Kamera_GetFlatDistance(Kamera const *self, GamePlatform const *platform);
static void Kamera_SetValidAngle(Kamera *self);

struct Key {
	int field;
	int wireType;
};

struct KeyEventArgs {
	cibool handled;
	int keyCode;
	cibool modifierAlt;
	cibool modifierCtrl;
	cibool modifierShift;
};

typedef struct {
	void (*onKeyDown)(KeyEventHandler *self, KeyEventArgs const *e);
	void (*onKeyPress)(KeyEventHandler *self, KeyPressEventArgs const *e);
	void (*onKeyUp)(KeyEventHandler *self, KeyEventArgs const *e);
}
KeyEventHandlerVtbl;
struct KeyEventHandler {
	const KeyEventHandlerVtbl *vtbl;
};
static void KeyEventHandler_Construct(KeyEventHandler *self, const KeyEventHandlerVtbl *vtbl);

struct KeyHelp {
	int defaultKey;
	const char *text;
};

struct KeyPressEventArgs {
	cibool handled;
	int keyChar;
};

struct KeyValue {
	Key const *key_;
	unsigned char const *value;
};

struct KeyValueStringInt {
	int value;
	const char *key;
};

struct KeyValueStringString {
	const char *key;
	const char *value;
};

struct Keyframe {
	int frame;
	int keyframeType;
	const char *animationName;
	const char *nodeName;
	float x;
	float y;
	float z;
};


struct Language {
	int loadedLanguagesCount;
	int loadedLanguagesMax;
	int stringsCount;
	int stringsMax;
	const char *overrideLanguage;
	const char **loadedLanguages;
	GamePlatform const *platform;
	TranslatedString const **strings;
};
static void Language_Construct(Language *self);
static void Language_Add(Language *self, const char *language, const char *id, const char *translated);
static void Language_AddEnglish(Language *self);
static cibool Language_ContainsTranslation(Language const *self, const char *language, const char *id);

struct LightBase {
	LightFlood const *flood;
	int *workData;
};
static void LightBase_Construct(LightBase *self);
static int LightBase_GetLightHeight(Game const *game, int cx, int cy, int xx, int yy);
static void LightBase_LightEmitting(LightBase const *self, int const *workportion, unsigned char *worklight, int const *dataLightRadius, cibool const *dataTransparent);
static void LightBase_Sunlight(Game const *game, int cx, int cy, int cz, unsigned char *worklight, int const *dataLightRadius, int sunlight);
static void LightBase_SunlightFlood(LightBase const *self, int const *workportion, unsigned char *worklight, int const *dataLightRadius, cibool const *dataTransparent);

struct LightBetweenChunks {
	int **chunksData;
	unsigned char **chunksLight;
	LightFlood const *flood;
};
static void LightBetweenChunks_Construct(LightBetweenChunks *self);
static void LightBetweenChunks_ArrayFillByte(LightBetweenChunks const *self, unsigned char *arr, int n, unsigned char value);
static void LightBetweenChunks_ArrayFillInt(LightBetweenChunks const *self, int *arr, int n, int value);
static void LightBetweenChunks_FloodBetweenChunks(LightBetweenChunks const *self, unsigned char const *const *chunksLight_, unsigned char const *cLight, unsigned char *dcLight, int cx, int cy, int cz, int dcx, int dcy, int dcz, int xx, int yy, int zz, int dxx, int dyy, int dzz, int const *dataLightRadius, cibool const *dataTransparent);
static void LightBetweenChunks_FloodBetweenChunks_(LightBetweenChunks const *self, int const *dataLightRadius, cibool const *dataTransparent);
static void LightBetweenChunks_Input(LightBetweenChunks const *self, Game const *game, int cx, int cy, int cz);
static void LightBetweenChunks_Output(LightBetweenChunks const *self, Game const *game, int cx, int cy, int cz);

struct LightFlood {
	FastQueueInt *q;
};
static void LightFlood_Construct(LightFlood *self);
static void LightFlood_Push(FastQueueInt *q_, unsigned char *light, int vLight, int newPos);

struct Line3D {
	float *end;
	float *start;
};

struct ListAction {
	int count;
	int max;
	Action_ const **items;
};
static void ListAction_Add(ListAction *self, Action_ const *action);
static void ListAction_Clear(ListAction *self);
static int ListAction_Count(ListAction const *self);
static void ListAction_RemoveAt(ListAction *self, int index);

struct ListBox3d {
	int count;
	Box3D const **arr;
};

struct ListConnectedPlayer {
	int count;
	ConnectedPlayer const **items;
};
static void ListConnectedPlayer_Construct(ListConnectedPlayer *self);
static void ListConnectedPlayer_Add(ListConnectedPlayer *self, ConnectedPlayer const *connectedPlayer);
static void ListConnectedPlayer_RemoveAt(ListConnectedPlayer *self, int at);

struct ListInfo {
	cibool empty;
	int indicescount;
	cibool render;
	int texture;
	cibool transparent;
	float centerX;
	float centerY;
	float centerZ;
	Model const *model;
	float radius;
};
static void ListInfo_Construct(ListInfo *self);

struct LoginClientCi {
	cibool shouldLogin;
	const char *loginPassword;
	const char *loginPublicServerKey;
	const char *loginToken;
	const char *loginUser;
	HttpResponseCi const *loginResponse;
	LoginResultRef *loginResult;
	const char *loginUrl;
	HttpResponseCi const *loginUrlResponse;
	LoginData *resultLoginData;
};

struct LoginData {
	cibool passwordCorrect;
	int port;
	cibool serverCorrect;
	const char *authCode;
	const char *serverAddress;
	const char *token;
};

struct LoginResultRef {
	LoginResult value;
};

struct MainMenu {
	int backgroundH;
	int backgroundW;
	int filter;
	cibool initialized;
	int minspeed;
	cibool mousePressed;
	int overlap;
	int previousMouseX;
	int previousMouseY;
	int previousTouchX;
	int previousTouchY;
	int textTexturesCount;
	int touchId;
	int viewportHeight;
	int viewportWidth;
	cibool xInv;
	cibool yInv;
	AssetList *assets;
	FloatRef const *assetsLoadProgress;
	Model const *cubeModel;
	cibool *currentlyPressedKeys;
	Language *lang;
	LoginClientCi *loginClient;
	float *mvMatrix;
	float one;
	GamePlatform const *p;
	float *pMatrix;
	RandomCi const *rnd;
	Screen *screen;
	TextColorRenderer *textColorRenderer;
	TextTexture const **textTextures;
	DictionaryStringInt1024 *textures;
	float windowX;
	float windowY;
	float xRot;
	float xSpeed;
	float yRot;
	float ySpeed;
	float z;
};
static void MainMenu_Construct(MainMenu *self);
static void MainMenu_Animate(MainMenu *self, float dt);
static void MainMenu_ConnectToGame(MainMenu *self, LoginData const *loginResultData, const char *username);
static void MainMenu_CreateAccount(MainMenu const *self, const char *user, const char *password, LoginResultRef *loginResult);
static void MainMenu_DrawBackground(MainMenu *self);
static void MainMenu_DrawButton(MainMenu *self, const char *text, float fontSize, float dx, float dy, float dw, float dh, cibool pressed);
static void MainMenu_DrawScene(MainMenu const *self, float dt);
static void MainMenu_DrawServerButton(MainMenu *self, const char *name, const char *motd, const char *gamemode, const char *playercount, float x, float y, float width, float height, const char *image);
static void MainMenu_DrawText(MainMenu *self, const char *text, float fontSize, float x, float y, TextAlign align, TextBaseline baseline);
static void MainMenu_Exit(MainMenu const *self);
static unsigned char const *MainMenu_GetFile(MainMenu const *self, const char *name);
static int MainMenu_GetFileLength(MainMenu const *self, const char *name);
static const char *const *MainMenu_GetSavegames(MainMenu const *self, IntRef *length);
static TextTexture const *MainMenu_GetTextTexture(MainMenu *self, const char *text, float fontSize);
static int MainMenu_GetTexture(MainMenu const *self, const char *name);
static void MainMenu_Login(MainMenu const *self, const char *user, const char *password, const char *serverHash, const char *token, LoginResultRef *loginResult, LoginData *loginResultData);
static void MainMenu_SetMatrixUniforms(MainMenu const *self);
static void MainMenu_StartConnectToIp(MainMenu *self);
static void MainMenu_StartLogin(MainMenu *self, const char *serverHash, const char *ip, int port);
static void MainMenu_StartMainMenu(MainMenu *self);
static void MainMenu_StartModifyWorld(MainMenu const *self);
static void MainMenu_StartMultiplayer(MainMenu *self);
static void MainMenu_StartNewWorld(MainMenu const *self);
static void MainMenu_StartSingleplayer(MainMenu *self);

struct MainMenuKeyEventHandler {
	KeyEventHandler base;
	MainMenu *l;
};
static void MainMenuKeyEventHandler_Construct(MainMenuKeyEventHandler *self, const KeyEventHandlerVtbl *vtbl);
static const KeyEventHandlerVtbl CiVtbl_MainMenuKeyEventHandler = {
	(void (*)(KeyEventHandler *self, KeyEventArgs const *e)) MainMenuKeyEventHandler_OnKeyDown,
	(void (*)(KeyEventHandler *self, KeyPressEventArgs const *e)) MainMenuKeyEventHandler_OnKeyPress,
	(void (*)(KeyEventHandler *self, KeyEventArgs const *e)) MainMenuKeyEventHandler_OnKeyUp
};

typedef struct {
	void (*onMouseDown)(MouseEventHandler *self, MouseEventArgs const *e);
	void (*onMouseMove)(MouseEventHandler *self, MouseEventArgs const *e);
	void (*onMouseUp)(MouseEventHandler *self, MouseEventArgs const *e);
	void (*onMouseWheel)(MouseEventHandler *self, MouseWheelEventArgs const *e);
}
MouseEventHandlerVtbl;
struct MouseEventHandler {
	const MouseEventHandlerVtbl *vtbl;
};
static void MouseEventHandler_Construct(MouseEventHandler *self, const MouseEventHandlerVtbl *vtbl);

struct MainMenuMouseEventHandler {
	MouseEventHandler base;
	MainMenu *l;
};
static void MainMenuMouseEventHandler_Construct(MainMenuMouseEventHandler *self, const MouseEventHandlerVtbl *vtbl);
static const MouseEventHandlerVtbl CiVtbl_MainMenuMouseEventHandler = {
	(void (*)(MouseEventHandler *self, MouseEventArgs const *e)) MainMenuMouseEventHandler_OnMouseDown,
	(void (*)(MouseEventHandler *self, MouseEventArgs const *e)) MainMenuMouseEventHandler_OnMouseMove,
	(void (*)(MouseEventHandler *self, MouseEventArgs const *e)) MainMenuMouseEventHandler_OnMouseUp,
	(void (*)(MouseEventHandler *self, MouseWheelEventArgs const *e)) MainMenuMouseEventHandler_OnMouseWheel
};

typedef struct {
	void (*onNewFrame)(NewFrameHandler *self, NewFrameEventArgs const *args);
}
NewFrameHandlerVtbl;
struct NewFrameHandler {
	const NewFrameHandlerVtbl *vtbl;
};
static void NewFrameHandler_Construct(NewFrameHandler *self, const NewFrameHandlerVtbl *vtbl);

struct MainMenuNewFrameHandler {
	NewFrameHandler base;
	MainMenu *l;
};
static void MainMenuNewFrameHandler_Construct(MainMenuNewFrameHandler *self, const NewFrameHandlerVtbl *vtbl);
static const NewFrameHandlerVtbl CiVtbl_MainMenuNewFrameHandler = {
	(void (*)(NewFrameHandler *self, NewFrameEventArgs const *args)) MainMenuNewFrameHandler_OnNewFrame
};

typedef struct {
	void (*onTouchEnd)(TouchEventHandler *self, TouchEventArgs const *e);
	void (*onTouchMove)(TouchEventHandler *self, TouchEventArgs const *e);
	void (*onTouchStart)(TouchEventHandler *self, TouchEventArgs const *e);
}
TouchEventHandlerVtbl;
struct TouchEventHandler {
	const TouchEventHandlerVtbl *vtbl;
};
static void TouchEventHandler_Construct(TouchEventHandler *self, const TouchEventHandlerVtbl *vtbl);

struct MainMenuTouchEventHandler {
	TouchEventHandler base;
	MainMenu *l;
};
static void MainMenuTouchEventHandler_Construct(MainMenuTouchEventHandler *self, const TouchEventHandlerVtbl *vtbl);
static const TouchEventHandlerVtbl CiVtbl_MainMenuTouchEventHandler = {
	(void (*)(TouchEventHandler *self, TouchEventArgs const *e)) MainMenuTouchEventHandler_OnTouchEnd,
	(void (*)(TouchEventHandler *self, TouchEventArgs const *e)) MainMenuTouchEventHandler_OnTouchMove,
	(void (*)(TouchEventHandler *self, TouchEventArgs const *e)) MainMenuTouchEventHandler_OnTouchStart
};

struct Map {
	int mapSizeX;
	int mapSizeY;
	int mapSizeZ;
	Chunk **chunks;
};

struct MapLoadingProgressEventArgs {
	int progressBytes;
	int progressPercent;
	const char *progressStatus;
};

struct MapStorage2 {
	IMapStorage2 base;
	Game *game;
};
static void MapStorage2_Construct(MapStorage2 *self, const IMapStorage2Vtbl *vtbl);
static const IMapStorage2Vtbl CiVtbl_MapStorage2 = {
	(int (*)(IMapStorage2 *self, int x, int y, int z)) MapStorage2_GetBlock,
	(int (*)(IMapStorage2 *self)) MapStorage2_GetMapSizeX,
	(int (*)(IMapStorage2 *self)) MapStorage2_GetMapSizeY,
	(int (*)(IMapStorage2 *self)) MapStorage2_GetMapSizeZ,
	(void (*)(IMapStorage2 *self, int x, int y, int z, int tileType)) MapStorage2_SetBlock
};

static void MapUtilCi_PosInt(int index, int sizex, int sizey, Vector3IntRef *ret);






struct MenuState {
	int selected;
};

struct MenuWidget {
	ButtonStyle buttonStyle;
	int color;
	cibool editing;
	cibool hasKeyboardFocus;
	cibool hover;
	cibool isbutton;
	int nextWidget;
	cibool password;
	cibool pressed;
	cibool selected;
	WidgetType type;
	cibool visible;
	const char *description;
	FontCi *font;
	float fontSize;
	const char *id;
	const char *image;
	float sizex;
	float sizey;
	const char *text;
	float x;
	float y;
};
static void MenuWidget_Construct(MenuWidget *self);

struct MeshBatcher {
	cibool bindTexture;
	int emptyCount;
	int glTexturesLength;
	int modelsCount;
	FrustumCulling const *d_FrustumCulling;
	int *empty;
	Game const *game;
	int *glTextures;
	ListInfo **models;
	ToCall **tocallSolid;
	ToCall **tocallTransparent;
};
static void MeshBatcher_Construct(MeshBatcher *self);
static int MeshBatcher_ArrayIndexOf(MeshBatcher const *self, int const *glTextures, int length, int glTexture);
static int MeshBatcher_GetTextureId(MeshBatcher *self, int glTexture);
static void MeshBatcher_SortListsByTexture(MeshBatcher *self);
static void MeshBatcher_UpdateCulling(MeshBatcher const *self);

struct Minecart {
	VehicleDirection12 direction;
	cibool enabled;
	VehicleDirection12 lastdirection;
	float positionX;
	float positionY;
	float positionZ;
	float progress;
};


struct ModAudio {
	ClientMod base;
	cibool wasLoaded;
	DictionaryStringAudioData const *audioData;
};
static void ModAudio_Construct(ModAudio *self, const ClientModVtbl *vtbl);
static AudioData const *ModAudio_GetAudioData(ModAudio const *self, Game const *game, const char *sound);
static void ModAudio_Preload(ModAudio const *self, Game const *game);
static const ClientModVtbl CiVtbl_ModAudio = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	(void (*)(ClientMod *self, Game const *game, NewFrameEventArgs const *args)) ModAudio_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModAutoCamera {
	ClientMod base;
	int cameraPointsCount;
	cibool firstFrameDone;
	int previousFreemove;
	AviWriterCi const *avi;
	CameraPoint const **cameraPoints;
	ClientModManager const *m;
	float one;
	float const *orientation;
	GamePlatform const *p;
	float playingSpeed;
	float playingTime;
	float const *position;
	float previousOrientationX;
	float previousOrientationY;
	float previousOrientationZ;
	float previousPositionX;
	float previousPositionY;
	float previousPositionZ;
	float recspeed;
	float writeAccum;
};
static void ModAutoCamera_Construct(ModAutoCamera *self, const ClientModVtbl *vtbl);
static float ModAutoCamera_Distance(ModAutoCamera const *self, CameraPoint const *a, CameraPoint const *b);
static void ModAutoCamera_Stop(ModAutoCamera *self);
static float ModAutoCamera_TotalDistance(ModAutoCamera const *self);
static void ModAutoCamera_UpdateAvi(ModAutoCamera *self, float dt);
static const ClientModVtbl CiVtbl_ModAutoCamera = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	(cibool (*)(ClientMod *self, Game const *game, ClientCommandArgs const *args)) ModAutoCamera_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	(void (*)(ClientMod *self, Game const *game, NewFrameEventArgs const *args)) ModAutoCamera_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	(void (*)(ClientMod *self, ClientModManager const *modmanager)) ModAutoCamera_Start
};

struct ModBlockDamageToPlayer {
	ClientMod base;
	TimerCi *blockDamageToPlayerTimer;
	float one;
};
static void ModBlockDamageToPlayer_Construct(ModBlockDamageToPlayer *self, const ClientModVtbl *vtbl);
static void ModBlockDamageToPlayer_UpdateBlockDamageToPlayer(ModBlockDamageToPlayer const *self, Game *game, float dt);
static const ClientModVtbl CiVtbl_ModBlockDamageToPlayer = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	(void (*)(ClientMod *self, Game const *game, NewFrameEventArgs const *args)) ModBlockDamageToPlayer_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModBullet {
	ClientMod base;
};
static void ModBullet_Construct(ModBullet *self, const ClientModVtbl *vtbl);
static const ClientModVtbl CiVtbl_ModBullet = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModBullet_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModCamera {
	ClientMod base;
	Vector3Ref *overheadCamera_cameraEye;
	float const *upVec3;
};
static void ModCamera_Construct(ModCamera *self, const ClientModVtbl *vtbl);
static float const *ModCamera_FppCamera(ModCamera const *self, Game *game);
static void ModCamera_LimitThirdPersonCameraToWalls(ModCamera const *self, Game const *game, Vector3Ref *eye, Vector3Ref const *target, FloatRef *curtppcameradistance);
static float const *ModCamera_OverheadCamera(ModCamera const *self, Game *game);
static const ClientModVtbl CiVtbl_ModCamera = {
	ClientMod_Dispose,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModCamera_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModCameraKeys {
	ClientMod base;
};
static void ModCameraKeys_Construct(ModCameraKeys *self, const ClientModVtbl *vtbl);
static const ClientModVtbl CiVtbl_ModCameraKeys = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	(void (*)(ClientMod *self, Game const *game, NewFrameEventArgs const *args)) ModCameraKeys_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModClearInactivePlayersDrawInfo {
	ClientMod base;
};
static void ModClearInactivePlayersDrawInfo_Construct(ModClearInactivePlayersDrawInfo *self, const ClientModVtbl *vtbl);
static const ClientModVtbl CiVtbl_ModClearInactivePlayersDrawInfo = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	(void (*)(ClientMod *self, Game const *game, NewFrameEventArgs const *args)) ModClearInactivePlayersDrawInfo_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModCompass {
	ClientMod base;
	int compassid;
	int needleid;
	float compassangle;
	float compassvertex;
	float one;
};
static void ModCompass_Construct(ModCompass *self, const ClientModVtbl *vtbl);
static cibool ModCompass_CompassInActiveMaterials(ModCompass const *self, Game const *game);
static const ClientModVtbl CiVtbl_ModCompass = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModCompass_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModDebugChunk {
	ClientMod base;
	cibool draw;
	DrawWireframeCube *lines;
};
static void ModDebugChunk_Construct(ModDebugChunk *self, const ClientModVtbl *vtbl);
static const ClientModVtbl CiVtbl_ModDebugChunk = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	(cibool (*)(ClientMod *self, Game const *game, ClientCommandArgs const *args)) ModDebugChunk_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModDebugChunk_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModDialog {
	ClientMod base;
	ClientPacketHandler const *packetHandler;
};
static void ModDialog_Construct(ModDialog *self, const ClientModVtbl *vtbl);
static void ModDialog_DrawDialogs(ModDialog const *self, Game const *game);
static const ClientModVtbl CiVtbl_ModDialog = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	(void (*)(ClientMod *self, Game const *game, KeyEventArgs const *args)) ModDialog_OnKeyDown,
	(void (*)(ClientMod *self, Game const *game, KeyPressEventArgs const *args)) ModDialog_OnKeyPress,
	(void (*)(ClientMod *self, Game const *game, KeyEventArgs const *args)) ModDialog_OnKeyUp,
	(void (*)(ClientMod *self, Game const *game, MouseEventArgs const *args)) ModDialog_OnMouseDown,
	ClientMod_OnMouseMove,
	(void (*)(ClientMod *self, Game const *game, MouseEventArgs const *args)) ModDialog_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModDialog_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModDraw2dMisc {
	ClientMod base;
};
static void ModDraw2dMisc_Construct(ModDraw2dMisc *self, const ClientModVtbl *vtbl);
static void ModDraw2dMisc_DrawAim(ModDraw2dMisc const *self, Game *game);
static void ModDraw2dMisc_DrawAmmo(ModDraw2dMisc const *self, Game *game);
static void ModDraw2dMisc_DrawDisconnected(ModDraw2dMisc const *self, Game *game);
static void ModDraw2dMisc_DrawEnemyHealthBlock(ModDraw2dMisc const *self, Game *game);
static void ModDraw2dMisc_DrawEnemyHealthCommon(ModDraw2dMisc const *self, Game *game, const char *name, float progress);
static void ModDraw2dMisc_DrawEnemyHealthUseInfo(ModDraw2dMisc const *self, Game *game, const char *name, float progress, cibool useInfo);
static void ModDraw2dMisc_DrawLocalPosition(ModDraw2dMisc const *self, Game *game);
static void ModDraw2dMisc_DrawMouseCursor(ModDraw2dMisc const *self, Game *game);
static const ClientModVtbl CiVtbl_ModDraw2dMisc = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModDraw2dMisc_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModDrawArea {
	ClientMod base;
	DrawWireframeCube *lines;
};
static void ModDrawArea_Construct(ModDrawArea *self, const ClientModVtbl *vtbl);
static const ClientModVtbl CiVtbl_ModDrawArea = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	(void (*)(ClientMod *self, Game const *game, OnUseEntityArgs const *e)) ModDrawArea_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModDrawArea_OnNewFrameDraw3d,
	(void (*)(ClientMod *self, Game const *game, NewFrameEventArgs const *args)) ModDrawArea_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModDrawHand2d {
	ClientMod base;
	const char *lasthandimage;
};
static void ModDrawHand2d_Construct(ModDrawHand2d *self, const ClientModVtbl *vtbl);
static const ClientModVtbl CiVtbl_ModDrawHand2d = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModDrawHand2d_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModDrawHand3d {
	ClientMod base;
	cibool build;
	int oldMaterial;
	float animperiod;
	float attack;
	float attackt;
	float buildt;
	BlockRendererTorch *d_BlockRendererTorch;
	Game *game;
	ModelData *modelData;
	float oldLight;
	float oldplayerposX;
	float oldplayerposY;
	float oldplayerposZ;
	float one;
	float range;
	float slowdownTimer;
	float slowdownTimerSpecial;
	float speed;
	float t_;
	float zzzposx;
	float zzzposy;
	float zzzposz;
	float zzzx;
	float zzzy;
};
static void ModDrawHand3d_Construct(ModDrawHand3d *self, const ClientModVtbl *vtbl);
static void ModDrawHand3d_DrawCube(ModDrawHand3d const *self, ModelData *m, int x, int y, int z, int c);
static float ModDrawHand3d_rot(ModDrawHand3d const *self, float t);
static float ModDrawHand3d_rot2(ModDrawHand3d const *self, float t);
static const ClientModVtbl CiVtbl_ModDrawHand3d = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModDrawHand3d_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModDrawLinesAroundSelectedBlock {
	ClientMod base;
	DrawWireframeCube *lines;
	float one;
};
static void ModDrawLinesAroundSelectedBlock_Construct(ModDrawLinesAroundSelectedBlock *self, const ClientModVtbl *vtbl);
static const ClientModVtbl CiVtbl_ModDrawLinesAroundSelectedBlock = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModDrawLinesAroundSelectedBlock_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModDrawMain {
	ClientMod base;
};
static void ModDrawMain_Construct(ModDrawMain *self, const ClientModVtbl *vtbl);
static const ClientModVtbl CiVtbl_ModDrawMain = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	(void (*)(ClientMod *self, Game const *game, float dt)) ModDrawMain_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModDrawMinecarts {
	ClientMod base;
	int minecarttexture;
};
static void ModDrawMinecarts_Construct(ModDrawMinecarts *self, const ClientModVtbl *vtbl);
static float ModDrawMinecarts_vehiclerotation(ModDrawMinecarts const *self, VehicleDirection12 dir);
static const ClientModVtbl CiVtbl_ModDrawMinecarts = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModDrawMinecarts_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModDrawParticleEffectBlockBreak {
	ClientMod base;
};
static void ModDrawParticleEffectBlockBreak_Construct(ModDrawParticleEffectBlockBreak *self, const ClientModVtbl *vtbl);
static const ClientModVtbl CiVtbl_ModDrawParticleEffectBlockBreak = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModDrawParticleEffectBlockBreak_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModDrawPlayerNames {
	ClientMod base;
};
static void ModDrawPlayerNames_Construct(ModDrawPlayerNames *self, const ClientModVtbl *vtbl);
static const ClientModVtbl CiVtbl_ModDrawPlayerNames = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModDrawPlayerNames_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModDrawPlayers {
	ClientMod base;
	float one;
};
static void ModDrawPlayers_Construct(ModDrawPlayers *self, const ClientModVtbl *vtbl);
static void ModDrawPlayers_DrawPlayers(ModDrawPlayers const *self, Game *game, float dt);
static const ClientModVtbl CiVtbl_ModDrawPlayers = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModDrawPlayers_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModDrawSprites {
	ClientMod base;
};
static void ModDrawSprites_Construct(ModDrawSprites *self, const ClientModVtbl *vtbl);
static const ClientModVtbl CiVtbl_ModDrawSprites = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModDrawSprites_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModDrawTerrain {
	ClientMod base;
	int chunksize;
	int chunkupdates;
	int idsCount;
	int lastPerformanceInfoupdateMilliseconds;
	int lastchunkupdates;
	int redrawCount;
	cibool started;
	cibool terrainRendererStarted;
	cibool *calculateShadowsisTransparentForLight;
	int *calculateShadowslightRadius;
	int *currentChunk;
	unsigned char *currentChunkShadows;
	Game *game;
	int *ids;
	LightBase const *lightBase;
	LightBetweenChunks const *lightBetweenChunks;
	TerrainRendererRedraw const **redraw;
	float sqrt3half;
	int *tempnearestpos;
};
static void ModDrawTerrain_Construct(ModDrawTerrain *self, const ClientModVtbl *vtbl);
static void ModDrawTerrain_CalculateShadows(ModDrawTerrain const *self, int cx, int cy, int cz);
static void ModDrawTerrain_Clear(ModDrawTerrain const *self);
static void ModDrawTerrain_DoRedraw(ModDrawTerrain *self, TerrainRendererRedraw const *r);
static void ModDrawTerrain_GetExtendedChunk(ModDrawTerrain const *self, int x, int y, int z);
static cibool ModDrawTerrain_IsSolidChunk(ModDrawTerrain const *self, int const *currentChunk, int length);
static ModelData const *ModDrawTerrain_ModelDataClone(ModDrawTerrain const *self, ModelData const *source);
static void ModDrawTerrain_NearestDirty(ModDrawTerrain const *self, int *nearestpos);
static void ModDrawTerrain_RedrawChunk(ModDrawTerrain *self, int x, int y, int z);
static void ModDrawTerrain_UpdatePerformanceInfo(ModDrawTerrain *self, float dt);
static VerticesIndicesToLoad const *ModDrawTerrain_VerticesIndicesToLoadClone(ModDrawTerrain const *self, VerticesIndicesToLoad const *source);
static int ModDrawTerrain_mapAreaSize(ModDrawTerrain const *self);
static int ModDrawTerrain_mapAreaSizeZ(ModDrawTerrain const *self);
static int ModDrawTerrain_mapsizexchunks(ModDrawTerrain const *self);
static int ModDrawTerrain_mapsizeychunks(ModDrawTerrain const *self);
static int ModDrawTerrain_mapsizezchunks(ModDrawTerrain const *self);
static const ClientModVtbl CiVtbl_ModDrawTerrain = {
	(void (*)(ClientMod *self, Game const *game)) ModDrawTerrain_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModDrawTerrain_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	(void (*)(ClientMod *self, Game const *game, float dt)) ModDrawTerrain_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModDrawTestModel {
	ClientMod base;
	AnimatedModelRenderer *testmodel;
};
static void ModDrawTestModel_Construct(ModDrawTestModel *self, const ClientModVtbl *vtbl);
static void ModDrawTestModel_DrawTestModel(ModDrawTestModel *self, Game const *game, float deltaTime);
static const ClientModVtbl CiVtbl_ModDrawTestModel = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	(cibool (*)(ClientMod *self, Game const *game, ClientCommandArgs const *args)) ModDrawTestModel_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModDrawTestModel_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModDrawText {
	ClientMod base;
};
static void ModDrawText_Construct(ModDrawText *self, const ClientModVtbl *vtbl);
static const ClientModVtbl CiVtbl_ModDrawText = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModDrawText_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModExpire {
	ClientMod base;
};
static void ModExpire_Construct(ModExpire *self, const ClientModVtbl *vtbl);
static void ModExpire_GrenadeExplosion(ModExpire const *self, Game *game, int grenadeEntityId);
static const ClientModVtbl CiVtbl_ModExpire = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	(void (*)(ClientMod *self, Game const *game, NewFrameEventArgs const *args)) ModExpire_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModFallDamageToPlayer {
	ClientMod base;
	cibool fallSoundPlaying;
	int lastfalldamagetimeMilliseconds;
	float one;
};
static void ModFallDamageToPlayer_Construct(ModFallDamageToPlayer *self, const ClientModVtbl *vtbl);
static void ModFallDamageToPlayer_SetFallSoundActive(ModFallDamageToPlayer *self, Game const *game, cibool active);
static void ModFallDamageToPlayer_UpdateFallDamageToPlayer(ModFallDamageToPlayer *self, Game const *game, float dt);
static const ClientModVtbl CiVtbl_ModFallDamageToPlayer = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	(void (*)(ClientMod *self, Game const *game, NewFrameEventArgs const *args)) ModFallDamageToPlayer_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModFpsHistoryGraph {
	ClientMod base;
	cibool drawfpsgraph;
	cibool drawfpstext;
	int fpscount;
	int lasttitleupdateMilliseconds;
	float *dtHistory;
	const char *fpstext;
	float longestframedt;
	ClientModManager const *m;
	float one;
	Draw2dData **todraw;
};
static void ModFpsHistoryGraph_Construct(ModFpsHistoryGraph *self, const ClientModVtbl *vtbl);
static void ModFpsHistoryGraph_Draw(ModFpsHistoryGraph const *self);
static void ModFpsHistoryGraph_DrawGraph(ModFpsHistoryGraph const *self);
static void ModFpsHistoryGraph_UpdateGraph(ModFpsHistoryGraph const *self, float dt);
static void ModFpsHistoryGraph_UpdateTitleFps(ModFpsHistoryGraph *self, float dt);
static const ClientModVtbl CiVtbl_ModFpsHistoryGraph = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	(cibool (*)(ClientMod *self, Game const *game, ClientCommandArgs const *args)) ModFpsHistoryGraph_OnClientCommand,
	ClientMod_OnHitEntity,
	(void (*)(ClientMod *self, Game const *game, KeyEventArgs const *args)) ModFpsHistoryGraph_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	(void (*)(ClientMod *self, Game const *game, NewFrameEventArgs const *args)) ModFpsHistoryGraph_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	(void (*)(ClientMod *self, ClientModManager const *modmanager)) ModFpsHistoryGraph_Start
};

struct ModGrenade {
	ClientMod base;
	float bouncespeedmultiply;
	float one;
	float projectilegravity;
	float walldistance;
};
static void ModGrenade_Construct(ModGrenade *self, const ClientModVtbl *vtbl);
static Vector3Ref const *ModGrenade_GrenadeBounce(ModGrenade const *self, Game const *game, Vector3Ref *oldposition, Vector3Ref *newposition, Vector3Ref *velocity, float dt);
static void ModGrenade_UpdateGrenade(ModGrenade const *self, Game const *game, int grenadeEntityId, float dt);
static const ClientModVtbl CiVtbl_ModGrenade = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	(void (*)(ClientMod *self, Game const *game, NewFrameEventArgs const *args)) ModGrenade_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModGuiChat {
	ClientMod base;
	int chatLinesMaxToDraw;
	int chatPageScroll;
	int chatScreenExpireTimeSeconds;
	int chatlines2Count;
	float chatFontSize;
	Chatline const **chatlines2;
	FontCi *font;
	Game *game;
	float one;
};
static void ModGuiChat_Construct(ModGuiChat *self, const ClientModVtbl *vtbl);
static const ClientModVtbl CiVtbl_ModGuiChat = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	(void (*)(ClientMod *self, Game const *game, KeyEventArgs const *args)) ModGuiChat_OnKeyDown,
	(void (*)(ClientMod *self, Game const *game, KeyPressEventArgs const *args)) ModGuiChat_OnKeyPress,
	ClientMod_OnKeyUp,
	(void (*)(ClientMod *self, Game const *game, MouseEventArgs const *args)) ModGuiChat_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModGuiChat_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModGuiCrafting {
	ClientMod base;
	int craftingTableposx;
	int craftingTableposy;
	int craftingTableposz;
	int craftingblocksCount;
	int craftingrecipes2Count;
	int craftingselectedrecipe;
	int currentRecipesCount;
	int d_CraftingRecipesCount;
	int const *craftingblocks;
	Packet_CraftingRecipe const *const *craftingrecipes2;
	int *currentRecipes;
	Packet_CraftingRecipe const *const *d_CraftingRecipes;
	CraftingTableTool *d_CraftingTableTool;
	PacketHandlerCraftingRecipes *handler;
};
static void ModGuiCrafting_Construct(ModGuiCrafting *self, const ClientModVtbl *vtbl);
static void ModGuiCrafting_CraftingMouse(ModGuiCrafting *self, Game *game);
static void ModGuiCrafting_CraftingRecipeSelected(ModGuiCrafting const *self, Game const *game, int x, int y, int z, IntRef const *recipe);
static void ModGuiCrafting_CraftingRecipesStart(ModGuiCrafting *self, Game *game, Packet_CraftingRecipe const *const *recipes, int recipesCount, int const *blocks, int blocksCount, int posx, int posy, int posz);
static void ModGuiCrafting_DrawCraftingRecipes(ModGuiCrafting *self, Game *game);
static int ModGuiCrafting_craftingblocksFindAllCount(ModGuiCrafting const *self, int const *craftingblocks_, int craftingblocksCount_, int p);
static const ClientModVtbl CiVtbl_ModGuiCrafting = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	(void (*)(ClientMod *self, Game const *game, KeyEventArgs const *args)) ModGuiCrafting_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModGuiCrafting_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	(void (*)(ClientMod *self, Game const *game, NewFrameEventArgs const *args)) ModGuiCrafting_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModGuiEscapeMenu {
	ClientMod base;
	cibool changedResolution;
	EscapeMenuState escapemenustate;
	int fontsLength;
	int keyselectid;
	cibool loaded;
	int originalResolutionHeight;
	int originalResolutionWidth;
	int widgetsCount;
	Button *buttonMainExit;
	Button *buttonMainOptions;
	Button *buttonMainReturnToGame;
	int *fontValues;
	const char **fonts;
	Game *game;
	Button *graphicsFontOption;
	Button *graphicsOptionDarkenSides;
	Button *graphicsOptionFramerate;
	Button *graphicsOptionFullscreen;
	Button *graphicsOptionResolution;
	Button *graphicsOptionSmoothShadows;
	Button *graphicsReturnToOptionsMenu;
	Button *graphicsUseServerTexturesOption;
	Button *graphicsViewDistanceOption;
	Button **keyButtons;
	Button *keysDefaultKeys;
	Button *keysReturnToOptionsMenu;
	float one;
	Button *optionsGraphics;
	Button *optionsKeys;
	Button *optionsOther;
	Button *optionsReturnToMainMenu;
	Button *otherAutoJumpOption;
	Button *otherLanguageSetting;
	Button *otherReturnToOptionsMenu;
	Button *otherSoundOption;
	Button **widgets;
};
static void ModGuiEscapeMenu_Construct(ModGuiEscapeMenu *self, const ClientModVtbl *vtbl);
static void ModGuiEscapeMenu_AddWidget(ModGuiEscapeMenu *self, Button *b);
static void ModGuiEscapeMenu_EscapeMenuMouse1(ModGuiEscapeMenu *self);
static const char *ModGuiEscapeMenu_FontString(ModGuiEscapeMenu const *self);
static void ModGuiEscapeMenu_GraphicsHandleClick(ModGuiEscapeMenu *self, Button const *b);
static void ModGuiEscapeMenu_GraphicsSet(ModGuiEscapeMenu *self);
static void ModGuiEscapeMenu_HandleButtonClick(ModGuiEscapeMenu *self, Button const *w);
static KeyHelp const *ModGuiEscapeMenu_KeyHelpCreate(ModGuiEscapeMenu const *self, const char *text, int defaultKey);
static const char *ModGuiEscapeMenu_KeyName(ModGuiEscapeMenu const *self, int key);
static void ModGuiEscapeMenu_KeysHandleClick(ModGuiEscapeMenu *self, Button const *b);
static void ModGuiEscapeMenu_KeysSet(ModGuiEscapeMenu *self);
static OptionsCi *ModGuiEscapeMenu_LoadOptions_(ModGuiEscapeMenu const *self);
static void ModGuiEscapeMenu_MainHandleClick(ModGuiEscapeMenu *self, Button const *b);
static void ModGuiEscapeMenu_MainSet(ModGuiEscapeMenu *self);
static void ModGuiEscapeMenu_MakeSimpleOptions(ModGuiEscapeMenu const *self, int fontsize, int textheight);
static void ModGuiEscapeMenu_OptionsHandleClick(ModGuiEscapeMenu *self, Button const *b);
static void ModGuiEscapeMenu_OptionsSet(ModGuiEscapeMenu *self);
static void ModGuiEscapeMenu_OtherHandleClick(ModGuiEscapeMenu *self, Button const *b);
static void ModGuiEscapeMenu_OtherSet(ModGuiEscapeMenu *self);
static cibool ModGuiEscapeMenu_RectContains(ModGuiEscapeMenu const *self, int x, int y, int w, int h, int px, int py);
static const char *ModGuiEscapeMenu_ResolutionString(ModGuiEscapeMenu const *self);
static void ModGuiEscapeMenu_SaveOptions_(ModGuiEscapeMenu const *self, OptionsCi const *options);
static void ModGuiEscapeMenu_SetEscapeMenuState(ModGuiEscapeMenu *self, EscapeMenuState state);
static void ModGuiEscapeMenu_ToggleFont(ModGuiEscapeMenu const *self);
static void ModGuiEscapeMenu_ToggleResolution(ModGuiEscapeMenu const *self);
static void ModGuiEscapeMenu_UseFullscreen(ModGuiEscapeMenu *self);
static const char *ModGuiEscapeMenu_VsyncString(ModGuiEscapeMenu const *self);
static void ModGuiEscapeMenu_WidgetsClear(ModGuiEscapeMenu *self);
static KeyHelp const *const *ModGuiEscapeMenu_keyhelps(ModGuiEscapeMenu const *self);
static const ClientModVtbl CiVtbl_ModGuiEscapeMenu = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	(void (*)(ClientMod *self, Game const *game, KeyEventArgs const *args)) ModGuiEscapeMenu_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModGuiEscapeMenu_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModGuiInventory {
	ClientMod base;
	int cellCountInPageX;
	int cellCountInPageY;
	int cellCountTotalX;
	int cellCountTotalY;
	int cellDrawSize;
	int scrollLine;
	int scrollingDownTimeMilliseconds;
	int scrollingUpTimeMilliseconds;
	IInventoryController const *controller;
	GameDataItemsClient *dataItems;
	Game *game;
	InventoryUtilClient const *inventoryUtil;
	PointRef const **wearPlaceCells;
	PointRef **wearPlaceStart;
};
static void ModGuiInventory_Construct(ModGuiInventory *self, const ClientModVtbl *vtbl);
static void ModGuiInventory_DrawItem(ModGuiInventory const *self, int screenposX, int screenposY, Packet_Item const *item, int drawsizeX, int drawsizeY);
static Packet_Item const *ModGuiInventory_GetItem(ModGuiInventory const *self, Packet_Inventory const *inventory, int x, int y);
static int ModGuiInventory_MaterialSelectorBackgroundStartX(ModGuiInventory const *self);
static int ModGuiInventory_MaterialSelectorBackgroundStartY(ModGuiInventory const *self);
static int ModGuiInventory_MaterialSelectorStartX(ModGuiInventory const *self);
static int ModGuiInventory_MaterialSelectorStartY(ModGuiInventory const *self);
static int ModGuiInventory_ScrollButtonSize(ModGuiInventory const *self);
static int ModGuiInventory_ScrollDownButtonX(ModGuiInventory const *self);
static int ModGuiInventory_ScrollDownButtonY(ModGuiInventory const *self);
static int ModGuiInventory_ScrollUpButtonX(ModGuiInventory const *self);
static int ModGuiInventory_ScrollUpButtonY(ModGuiInventory const *self);
static PointRef *ModGuiInventory_SelectedCell(ModGuiInventory const *self, PointRef const *scaledMouse);
static cibool ModGuiInventory_SelectedCellOrScrollbar(ModGuiInventory const *self, int scaledMouseX, int scaledMouseY);
static IntRef const *ModGuiInventory_SelectedMaterialSelectorSlot(ModGuiInventory const *self, PointRef const *scaledMouse);
static IntRef const *ModGuiInventory_SelectedWearPlace(ModGuiInventory const *self, PointRef const *scaledMouse);
static const ClientModVtbl CiVtbl_ModGuiInventory = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	(void (*)(ClientMod *self, Game const *game, KeyPressEventArgs const *args)) ModGuiInventory_OnKeyPress,
	ClientMod_OnKeyUp,
	(void (*)(ClientMod *self, Game const *game, MouseEventArgs const *args)) ModGuiInventory_OnMouseDown,
	ClientMod_OnMouseMove,
	(void (*)(ClientMod *self, Game const *game, MouseEventArgs const *args)) ModGuiInventory_OnMouseUp,
	(void (*)(ClientMod *self, Game const *game, MouseWheelEventArgs const *args)) ModGuiInventory_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModGuiInventory_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	(void (*)(ClientMod *self, Game const *game, TouchEventArgs const *e)) ModGuiInventory_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModGuiMapLoading {
	ClientMod base;
	int height;
	int width;
	int backgroundH;
	int backgroundW;
};
static void ModGuiMapLoading_Construct(ModGuiMapLoading *self, const ClientModVtbl *vtbl);
static void ModGuiMapLoading_DrawBackground(ModGuiMapLoading *self, Game *game);
static const ClientModVtbl CiVtbl_ModGuiMapLoading = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModGuiMapLoading_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModGuiPlayerStats {
	ClientMod base;
	int healthPosX;
	int healthPosY;
	int oxygenPosX;
	int oxygenPosY;
};
static void ModGuiPlayerStats_Construct(ModGuiPlayerStats *self, const ClientModVtbl *vtbl);
static const ClientModVtbl CiVtbl_ModGuiPlayerStats = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModGuiPlayerStats_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModGuiTextEditor {
	GameScreen base;
	int charSize;
	int cursorColumn;
	int cursorLine;
	int startX;
	int startY;
	cibool visible;
	int **buffer;
	FontCi *font;
};
static void ModGuiTextEditor_Construct(ModGuiTextEditor *self, const ClientModVtbl *vtbl);
static int ModGuiTextEditor_LineLength(ModGuiTextEditor const *self, int const *line);
static const char *ModGuiTextEditor_LineToString(ModGuiTextEditor const *self, int const *line);
static const GameScreenVtbl CiVtbl_ModGuiTextEditor = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	(void (*)(ClientMod *self, Game const *game, KeyEventArgs const *args)) ModGuiTextEditor_OnKeyDown,
	(void (*)(ClientMod *self, Game const *game, KeyPressEventArgs const *args)) ModGuiTextEditor_OnKeyPress,
	ClientMod_OnKeyUp,
	(void (*)(ClientMod *self, Game const *game, MouseEventArgs const *args)) GameScreen_OnMouseDown,
	(void (*)(ClientMod *self, Game const *game, MouseEventArgs const *args)) GameScreen_OnMouseMove,
	(void (*)(ClientMod *self, Game const *game, MouseEventArgs const *args)) GameScreen_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModGuiTextEditor_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	(void (*)(ClientMod *self, Game const *game, TouchEventArgs const *e)) GameScreen_OnTouchEnd,
	ClientMod_OnTouchMove,
	(void (*)(ClientMod *self, Game const *game, TouchEventArgs const *e)) GameScreen_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start,
	GameScreen_OnBackPressed,
	GameScreen_OnButton,
	GameScreen_OnMouseWheel
};

struct ModGuiTouchButtons {
	GameScreen base;
	cibool touchButtonsEnabled;
	int touchIdMove;
	int touchIdRotate;
	int touchMoveStartX;
	int touchMoveStartY;
	int touchRotateStartX;
	int touchRotateStartY;
	MenuWidget *buttonCamera;
	MenuWidget *buttonInventory;
	MenuWidget *buttonMenu;
	MenuWidget *buttonTalk;
};
static void ModGuiTouchButtons_Construct(ModGuiTouchButtons *self, const ClientModVtbl *vtbl);
static float ModGuiTouchButtons_Scale(ModGuiTouchButtons const *self);
static const GameScreenVtbl CiVtbl_ModGuiTouchButtons = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	(void (*)(ClientMod *self, Game const *game, KeyEventArgs const *args)) GameScreen_OnKeyDown,
	(void (*)(ClientMod *self, Game const *game, KeyPressEventArgs const *args)) GameScreen_OnKeyPress,
	ClientMod_OnKeyUp,
	(void (*)(ClientMod *self, Game const *game, MouseEventArgs const *args)) GameScreen_OnMouseDown,
	(void (*)(ClientMod *self, Game const *game, MouseEventArgs const *args)) GameScreen_OnMouseMove,
	(void (*)(ClientMod *self, Game const *game, MouseEventArgs const *args)) GameScreen_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModGuiTouchButtons_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	(void (*)(ClientMod *self, Game const *game, TouchEventArgs const *e)) ModGuiTouchButtons_OnTouchEnd,
	(void (*)(ClientMod *self, Game const *game, TouchEventArgs const *e)) ModGuiTouchButtons_OnTouchMove,
	(void (*)(ClientMod *self, Game const *game, TouchEventArgs const *e)) ModGuiTouchButtons_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start,
	GameScreen_OnBackPressed,
	(void (*)(GameScreen *self, MenuWidget const *w)) ModGuiTouchButtons_OnButton,
	GameScreen_OnMouseWheel
};

struct ModInterpolatePositions {
	ClientMod base;
};
static void ModInterpolatePositions_Construct(ModInterpolatePositions *self, const ClientModVtbl *vtbl);
static void ModInterpolatePositions_InterpolatePositions(ModInterpolatePositions const *self, Game const *game, float dt);
static const ClientModVtbl CiVtbl_ModInterpolatePositions = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	(void (*)(ClientMod *self, Game const *game, NewFrameEventArgs const *args)) ModInterpolatePositions_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModLoadPlayerTextures {
	ClientMod base;
	cibool started;
	const char *skinserver;
	HttpResponseCi const *skinserverResponse;
};
static void ModLoadPlayerTextures_Construct(ModLoadPlayerTextures *self, const ClientModVtbl *vtbl);
static void ModLoadPlayerTextures_LoadPlayerTextures(ModLoadPlayerTextures *self, Game const *game);
static const ClientModVtbl CiVtbl_ModLoadPlayerTextures = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	(void (*)(ClientMod *self, Game const *game, NewFrameEventArgs const *args)) ModLoadPlayerTextures_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

typedef struct {
	void (*addToInventory)(ModManagerSimple *self, int player, const char *block, int amount);
	BlockTypeSimple const *(*createBlockType)(ModManagerSimple *self, const char *name);
	int (*getBlockTypeId)(ModManagerSimple *self, const char *p);
}
ModManagerSimpleVtbl;
struct ModManagerSimple {
	const ModManagerSimpleVtbl *vtbl;
};
static void ModManagerSimple_Construct(ModManagerSimple *self, const ModManagerSimpleVtbl *vtbl);

struct ModManagerSimple1 {
	ModManagerSimple base;
	ServerSimple *server;
};
static void ModManagerSimple1_Construct(ModManagerSimple1 *self, const ModManagerSimpleVtbl *vtbl);
static const ModManagerSimpleVtbl CiVtbl_ModManagerSimple1 = {
	(void (*)(ModManagerSimple *self, int player, const char *block, int amount)) ModManagerSimple1_AddToInventory,
	(BlockTypeSimple const *(*)(ModManagerSimple *self, const char *name)) ModManagerSimple1_CreateBlockType,
	(int (*)(ModManagerSimple *self, const char *p)) ModManagerSimple1_GetBlockTypeId
};

struct ModNetworkEntity {
	ClientMod base;
	ClientPacketHandlerEntityDespawn const *despawn;
	ClientPacketHandlerEntityPosition const *position;
	ClientPacketHandlerEntitySpawn const *spawn;
};
static void ModNetworkEntity_Construct(ModNetworkEntity *self, const ClientModVtbl *vtbl);
static const ClientModVtbl CiVtbl_ModNetworkEntity = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	(void (*)(ClientMod *self, Game const *game, NewFrameEventArgs const *args)) ModNetworkEntity_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModNetworkProcess {
	ClientMod base;
	int currentChunkCount;
	unsigned char *currentChunk;
	unsigned char const *decompressedchunk;
	Game *game;
	int *receivedchunk;
};
static void ModNetworkProcess_Construct(ModNetworkProcess *self, const ClientModVtbl *vtbl);
static void ModNetworkProcess_ProcessInBackground(ModNetworkProcess *self, Packet_Server const *packet);
static const ClientModVtbl CiVtbl_ModNetworkProcess = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	(void (*)(ClientMod *self, Game const *game, float dt)) ModNetworkProcess_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModPicking {
	ClientMod base;
	cibool fastclicking;
	int lastbuildMilliseconds;
	DictionaryVector3Float const *fillarea;
	Vector3IntRef const *fillend;
	Vector3IntRef const *fillstart;
	float *tempRay;
	float *tempRayStartPoint;
	float *tempViewport;
	Unproject const *unproject;
};
static void ModPicking_Construct(ModPicking *self, const ClientModVtbl *vtbl);
static float ModPicking_BuildDelay(ModPicking const *self, Game const *game);
static void ModPicking_ClearFillArea(ModPicking const *self, Game *game);
static float ModPicking_CurrentPickDistance(ModPicking const *self, Game const *game);
static void ModPicking_FillFill(ModPicking const *self, Game *game, Vector3IntRef const *a_, Vector3IntRef const *b_);
static PointFloatRef const *ModPicking_GetAim(ModPicking const *self, Game const *game);
static void ModPicking_NextBullet(ModPicking *self, Game *game, int bulletsshot);
static void ModPicking_OnPick(ModPicking *self, Game *game, int blockposX, int blockposY, int blockposZ, int blockposoldX, int blockposoldY, int blockposoldZ, float const *collisionPos, cibool right);
static void ModPicking_OnPickUseWithTool(ModPicking const *self, Game const *game, int posX, int posY, int posZ);
static void ModPicking_OnPick_(ModPicking const *self, BlockPosSide const *pick0);
static RailDirection ModPicking_PickCorners(ModPicking const *self, float xfract, float zfract);
static void ModPicking_PickEntity(ModPicking const *self, Game *game, Line3D const *pick, BlockPosSide const *const *pick2, IntRef const *pick2count);
static RailDirection ModPicking_PickHorizontalVertical(ModPicking const *self, float xfract, float yfract);
static void ModPicking_PickingEnd(ModPicking *self, cibool left, cibool right, cibool middle, cibool ispistol);
static void ModPicking_UpdateEntityHit(ModPicking const *self, Game const *game);
static void ModPicking_UpdatePicking(ModPicking *self, Game *game);
static const ClientModVtbl CiVtbl_ModPicking = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	(void (*)(ClientMod *self, Game const *game, MouseEventArgs const *args)) ModPicking_OnMouseDown,
	ClientMod_OnMouseMove,
	(void (*)(ClientMod *self, Game const *game, MouseEventArgs const *args)) ModPicking_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModPicking_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModPush {
	ClientMod base;
};
static void ModPush_Construct(ModPush *self, const ClientModVtbl *vtbl);
static const ClientModVtbl CiVtbl_ModPush = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	(void (*)(ClientMod *self, Game const *game, NewFrameEventArgs const *args)) ModPush_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModRail {
	ClientMod base;
	VehicleDirection12 currentdirection;
	int currentrailblockX;
	int currentrailblockY;
	int currentrailblockZ;
	VehicleDirection12 lastdirection;
	int lastrailsound;
	int lastrailsoundtimeMilliseconds;
	cibool railriding;
	cibool wasepressed;
	cibool wasqpressed;
	float currentrailblockprogress;
	float currentvehiclespeed;
	RailMapUtil *d_RailMapUtil;
	Entity *localMinecart;
	float one;
	float originalmodelheight;
	float railheight;
};
static void ModRail_Construct(ModRail *self, const ClientModVtbl *vtbl);
static VehicleDirection12 ModRail_BestNewDirection(ModRail const *self, int dirVehicleDirection12Flags, cibool turnleft, cibool turnright, BoolRef *retFound);
static Vector3Ref const *ModRail_CurrentRailPos(ModRail const *self, Game const *game);
static void ModRail_ExitVehicle(ModRail *self, Game *game);
static int ModRail_GetUpDownMove(ModRail const *self, Game const *game, int railblockX, int railblockY, int railblockZ, TileEnterDirection dir);
static int ModRail_PossibleRails(ModRail const *self, Game const *game, TileEnterData const *enter);
static void ModRail_RailOnNewFrame(ModRail *self, Game *game, float dt);
static void ModRail_RailSound(ModRail *self, Game const *game);
static void ModRail_Reverse(ModRail *self);
static float ModRail_minecartheight(ModRail const *self);
static const ClientModVtbl CiVtbl_ModRail = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	(void (*)(ClientMod *self, Game const *game, NewFrameEventArgs const *args)) ModRail_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModReloadAmmo {
	ClientMod base;
};
static void ModReloadAmmo_Construct(ModReloadAmmo *self, const ClientModVtbl *vtbl);
static const ClientModVtbl CiVtbl_ModReloadAmmo = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	(void (*)(ClientMod *self, Game const *game, KeyEventArgs const *args)) ModReloadAmmo_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	(void (*)(ClientMod *self, Game const *game, NewFrameEventArgs const *args)) ModReloadAmmo_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModScreenshot {
	ClientMod base;
	int screenshotFlashFramesLeft;
	cibool takeScreenshot;
};
static void ModScreenshot_Construct(ModScreenshot *self, const ClientModVtbl *vtbl);
static void ModScreenshot_DrawScreenshotFlash(ModScreenshot const *self, Game *game);
static const ClientModVtbl CiVtbl_ModScreenshot = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	(void (*)(ClientMod *self, Game const *game, KeyEventArgs const *args)) ModScreenshot_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModScreenshot_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModSendActiveMaterial {
	ClientMod base;
	int previousActiveMaterialBlock;
};
static void ModSendActiveMaterial_Construct(ModSendActiveMaterial *self, const ClientModVtbl *vtbl);
static const ClientModVtbl CiVtbl_ModSendActiveMaterial = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	(void (*)(ClientMod *self, Game const *game, NewFrameEventArgs const *args)) ModSendActiveMaterial_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModSendPosition {
	ClientMod base;
};
static void ModSendPosition_Construct(ModSendPosition *self, const ClientModVtbl *vtbl);
static const ClientModVtbl CiVtbl_ModSendPosition = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	(void (*)(ClientMod *self, Game const *game, NewFrameEventArgs const *args)) ModSendPosition_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModServerSimple {
	ClientMod base;
	ServerSimple *server;
};
static void ModServerSimple_Construct(ModServerSimple *self, const ClientModVtbl *vtbl);
static const ClientModVtbl CiVtbl_ModServerSimple = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	(void (*)(ClientMod *self, Game const *game, float dt)) ModServerSimple_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

typedef struct {
	void (*generateChunk)(ModSimple *self, int cx, int cy, int cz, int const *chunk);
	int (*getHeight)(ModSimple *self);
	void (*onPlayerJoin)(ModSimple *self, int playerId);
	void (*start)(ModSimple *self, ModManagerSimple const *manager);
}
ModSimpleVtbl;
struct ModSimple {
	const ModSimpleVtbl *vtbl;
};
static void ModSimple_Construct(ModSimple *self, const ModSimpleVtbl *vtbl);

struct ModSimpleDefault {
	ModSimple base;
	ModManagerSimple const *m;
};
static void ModSimpleDefault_Construct(ModSimpleDefault *self, const ModSimpleVtbl *vtbl);
static const ModSimpleVtbl CiVtbl_ModSimpleDefault = {
	ModSimple_GenerateChunk,
	ModSimple_GetHeight,
	(void (*)(ModSimple *self, int playerId)) ModSimpleDefault_OnPlayerJoin,
	(void (*)(ModSimple *self, ModManagerSimple const *manager)) ModSimpleDefault_Start
};

struct ModSimpleWorldGenerator {
	ModSimple base;
	ModManagerSimple const *m;
};
static void ModSimpleWorldGenerator_Construct(ModSimpleWorldGenerator *self, const ModSimpleVtbl *vtbl);
static const ModSimpleVtbl CiVtbl_ModSimpleWorldGenerator = {
	(void (*)(ModSimple *self, int cx, int cy, int cz, int const *chunk)) ModSimpleWorldGenerator_GenerateChunk,
	(int (*)(ModSimple *self)) ModSimpleWorldGenerator_GetHeight,
	ModSimple_OnPlayerJoin,
	(void (*)(ModSimple *self, ModManagerSimple const *manager)) ModSimpleWorldGenerator_Start
};

struct ModSkySphereAnimated {
	ClientMod base;
	cibool started;
	int const *glowPixels;
	int const *skyPixels;
	ModelData *skymodel;
	ClientMod const *stars;
};
static void ModSkySphereAnimated_Construct(ModSkySphereAnimated *self, const ClientModVtbl *vtbl);
static void ModSkySphereAnimated_DrawSkySphere(ModSkySphereAnimated *self, Game *game);
static int ModSkySphereAnimated_Texture2d(GamePlatform const *platform, int const *pixelsArgb, float x, float y);
static int ModSkySphereAnimated_positive_modulo(int i, int n);
static const ClientModVtbl CiVtbl_ModSkySphereAnimated = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModSkySphereAnimated_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModSkySphereStatic {
	ClientMod base;
	int skyTexture;
	int skyspherenighttexture;
	int skyspheretexture;
	Model const *skymodel;
};
static void ModSkySphereStatic_Construct(ModSkySphereStatic *self, const ClientModVtbl *vtbl);
static void ModSkySphereStatic_DrawSkySphere(ModSkySphereStatic *self, Game *game);
static const ClientModVtbl CiVtbl_ModSkySphereStatic = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) ModSkySphereStatic_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModUnloadRendererChunks {
	ClientMod base;
	int chunksize;
	int mapsizexchunks;
	int mapsizeychunks;
	int mapsizezchunks;
	int unloadIterationXy;
	Game const *game;
	Vector3IntRef *unloadxyztemp;
};
static void ModUnloadRendererChunks_Construct(ModUnloadRendererChunks *self, const ClientModVtbl *vtbl);
static int ModUnloadRendererChunks_mapAreaSize(ModUnloadRendererChunks const *self);
static int ModUnloadRendererChunks_mapAreaSizeZ(ModUnloadRendererChunks const *self);
static const ClientModVtbl CiVtbl_ModUnloadRendererChunks = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	(void (*)(ClientMod *self, Game const *game, float dt)) ModUnloadRendererChunks_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModUpdateMain {
	ClientMod base;
};
static void ModUpdateMain_Construct(ModUpdateMain *self, const ClientModVtbl *vtbl);
static const ClientModVtbl CiVtbl_ModUpdateMain = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	(void (*)(ClientMod *self, Game const *game, float dt)) ModUpdateMain_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};

struct ModWalkSound {
	ClientMod base;
	int lastwalksound;
	float one;
	float stepsoundduration;
	float walksoundtimer;
};
static void ModWalkSound_Construct(ModWalkSound *self, const ClientModVtbl *vtbl);
static int ModWalkSound_GetSoundCount(ModWalkSound const *self, const char *const *soundwalk);
static void ModWalkSound_UpdateWalkSound(ModWalkSound *self, Game const *game, float dt);
static const char *const *ModWalkSound_soundwalkcurrent(ModWalkSound const *self, Game const *game);
static const ClientModVtbl CiVtbl_ModWalkSound = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	ClientMod_OnNewFrameDraw3d,
	(void (*)(ClientMod *self, Game const *game, NewFrameEventArgs const *args)) ModWalkSound_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};


struct ModelData {
	int indicesCount;
	int indicesMax;
	int mode;
	int verticesCount;
	int verticesMax;
	int *indices;
	unsigned char *rgba;
	float *uv;
	float *xyz;
};

static void ModelDataTool_AddIndex(ModelData *model, int index);



struct MouseEventArgs {
	int button;
	cibool emulated;
	cibool forceUsage;
	cibool handled;
	int movementX;
	int movementY;
	int x;
	int y;
};

struct MouseWheelEventArgs {
	int delta;
	float deltaPrecise;
};

struct NetIncomingMessage {
	NetworkMessageType type;
	int messageLength;
	NetConnection const *senderConnection;
	unsigned char *message;
};

struct NetworkInterpolation {
	INetworkInterpolation base;
	int dELAYMILLISECONDS;
	cibool eXTRAPOLATE;
	int eXTRAPOLATION_TIMEMILLISECONDS;
	int receivedCount;
	Packet_ const **received;
	IInterpolation const *req;
};
static void NetworkInterpolation_Construct(NetworkInterpolation *self, const INetworkInterpolationVtbl *vtbl);
static const INetworkInterpolationVtbl CiVtbl_NetworkInterpolation = {
	(void (*)(INetworkInterpolation *self, InterpolatedObject const *c, int timeMilliseconds)) NetworkInterpolation_AddNetworkPacket,
	(InterpolatedObject const *(*)(INetworkInterpolation *self, int timeMilliseconds)) NetworkInterpolation_InterpolatedState
};

struct NewFrameEventArgs {
	float dt;
};

struct Node {
	float head;
	const char *name;
	const char *parentName;
	float pivotx;
	float pivoty;
	float pivotz;
	float posx;
	float posy;
	float posz;
	float rotatex;
	float rotatey;
	float rotatez;
	float scalex;
	float scaley;
	float scalez;
	float sizex;
	float sizey;
	float sizez;
	float u;
	float v;
};

struct NotifyMapAction {
	Action_ base;
	int clientId;
	ServerSimple const *server;
};
static void NotifyMapAction_Construct(NotifyMapAction *self, const Action_Vtbl *vtbl);
static void NotifyMapAction_LoadAndSendChunk(NotifyMapAction const *self, int x, int y, int z);
static void NotifyMapAction_NearestDirty(NotifyMapAction const *self, int clientid, int playerx, int playery, int playerz, int *retNearest);
static int NotifyMapAction_mapAreaSize(NotifyMapAction const *self);
static int NotifyMapAction_mapAreaSizeZ(NotifyMapAction const *self);
static int NotifyMapAction_mapsizexchunks(NotifyMapAction const *self);
static int NotifyMapAction_mapsizeychunks(NotifyMapAction const *self);
static int NotifyMapAction_mapsizezchunks(NotifyMapAction const *self);
static const Action_Vtbl CiVtbl_NotifyMapAction = {
	(void (*)(Action_ *self)) NotifyMapAction_Run
};

typedef struct {
	void (*onCrash)(OnCrashHandler *self);
}
OnCrashHandlerVtbl;
struct OnCrashHandler {
	const OnCrashHandlerVtbl *vtbl;
};
static void OnCrashHandler_Construct(OnCrashHandler *self, const OnCrashHandlerVtbl *vtbl);
static const OnCrashHandlerVtbl CiVtbl_OnCrashHandler = {
	OnCrashHandler_OnCrash
};

struct OnCrashHandlerLeave {
	OnCrashHandler base;
	Game const *g;
};
static void OnCrashHandlerLeave_Construct(OnCrashHandlerLeave *self, const OnCrashHandlerVtbl *vtbl);
static const OnCrashHandlerVtbl CiVtbl_OnCrashHandlerLeave = {
	(void (*)(OnCrashHandler *self)) OnCrashHandlerLeave_OnCrash
};

struct OnUseEntityArgs {
	int entityId;
};

struct OptionsCi {
	int drawDistance;
	cibool enableAutoJump;
	cibool enableBlockShadow;
	cibool enableSound;
	int font;
	int framerate;
	cibool fullscreen;
	int resolution;
	cibool shadows;
	cibool smoothshadows;
	cibool useServerTextures;
	float blockShadowSave;
	const char *clientLanguage;
	int *keys;
};
static void OptionsCi_Construct(OptionsCi *self);

struct PacketHandlerCraftingRecipes {
	ClientPacketHandler base;
	ModGuiCrafting *mod;
};
static void PacketHandlerCraftingRecipes_Construct(PacketHandlerCraftingRecipes *self, const ClientPacketHandlerVtbl *vtbl);
static const ClientPacketHandlerVtbl CiVtbl_PacketHandlerCraftingRecipes = {
	(void (*)(ClientPacketHandler *self, Game const *game, Packet_Server const *packet)) PacketHandlerCraftingRecipes_Handle
};

struct Packet_ {
	int timestampMilliseconds;
	InterpolatedObject const *content;
};


struct Packet_BlockType {
	int aimRadiusFloat;
	int ammoMagazine;
	int ammoTotal;
	int bulletsPerShotFloat;
	int damageBodyFloat;
	int damageHeadFloat;
	int damageToPlayer;
	int delayFloat;
	int drawType;
	int explosionRangeFloat;
	int explosionTimeFloat;
	int ironSightsAimRadiusFloat;
	cibool ironSightsEnabled;
	int ironSightsFovFloat;
	int ironSightsMoveSpeedFloat;
	cibool isBuildable;
	cibool isPistol;
	cibool isSlipperyWalk;
	cibool isTool;
	cibool isUsable;
	int lightRadius;
	int pickDistanceWhenUsedFloat;
	int pistolType;
	/**
	 * &lt;summary&gt; 0 is infinite&lt;/summary&gt;
	 */
	cibool projectileBounce;
	int projectileSpeedFloat;
	int rail;
	int recoilFloat;
	int reloadDelayFloat;
	int startInventoryAmount;
	int strength;
	int walkSpeedFloat;
	int walkSpeedWhenUsedFloat;
	int walkableType;
	int whenPlacedGetsConvertedTo;
	const char *handimage;
	const char *ironSightsImage;
	const char *name;
	Packet_SoundSet *sounds;
	const char *textureIdBack;
	const char *textureIdBottom;
	const char *textureIdForInventory;
	const char *textureIdFront;
	const char *textureIdLeft;
	const char *textureIdRight;
	const char *textureIdTop;
};


struct Packet_Client {
	int id;
	Packet_ClientActiveMaterialSlot *activeMaterialSlot;
	Packet_ClientCraft *craft;
	Packet_ClientDeath *death;
	Packet_ClientDialogClick *dialogClick_;
	Packet_ClientEntityInteraction *entityInteraction;
	Packet_ClientFillArea *fillArea;
	Packet_ClientGameResolution *gameResolution;
	Packet_ClientHealth *health;
	Packet_ClientIdentification *identification;
	Packet_ClientInventoryAction *inventoryAction;
	Packet_ClientLeave *leave;
	Packet_ClientMessage *message;
	Packet_ClientOxygen *oxygen;
	Packet_ClientPingReply const *pingReply;
	Packet_ClientPositionAndOrientation *positionAndOrientation;
	Packet_ClientServerQuery const *query;
	Packet_ClientReload const *reload;
	Packet_ClientRequestBlob *requestBlob;
	Packet_ClientSetBlock *setBlock;
	Packet_ClientShot *shot;
	Packet_ClientSpecialKey *specialKey_;
};

struct Packet_ClientActiveMaterialSlot {
	int activeMaterialSlot;
};


struct Packet_ClientCraft {
	int recipeId;
	int x;
	int y;
	int z;
};


struct Packet_ClientDeath {
	int reason;
	int sourcePlayer;
};


struct Packet_ClientDialogClick {
	int textBoxValueCount;
	int textBoxValueLength;
	const char **textBoxValue;
	const char *widgetId;
};


struct Packet_ClientEntityInteraction {
	int entityId;
	int interactionType;
};


struct Packet_ClientFillArea {
	int blockType;
	int materialSlot;
	int x1;
	int x2;
	int y1;
	int y2;
	int z1;
	int z2;
};


struct Packet_ClientGameResolution {
	int height;
	int width;
};


struct Packet_ClientHealth {
	int currentHealth;
};



struct Packet_ClientIdentification {
	const char *mdProtocolVersion;
	Packet_PositionAndOrientation *requestPosition;
	const char *serverPassword;
	const char *username;
	const char *verificationKey;
};


struct Packet_ClientInventoryAction {
	int action;
	Packet_InventoryPosition *a;
	Packet_InventoryPosition *b;
};


struct Packet_ClientLeave {
	int reason;
};


struct Packet_ClientMessage {
	int isTeamchat;
	const char *message;
};


struct Packet_ClientOxygen {
	int currentOxygen;
};




struct Packet_ClientPositionAndOrientation {
	int heading;
	int pitch;
	int playerId;
	int stance;
	int x;
	int y;
	int z;
};




struct Packet_ClientRequestBlob {
	Packet_StringList *requestedMd5;
};





struct Packet_ClientSetBlock {
	int blockType;
	/**
	 * &lt;summary&gt; obsolete&lt;/summary&gt;
	 */
	int materialSlot;
	int mode;
	int x;
	int y;
	int z;
};


struct Packet_ClientShot {
	int explodesAfter;
	int fromX;
	int fromY;
	int fromZ;
	int hitPlayer;
	int isHitHead;
	int toX;
	int toY;
	int toZ;
	int weaponBlock;
};


struct Packet_ClientSpecialKey {
	int key_;
};


struct Packet_CraftingRecipe {
	int ingredientsCount;
	int ingredientsLength;
	Packet_Ingredient const **ingredients;
	Packet_Ingredient *output;
};



struct Packet_Dialog {
	int height_;
	int isModal;
	int widgetsCount;
	int widgetsLength;
	int width;
	Packet_Widget const **widgets;
};

struct Packet_DialogFont {
	int fontStyle;
	int sizeFloat;
	const char *familyName;
};






struct Packet_Ingredient {
	int amount;
	int type;
};


struct Packet_IntInt {
	int key_;
	int value_;
};


struct Packet_IntString {
	int key_;
	const char *value_;
};


struct Packet_Inventory {
	int itemsCount;
	int itemsLength;
	int rightHandCount;
	int rightHandLength;
	Packet_Item *boots;
	Packet_Item *dragDropItem;
	Packet_Item *gauntlet;
	Packet_Item *helmet;
	Packet_PositionItem const **items;
	Packet_Item *mainArmor;
	Packet_Item **rightHand;
};


struct Packet_InventoryPosition {
	int activeMaterial;
	int areaX;
	int areaY;
	int groundPositionX;
	int groundPositionY;
	int groundPositionZ;
	int materialId;
	int type;
	/**
	 * &lt;summary&gt;WearPlace&lt;/summary&gt;
	 */
	int wearPlace;
};




struct Packet_Item {
	int blockCount;
	int blockId;
	int itemClass;
	const char *itemId;
};





struct Packet_PositionAndOrientation {
	int heading;
	int pitch;
	int stance;
	int x;
	int y;
	int z;
};


struct Packet_PositionItem {
	int x;
	int y;
	const char *key_;
	Packet_Item *value_;
};


struct Packet_Server {
	int id;
	Packet_ServerAmmo *ammo;
	Packet_ServerBlobFinalize const *blobFinalize;
	Packet_ServerBlobInitialize *blobInitialize;
	Packet_ServerBlobPart *blobPart;
	Packet_ServerBlockType *blockType;
	Packet_ServerBlockTypes const *blockTypes;
	Packet_ServerBullet *bullet;
	Packet_ServerChunkPart *chunkPart;
	Packet_ServerChunk *chunk_;
	Packet_ServerCraftingRecipes *craftingRecipes;
	Packet_ServerDialog *dialog;
	Packet_ServerDisconnectPlayer *disconnectPlayer;
	Packet_ServerEntityDespawn *entityDespawn;
	Packet_ServerEntityPositionAndOrientation *entityPosition;
	Packet_ServerEntitySpawn *entitySpawn;
	Packet_ServerExplosion *explosion;
	Packet_ServerFillArea *fillArea;
	Packet_ServerFillAreaLimit *fillAreaLimit;
	Packet_ServerFollow *follow;
	Packet_ServerFreemove *freemove;
	Packet_ServerHeightmapChunk *heightmapChunk;
	Packet_ServerIdentification *identification;
	Packet_ServerInventory *inventory;
	Packet_ServerLevelProgress *levelDataChunk;
	Packet_ServerLevelFinalize const *levelFinalize;
	Packet_ServerLevelInitialize const *levelInitialize;
	Packet_ServerLightLevels *lightLevels;
	Packet_ServerMessage *message;
	Packet_ServerMonsters *monster;
	Packet_ServerPing const *ping;
	Packet_ServerPlayerPing *playerPing;
	Packet_ServerPlayerSpawnPosition *playerSpawnPosition;
	Packet_ServerPlayerStats *playerStats;
	Packet_ServerProjectile *projectile;
	Packet_ServerQueryAnswer *queryAnswer;
	Packet_ServerRedirect *redirect;
	Packet_ServerSeason *season;
	Packet_ServerSetBlock *setBlock;
	Packet_ServerSound *sound;
	Packet_ServerSunLevels *sunLevels;
	Packet_ServerTranslatedString *translation;
};

struct Packet_ServerAmmo {
	int totalAmmoCount;
	int totalAmmoLength;
	Packet_IntInt const **totalAmmo;
};




struct Packet_ServerBlobInitialize {
	const char *md5;
	/**
	 * &lt;summary&gt;
	 * &lt;para&gt;[ProtoMember(1, IsRequired = false)]&lt;/para&gt;
	 * &lt;para&gt;optional byte[] hash; //todo, currently ignored.&lt;/para&gt;
	 * &lt;/summary&gt;
	 */
	const char *name;
};


struct Packet_ServerBlobPart {
	int islastpart;
	unsigned char const *data;
};


struct Packet_ServerBlockType {
	int id;
	Packet_BlockType *blocktype;
};




struct Packet_ServerBullet {
	int fromXFloat;
	int fromYFloat;
	int fromZFloat;
	int speedFloat;
	int toXFloat;
	int toYFloat;
	int toZFloat;
};


struct Packet_ServerChunk {
	int sizeX;
	int sizeY;
	int sizeZ;
	int x;
	int y;
	int z;
};

struct Packet_ServerChunkPart {
	unsigned char const *compressedChunkPart;
};



struct Packet_ServerCraftingRecipes {
	int craftingRecipesCount;
	int craftingRecipesLength;
	Packet_CraftingRecipe const **craftingRecipes;
};


struct Packet_ServerDialog {
	Packet_Dialog *dialog;
	const char *dialogId;
};


struct Packet_ServerDisconnectPlayer {
	const char *disconnectReason;
};


struct Packet_ServerEntity {
	cibool usable;
	Packet_ServerEntityDrawArea *drawArea;
	Packet_ServerEntityDrawBlock *drawBlock;
	Packet_ServerEntityAnimatedModel *drawModel;
	Packet_ServerEntityDrawName *drawName_;
	Packet_ServerEntityDrawText *drawText;
	Packet_ServerPlayerStats *playerStats;
	Packet_PositionAndOrientation *position;
	Packet_ServerEntityPush *push;
};

struct Packet_ServerEntityAnimatedModel {
	int downloadSkin;
	int eyeHeight;
	int modelHeight;
	const char *model_;
	const char *texture_;
};


struct Packet_ServerEntityDespawn {
	int id;
};


struct Packet_ServerEntityDrawArea {
	int sizex;
	int sizey;
	int sizez;
	int visibleToClientId;
	int x;
	int y;
	int z;
};


struct Packet_ServerEntityDrawBlock {
	int blockType;
};


struct Packet_ServerEntityDrawName {
	cibool clientAutoComplete;
	cibool onlyWhenSelected;
	const char *color;
	const char *name;
};


struct Packet_ServerEntityDrawText {
	int dx;
	int dy;
	int dz;
	int rotx;
	int roty;
	int rotz;
	const char *text;
};


struct Packet_ServerEntityPositionAndOrientation {
	int id;
	Packet_PositionAndOrientation *positionAndOrientation;
};


struct Packet_ServerEntityPush {
	int rangeFloat;
};



struct Packet_ServerEntitySpawn {
	int id;
	Packet_ServerEntity *entity_;
};


struct Packet_ServerExplosion {
	int isRelativeToPlayerPosition;
	int rangeFloat;
	int timeFloat;
	int xFloat;
	int yFloat;
	int zFloat;
};


struct Packet_ServerFillArea {
	int blockCount;
	int blockType;
	int x1;
	int x2;
	int y1;
	int y2;
	int z1;
	int z2;
};

struct Packet_ServerFillAreaLimit {
	int limit;
};



struct Packet_ServerFollow {
	int tpp;
	const char *client;
};


struct Packet_ServerFreemove {
	int isEnabled;
};


struct Packet_ServerHeightmapChunk {
	int sizeX;
	int sizeY;
	int x;
	int y;
	unsigned char const *compressedHeightmap;
};



struct Packet_ServerIdentification {
	int assignedClientId;
	int disableShadows;
	int mapSizeX;
	int mapSizeY;
	int mapSizeZ;
	int playerAreaSize;
	int renderHint_;
	const char *mdProtocolVersion;
	Packet_StringList *requiredBlobMd5;
	Packet_StringList *requiredBlobName;
	const char *serverMotd;
	const char *serverName;
};


struct Packet_ServerInventory {
	Packet_Inventory *inventory;
};






struct Packet_ServerLevelProgress {
	/**
	 * &lt;summary&gt;
	 * &lt;para&gt;[ProtoMember(1, IsRequired = false)]&lt;/para&gt;
	 * &lt;para&gt;optional byte[] Chunk;&lt;/para&gt;
	 * &lt;/summary&gt;
	 */
	int percentComplete;
	int percentCompleteSubitem;
	const char *status;
};


struct Packet_ServerLightLevels {
	int lightlevelsCount;
	int lightlevelsLength;
	int *lightlevels;
};


struct Packet_ServerMessage {
	/**
	 * &lt;summary&gt; optional int32 playerId = 1;&lt;/summary&gt;
	 */
	const char *message;
};


struct Packet_ServerMonster {
	int health;
	int id;
	int monsterType;
	Packet_PositionAndOrientation *positionAndOrientation;
};


struct Packet_ServerMonsters {
	int monstersCount;
	int monstersLength;
	Packet_ServerMonster const **monsters;
};




struct Packet_ServerPlayerPing {
	int clientId;
	int ping;
};


struct Packet_ServerPlayerSpawnPosition {
	int x;
	int y;
	int z;
};


struct Packet_ServerPlayerStats {
	int currentHealth;
	int currentOxygen;
	int maxHealth;
	int maxOxygen;
};


struct Packet_ServerProjectile {
	int blockId;
	int explodesAfterFloat;
	int fromXFloat;
	int fromYFloat;
	int fromZFloat;
	int sourcePlayerID;
	int velocityXFloat;
	int velocityYFloat;
	int velocityZFloat;
};


struct Packet_ServerQueryAnswer {
	int mapSizeX;
	int mapSizeY;
	int mapSizeZ;
	int maxPlayers;
	cibool password;
	int playerCount;
	int port;
	const char *gameMode;
	const char *mOTD;
	const char *name;
	const char *playerList;
	const char *publicHash;
	unsigned char const *serverThumbnail;
	const char *serverVersion;
};


struct Packet_ServerRedirect {
	int port;
	const char *iP;
};


struct Packet_ServerSeason {
	/**
	 * &lt;summary&gt;1-24*4&lt;/summary&gt;
	 */
	int dayNightCycleSpeedup;
	/**
	 * &lt;summary&gt;optional int32 Season;&lt;/summary&gt;
	 */
	int hour;
	/**
	 * &lt;summary&gt;used for predicting sun speed.&lt;/summary&gt;
	 */
	int moon;
};



struct Packet_ServerSetBlock {
	int blockType;
	int x;
	int y;
	int z;
};


struct Packet_ServerSound {
	int x;
	int y;
	int z;
	const char *name;
};


struct Packet_ServerSunLevels {
	int sunlevelsCount;
	int sunlevelsLength;
	int *sunlevels;
};


struct Packet_ServerTranslatedString {
	const char *id;
	const char *lang;
	const char *translation;
};


struct Packet_SoundSet {
	int break1Count;
	int break1Length;
	int buildCount;
	int buildLength;
	int cloneCount;
	int cloneLength;
	int reloadCount;
	int reloadLength;
	int shootCount;
	int shootEndCount;
	int shootEndLength;
	int shootLength;
	int walkCount;
	int walkLength;
	const char **break1;
	const char **build;
	const char **clone;
	const char **reload;
	const char **shoot;
	const char **shootEnd;
	const char **walk;
};



struct Packet_StringList {
	int itemsCount;
	int itemsLength;
	const char **items;
};



struct Packet_Widget {
	int click;
	int clickKey;
	int color;
	int height_;
	int type;
	int width;
	int x;
	int y;
	/**
	 * &lt;summary&gt;white&lt;/summary&gt;
	 */
	Packet_DialogFont *font;
	const char *id;
	const char *image;
	const char *text;
};



struct Ping_ {
	int roundtripTimeMilliseconds;
	cibool ready;
	int timeSendMilliseconds;
	int timeout;
};
static void Ping__Construct(Ping_ *self);
static int Ping__RoundtripTimeTotalMilliseconds(Ping_ const *self);


struct Player {
	unsigned char heading;
	unsigned char networkHeading;
	unsigned char networkPitch;
	unsigned char pitch;
	int currentTexture;
	int health;
	int lastUpdateMilliseconds;
	int monsterType;
	cibool positionLoaded;
	PlayerType type;
	cibool moves;
	AnimationHint const *animationHint_;
	float eyeHeight;
	float modelHeight;
	const char *model_;
	const char *name;
	float networkX;
	float networkY;
	float networkZ;
	float positionX;
	float positionY;
	float positionZ;
	HttpResponseCi const *skinDownloadResponse;
	const char *texture;
	PlayerDrawInfo const *playerDrawInfo;
};
static void Player_Construct(Player *self);

struct PlayerDrawInfo {
	cibool moves;
	AnimationHint const *animationHint_;
	AnimationState *anim;
	NetworkInterpolation *interpolation;
	float lastcurposX;
	float lastcurposY;
	float lastcurposZ;
	float lastnetworkposX;
	float lastnetworkposY;
	float lastnetworkposZ;
	float lastnetworkrotx;
	float lastnetworkroty;
	float lastnetworkrotz;
	float velocityX;
	float velocityY;
	float velocityZ;
};
static void PlayerDrawInfo_Construct(PlayerDrawInfo *self);

struct PlayerInterpolate {
	IInterpolation base;
	GamePlatform const *platform;
};
static void PlayerInterpolate_Construct(PlayerInterpolate *self, const IInterpolationVtbl *vtbl);
static const IInterpolationVtbl CiVtbl_PlayerInterpolate = {
	(InterpolatedObject const *(*)(IInterpolation *self, InterpolatedObject const *a, InterpolatedObject const *b, float progress)) PlayerInterpolate_Interpolate
};

struct PlayerInterpolationState {
	InterpolatedObject base;
	unsigned char heading;
	unsigned char pitch;
	float positionX;
	float positionY;
	float positionZ;
	float rotx;
	float roty;
	float rotz;
};

struct PointFloatRef {
	float x;
	float y;
};

struct PointRef {
	int x;
	int y;
};

typedef struct {
	cibool (*hit)(PredicateBox3D *self, Box3D const *o);
}
PredicateBox3DVtbl;
struct PredicateBox3D {
	const PredicateBox3DVtbl *vtbl;
};
static void PredicateBox3D_Construct(PredicateBox3D *self, const PredicateBox3DVtbl *vtbl);

struct PredicateBox3DHit {
	PredicateBox3D base;
	BlockOctreeSearcher const *s;
};
static void PredicateBox3DHit_Construct(PredicateBox3DHit *self, const PredicateBox3DVtbl *vtbl);
static const PredicateBox3DVtbl CiVtbl_PredicateBox3DHit = {
	(cibool (*)(PredicateBox3D *self, Box3D const *o)) PredicateBox3DHit_Hit
};

struct Preferences {
	DictionaryStringString const *items;
	GamePlatform const *platform;
};
static void Preferences_Construct(Preferences *self);
static void Preferences_Remove(Preferences const *self, const char *key);

struct ProcessPacketTask {
	Action_ base;
	Game *game;
	Packet_Server const *packet_;
};
static void ProcessPacketTask_Construct(ProcessPacketTask *self, const Action_Vtbl *vtbl);
static cibool ProcessPacketTask_Contains(ProcessPacketTask const *self, const char *const *arr, int arrLength, const char *value);
static int ProcessPacketTask_IndexOf(ProcessPacketTask const *self, const char *const *arr, int arrLength, const char *value);
static void ProcessPacketTask_ProcessPacket(ProcessPacketTask const *self, Packet_Server const *packet);
static const Action_Vtbl CiVtbl_ProcessPacketTask = {
	(void (*)(Action_ *self)) ProcessPacketTask_Run
};


static void ProtocolParser_WriteUInt32(CitoMemoryStream const *ms, int length);

static const int QuadModelData_cubeVertices[12] = { -1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0 };
static const int QuadModelData_quadTextureCoords[8] = { 0, 0, 1, 0, 1, 1, 0, 1 };
static const int QuadModelData_quadVertexIndices[6] = { 0, 1, 2, 0, 2, 3 };


struct QueryClient {
	cibool queryPerformed;
	cibool querySuccess;
	GamePlatform const *p;
	QueryResult *result;
	const char *serverMessage;
};
static void QueryClient_Construct(QueryClient *self);
static void QueryClient_ReadPacket(QueryClient *self, NetClient const *client);
static void QueryClient_SendRequest(QueryClient const *self, NetClient const *client);

struct QueryResult {
	int mapSizeX;
	int mapSizeY;
	int mapSizeZ;
	int maxPlayers;
	cibool password;
	int playerCount;
	int port;
	const char *gameMode;
	const char *mOTD;
	const char *name;
	const char *playerList;
	const char *publicHash;
	unsigned char const *serverThumbnail;
	const char *serverVersion;
};

struct QueueAction {
	int count;
	int max;
	int start;
	Action_ const **items;
};
static void QueueAction_Construct(QueueAction *self);
static void QueueAction_Resize(QueueAction *self, int newSize);
static void QueueAction_Start(QueueAction *self, int max_);

struct QueueByte {
	int count;
	int max;
	int start;
	unsigned char *items;
};
static void QueueByte_Construct(QueueByte *self);
static void QueueByte_PeekRange(QueueByte const *self, unsigned char *data, int length);

struct QueueByteArray {
	int count;
	int itemsSize;
	ByteArray const **items;
};
static void QueueByteArray_Construct(QueueByteArray *self);
static int QueueByteArray_Count(QueueByteArray const *self);
static ByteArray const *QueueByteArray_Dequeue(QueueByteArray *self);
static void QueueByteArray_Enqueue(QueueByteArray *self, ByteArray const *p);

struct QueueINetOutgoingMessage {
	int count;
	int itemsSize;
	INetOutgoingMessage const **items;
};
static void QueueINetOutgoingMessage_Construct(QueueINetOutgoingMessage *self);
static int QueueINetOutgoingMessage_Count(QueueINetOutgoingMessage const *self);
static INetOutgoingMessage const *QueueINetOutgoingMessage_Dequeue(QueueINetOutgoingMessage *self);
static void QueueINetOutgoingMessage_Enqueue(QueueINetOutgoingMessage *self, INetOutgoingMessage const *p);

struct QueueNetIncomingMessage {
	int count;
	int itemsSize;
	NetIncomingMessage const **items;
};
static void QueueNetIncomingMessage_Construct(QueueNetIncomingMessage *self);
static int QueueNetIncomingMessage_Count(QueueNetIncomingMessage const *self);
static NetIncomingMessage const *QueueNetIncomingMessage_Dequeue(QueueNetIncomingMessage *self);
static void QueueNetIncomingMessage_Enqueue(QueueNetIncomingMessage *self, NetIncomingMessage const *p);



struct RailMapUtil {
	Game const *game;
};


typedef struct {
	int (*maxNext)(RandomCi *self, int range);
	int (*next)(RandomCi *self);
	float (*nextFloat)(RandomCi *self);
}
RandomCiVtbl;
struct RandomCi {
	const RandomCiVtbl *vtbl;
};
static void RandomCi_Construct(RandomCi *self, const RandomCiVtbl *vtbl);

struct RectFRef {
	float h;
	float w;
	float x;
	float y;
};
static float RectFRef_Bottom(RectFRef const *self);
static float RectFRef_Left(RectFRef const *self);
static float RectFRef_Right(RectFRef const *self);
static float RectFRef_Top(RectFRef const *self);

struct RectangleFloat {
	float height;
	float width;
	float x;
	float y;
};


struct RenderedChunk {
	cibool dirty;
	int idsCount;
	int const *ids;
	unsigned char *light;
};
static void RenderedChunk_Construct(RenderedChunk *self);

typedef struct {
	void (*loadTranslations)(Screen *self);
	void (*onBackPressed)(Screen *self);
	void (*onButton)(Screen *self, MenuWidget const *w);
	void (*onKeyDown)(Screen *self, KeyEventArgs const *e);
	void (*onKeyPress)(Screen *self, KeyPressEventArgs const *e);
	void (*onKeyUp)(Screen *self, KeyEventArgs const *e);
	void (*onMouseDown)(Screen *self, MouseEventArgs const *e);
	void (*onMouseMove)(Screen *self, MouseEventArgs const *e);
	void (*onMouseUp)(Screen *self, MouseEventArgs const *e);
	void (*onMouseWheel)(Screen *self, MouseWheelEventArgs const *e);
	void (*onTouchEnd)(Screen *self, TouchEventArgs const *e);
	void (*onTouchMove)(Screen *self, TouchEventArgs const *e);
	void (*onTouchStart)(Screen *self, TouchEventArgs const *e);
	void (*render)(Screen *self, float dt);
}
ScreenVtbl;
struct Screen {
	const ScreenVtbl *vtbl;
	int widgetCount;
	MainMenu *menu;
	MenuWidget **widgets;
};
static void Screen_Construct(Screen *self, const ScreenVtbl *vtbl);
static void Screen_AllLoseFocus(Screen const *self);
static void Screen_KeyDown(Screen const *self, KeyEventArgs const *e);
static void Screen_KeyPress(Screen const *self, KeyPressEventArgs const *e);
static void Screen_MouseDown(Screen const *self, int x, int y);
static void Screen_MouseMove(Screen const *self, MouseEventArgs const *e);
static void Screen_MouseUp(Screen const *self, int x, int y);
static cibool Screen_pointInRect(Screen const *self, float x, float y, float rx, float ry, float rw, float rh);
static const ScreenVtbl CiVtbl_Screen = {
	Screen_LoadTranslations,
	Screen_OnBackPressed,
	Screen_OnButton,
	Screen_OnKeyDown,
	Screen_OnKeyPress,
	Screen_OnKeyUp,
	Screen_OnMouseDown,
	Screen_OnMouseMove,
	Screen_OnMouseUp,
	Screen_OnMouseWheel,
	Screen_OnTouchEnd,
	Screen_OnTouchMove,
	Screen_OnTouchStart,
	Screen_Render
};

struct ScreenConnectToIp {
	Screen base;
	cibool loaded;
	MenuWidget *back;
	MenuWidget *buttonConnect;
	const char *errorText;
	const char *preferences_ip;
	const char *preferences_port;
	MenuWidget *textboxIp;
	MenuWidget *textboxPort;
	const char *title;
};
static void ScreenConnectToIp_Construct(ScreenConnectToIp *self, const ScreenVtbl *vtbl);
static const ScreenVtbl CiVtbl_ScreenConnectToIp = {
	(void (*)(Screen *self)) ScreenConnectToIp_LoadTranslations,
	(void (*)(Screen *self)) ScreenConnectToIp_OnBackPressed,
	(void (*)(Screen *self, MenuWidget const *w)) ScreenConnectToIp_OnButton,
	Screen_OnKeyDown,
	Screen_OnKeyPress,
	Screen_OnKeyUp,
	Screen_OnMouseDown,
	Screen_OnMouseMove,
	Screen_OnMouseUp,
	Screen_OnMouseWheel,
	Screen_OnTouchEnd,
	Screen_OnTouchMove,
	Screen_OnTouchStart,
	(void (*)(Screen *self, float dt)) ScreenConnectToIp_Render
};

struct ScreenGame {
	Screen base;
	cibool singleplayer;
	ConnectData *connectData;
	Game *game;
	GamePlatform const *platform;
	ServerSimple *serverSimple;
	ModServerSimple *serverSimpleMod;
	const char *singleplayerSavePath;
};
static void ScreenGame_Construct(ScreenGame *self, const ScreenVtbl *vtbl);
static void ScreenGame_Connect(ScreenGame *self, GamePlatform const *platform);
static const ScreenVtbl CiVtbl_ScreenGame = {
	Screen_LoadTranslations,
	(void (*)(Screen *self)) ScreenGame_OnBackPressed,
	Screen_OnButton,
	(void (*)(Screen *self, KeyEventArgs const *e)) ScreenGame_OnKeyDown,
	(void (*)(Screen *self, KeyPressEventArgs const *e)) ScreenGame_OnKeyPress,
	(void (*)(Screen *self, KeyEventArgs const *e)) ScreenGame_OnKeyUp,
	(void (*)(Screen *self, MouseEventArgs const *e)) ScreenGame_OnMouseDown,
	(void (*)(Screen *self, MouseEventArgs const *e)) ScreenGame_OnMouseMove,
	(void (*)(Screen *self, MouseEventArgs const *e)) ScreenGame_OnMouseUp,
	(void (*)(Screen *self, MouseWheelEventArgs const *e)) ScreenGame_OnMouseWheel,
	(void (*)(Screen *self, TouchEventArgs const *e)) ScreenGame_OnTouchEnd,
	(void (*)(Screen *self, TouchEventArgs const *e)) ScreenGame_OnTouchMove,
	(void (*)(Screen *self, TouchEventArgs const *e)) ScreenGame_OnTouchStart,
	(void (*)(Screen *self, float dt)) ScreenGame_Render
};

struct ScreenLogin {
	Screen base;
	int serverPort;
	cibool triedSavedLogin;
	MenuWidget *back;
	MenuWidget *createAccount;
	MenuWidget *createAccountPassword;
	MenuWidget *createAccountRememberMe;
	MenuWidget *createAccountUsername;
	MenuWidget *login;
	MenuWidget *loginPassword;
	MenuWidget *loginRememberMe;
	LoginResultRef *loginResult;
	LoginData *loginResultData;
	MenuWidget *loginUsername;
	const char *serverHash;
	const char *serverIp;
	const char *title;
};
static void ScreenLogin_Construct(ScreenLogin *self, const ScreenVtbl *vtbl);
static const ScreenVtbl CiVtbl_ScreenLogin = {
	(void (*)(Screen *self)) ScreenLogin_LoadTranslations,
	(void (*)(Screen *self)) ScreenLogin_OnBackPressed,
	(void (*)(Screen *self, MenuWidget const *w)) ScreenLogin_OnButton,
	Screen_OnKeyDown,
	Screen_OnKeyPress,
	Screen_OnKeyUp,
	Screen_OnMouseDown,
	Screen_OnMouseMove,
	Screen_OnMouseUp,
	Screen_OnMouseWheel,
	Screen_OnTouchEnd,
	Screen_OnTouchMove,
	Screen_OnTouchStart,
	(void (*)(Screen *self, float dt)) ScreenLogin_Render
};

struct ScreenMain {
	Screen base;
	cibool cursorLoaded;
	cibool queryStringChecked;
	MenuWidget *exit;
	MenuWidget *multiplayer;
	MenuWidget *singleplayer;
	float windowX;
	float windowY;
};
static void ScreenMain_Construct(ScreenMain *self, const ScreenVtbl *vtbl);
static void ScreenMain_UseQueryStringIpAndPort(ScreenMain *self, MainMenu *menu);
static const ScreenVtbl CiVtbl_ScreenMain = {
	Screen_LoadTranslations,
	(void (*)(Screen *self)) ScreenMain_OnBackPressed,
	(void (*)(Screen *self, MenuWidget const *w)) ScreenMain_OnButton,
	(void (*)(Screen *self, KeyEventArgs const *e)) ScreenMain_OnKeyDown,
	Screen_OnKeyPress,
	Screen_OnKeyUp,
	Screen_OnMouseDown,
	Screen_OnMouseMove,
	Screen_OnMouseUp,
	Screen_OnMouseWheel,
	Screen_OnTouchEnd,
	Screen_OnTouchMove,
	Screen_OnTouchStart,
	(void (*)(Screen *self, float dt)) ScreenMain_Render
};

struct ScreenModifyWorld {
	Screen base;
	MenuWidget *back;
};
static void ScreenModifyWorld_Construct(ScreenModifyWorld *self, const ScreenVtbl *vtbl);
static const ScreenVtbl CiVtbl_ScreenModifyWorld = {
	Screen_LoadTranslations,
	(void (*)(Screen *self)) ScreenModifyWorld_OnBackPressed,
	(void (*)(Screen *self, MenuWidget const *w)) ScreenModifyWorld_OnButton,
	Screen_OnKeyDown,
	Screen_OnKeyPress,
	Screen_OnKeyUp,
	Screen_OnMouseDown,
	Screen_OnMouseMove,
	Screen_OnMouseUp,
	Screen_OnMouseWheel,
	Screen_OnTouchEnd,
	Screen_OnTouchMove,
	Screen_OnTouchStart,
	(void (*)(Screen *self, float dt)) ScreenModifyWorld_Render
};

struct ScreenMultiplayer {
	Screen base;
	cibool loaded;
	cibool loading;
	int page;
	int serversPerPage;
	MenuWidget *back;
	MenuWidget *connect;
	MenuWidget *connectToIp;
	MenuWidget *loggedInName;
	MenuWidget *logout;
	MenuWidget *pageDown;
	MenuWidget *pageUp;
	MenuWidget *refresh;
	const char *selectedServerHash;
	MenuWidget **serverButtons;
	HttpResponseCi *serverListAddress;
	HttpResponseCi *serverListCsv;
	ServerOnList **serversOnList;
	ThumbnailResponseCi const **thumbResponses;
	const char *title;
};
static void ScreenMultiplayer_Construct(ScreenMultiplayer *self, const ScreenVtbl *vtbl);
static const ScreenVtbl CiVtbl_ScreenMultiplayer = {
	(void (*)(Screen *self)) ScreenMultiplayer_LoadTranslations,
	(void (*)(Screen *self)) ScreenMultiplayer_OnBackPressed,
	(void (*)(Screen *self, MenuWidget const *w)) ScreenMultiplayer_OnButton,
	Screen_OnKeyDown,
	Screen_OnKeyPress,
	Screen_OnKeyUp,
	Screen_OnMouseDown,
	Screen_OnMouseMove,
	Screen_OnMouseUp,
	(void (*)(Screen *self, MouseWheelEventArgs const *e)) ScreenMultiplayer_OnMouseWheel,
	Screen_OnTouchEnd,
	Screen_OnTouchMove,
	Screen_OnTouchStart,
	(void (*)(Screen *self, float dt)) ScreenMultiplayer_Render
};

struct ScreenSingleplayer {
	Screen base;
	int savegamesCount;
	MenuWidget *back;
	MenuWidget *modify;
	MenuWidget *newWorld;
	MenuWidget *open;
	MenuWidget *play;
	const char *const *savegames;
	const char *title;
	MenuWidget **worldButtons;
};
static void ScreenSingleplayer_Construct(ScreenSingleplayer *self, const ScreenVtbl *vtbl);
static const ScreenVtbl CiVtbl_ScreenSingleplayer = {
	(void (*)(Screen *self)) ScreenSingleplayer_LoadTranslations,
	(void (*)(Screen *self)) ScreenSingleplayer_OnBackPressed,
	(void (*)(Screen *self, MenuWidget const *w)) ScreenSingleplayer_OnButton,
	Screen_OnKeyDown,
	Screen_OnKeyPress,
	Screen_OnKeyUp,
	Screen_OnMouseDown,
	Screen_OnMouseMove,
	Screen_OnMouseUp,
	Screen_OnMouseWheel,
	Screen_OnTouchEnd,
	Screen_OnTouchMove,
	Screen_OnTouchStart,
	(void (*)(Screen *self, float dt)) ScreenSingleplayer_Render
};

typedef struct {
	void (*onCreate)(Script *self, ScriptManager const *manager);
	void (*onUse)(Script *self);
}
ScriptVtbl;
struct Script {
	const ScriptVtbl *vtbl;
};
static void Script_Construct(Script *self, const ScriptVtbl *vtbl);
static const ScriptVtbl CiVtbl_Script = {
	Script_OnCreate,
	Script_OnUse
};

struct ScriptCharacterPhysics {
	EntityScript base;
	cibool constEnableAcceleration;
	cibool isplayeronground;
	Acceleration *acceleration;
	float constGravity;
	float constJump;
	float constWaterGravityMultiplier;
	Vector3Ref *curspeed;
	Game *game;
	float jumpacceleration;
	float jumpstartacceleration;
	float jumpstartaccelerationhalf;
	float movedz;
	float movespeednow;
	IntRef *tmpBlockingBlockType;
	float *tmpPlayerPosition;
};
static void ScriptCharacterPhysics_Construct(ScriptCharacterPhysics *self, const EntityScriptVtbl *vtbl);
static int ScriptCharacterPhysics_FloatToInt(ScriptCharacterPhysics const *self, float value);
static cibool ScriptCharacterPhysics_IsEmptyPoint(ScriptCharacterPhysics const *self, float x, float y, float z, IntRef *blockingBlocktype);
static cibool ScriptCharacterPhysics_IsEmptySpaceForPlayer(ScriptCharacterPhysics const *self, cibool high, float x, float y, float z, IntRef *blockingBlockType);
static float ScriptCharacterPhysics_Max3(float a, float b, float c);
static cibool ScriptCharacterPhysics_StandingOnHalfBlock(ScriptCharacterPhysics const *self, float x, float y, float z);
static const EntityScriptVtbl CiVtbl_ScriptCharacterPhysics = {
	(void (*)(EntityScript *self, Game const *game, int entity, float dt)) ScriptCharacterPhysics_OnNewFrameFixed
};

typedef struct {
	void (*sendMessage)(ScriptManager *self, int player, const char *p);
}
ScriptManagerVtbl;
struct ScriptManager {
	const ScriptManagerVtbl *vtbl;
};
static void ScriptManager_Construct(ScriptManager *self, const ScriptManagerVtbl *vtbl);

struct SendPacketAction {
	Action_ base;
	int client;
	Packet_Server const *packet;
	ServerSimple const *server;
};
static void SendPacketAction_Construct(SendPacketAction *self, const Action_Vtbl *vtbl);
static const Action_Vtbl CiVtbl_SendPacketAction = {
	(void (*)(Action_ *self)) SendPacketAction_Run
};

struct ServerCi {
	int mainSocketsCount;
	NetServer const *const *mainSockets;
	float one;
};
static void ServerCi_Construct(ServerCi *self);

struct ServerInformation {
	const char *serverMotd;
	const char *serverName;
	Ping_ *serverPing;
	ConnectData const *connectdata;
};
static void ServerInformation_Construct(ServerInformation *self);

struct ServerOnList {
	int max;
	int port;
	cibool thumbnailDownloading;
	cibool thumbnailError;
	cibool thumbnailFetched;
	int users;
	const char *gamemode;
	const char *hash;
	const char *ip;
	const char *motd;
	const char *name;
	const char *players;
	const char *version;
};

static Packet_Server const *ServerPackets_AnswerQuery(Packet_ServerQueryAnswer *answer);
static Packet_Server const *ServerPackets_DisconnectPlayer(const char *disconnectReason);
static Packet_Server const *ServerPackets_EntityDespawn(int id);
static Packet_Server const *ServerPackets_EntityPositionAndOrientation(int id, Packet_PositionAndOrientation *positionAndOrientation);
static Packet_Server const *ServerPackets_EntitySpawn(int id, Packet_ServerEntity *entity);
static Packet_Server const *ServerPackets_Inventory(Packet_Inventory *inventory);
static Packet_Server const *ServerPackets_Ping(void);
static Packet_Server const *ServerPackets_PlayerStats(int health, int maxHealth, int oxygen, int maxOxygen);
static Packet_Server const *ServerPackets_SetBlock(int x, int y, int z, int block);

struct ServerSimple {
	int mapSizeX;
	int mapSizeY;
	int mapSizeZ;
	int blockTypesCount;
	int chunkdrawdistance;
	int clientsCount;
	int modsCount;
	int spawnGlX;
	int spawnGlY;
	int spawnGlZ;
	QueueAction *actions;
	Packet_BlockType **blockTypes;
	ChunkSimple const *const *const *chunks;
	ClientSimple **clients;
	QueueAction *mainThreadActions;
	MonitorObject const *mainThreadActionsLock;
	ModSimple const **mods;
	float one;
	GamePlatform const *platform;
	const char *saveFilename;
	NetServer const *server;
};
static void ServerSimple_Construct(ServerSimple *self);
static void ServerSimple_Move(ServerSimple const *self, QueueAction *from, QueueAction *to);
static void ServerSimple_NotifyInventory(ServerSimple const *self);
static void ServerSimple_NotifyMap(ServerSimple const *self);
static void ServerSimple_NotifyPing(ServerSimple const *self);
static void ServerSimple_ProcessActions(ServerSimple const *self);
static void ServerSimple_ProcessPacket(ServerSimple const *self, int client, Packet_Client const *packet);
static void ServerSimple_ProcessPackets(ServerSimple *self);
static void ServerSimple_SendPacketToAll(ServerSimple const *self, Packet_Server const *packet);

struct Sound_ {
	cibool loop;
	cibool stop;
	AudioCi const *audio;
	const char *name;
	float x;
	float y;
	float z;
};
static void Sound__Construct(Sound_ *self);


struct Speculative {
	int blocktype;
	int timeMilliseconds;
	int x;
	int y;
	int z;
};

static float SphereModelData_GetPi(void);

struct Sprite {
	int animationcount;
	int size;
	const char *image;
	float positionX;
	float positionY;
	float positionZ;
};
static void Sprite_Construct(Sprite *self);

struct StackMatrix4 {
	int count_;
	float **values;
};
static void StackMatrix4_Construct(StackMatrix4 *self);
static int StackMatrix4_Count(StackMatrix4 const *self);
static float *StackMatrix4_Peek(StackMatrix4 const *self);
static float const *StackMatrix4_Pop(StackMatrix4 *self);
static void StackMatrix4_Push(StackMatrix4 *self, float const *p);

struct StringByteArray {
	unsigned char const *data;
	const char *name;
};


struct SunMoonRenderer {
	ClientMod base;
	int imageSize;
	int hour;
	int moontexture;
	int suntexture;
	float day_length_in_seconds;
	float one;
	float t;
};
static void SunMoonRenderer_Construct(SunMoonRenderer *self, const ClientModVtbl *vtbl);
static void SunMoonRenderer_UpdateSunMoonPosition(SunMoonRenderer *self, Game *game, float dt);
static const ClientModVtbl CiVtbl_SunMoonRenderer = {
	ClientMod_Dispose,
	ClientMod_OnBeforeNewFrameDraw3d,
	ClientMod_OnClientCommand,
	ClientMod_OnHitEntity,
	ClientMod_OnKeyDown,
	ClientMod_OnKeyPress,
	ClientMod_OnKeyUp,
	ClientMod_OnMouseDown,
	ClientMod_OnMouseMove,
	ClientMod_OnMouseUp,
	ClientMod_OnMouseWheelChanged,
	ClientMod_OnNewFrame,
	ClientMod_OnNewFrameDraw2d,
	(void (*)(ClientMod *self, Game const *game, float deltaTime)) SunMoonRenderer_OnNewFrameDraw3d,
	ClientMod_OnNewFrameFixed,
	ClientMod_OnNewFrameReadOnlyMainThread,
	ClientMod_OnReadOnlyBackgroundThread,
	ClientMod_OnReadOnlyMainThread,
	ClientMod_OnReadWriteMainThread,
	ClientMod_OnTouchEnd,
	ClientMod_OnTouchMove,
	ClientMod_OnTouchStart,
	ClientMod_OnUseEntity,
	ClientMod_Start
};


struct TaskScheduler {
	BackgroundAction **actions;
};
static void TaskScheduler_Construct(TaskScheduler *self);

struct TcpNetClient {
	NetClient base;
	BoolRef const *connected;
	unsigned char const *data;
	QueueByte *incoming;
	GamePlatform const *platform;
	QueueINetOutgoingMessage *tosend;
};
static void TcpNetClient_Construct(TcpNetClient *self, const NetClientVtbl *vtbl);
static void TcpNetClient_DoSendPacket(TcpNetClient const *self, INetOutgoingMessage const *msg);
static NetIncomingMessage const *TcpNetClient_GetMessage(TcpNetClient const *self);
static int TcpNetClient_ReadInt(TcpNetClient const *self, unsigned char const *readBuf, int readPos);
static void TcpNetClient_WriteInt(TcpNetClient const *self, unsigned char *writeBuf, int writePos, int n);
static const NetClientVtbl CiVtbl_TcpNetClient = {
	(NetConnection const *(*)(NetClient *self, const char *ip, int port)) TcpNetClient_Connect,
	(NetIncomingMessage const *(*)(NetClient *self)) TcpNetClient_ReadMessage,
	(void (*)(NetClient *self, INetOutgoingMessage const *message, MyNetDeliveryMethod method)) TcpNetClient_SendMessage,
	(void (*)(NetClient *self)) TcpNetClient_Start
};

struct TerrainChunkTesselatorCi {
	cibool eNABLE_TEXTURE_TILING;
	cibool enableSmoothLight;
	int torchSideTexture;
	int torchTopTexture;
	int _colorWhite;
	int mapsizex;
	int mapsizey;
	int mapsizez;
	cibool option_DarkenBlockSides;
	cibool option_DoNotDrawEdges;
	cibool started;
	int terrainTexturesPerAtlas;
	int toreturnatlas1dLength;
	float atiArtifactFix;
	float blockShadow;
	float _texrecHeight;
	float _texrecLeft;
	float _texrecRight;
	float _texrecWidth;
	VecCito3i const ***c_OcclusionNeighbors;
	int const *currentChunk18;
	unsigned char *currentChunkDraw16;
	unsigned char **currentChunkDrawCount16;
	unsigned char const *currentChunkShadows18;
	Game const *game;
	float halfocc;
	cibool *isFluid;
	cibool *isLowered;
	cibool *istransparent;
	float const *lightlevels;
	float maxlightInverse;
	float occ;
	float *ref_blockCornerHeight;
	float terrainTexturesPerAtlasInverse;
	float *tmpfShadowRation;
	int *tmpnPos;
	cibool *tmpoccupied;
	int *tmpshadowration;
	VecCito3i *tmpv;
	ModelData **toreturnatlas1d;
	ModelData **toreturnatlas1dtransparent;
};
static void TerrainChunkTesselatorCi_Construct(TerrainChunkTesselatorCi *self);
static void TerrainChunkTesselatorCi_BuildBlockFace(TerrainChunkTesselatorCi const *self, int x, int y, int z, int tileType, float vOffsetX, float vOffsetY, float vOffsetZ, float vScaleX, float vScaleY, float vScaleZ, int const *currentChunk, int tileSide);
static void TerrainChunkTesselatorCi_CalcShadowRation(TerrainChunkTesselatorCi const *self, int nDir1, int nDir2, int nDirBetween, int nCorner, float *fShadowRation, cibool const *occupied, int const *shadowRationInt);
static int TerrainChunkTesselatorCi_ColorMultiply(TerrainChunkTesselatorCi const *self, int color, float fValue);
static void TerrainChunkTesselatorCi_DrawBlockFace(TerrainChunkTesselatorCi const *self, int x, int y, int z, int tileType, int tileSide, float vOffsetX, float vOffsetY, float vOffsetZ, float vScaleX, float vScaleY, float vScaleZ, VecCito3i const *const *vNeighbors, float const *fShadowRation);
static float TerrainChunkTesselatorCi_GetCornerHeightModifier(TerrainChunkTesselatorCi const *self, int side, int corner);
static int TerrainChunkTesselatorCi_GetFaceVisibility(TerrainChunkTesselatorCi const *self, int nSide, int const *currentChunk, int const *nPos, cibool blnIsFluid, cibool blnIsLowered);
static int TerrainChunkTesselatorCi_GetToDrawFlags(TerrainChunkTesselatorCi const *self, int xx, int yy, int zz);
static int TerrainChunkTesselatorCi_Max(TerrainChunkTesselatorCi const *self, int a, int b);
static int TerrainChunkTesselatorCi_SetVisibleFlag(TerrainChunkTesselatorCi const *self, unsigned char const *drawFlags, int tileSideIndex, int nCurrentFlags, int nFlagToSet);

struct TerrainRendererCommit {
	Action_ base;
	ModDrawTerrain *renderer;
};
static void TerrainRendererCommit_Construct(TerrainRendererCommit *self, const Action_Vtbl *vtbl);
static const Action_Vtbl CiVtbl_TerrainRendererCommit = {
	(void (*)(Action_ *self)) TerrainRendererCommit_Run
};

struct TerrainRendererRedraw {
	int dataCount;
	Chunk const *c;
	VerticesIndicesToLoad const **data;
};

struct TextColorRenderer {
	GamePlatform const *platform;
};
static BitmapCi const *TextColorRenderer_CreateTextTexture(TextColorRenderer const *self, Text_ const *t);
static int TextColorRenderer_GetColor(TextColorRenderer const *self, int currentcolor);
static int TextColorRenderer_HexToInt(TextColorRenderer const *self, int c);
static int TextColorRenderer_NextPowerOfTwo(TextColorRenderer const *self, int x);

struct TextPart {
	int color;
	const char *text;
};

struct TextTexture {
	int textheight;
	int texture;
	int textureheight;
	int texturewidth;
	int textwidth;
	float size;
	const char *text;
};

struct Text_ {
	int color;
	int fontstyle;
	const char *fontfamily;
	float fontsize;
	const char *text;
};
static cibool Text__Equals_(Text_ const *self, Text_ const *t);





struct ThumbnailResponseCi {
	int dataLength;
	cibool done;
	cibool error;
	unsigned char const *data;
	const char *serverMessage;
};


struct TileEnterData {
	int blockPositionX;
	int blockPositionY;
	int blockPositionZ;
	TileEnterDirection enterDirection;
};




struct TimerCi {
	float accumulator;
	float interval;
	float maxDeltaTime;
};
static void TimerCi_Construct(TimerCi *self);
static TimerCi *TimerCi_Create(int interval_, int maxDeltaTime_);

struct ToCall {
	int count;
	int max;
	Model const **lists;
};


struct TouchEventArgs {
	cibool handled;
	int id;
	int x;
	int y;
};

struct TranslatedString {
	const char *id;
	const char *language;
	const char *translated;
};

struct UnloadRendererChunksCommit {
	Action_ base;
	int unloadChunkPos;
	Game const *game;
};
static void UnloadRendererChunksCommit_Construct(UnloadRendererChunksCommit *self, const Action_Vtbl *vtbl);
static const Action_Vtbl CiVtbl_UnloadRendererChunksCommit = {
	(void (*)(Action_ *self)) UnloadRendererChunksCommit_Run
};

struct Unproject {
	float *finalMatrix;
	float *inp;
	float *out_;
};
static void Unproject_Construct(Unproject *self);
static void Unproject_MultMatrixVec(Unproject const *self, float const *matrix, float const *inp__, float *out__);


struct UriCi {
	int port;
	DictionaryStringString const *get;
	const char *ip;
	const char *url;
};




struct VecCito3i {
	int x;
	int y;
	int z;
};

struct Vector3Float {
	int x;
	int y;
	int z;
	float value;
};

struct Vector3IntRef {
	int x;
	int y;
	int z;
};
static Vector3IntRef const *Vector3IntRef_Create(int x, int y, int z);

struct Vector3Ref {
	float x;
	float y;
	float z;
};
static Vector3Ref *Vector3Ref_Create(float x, float y, float z);
static float Vector3Ref_Length(Vector3Ref const *self);
static void Vector3Ref_Normalize(Vector3Ref *self);



struct VerticesIndicesToLoad {
	int texture;
	cibool transparent;
	ModelData const *modelData;
	float positionX;
	float positionY;
	float positionZ;
};

struct VisibleDialog {
	const char *key;
	GameScreen *screen;
	Packet_Dialog const *value;
};


struct WebSocketClient {
	NetClient base;
	WebSocketClientConnection *c;
	unsigned char *incomingData;
	GamePlatform const *p;
};
static void WebSocketClient_Construct(WebSocketClient *self, const NetClientVtbl *vtbl);
static void WebSocketClient_SetPlatform(WebSocketClient *self, GamePlatform const *platform);
static const NetClientVtbl CiVtbl_WebSocketClient = {
	(NetConnection const *(*)(NetClient *self, const char *ip, int port)) WebSocketClient_Connect,
	(NetIncomingMessage const *(*)(NetClient *self)) WebSocketClient_ReadMessage,
	(void (*)(NetClient *self, INetOutgoingMessage const *message, MyNetDeliveryMethod method)) WebSocketClient_SendMessage,
	(void (*)(NetClient *self)) WebSocketClient_Start
};

struct WebSocketClientConnection {
	NetConnection base;
	const char *address;
	GamePlatform const *platform;
};
static void WebSocketClientConnection_Construct(WebSocketClientConnection *self, const NetConnectionVtbl *vtbl);
static const NetConnectionVtbl CiVtbl_WebSocketClientConnection = {
	(cibool (*)(NetConnection *self, NetConnection const *connection)) WebSocketClientConnection_EqualsConnection,
	(IPEndPointCi const *(*)(NetConnection *self)) WebSocketClientConnection_RemoteEndPoint,
	(void (*)(NetConnection *self, INetOutgoingMessage const *msg, MyNetDeliveryMethod method, int sequenceChannel)) WebSocketClientConnection_SendMessage,
	(void (*)(NetConnection *self)) WebSocketClientConnection_Update
};


static void WireframeCube_AddVertex(ModelData *model, float x, float y, float z, float u, float v, int color);
static void WireframeCube_DrawLineLoop(ModelData *m, Vector3Ref const *p0, Vector3Ref const *p1, Vector3Ref const *p2, Vector3Ref const *p3);

static void Acceleration_Construct(Acceleration *self)
{
	Acceleration_SetDefault(self);
}

Acceleration *Acceleration_New(void)
{
	Acceleration *self = (Acceleration *) malloc(sizeof(Acceleration));
	if (self != NULL)
		Acceleration_Construct(self);
	return self;
}

void Acceleration_Delete(Acceleration *self)
{
	free(self);
}

void Acceleration_SetDefault(Acceleration *self)
{
	self->acceleration1 = 0.9f;
	self->acceleration2 = 2;
	self->acceleration3 = 700;
}

static void Action__Construct(Action_ *self, const Action_Vtbl *vtbl)
{
	self->vtbl = vtbl;
}

int AngleInterpolation_InterpolateAngle256(GamePlatform const *platform, int a, int b, float progress)
{
	if (progress != 0 && b != a) {
		int diff = AngleInterpolation_NormalizeAngle256(b - a);
		if (diff >= 128) {
			diff -= 256;
		}
		a += platform->vtbl->floatToInt(platform, progress * diff);
	}
	return AngleInterpolation_NormalizeAngle256(a);
}

float AngleInterpolation_InterpolateAngle360(GamePlatform const *platform, float a, float b, float progress)
{
	if (progress != 0 && b != a) {
		float diff = AngleInterpolation_NormalizeAngle360(platform, b - a);
		if (diff >= 180) {
			diff -= 360;
		}
		a += progress * diff;
	}
	return AngleInterpolation_NormalizeAngle360(platform, a);
}

static int AngleInterpolation_NormalizeAngle256(int v)
{
	return (v + 16383) % 256;
}

static float AngleInterpolation_NormalizeAngle360(GamePlatform const *platform, float v)
{
	return platform->vtbl->floatModulo(platform, v + 16200, 360);
}

static void AnimatedModel_Construct(AnimatedModel *self)
{
	self->global = AnimationGlobal_New();
}

AnimatedModel *AnimatedModel_New(void)
{
	AnimatedModel *self = (AnimatedModel *) malloc(sizeof(AnimatedModel));
	if (self != NULL)
		AnimatedModel_Construct(self);
	return self;
}

void AnimatedModel_Delete(AnimatedModel *self)
{
	free(self);
}

static void AnimatedModelBinding_Construct(AnimatedModelBinding *self, const TableBindingVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_AnimatedModelBinding;
	TableBinding_Construct(&self->base, vtbl);
}

AnimatedModelBinding *AnimatedModelBinding_New(void)
{
	AnimatedModelBinding *self = (AnimatedModelBinding *) malloc(sizeof(AnimatedModelBinding));
	if (self != NULL)
		AnimatedModelBinding_Construct(self, NULL);
	return self;
}

void AnimatedModelBinding_Delete(AnimatedModelBinding *self)
{
	free(self);
}

static float AnimatedModelBinding_FloatParse(AnimatedModelBinding const *self, const char *s)
{
	FloatRef const *ret = FloatRef_New();
	self->p->vtbl->floatTryParse(self->p, s, ret);
	return ret->value;
}

void AnimatedModelBinding_Get(AnimatedModelBinding const *self, const char *table, int index, DictionaryStringString const *items)
{
	if (strcmp(table, "nodes") == 0) {
		Node const *k = self->m->nodes[index];
		DictionaryStringString_Set(items, "name", k->name);
		DictionaryStringString_Set(items, "paren", k->parentName);
		DictionaryStringString_Set(items, "x", self->p->vtbl->floatToString(self->p, k->posx));
		DictionaryStringString_Set(items, "y", self->p->vtbl->floatToString(self->p, k->posy));
		DictionaryStringString_Set(items, "z", self->p->vtbl->floatToString(self->p, k->posz));
		DictionaryStringString_Set(items, "rotx", self->p->vtbl->floatToString(self->p, k->rotatex));
		DictionaryStringString_Set(items, "roty", self->p->vtbl->floatToString(self->p, k->rotatey));
		DictionaryStringString_Set(items, "rotz", self->p->vtbl->floatToString(self->p, k->rotatez));
		DictionaryStringString_Set(items, "sizex", self->p->vtbl->floatToString(self->p, k->sizex));
		DictionaryStringString_Set(items, "sizey", self->p->vtbl->floatToString(self->p, k->sizey));
		DictionaryStringString_Set(items, "sizez", self->p->vtbl->floatToString(self->p, k->sizez));
		DictionaryStringString_Set(items, "u", self->p->vtbl->floatToString(self->p, k->u));
		DictionaryStringString_Set(items, "v", self->p->vtbl->floatToString(self->p, k->v));
		DictionaryStringString_Set(items, "pivx", self->p->vtbl->floatToString(self->p, k->pivotx));
		DictionaryStringString_Set(items, "pivy", self->p->vtbl->floatToString(self->p, k->pivoty));
		DictionaryStringString_Set(items, "pivz", self->p->vtbl->floatToString(self->p, k->pivotz));
		DictionaryStringString_Set(items, "scalx", self->p->vtbl->floatToString(self->p, k->scalex));
		DictionaryStringString_Set(items, "scaly", self->p->vtbl->floatToString(self->p, k->scaley));
		DictionaryStringString_Set(items, "scalz", self->p->vtbl->floatToString(self->p, k->scalez));
		DictionaryStringString_Set(items, "head", self->p->vtbl->floatToString(self->p, k->head));
	}
	if (strcmp(table, "keyframes") == 0) {
		Keyframe const *k = self->m->keyframes[index];
		DictionaryStringString_Set(items, "anim", k->animationName);
		DictionaryStringString_Set(items, "node", k->nodeName);
		DictionaryStringString_Set(items, "frame", self->p->vtbl->floatToString(self->p, k->frame));
		DictionaryStringString_Set(items, "type", KeyframeType_GetName(k->frame));
		DictionaryStringString_Set(items, "x", self->p->vtbl->floatToString(self->p, k->x));
		DictionaryStringString_Set(items, "y", self->p->vtbl->floatToString(self->p, k->y));
		DictionaryStringString_Set(items, "z", self->p->vtbl->floatToString(self->p, k->z));
	}
	if (strcmp(table, "animations") == 0) {
		Animation const *k = self->m->animations[index];
		DictionaryStringString_Set(items, "name", k->name);
		DictionaryStringString_Set(items, "len", self->p->vtbl->floatToString(self->p, k->length));
	}
	if (strcmp(table, "global") == 0) {
		AnimationGlobal const *global = self->m->global;
		DictionaryStringString_Set(items, "texw", self->p->vtbl->floatToString(self->p, global->texw));
		DictionaryStringString_Set(items, "texh", self->p->vtbl->floatToString(self->p, global->texh));
	}
}

void AnimatedModelBinding_GetTables(AnimatedModelBinding const *self, const char **name, int *count)
{
	name[0] = "nodes";
	count[0] = self->m->nodesCount;
	name[1] = "keyframes";
	count[1] = self->m->keyframesCount;
	name[2] = "animations";
	count[2] = self->m->animationsCount;
	name[3] = "global";
	count[3] = 1;
}

static int AnimatedModelBinding_IntParse(AnimatedModelBinding const *self, const char *s)
{
	return self->p->vtbl->floatToInt(self->p, AnimatedModelBinding_FloatParse(self, s));
}

void AnimatedModelBinding_Set(AnimatedModelBinding const *self, const char *table, int index, const char *column, const char *value)
{
	if (strcmp(table, "nodes") == 0) {
		Node *k;
		if (index >= self->m->nodesCount) {
			self->m->nodesCount = index + 1;
		}
		if (self->m->nodes[index] == NULL) {
			self->m->nodes[index] = Node_New();
		}
		k = self->m->nodes[index];
		if (strcmp(column, "name") == 0) {
			k->name = value;
		}
		if (strcmp(column, "paren") == 0) {
			k->parentName = value;
		}
		if (strcmp(column, "x") == 0) {
			k->posx = AnimatedModelBinding_FloatParse(self, value);
		}
		if (strcmp(column, "y") == 0) {
			k->posy = AnimatedModelBinding_FloatParse(self, value);
		}
		if (strcmp(column, "z") == 0) {
			k->posz = AnimatedModelBinding_FloatParse(self, value);
		}
		if (strcmp(column, "rotx") == 0) {
			k->rotatex = AnimatedModelBinding_FloatParse(self, value);
		}
		if (strcmp(column, "roty") == 0) {
			k->rotatey = AnimatedModelBinding_FloatParse(self, value);
		}
		if (strcmp(column, "rotz") == 0) {
			k->rotatez = AnimatedModelBinding_FloatParse(self, value);
		}
		if (strcmp(column, "sizex") == 0) {
			k->sizex = AnimatedModelBinding_FloatParse(self, value);
		}
		if (strcmp(column, "sizey") == 0) {
			k->sizey = AnimatedModelBinding_FloatParse(self, value);
		}
		if (strcmp(column, "sizez") == 0) {
			k->sizez = AnimatedModelBinding_FloatParse(self, value);
		}
		if (strcmp(column, "u") == 0) {
			k->u = AnimatedModelBinding_FloatParse(self, value);
		}
		if (strcmp(column, "v") == 0) {
			k->v = AnimatedModelBinding_FloatParse(self, value);
		}
		if (strcmp(column, "pivx") == 0) {
			k->pivotx = AnimatedModelBinding_FloatParse(self, value);
		}
		if (strcmp(column, "pivy") == 0) {
			k->pivoty = AnimatedModelBinding_FloatParse(self, value);
		}
		if (strcmp(column, "pivz") == 0) {
			k->pivotz = AnimatedModelBinding_FloatParse(self, value);
		}
		if (strcmp(column, "scalx") == 0) {
			k->scalex = AnimatedModelBinding_FloatParse(self, value);
		}
		if (strcmp(column, "scaly") == 0) {
			k->scaley = AnimatedModelBinding_FloatParse(self, value);
		}
		if (strcmp(column, "scalz") == 0) {
			k->scalez = AnimatedModelBinding_FloatParse(self, value);
		}
		if (strcmp(column, "head") == 0) {
			k->head = AnimatedModelBinding_FloatParse(self, value);
		}
	}
	if (strcmp(table, "keyframes") == 0) {
		Keyframe *k;
		if (index >= self->m->keyframesCount) {
			self->m->keyframesCount = index + 1;
		}
		if (self->m->keyframes[index] == NULL) {
			self->m->keyframes[index] = Keyframe_New();
		}
		k = self->m->keyframes[index];
		if (strcmp(column, "anim") == 0) {
			k->animationName = value;
		}
		if (strcmp(column, "node") == 0) {
			k->nodeName = value;
		}
		if (strcmp(column, "frame") == 0) {
			k->frame = AnimatedModelBinding_IntParse(self, value);
		}
		if (strcmp(column, "type") == 0) {
			k->keyframeType = KeyframeType_GetValue(value);
		}
		if (strcmp(column, "x") == 0) {
			k->x = AnimatedModelBinding_FloatParse(self, value);
		}
		if (strcmp(column, "y") == 0) {
			k->y = AnimatedModelBinding_FloatParse(self, value);
		}
		if (strcmp(column, "z") == 0) {
			k->z = AnimatedModelBinding_FloatParse(self, value);
		}
	}
	if (strcmp(table, "animations") == 0) {
		Animation *k;
		if (index >= self->m->animationsCount) {
			self->m->animationsCount = index + 1;
		}
		if (self->m->animations[index] == NULL) {
			self->m->animations[index] = Animation_New();
		}
		k = self->m->animations[index];
		if (strcmp(column, "name") == 0) {
			k->name = value;
		}
		if (strcmp(column, "len") == 0) {
			k->length = AnimatedModelBinding_IntParse(self, value);
		}
	}
	if (strcmp(table, "global") == 0) {
		AnimationGlobal *global = self->m->global;
		if (strcmp(column, "texw") == 0) {
			global->texw = AnimatedModelBinding_IntParse(self, value);
		}
		if (strcmp(column, "texh") == 0) {
			global->texh = AnimatedModelBinding_IntParse(self, value);
		}
	}
}

static void AnimatedModelRenderer_Construct(AnimatedModelRenderer *self)
{
	self->one = 1;
	self->tempframes = (Keyframe const **) malloc(256 * sizeof(Keyframe const *));
	self->tempframesCount = IntRef_New();
	self->tempVec3 = (float *) malloc(3 * sizeof(float ));
}

AnimatedModelRenderer *AnimatedModelRenderer_New(void)
{
	AnimatedModelRenderer *self = (AnimatedModelRenderer *) malloc(sizeof(AnimatedModelRenderer));
	if (self != NULL)
		AnimatedModelRenderer_Construct(self);
	return self;
}

void AnimatedModelRenderer_Delete(AnimatedModelRenderer *self)
{
	free(self);
}

static void AnimatedModelRenderer_DrawNode(AnimatedModelRenderer const *self, const char *parent, float headDeg, float light)
{
	{
		int i;
		for (i = 0; i < self->m->nodesCount; i++) {
			Node const *n = self->m->nodes[i];
			RectangleFloat const **r;
			if (n == NULL) {
				continue;
			}
			if (strcmp(n->parentName, parent) != 0) {
				continue;
			}
			Game_GLPushMatrix(self->game);
			r = (RectangleFloat const **) malloc(6 * sizeof(RectangleFloat const *));
			r = CuboidRenderer_CuboidNet(n->sizex, n->sizey, n->sizez, n->u, n->v);
			CuboidRenderer_CuboidNetNormalize(r, self->m->global->texw, self->m->global->texh);
			AnimatedModelRenderer_GetAnimation(self, n, self->tempVec3, 5);
			if (self->tempVec3[0] != 0 && self->tempVec3[1] != 0 && self->tempVec3[2] != 0) {
				Game_GLScale(self->game, self->tempVec3[0], self->tempVec3[1], self->tempVec3[2]);
			}
			AnimatedModelRenderer_GetAnimation(self, n, self->tempVec3, 1);
			self->tempVec3[0] /= 16;
			self->tempVec3[1] /= 16;
			self->tempVec3[2] /= 16;
			if (!AnimatedModelRenderer_IsZero(self, self->tempVec3)) {
				Game_GLTranslate(self->game, self->tempVec3[0], self->tempVec3[1], self->tempVec3[2]);
			}
			AnimatedModelRenderer_GetAnimation(self, n, self->tempVec3, 2);
			if (self->tempVec3[0] != 0) {
				Game_GLRotate(self->game, self->tempVec3[0], 1, 0, 0);
			}
			if (self->tempVec3[1] != 0) {
				Game_GLRotate(self->game, self->tempVec3[1], 0, 1, 0);
			}
			if (self->tempVec3[2] != 0) {
				Game_GLRotate(self->game, self->tempVec3[2], 0, 0, 1);
			}
			if (n->head == 1) {
				Game_GLRotate(self->game, headDeg, 1, 0, 0);
			}
			AnimatedModelRenderer_GetAnimation(self, n, self->tempVec3, 4);
			self->tempVec3[0] /= 16;
			self->tempVec3[1] /= 16;
			self->tempVec3[2] /= 16;
			Game_GLTranslate(self->game, self->tempVec3[0], self->tempVec3[1], self->tempVec3[2]);
			AnimatedModelRenderer_GetAnimation(self, n, self->tempVec3, 3);
			self->tempVec3[0] /= 16;
			self->tempVec3[1] /= 16;
			self->tempVec3[2] /= 16;
			CuboidRenderer_DrawCuboid2(self->game, 0 - self->tempVec3[0] / 2, 0 - self->tempVec3[1] / 2, 0 - self->tempVec3[2] / 2, self->tempVec3[0], self->tempVec3[1], self->tempVec3[2], r, light);
			AnimatedModelRenderer_DrawNode(self, n->name, headDeg, light);
			Game_GLPopMatrix(self->game);
		}
	}
}

static void AnimatedModelRenderer_GetAnimation(AnimatedModelRenderer const *self, Node const *node, float *ret, int type)
{
	int currentI;
	int nextI;
	Keyframe const *current;
	Keyframe const *next;
	float t;
	float length;
	AnimatedModelRenderer_GetFrames(self, node->name, type, self->tempframes, self->tempframesCount);
	currentI = AnimatedModelRenderer_GetFrameCurrent(self, self->tempframes, self->tempframesCount->value);
	if (currentI == -1) {
		AnimatedModelRenderer_GetDefaultFrame(self, node, type, ret);
		return;
	}
	nextI = (currentI + 1) % self->tempframesCount->value;
	current = self->tempframes[currentI];
	next = self->tempframes[nextI];
	length = self->m->animations[self->anim]->length;
	if (next->frame == current->frame) {
		t = 0;
	}
	else if (next->frame > current->frame) {
		t = (self->frame - current->frame) / (next->frame - current->frame);
	}
	else {
		float end = 0;
		float begin = 0;
		if (self->frame >= current->frame) {
			end = self->frame - current->frame;
		}
		else {
			end = length - current->frame;
			begin = self->frame;
		}
		t = (end + begin) / (length - current->frame + next->frame);
	}
	ret[0] = AnimatedModelRenderer_Lerp(self, current->x, next->x, t);
	ret[1] = AnimatedModelRenderer_Lerp(self, current->y, next->y, t);
	ret[2] = AnimatedModelRenderer_Lerp(self, current->z, next->z, t);
}

static void AnimatedModelRenderer_GetDefaultFrame(AnimatedModelRenderer const *self, Node const *node, int type, float *ret)
{
	switch (type) {
	case 1:
		{
			ret[0] = node->posx;
			ret[1] = node->posy;
			ret[2] = node->posz;
		}
		break;
	case 2:
		{
			ret[0] = node->rotatex;
			ret[1] = node->rotatey;
			ret[2] = node->rotatez;
		}
		break;
	case 3:
		{
			ret[0] = node->sizex;
			ret[1] = node->sizey;
			ret[2] = node->sizez;
		}
		break;
	case 4:
		{
			ret[0] = node->pivotx;
			ret[1] = node->pivoty;
			ret[2] = node->pivotz;
		}
		break;
	case 5:
		{
			ret[0] = node->scalex;
			ret[1] = node->scaley;
			ret[2] = node->scalez;
		}
		break;
	}
}

static int AnimatedModelRenderer_GetFrameCurrent(AnimatedModelRenderer const *self, Keyframe const *const *frames, int framesCount)
{
	const char *animName = self->m->animations[self->anim]->name;
	int current = -1;
	{
		int i;
		for (i = 0; i < framesCount; i++) {
			Keyframe const *k = frames[i];
			if (k->frame <= self->frame) {
				if (current == -1) {
					current = i;
				}
				else {
					if (k->frame > frames[current]->frame) {
						current = i;
					}
				}
			}
		}
	}
	if (current == -1) {
		{
			int i;
			for (i = 0; i < framesCount; i++) {
				Keyframe const *k = frames[i];
				if (current == -1 || k->frame > frames[current]->frame) {
					current = i;
				}
			}
		}
	}
	return current;
}

static void AnimatedModelRenderer_GetFrames(AnimatedModelRenderer const *self, const char *nodeName, int type, Keyframe const **frames, IntRef *count)
{
	const char *animName;
	count->value = 0;
	animName = self->m->animations[self->anim]->name;
	{
		int i;
		for (i = 0; i < self->m->keyframesCount; i++) {
			Keyframe const *k = self->m->keyframes[i];
			if (k == NULL) {
				continue;
			}
			if (strcmp(k->nodeName, nodeName) != 0) {
				continue;
			}
			if (strcmp(k->animationName, animName) != 0) {
				continue;
			}
			if (k->keyframeType != type) {
				continue;
			}
			frames[count->value++] = k;
		}
	}
}

static cibool AnimatedModelRenderer_IsZero(AnimatedModelRenderer const *self, float const *vec)
{
	return vec[0] == 0 && vec[1] == 0 && vec[2] == 0;
}

static float AnimatedModelRenderer_Lerp(AnimatedModelRenderer const *self, float v0, float v1, float t)
{
	return v0 + (v1 - v0) * t;
}

void AnimatedModelRenderer_Render(AnimatedModelRenderer *self, float dt, float headDeg, cibool walkAnimation, cibool moves, float light)
{
	float length;
	if (self->m == NULL) {
		return;
	}
	if (self->m->animations == NULL) {
		return;
	}
	if (self->m->animations[self->anim] == NULL) {
		return;
	}
	length = self->m->animations[self->anim]->length;
	if (moves) {
		self->frame += dt * 60;
		self->frame = self->frame % length;
	}
	if (walkAnimation) {
		if (!moves) {
			if (self->frame != 0 && self->frame != length / 2 && self->frame != length) {
				if (self->frame < length / 2) {
					self->frame += dt * 60;
					if (self->frame > length / 2) {
						self->frame = length / 2;
					}
				}
				else {
					self->frame += dt * 60;
					if (self->frame > length) {
						self->frame = length;
					}
				}
			}
		}
	}
	AnimatedModelRenderer_DrawNode(self, "root", headDeg, light);
}

void AnimatedModelRenderer_Start(AnimatedModelRenderer *self, Game const *game_, AnimatedModel const *model_)
{
	self->game = game_;
	self->m = model_;
}

AnimatedModel const *AnimatedModelSerializer_Deserialize(GamePlatform const *p, const char *data)
{
	AnimatedModel *model = AnimatedModel_New();
	AnimatedModelBinding *b;
	TableSerializer const *s;
	model->nodes = (Node const **) malloc(256 * sizeof(Node const *));
	model->keyframes = (Keyframe const **) malloc(1024 * sizeof(Keyframe const *));
	model->animations = (Animation const **) malloc(128 * sizeof(Animation const *));
	b = AnimatedModelBinding_New();
	b->p = p;
	b->m = model;
	s = TableSerializer_New();
	TableSerializer_Deserialize(s, p, data, &b->base);
	return model;
}

const char *AnimatedModelSerializer_Serialize(GamePlatform const *p, AnimatedModel const *m)
{
	return NULL;
}

Animation *Animation_New(void)
{
	Animation *self = (Animation *) malloc(sizeof(Animation));
	return self;
}

void Animation_Delete(Animation *self)
{
	free(self);
}

AnimationGlobal *AnimationGlobal_New(void)
{
	AnimationGlobal *self = (AnimationGlobal *) malloc(sizeof(AnimationGlobal));
	return self;
}

void AnimationGlobal_Delete(AnimationGlobal *self)
{
	free(self);
}

AnimationHint *AnimationHint_New(void)
{
	AnimationHint *self = (AnimationHint *) malloc(sizeof(AnimationHint));
	return self;
}

void AnimationHint_Delete(AnimationHint *self)
{
	free(self);
}

static void AnimationState_Construct(AnimationState *self)
{
	self->bodyrotation = -1;
	self->light = 1;
}

AnimationState *AnimationState_New(void)
{
	AnimationState *self = (AnimationState *) malloc(sizeof(AnimationState));
	if (self != NULL)
		AnimationState_Construct(self);
	return self;
}

void AnimationState_Delete(AnimationState *self)
{
	free(self);
}

float AnimationState_GetInterp(AnimationState const *self)
{
	return self->interp;
}

Asset *Asset_New(void)
{
	Asset *self = (Asset *) malloc(sizeof(Asset));
	return self;
}

void Asset_Delete(Asset *self)
{
	free(self);
}

unsigned char const *Asset_GetData(Asset const *self)
{
	return self->data;
}

int Asset_GetDataLength(Asset const *self)
{
	return self->dataLength;
}

const char *Asset_GetMd5(Asset const *self)
{
	return self->md5;
}

const char *Asset_GetName(Asset const *self)
{
	return self->name;
}

void Asset_SetData(Asset *self, unsigned char const *value)
{
	self->data = value;
}

void Asset_SetDataLength(Asset *self, int value)
{
	self->dataLength = value;
}

void Asset_SetMd5(Asset *self, const char *value)
{
	self->md5 = value;
}

void Asset_SetName(Asset *self, const char *value)
{
	self->name = value;
}

AssetList *AssetList_New(void)
{
	AssetList *self = (AssetList *) malloc(sizeof(AssetList));
	return self;
}

void AssetList_Delete(AssetList *self)
{
	free(self);
}

int AssetList_GetCount(AssetList const *self)
{
	return self->count;
}

Asset const *const *AssetList_GetItems(AssetList const *self)
{
	return self->items;
}

void AssetList_SetCount(AssetList *self, int value)
{
	self->count = value;
}

void AssetList_SetItems(AssetList *self, Asset const **value)
{
	self->items = value;
}

static void AudioControl_Construct(AudioControl *self)
{
	self->soundsCount = 0;
	self->sounds = (Sound_ const **) malloc(64 * sizeof(Sound_ const *));
	{
		int i;
		for (i = 0; i < 64; i++) {
			self->sounds[i] = NULL;
		}
	}
}

AudioControl *AudioControl_New(void)
{
	AudioControl *self = (AudioControl *) malloc(sizeof(AudioControl));
	if (self != NULL)
		AudioControl_Construct(self);
	return self;
}

void AudioControl_Delete(AudioControl *self)
{
	free(self);
}

void AudioControl_Add(AudioControl *self, Sound_ *s)
{
	{
		int i;
		for (i = 0; i < self->soundsCount; i++) {
			if (self->sounds[i] == NULL) {
				self->sounds[i] = s;
				return;
			}
		}
	}
	if (self->soundsCount < 64) {
		self->sounds[self->soundsCount++] = s;
	}
}

void AudioControl_Clear(AudioControl *self)
{
	{
		int i;
		for (i = 0; i < self->soundsCount; i++) {
			self->sounds[i] = NULL;
		}
	}
	self->soundsCount = 0;
}

void AudioControl_StopAll(AudioControl const *self)
{
	{
		int i;
		for (i = 0; i < self->soundsCount; i++) {
			if (self->sounds[i] == NULL) {
				continue;
			}
			self->sounds[i]->stop = TRUE;
		}
	}
}

static void AviWriterCi_Construct(AviWriterCi *self, const AviWriterCiVtbl *vtbl)
{
	self->vtbl = vtbl;
}

static void BackgroundAction_Construct(BackgroundAction *self, const Action_Vtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_BackgroundAction;
	Action__Construct(&self->base, vtbl);
	self->game = NULL;
	self->i = -1;
	self->dt = 1;
	self->active = FALSE;
	self->finished = FALSE;
}

BackgroundAction *BackgroundAction_New(void)
{
	BackgroundAction *self = (BackgroundAction *) malloc(sizeof(BackgroundAction));
	if (self != NULL)
		BackgroundAction_Construct(self, NULL);
	return self;
}

void BackgroundAction_Delete(BackgroundAction *self)
{
	free(self);
}

void BackgroundAction_Run(BackgroundAction *self)
{
	self->game->clientmods[self->i]->vtbl->onReadOnlyBackgroundThread(self->game->clientmods[self->i], self->game, self->dt);
	self->finished = TRUE;
}

cibool BitTools_IsPowerOfTwo(int x)
{
	return x == 1 || x == 2 || x == 4 || x == 8 || x == 16 || x == 32 || x == 64 || x == 128 || x == 256 || x == 512 || x == 1024 || x == 2048 || x == 4096 || x == 8192 || x == 16384 || x == 32768 || x == 65536 || x == 131072 || x == 262144 || x == 524288 || x == 1048576 || x == 2097152 || x == 4194304 || x == 8388608 || x == 16777216 || x == 33554432 || x == 67108864 || x == 134217728 || x == 268435456 || x == 536870912 || x == 1073741824;
}

int BitTools_NextPowerOfTwo(int x)
{
	x--;
	x |= x >> 1;
	x |= x >> 2;
	x |= x >> 4;
	x |= x >> 8;
	x |= x >> 16;
	x++;
	return x;
}

static void BitmapCi_Construct(BitmapCi *self, const BitmapCiVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_BitmapCi;
	self->vtbl = vtbl;
}

BitmapCi *BitmapCi_New(void)
{
	BitmapCi *self = (BitmapCi *) malloc(sizeof(BitmapCi));
	if (self != NULL)
		BitmapCi_Construct(self, NULL);
	return self;
}

void BitmapCi_Delete(BitmapCi *self)
{
	free(self);
}

void BitmapCi_Dispose(BitmapCi const *self)
{
}

BitmapData_ *BitmapData__New(void)
{
	BitmapData_ *self = (BitmapData_ *) malloc(sizeof(BitmapData_));
	return self;
}

void BitmapData__Delete(BitmapData_ *self)
{
	free(self);
}

BitmapData_ const *BitmapData__Create(int width, int height)
{
	BitmapData_ *b = BitmapData__New();
	b->width = width;
	b->height = height;
	b->argb = (int *) malloc(width * height * sizeof(int ));
	return b;
}

BitmapData_ const *BitmapData__CreateFromBitmap(GamePlatform const *p, BitmapCi const *atlas2d_)
{
	BitmapData_ *b = BitmapData__New();
	b->width = p->vtbl->floatToInt(p, p->vtbl->bitmapGetWidth(p, atlas2d_));
	b->height = p->vtbl->floatToInt(p, p->vtbl->bitmapGetHeight(p, atlas2d_));
	b->argb = (int *) malloc(b->width * b->height * sizeof(int ));
	p->vtbl->bitmapGetPixelsArgb(p, atlas2d_, b->argb);
	return b;
}

int BitmapData__GetPixel(BitmapData_ const *self, int x, int y)
{
	return self->argb[x + y * self->width];
}

void BitmapData__SetPixel(BitmapData_ const *self, int x, int y, int color)
{
	self->argb[x + y * self->width] = color;
}

BitmapCi const *BitmapData__ToBitmap(BitmapData_ const *self, GamePlatform const *p)
{
	BitmapCi const *bmp = p->vtbl->bitmapCreate(p, self->width, self->height);
	p->vtbl->bitmapSetPixelsArgb(p, bmp, self->argb);
	return bmp;
}

static void BlockOctreeSearcher_Construct(BlockOctreeSearcher *self)
{
	self->intersection = Intersection_New();
	self->pool = (Box3D const **) malloc(10000 * sizeof(Box3D const *));
	{
		int i;
		for (i = 0; i < 10000; i++) {
			self->pool[i] = Box3D_New();
		}
	}
	self->listpool = (ListBox3d const **) malloc(50 * sizeof(ListBox3d const *));
	{
		int i;
		for (i = 0; i < 50; i++) {
			self->listpool[i] = ListBox3d_New();
			self->listpool[i]->arr = (Box3D const **) malloc(1000 * sizeof(Box3D const *));
		}
	}
	self->l = (BlockPosSide const **) malloc(1024 * sizeof(BlockPosSide const *));
	self->lCount = 0;
	self->currentHit = (float *) malloc(3 * sizeof(float ));
}

BlockOctreeSearcher *BlockOctreeSearcher_New(void)
{
	BlockOctreeSearcher *self = (BlockOctreeSearcher *) malloc(sizeof(BlockOctreeSearcher));
	if (self != NULL)
		BlockOctreeSearcher_Construct(self);
	return self;
}

void BlockOctreeSearcher_Delete(BlockOctreeSearcher *self)
{
	free(self);
}

cibool BlockOctreeSearcher_BoxHit(BlockOctreeSearcher const *self, Box3D const *box)
{
	self->currentHit[0] = 0;
	self->currentHit[1] = 0;
	self->currentHit[2] = 0;
	return Intersection_CheckLineBox(box, self->currentLine, self->currentHit);
}

static ListBox3d *BlockOctreeSearcher_Children(BlockOctreeSearcher *self, Box3D const *box)
{
	ListBox3d *l = BlockOctreeSearcher_newListBox3d(self);
	Box3D **c;
	float x;
	float y;
	float z;
	float size;
	l->count = 8;
	c = l->arr;
	{
		int i;
		for (i = 0; i < 8; i++) {
			c[i] = BlockOctreeSearcher_newBox3d(self);
		}
	}
	x = box->minEdge[0];
	y = box->minEdge[1];
	z = box->minEdge[2];
	size = Box3D_LengthX(box) / 2;
	Box3D_Set(c[0], x, y, z, size);
	Box3D_Set(c[1], x + size, y, z, size);
	Box3D_Set(c[2], x, y, z + size, size);
	Box3D_Set(c[3], x + size, y, z + size, size);
	Box3D_Set(c[4], x, y + size, z, size);
	Box3D_Set(c[5], x + size, y + size, z, size);
	Box3D_Set(c[6], x, y + size, z + size, size);
	Box3D_Set(c[7], x + size, y + size, z + size, size);
	return l;
}

BlockPosSide const **BlockOctreeSearcher_LineIntersection(BlockOctreeSearcher *self, DelegateIsBlockEmpty const *isEmpty, DelegateGetBlockHeight const *getBlockHeight, Line3D const *line, IntRef *retCount)
{
	ListBox3d const *l1;
	BlockPosSide const **ll;
	self->lCount = 0;
	self->currentLine = line;
	self->currentHit[0] = 0;
	self->currentHit[1] = 0;
	self->currentHit[2] = 0;
	l1 = BlockOctreeSearcher_Search(self, &PredicateBox3DHit_Create(self)->base);
	{
		int i;
		for (i = 0; i < l1->count; i++) {
			Box3D const *node = l1->arr[i];
			float const *hit = self->currentHit;
			float x = node->minEdge[0];
			float y = node->minEdge[2];
			float z = node->minEdge[1];
			if (!isEmpty->vtbl->isBlockEmpty(isEmpty, self->platform->vtbl->floatToInt(self->platform, x), self->platform->vtbl->floatToInt(self->platform, y), self->platform->vtbl->floatToInt(self->platform, z))) {
				Box3D *node2 = Box3D_New();
				BlockPosSide *b;
				float *hit2;
				float *dir;
				cibool ishit;
				node2->minEdge = Vec3_CloneIt(node->minEdge);
				node2->maxEdge = Vec3_CloneIt(node->maxEdge);
				node2->maxEdge[1] = node2->minEdge[1] + getBlockHeight->vtbl->getBlockHeight(getBlockHeight, self->platform->vtbl->floatToInt(self->platform, x), self->platform->vtbl->floatToInt(self->platform, y), self->platform->vtbl->floatToInt(self->platform, z));
				b = BlockPosSide_New();
				hit2 = (float *) malloc(3 * sizeof(float ));
				dir = (float *) malloc(3 * sizeof(float ));
				dir[0] = line->end[0] - line->start[0];
				dir[1] = line->end[1] - line->start[1];
				dir[2] = line->end[2] - line->start[2];
				ishit = Intersection_HitBoundingBox(node2->minEdge, node2->maxEdge, line->start, dir, hit2);
				if (ishit) {
					b->blockPos = Vec3_FromValues(self->platform->vtbl->floatToInt(self->platform, x), self->platform->vtbl->floatToInt(self->platform, z), self->platform->vtbl->floatToInt(self->platform, y));
					b->collisionPos = hit2;
					self->l[self->lCount++] = b;
				}
			}
		}
	}
	ll = (BlockPosSide const **) malloc(self->lCount * sizeof(BlockPosSide const *));
	{
		int i;
		for (i = 0; i < self->lCount; i++) {
			ll[i] = self->l[i];
		}
	}
	retCount->value = self->lCount;
	return ll;
}

static ListBox3d const *BlockOctreeSearcher_Search(BlockOctreeSearcher *self, PredicateBox3D const *query)
{
	self->pool_i = 0;
	self->listpool_i = 0;
	if (Box3D_LengthX(self->startBox) == 0 && Box3D_LengthY(self->startBox) == 0 && Box3D_LengthZ(self->startBox) == 0) {
		return ListBox3d_New();
	}
	return BlockOctreeSearcher_SearchPrivate(self, query, self->startBox);
}

static ListBox3d *BlockOctreeSearcher_SearchPrivate(BlockOctreeSearcher *self, PredicateBox3D const *query, Box3D const *box)
{
	ListBox3d *l;
	ListBox3d *children;
	if (Box3D_LengthX(box) == 1) {
		ListBox3d *l1 = BlockOctreeSearcher_newListBox3d(self);
		l1->count = 1;
		l1->arr[0] = box;
		return l1;
	}
	l = BlockOctreeSearcher_newListBox3d(self);
	l->count = 0;
	children = BlockOctreeSearcher_Children(self, box);
	{
		int k;
		for (k = 0; k < children->count; k++) {
			Box3D const *child = children->arr[k];
			if (query->vtbl->hit(query, child)) {
				ListBox3d *l2 = BlockOctreeSearcher_SearchPrivate(self, query, child);
				{
					int i;
					for (i = 0; i < l2->count; i++) {
						Box3D const *n = l2->arr[i];
						l->arr[l->count++] = n;
					}
				}
				BlockOctreeSearcher_recycleListBox3d(self, l2);
			}
		}
	}
	BlockOctreeSearcher_recycleListBox3d(self, children);
	return l;
}

static Box3D *BlockOctreeSearcher_newBox3d(BlockOctreeSearcher *self)
{
	return self->pool[self->pool_i++];
}

static ListBox3d *BlockOctreeSearcher_newListBox3d(BlockOctreeSearcher *self)
{
	ListBox3d *l = self->listpool[self->listpool_i++];
	l->count = 0;
	return l;
}

static void BlockOctreeSearcher_recycleListBox3d(BlockOctreeSearcher *self, ListBox3d *l)
{
	self->listpool_i--;
	self->listpool[self->listpool_i] = l;
}

static void BlockPosSide_Construct(BlockPosSide *self)
{
}

BlockPosSide *BlockPosSide_New(void)
{
	BlockPosSide *self = (BlockPosSide *) malloc(sizeof(BlockPosSide));
	if (self != NULL)
		BlockPosSide_Construct(self);
	return self;
}

void BlockPosSide_Delete(BlockPosSide *self)
{
	free(self);
}

BlockPosSide const *BlockPosSide_Create(int x, int y, int z)
{
	BlockPosSide *p = BlockPosSide_New();
	p->blockPos = Vec3_FromValues(x, y, z);
	return p;
}

float const *BlockPosSide_Current(BlockPosSide const *self)
{
	return self->blockPos;
}

float const *BlockPosSide_Translated(BlockPosSide const *self)
{
	float *translated = (float *) malloc(3 * sizeof(float ));
	translated[0] = self->blockPos[0];
	translated[1] = self->blockPos[1];
	translated[2] = self->blockPos[2];
	if (self->collisionPos == NULL) {
		return translated;
	}
	if (self->collisionPos[0] == self->blockPos[0]) {
		translated[0] = translated[0] - 1;
	}
	if (self->collisionPos[1] == self->blockPos[1]) {
		translated[1] = translated[1] - 1;
	}
	if (self->collisionPos[2] == self->blockPos[2]) {
		translated[2] = translated[2] - 1;
	}
	if (self->collisionPos[0] == self->blockPos[0] + 1) {
		translated[0] = translated[0] + 1;
	}
	if (self->collisionPos[1] == self->blockPos[1] + 1) {
		translated[1] = translated[1] + 1;
	}
	if (self->collisionPos[2] == self->blockPos[2] + 1) {
		translated[2] = translated[2] + 1;
	}
	return translated;
}

BlockRendererTorch *BlockRendererTorch_New(void)
{
	BlockRendererTorch *self = (BlockRendererTorch *) malloc(sizeof(BlockRendererTorch));
	return self;
}

void BlockRendererTorch_Delete(BlockRendererTorch *self)
{
	free(self);
}

void BlockRendererTorch_AddTorch(BlockRendererTorch const *self, GameData const *d_Data, Game const *d_TerainRenderer, ModelData *m, int x, int y, int z, TorchType type)
{
	float one = 1;
	int curcolor = Game_ColorFromArgb(255, 255, 255, 255);
	float torchsizexy = one * 16 / 100;
	float topx = one / 2 - torchsizexy / 2;
	float topy = one / 2 - torchsizexy / 2;
	float bottomx = one / 2 - torchsizexy / 2;
	float bottomy = one / 2 - torchsizexy / 2;
	Vector3Ref *top00;
	Vector3Ref *top01;
	Vector3Ref *top10;
	Vector3Ref *top11;
	Vector3Ref const *bottom00;
	Vector3Ref const *bottom01;
	Vector3Ref const *bottom10;
	Vector3Ref const *bottom11;
	topx += x;
	topy += y;
	bottomx += x;
	bottomy += y;
	if (type == TorchType_FRONT) {
		bottomx = x - torchsizexy;
	}
	if (type == TorchType_BACK) {
		bottomx = x + 1;
	}
	if (type == TorchType_LEFT) {
		bottomy = y - torchsizexy;
	}
	if (type == TorchType_RIGHT) {
		bottomy = y + 1;
	}
	top00 = Vector3Ref_Create(topx, z + one * 9 / 10, topy);
	top01 = Vector3Ref_Create(topx, z + one * 9 / 10, topy + torchsizexy);
	top10 = Vector3Ref_Create(topx + torchsizexy, z + one * 9 / 10, topy);
	top11 = Vector3Ref_Create(topx + torchsizexy, z + one * 9 / 10, topy + torchsizexy);
	if (type == TorchType_LEFT) {
		top01->y += -(one * 1 / 10);
		top11->y += -(one * 1 / 10);
	}
	if (type == TorchType_RIGHT) {
		top10->y += -(one * 1 / 10);
		top00->y += -(one * 1 / 10);
	}
	if (type == TorchType_FRONT) {
		top10->y += -(one * 1 / 10);
		top11->y += -(one * 1 / 10);
	}
	if (type == TorchType_BACK) {
		top01->y += -(one * 1 / 10);
		top00->y += -(one * 1 / 10);
	}
	bottom00 = Vector3Ref_Create(bottomx, z + 0, bottomy);
	bottom01 = Vector3Ref_Create(bottomx, z + 0, bottomy + torchsizexy);
	bottom10 = Vector3Ref_Create(bottomx + torchsizexy, z + 0, bottomy);
	bottom11 = Vector3Ref_Create(bottomx + torchsizexy, z + 0, bottomy + torchsizexy);
	{
		int sidetexture = self->topTexture;
		RectFRef const *texrec = TextureAtlas_TextureCoords2d(sidetexture, Game_texturesPacked(d_TerainRenderer));
		int lastelement = ModelData_GetVerticesCount(m);
		BlockRendererTorch_AddVertex(self, m, top00->x, top00->y, top00->z, RectFRef_Left(texrec), RectFRef_Top(texrec), curcolor);
		BlockRendererTorch_AddVertex(self, m, top01->x, top01->y, top01->z, RectFRef_Left(texrec), RectFRef_Bottom(texrec), curcolor);
		BlockRendererTorch_AddVertex(self, m, top10->x, top10->y, top10->z, RectFRef_Right(texrec), RectFRef_Top(texrec), curcolor);
		BlockRendererTorch_AddVertex(self, m, top11->x, top11->y, top11->z, RectFRef_Right(texrec), RectFRef_Bottom(texrec), curcolor);
		m->indices[m->indicesCount++] = lastelement + 0;
		m->indices[m->indicesCount++] = lastelement + 1;
		m->indices[m->indicesCount++] = lastelement + 2;
		m->indices[m->indicesCount++] = lastelement + 1;
		m->indices[m->indicesCount++] = lastelement + 3;
		m->indices[m->indicesCount++] = lastelement + 2;
	}
	{
		int sidetexture = self->sideTexture;
		RectFRef const *texrec = TextureAtlas_TextureCoords2d(sidetexture, Game_texturesPacked(d_TerainRenderer));
		int lastelement = ModelData_GetVerticesCount(m);
		BlockRendererTorch_AddVertex(self, m, bottom00->x, bottom00->y, bottom00->z, RectFRef_Left(texrec), RectFRef_Top(texrec), curcolor);
		BlockRendererTorch_AddVertex(self, m, bottom01->x, bottom01->y, bottom01->z, RectFRef_Left(texrec), RectFRef_Bottom(texrec), curcolor);
		BlockRendererTorch_AddVertex(self, m, bottom10->x, bottom10->y, bottom10->z, RectFRef_Right(texrec), RectFRef_Top(texrec), curcolor);
		BlockRendererTorch_AddVertex(self, m, bottom11->x, bottom11->y, bottom11->z, RectFRef_Right(texrec), RectFRef_Bottom(texrec), curcolor);
		m->indices[m->indicesCount++] = lastelement + 1;
		m->indices[m->indicesCount++] = lastelement + 0;
		m->indices[m->indicesCount++] = lastelement + 2;
		m->indices[m->indicesCount++] = lastelement + 3;
		m->indices[m->indicesCount++] = lastelement + 1;
		m->indices[m->indicesCount++] = lastelement + 2;
	}
	{
		int sidetexture = self->sideTexture;
		RectFRef const *texrec = TextureAtlas_TextureCoords2d(sidetexture, Game_texturesPacked(d_TerainRenderer));
		int lastelement = ModelData_GetVerticesCount(m);
		BlockRendererTorch_AddVertex(self, m, bottom00->x, bottom00->y, bottom00->z, RectFRef_Left(texrec), RectFRef_Bottom(texrec), curcolor);
		BlockRendererTorch_AddVertex(self, m, bottom01->x, bottom01->y, bottom01->z, RectFRef_Right(texrec), RectFRef_Bottom(texrec), curcolor);
		BlockRendererTorch_AddVertex(self, m, top00->x, top00->y, top00->z, RectFRef_Left(texrec), RectFRef_Top(texrec), curcolor);
		BlockRendererTorch_AddVertex(self, m, top01->x, top01->y, top01->z, RectFRef_Right(texrec), RectFRef_Top(texrec), curcolor);
		m->indices[m->indicesCount++] = lastelement + 0;
		m->indices[m->indicesCount++] = lastelement + 1;
		m->indices[m->indicesCount++] = lastelement + 2;
		m->indices[m->indicesCount++] = lastelement + 1;
		m->indices[m->indicesCount++] = lastelement + 3;
		m->indices[m->indicesCount++] = lastelement + 2;
	}
	{
		int sidetexture = self->sideTexture;
		RectFRef const *texrec = TextureAtlas_TextureCoords2d(sidetexture, Game_texturesPacked(d_TerainRenderer));
		int lastelement = ModelData_GetVerticesCount(m);
		BlockRendererTorch_AddVertex(self, m, bottom10->x, bottom10->y, bottom10->z, RectFRef_Right(texrec), RectFRef_Bottom(texrec), curcolor);
		BlockRendererTorch_AddVertex(self, m, bottom11->x, bottom11->y, bottom11->z, RectFRef_Left(texrec), RectFRef_Bottom(texrec), curcolor);
		BlockRendererTorch_AddVertex(self, m, top10->x, top10->y, top10->z, RectFRef_Right(texrec), RectFRef_Top(texrec), curcolor);
		BlockRendererTorch_AddVertex(self, m, top11->x, top11->y, top11->z, RectFRef_Left(texrec), RectFRef_Top(texrec), curcolor);
		m->indices[m->indicesCount++] = lastelement + 1;
		m->indices[m->indicesCount++] = lastelement + 0;
		m->indices[m->indicesCount++] = lastelement + 2;
		m->indices[m->indicesCount++] = lastelement + 3;
		m->indices[m->indicesCount++] = lastelement + 1;
		m->indices[m->indicesCount++] = lastelement + 2;
	}
	{
		int sidetexture = self->sideTexture;
		RectFRef const *texrec = TextureAtlas_TextureCoords2d(sidetexture, Game_texturesPacked(d_TerainRenderer));
		int lastelement = ModelData_GetVerticesCount(m);
		BlockRendererTorch_AddVertex(self, m, bottom00->x, bottom00->y, bottom00->z, RectFRef_Right(texrec), RectFRef_Bottom(texrec), curcolor);
		BlockRendererTorch_AddVertex(self, m, top00->x, top00->y, top00->z, RectFRef_Right(texrec), RectFRef_Top(texrec), curcolor);
		BlockRendererTorch_AddVertex(self, m, bottom10->x, bottom10->y, bottom10->z, RectFRef_Left(texrec), RectFRef_Bottom(texrec), curcolor);
		BlockRendererTorch_AddVertex(self, m, top10->x, top10->y, top10->z, RectFRef_Left(texrec), RectFRef_Top(texrec), curcolor);
		m->indices[m->indicesCount++] = lastelement + 0;
		m->indices[m->indicesCount++] = lastelement + 1;
		m->indices[m->indicesCount++] = lastelement + 2;
		m->indices[m->indicesCount++] = lastelement + 1;
		m->indices[m->indicesCount++] = lastelement + 3;
		m->indices[m->indicesCount++] = lastelement + 2;
	}
	{
		int sidetexture = self->sideTexture;
		RectFRef const *texrec = TextureAtlas_TextureCoords2d(sidetexture, Game_texturesPacked(d_TerainRenderer));
		int lastelement = ModelData_GetVerticesCount(m);
		BlockRendererTorch_AddVertex(self, m, bottom01->x, bottom01->y, bottom01->z, RectFRef_Left(texrec), RectFRef_Bottom(texrec), curcolor);
		BlockRendererTorch_AddVertex(self, m, top01->x, top01->y, top01->z, RectFRef_Left(texrec), RectFRef_Top(texrec), curcolor);
		BlockRendererTorch_AddVertex(self, m, bottom11->x, bottom11->y, bottom11->z, RectFRef_Right(texrec), RectFRef_Bottom(texrec), curcolor);
		BlockRendererTorch_AddVertex(self, m, top11->x, top11->y, top11->z, RectFRef_Right(texrec), RectFRef_Top(texrec), curcolor);
		m->indices[m->indicesCount++] = lastelement + 1;
		m->indices[m->indicesCount++] = lastelement + 0;
		m->indices[m->indicesCount++] = lastelement + 2;
		m->indices[m->indicesCount++] = lastelement + 3;
		m->indices[m->indicesCount++] = lastelement + 1;
		m->indices[m->indicesCount++] = lastelement + 2;
	}
}

void BlockRendererTorch_AddVertex(BlockRendererTorch const *self, ModelData *model, float x, float y, float z, float u, float v, int color)
{
	model->xyz[ModelData_GetXyzCount(model) + 0] = x;
	model->xyz[ModelData_GetXyzCount(model) + 1] = y;
	model->xyz[ModelData_GetXyzCount(model) + 2] = z;
	model->uv[ModelData_GetUvCount(model) + 0] = u;
	model->uv[ModelData_GetUvCount(model) + 1] = v;
	model->rgba[ModelData_GetRgbaCount(model) + 0] = Game_IntToByte(Game_ColorR(color));
	model->rgba[ModelData_GetRgbaCount(model) + 1] = Game_IntToByte(Game_ColorG(color));
	model->rgba[ModelData_GetRgbaCount(model) + 2] = Game_IntToByte(Game_ColorB(color));
	model->rgba[ModelData_GetRgbaCount(model) + 3] = Game_IntToByte(Game_ColorA(color));
	model->verticesCount++;
}

static void BlockTypeSimple_Construct(BlockTypeSimple *self)
{
	self->block = Packet_BlockType_New();
}

BlockTypeSimple *BlockTypeSimple_New(void)
{
	BlockTypeSimple *self = (BlockTypeSimple *) malloc(sizeof(BlockTypeSimple));
	if (self != NULL)
		BlockTypeSimple_Construct(self);
	return self;
}

void BlockTypeSimple_Delete(BlockTypeSimple *self)
{
	free(self);
}

void BlockTypeSimple_SetAllTextures(BlockTypeSimple const *self, const char *texture)
{
	self->block->textureIdTop = texture;
	self->block->textureIdBottom = texture;
	self->block->textureIdFront = texture;
	self->block->textureIdBack = texture;
	self->block->textureIdLeft = texture;
	self->block->textureIdRight = texture;
	self->block->textureIdForInventory = texture;
}

void BlockTypeSimple_SetDrawType(BlockTypeSimple const *self, int p)
{
	self->block->drawType = p;
}

void BlockTypeSimple_SetName(BlockTypeSimple const *self, const char *name)
{
	self->block->name = name;
}

void BlockTypeSimple_SetTextureBack(BlockTypeSimple const *self, const char *p)
{
	self->block->textureIdBack = p;
}

void BlockTypeSimple_SetTextureBottom(BlockTypeSimple const *self, const char *p)
{
	self->block->textureIdBottom = p;
}

void BlockTypeSimple_SetTextureFront(BlockTypeSimple const *self, const char *p)
{
	self->block->textureIdFront = p;
}

void BlockTypeSimple_SetTextureLeft(BlockTypeSimple const *self, const char *p)
{
	self->block->textureIdLeft = p;
}

void BlockTypeSimple_SetTextureRight(BlockTypeSimple const *self, const char *p)
{
	self->block->textureIdRight = p;
}

void BlockTypeSimple_SetTextureTop(BlockTypeSimple const *self, const char *p)
{
	self->block->textureIdTop = p;
}

void BlockTypeSimple_SetWalkableType(BlockTypeSimple const *self, int p)
{
	self->block->walkableType = p;
}

BoolRef *BoolRef_New(void)
{
	BoolRef *self = (BoolRef *) malloc(sizeof(BoolRef));
	return self;
}

void BoolRef_Delete(BoolRef *self)
{
	free(self);
}

cibool BoolRef_GetValue(BoolRef const *self)
{
	return self->value;
}

void BoolRef_SetValue(BoolRef *self, cibool value_)
{
	self->value = value_;
}

Box3D *Box3D_New(void)
{
	Box3D *self = (Box3D *) malloc(sizeof(Box3D));
	return self;
}

void Box3D_Delete(Box3D *self)
{
	free(self);
}

void Box3D_AddPoint(Box3D *self, float x, float y, float z)
{
	if (self->minEdge == NULL || self->maxEdge == NULL || (self->minEdge[0] == 0 && self->minEdge[1] == 0 && self->minEdge[2] == 0 && self->maxEdge[0] == 0 && self->maxEdge[1] == 0 && self->maxEdge[2] == 0)) {
		self->minEdge = Vec3_FromValues(x, y, z);
		self->maxEdge = Vec3_FromValues(x, y, z);
	}
	self->minEdge[0] = MathCi_MinFloat(self->minEdge[0], x);
	self->minEdge[1] = MathCi_MinFloat(self->minEdge[1], y);
	self->minEdge[2] = MathCi_MinFloat(self->minEdge[2], z);
	self->maxEdge[0] = MathCi_MaxFloat(self->maxEdge[0], x);
	self->maxEdge[1] = MathCi_MaxFloat(self->maxEdge[1], y);
	self->maxEdge[2] = MathCi_MaxFloat(self->maxEdge[2], z);
}

float const *Box3D_Center(Box3D const *self)
{
	return NULL;
}

static Box3D const *Box3D_Create(int x, int y, int z, int size)
{
	Box3D *b = Box3D_New();
	Box3D_Set(b, x, y, z, size);
	return b;
}

float Box3D_LengthX(Box3D const *self)
{
	return self->maxEdge[0] - self->minEdge[0];
}

float Box3D_LengthY(Box3D const *self)
{
	return self->maxEdge[1] - self->minEdge[1];
}

float Box3D_LengthZ(Box3D const *self)
{
	return self->maxEdge[2] - self->minEdge[2];
}

void Box3D_Set(Box3D *self, float x, float y, float z, float size)
{
	if (self->minEdge == NULL) {
		self->minEdge = (float *) malloc(3 * sizeof(float ));
		self->maxEdge = (float *) malloc(3 * sizeof(float ));
	}
	self->minEdge[0] = x;
	self->minEdge[1] = y;
	self->minEdge[2] = z;
	self->maxEdge[0] = x + size;
	self->maxEdge[1] = y + size;
	self->maxEdge[2] = z + size;
}

Bullet_ *Bullet__New(void)
{
	Bullet_ *self = (Bullet_ *) malloc(sizeof(Bullet_));
	return self;
}

void Bullet__Delete(Bullet_ *self)
{
	free(self);
}

static void Button_Construct(Button *self)
{
	self->fontcolor = Game_ColorFromArgb(255, 255, 255, 255);
	self->fontcolorselected = Game_ColorFromArgb(255, 255, 0, 0);
	self->fontsize = 20;
}

Button *Button_New(void)
{
	Button *self = (Button *) malloc(sizeof(Button));
	if (self != NULL)
		Button_Construct(self);
	return self;
}

void Button_Delete(Button *self)
{
	free(self);
}

ByteArray *ByteArray_New(void)
{
	ByteArray *self = (ByteArray *) malloc(sizeof(ByteArray));
	return self;
}

void ByteArray_Delete(ByteArray *self)
{
	free(self);
}

CachedTextTexture *CachedTextTexture_New(void)
{
	CachedTextTexture *self = (CachedTextTexture *) malloc(sizeof(CachedTextTexture));
	return self;
}

void CachedTextTexture_Delete(CachedTextTexture *self)
{
	free(self);
}

CachedTexture *CachedTexture_New(void)
{
	CachedTexture *self = (CachedTexture *) malloc(sizeof(CachedTexture));
	return self;
}

void CachedTexture_Delete(CachedTexture *self)
{
	free(self);
}

CameraMove *CameraMove_New(void)
{
	CameraMove *self = (CameraMove *) malloc(sizeof(CameraMove));
	return self;
}

void CameraMove_Delete(CameraMove *self)
{
	free(self);
}

CameraPoint *CameraPoint_New(void)
{
	CameraPoint *self = (CameraPoint *) malloc(sizeof(CameraPoint));
	return self;
}

void CameraPoint_Delete(CameraPoint *self)
{
	free(self);
}

Chatline *Chatline_New(void)
{
	Chatline *self = (Chatline *) malloc(sizeof(Chatline));
	return self;
}

void Chatline_Delete(Chatline *self)
{
	free(self);
}

static Chatline const *Chatline_Create(const char *text_, int timeMilliseconds_)
{
	Chatline *c = Chatline_New();
	c->text = text_;
	c->timeMilliseconds = timeMilliseconds_;
	c->clickable = FALSE;
	return c;
}

static Chatline const *Chatline_CreateClickable(const char *text_, int timeMilliseconds_, const char *linkTarget_)
{
	Chatline *c = Chatline_New();
	c->text = text_;
	c->timeMilliseconds = timeMilliseconds_;
	c->clickable = TRUE;
	c->linkTarget = linkTarget_;
	return c;
}

static void Chunk_Construct(Chunk *self)
{
	self->baseLightDirty = TRUE;
}

Chunk *Chunk_New(void)
{
	Chunk *self = (Chunk *) malloc(sizeof(Chunk));
	if (self != NULL)
		Chunk_Construct(self);
	return self;
}

void Chunk_Delete(Chunk *self)
{
	free(self);
}

cibool Chunk_ChunkHasData(Chunk const *self)
{
	return self->data != NULL || self->dataInt != NULL;
}

int Chunk_GetBlockInChunk(Chunk const *self, int pos)
{
	if (self->dataInt != NULL) {
		return self->dataInt[pos];
	}
	else {
		return self->data[pos];
	}
}

void Chunk_SetBlockInChunk(Chunk *self, int pos, int block)
{
	if (self->dataInt == NULL) {
		if (block < 255) {
			self->data[pos] = Game_IntToByte(block);
		}
		else {
			int n = 4096;
			self->dataInt = (int *) malloc(n * sizeof(int ));
			{
				int i;
				for (i = 0; i < n; i++) {
					self->dataInt[i] = self->data[i];
				}
			}
			self->data = NULL;
			self->dataInt[pos] = block;
		}
	}
	else {
		self->dataInt[pos] = block;
	}
}

ChunkSimple *ChunkSimple_New(void)
{
	ChunkSimple *self = (ChunkSimple *) malloc(sizeof(ChunkSimple));
	return self;
}

void ChunkSimple_Delete(ChunkSimple *self)
{
	free(self);
}

static void CitoMemoryStream_Construct(CitoMemoryStream *self, const CitoStreamVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_CitoMemoryStream;
	CitoStream_Construct(&self->base, vtbl);
	self->buffer_ = (unsigned char *) malloc(1 * sizeof(unsigned char ));
	self->count_ = 0;
	self->bufferlength = 1;
	self->position_ = 0;
}

CitoMemoryStream *CitoMemoryStream_New(void)
{
	CitoMemoryStream *self = (CitoMemoryStream *) malloc(sizeof(CitoMemoryStream));
	if (self != NULL)
		CitoMemoryStream_Construct(self, NULL);
	return self;
}

void CitoMemoryStream_Delete(CitoMemoryStream *self)
{
	free(self);
}

cibool CitoMemoryStream_CanSeek(CitoMemoryStream const *self)
{
	return FALSE;
}

CitoMemoryStream const *CitoMemoryStream_Create(unsigned char *buffer, int length)
{
	CitoMemoryStream *m = CitoMemoryStream_New();
	m->buffer_ = buffer;
	m->count_ = length;
	m->bufferlength = length;
	m->position_ = 0;
	return m;
}

unsigned char const *CitoMemoryStream_GetBuffer(CitoMemoryStream const *self)
{
	return self->buffer_;
}

int CitoMemoryStream_Length(CitoMemoryStream const *self)
{
	return self->count_;
}

int CitoMemoryStream_Position(CitoMemoryStream const *self)
{
	return self->position_;
}

int CitoMemoryStream_Read(CitoMemoryStream *self, unsigned char *buffer, int offset, int count)
{
	{
		int i;
		for (i = 0; i < count; i++) {
			if (self->position_ + i >= self->count_) {
				self->position_ += i;
				return i;
			}
			buffer[offset + i] = self->buffer_[self->position_ + i];
		}
	}
	self->position_ += count;
	return count;
}

int CitoMemoryStream_ReadByte(CitoMemoryStream *self)
{
	if (self->position_ >= self->count_) {
		return -1;
	}
	return self->buffer_[self->position_++];
}

void CitoMemoryStream_Seek(CitoMemoryStream *self, int length, CitoSeekOrigin seekOrigin)
{
	switch (seekOrigin) {
	case CitoSeekOrigin_CURRENT:
		self->position_ += length;
		break;
	}
}

void CitoMemoryStream_Seek_(CitoMemoryStream const *self, int p, CitoSeekOrigin seekOrigin)
{
}

unsigned char const *CitoMemoryStream_ToArray(CitoMemoryStream const *self)
{
	return self->buffer_;
}

void CitoMemoryStream_Write(CitoMemoryStream *self, unsigned char const *buffer, int offset, int count)
{
	{
		int i;
		for (i = 0; i < count; i++) {
			self->base.vtbl->writeByte(&self->base, buffer[offset + i]);
		}
	}
}

void CitoMemoryStream_WriteByte(CitoMemoryStream *self, unsigned char p)
{
	if (self->position_ >= self->bufferlength) {
		unsigned char *buffer2 = (unsigned char *) malloc(self->bufferlength * 2 * sizeof(unsigned char ));
		{
			int i;
			for (i = 0; i < self->bufferlength; i++) {
				buffer2[i] = self->buffer_[i];
			}
		}
		self->buffer_ = buffer2;
		self->bufferlength = self->bufferlength * 2;
	}
	self->buffer_[self->position_] = p;
	if (self->position_ == self->count_) {
		self->count_++;
	}
	self->position_++;
}

static void CitoStream_Construct(CitoStream *self, const CitoStreamVtbl *vtbl)
{
	self->vtbl = vtbl;
}

ClientCommandArgs *ClientCommandArgs_New(void)
{
	ClientCommandArgs *self = (ClientCommandArgs *) malloc(sizeof(ClientCommandArgs));
	return self;
}

void ClientCommandArgs_Delete(ClientCommandArgs *self)
{
	free(self);
}

static void ClientInventoryController_Construct(ClientInventoryController *self, const IInventoryControllerVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ClientInventoryController;
	IInventoryController_Construct(&self->base, vtbl);
}

ClientInventoryController *ClientInventoryController_New(void)
{
	ClientInventoryController *self = (ClientInventoryController *) malloc(sizeof(ClientInventoryController));
	if (self != NULL)
		ClientInventoryController_Construct(self, NULL);
	return self;
}

void ClientInventoryController_Delete(ClientInventoryController *self)
{
	free(self);
}

ClientInventoryController const *ClientInventoryController_Create(Game const *game)
{
	ClientInventoryController *c = ClientInventoryController_New();
	c->g = game;
	return c;
}

void ClientInventoryController_InventoryClick(ClientInventoryController const *self, Packet_InventoryPosition *pos)
{
	Game_InventoryClick(self->g, pos);
}

void ClientInventoryController_MoveToInventory(ClientInventoryController const *self, Packet_InventoryPosition *from)
{
	Game_MoveToInventory(self->g, from);
}

void ClientInventoryController_WearItem(ClientInventoryController const *self, Packet_InventoryPosition *from, Packet_InventoryPosition *to)
{
	Game_WearItem(self->g, from, to);
}

static void ClientMod_Construct(ClientMod *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ClientMod;
	self->vtbl = vtbl;
}

void ClientMod_Dispose(ClientMod const *self, Game const *game)
{
}

void ClientMod_OnBeforeNewFrameDraw3d(ClientMod const *self, Game const *game, float deltaTime)
{
}

cibool ClientMod_OnClientCommand(ClientMod const *self, Game const *game, ClientCommandArgs const *args)
{
	return FALSE;
}

void ClientMod_OnHitEntity(ClientMod const *self, Game const *game, OnUseEntityArgs const *e)
{
}

void ClientMod_OnKeyDown(ClientMod const *self, Game const *game, KeyEventArgs const *args)
{
}

void ClientMod_OnKeyPress(ClientMod const *self, Game const *game, KeyPressEventArgs const *args)
{
}

void ClientMod_OnKeyUp(ClientMod const *self, Game const *game, KeyEventArgs const *args)
{
}

void ClientMod_OnMouseDown(ClientMod const *self, Game const *game, MouseEventArgs const *args)
{
}

void ClientMod_OnMouseMove(ClientMod const *self, Game const *game, MouseEventArgs const *args)
{
}

void ClientMod_OnMouseUp(ClientMod const *self, Game const *game, MouseEventArgs const *args)
{
}

void ClientMod_OnMouseWheelChanged(ClientMod const *self, Game const *game, MouseWheelEventArgs const *args)
{
}

void ClientMod_OnNewFrame(ClientMod const *self, Game const *game, NewFrameEventArgs const *args)
{
}

void ClientMod_OnNewFrameDraw2d(ClientMod const *self, Game const *game, float deltaTime)
{
}

void ClientMod_OnNewFrameDraw3d(ClientMod const *self, Game const *game, float deltaTime)
{
}

void ClientMod_OnNewFrameFixed(ClientMod const *self, Game const *game, NewFrameEventArgs const *args)
{
}

void ClientMod_OnNewFrameReadOnlyMainThread(ClientMod const *self, Game const *game, float deltaTime)
{
}

void ClientMod_OnReadOnlyBackgroundThread(ClientMod const *self, Game const *game, float dt)
{
}

void ClientMod_OnReadOnlyMainThread(ClientMod const *self, Game const *game, float dt)
{
}

void ClientMod_OnReadWriteMainThread(ClientMod const *self, Game const *game, float dt)
{
}

void ClientMod_OnTouchEnd(ClientMod const *self, Game const *game, TouchEventArgs const *e)
{
}

void ClientMod_OnTouchMove(ClientMod const *self, Game const *game, TouchEventArgs const *e)
{
}

void ClientMod_OnTouchStart(ClientMod const *self, Game const *game, TouchEventArgs const *e)
{
}

void ClientMod_OnUseEntity(ClientMod const *self, Game const *game, OnUseEntityArgs const *e)
{
}

void ClientMod_Start(ClientMod const *self, ClientModManager const *modmanager)
{
}

static void ClientModManager_Construct(ClientModManager *self, const ClientModManagerVtbl *vtbl)
{
	self->vtbl = vtbl;
}

static void ClientModManager1_Construct(ClientModManager1 *self, const ClientModManagerVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ClientModManager1;
	ClientModManager_Construct(&self->base, vtbl);
}

ClientModManager1 *ClientModManager1_New(void)
{
	ClientModManager1 *self = (ClientModManager1 *) malloc(sizeof(ClientModManager1));
	if (self != NULL)
		ClientModManager1_Construct(self, NULL);
	return self;
}

void ClientModManager1_Delete(ClientModManager1 *self)
{
	free(self);
}

AviWriterCi const *ClientModManager1_AviWriterCreate(ClientModManager1 const *self)
{
	return self->game->platform->vtbl->aviWriterCreate(self->game->platform);
}

void ClientModManager1_DisplayNotification(ClientModManager1 const *self, const char *message)
{
	Game_AddChatline(self->game, message);
}

void ClientModManager1_Draw2dText(ClientModManager1 const *self, const char *text, float x, float y, float fontsize)
{
	FontCi *font = FontCi_New();
	font->family = "Arial";
	font->size = fontsize;
	Game_Draw2dText(self->game, text, font, x, y, NULL, FALSE);
}

void ClientModManager1_Draw2dTexture(ClientModManager1 const *self, int textureid, float x1, float y1, float width, float height, IntRef const *inAtlasId, int color)
{
	int a = Game_ColorA(color);
	int r = Game_ColorR(color);
	int g = Game_ColorG(color);
	int b = Game_ColorB(color);
	Game_Draw2dTexture(self->game, textureid, self->game->platform->vtbl->floatToInt(self->game->platform, x1), self->game->platform->vtbl->floatToInt(self->game->platform, y1), self->game->platform->vtbl->floatToInt(self->game->platform, width), self->game->platform->vtbl->floatToInt(self->game->platform, height), inAtlasId, 0, Game_ColorFromArgb(a, r, g, b), FALSE);
}

void ClientModManager1_Draw2dTextures(ClientModManager1 const *self, Draw2dData const *const *todraw, int todrawLength, int textureId)
{
	Game_Draw2dTextures(self->game, todraw, todrawLength, textureId);
}

void ClientModManager1_EnableCameraControl(ClientModManager1 const *self, cibool enable)
{
	self->game->enableCameraControl = enable;
}

int ClientModManager1_GetFreemove(ClientModManager1 const *self)
{
	return Controls_GetFreemove(self->game->controls);
}

float ClientModManager1_GetLocalOrientationX(ClientModManager1 const *self)
{
	return self->game->player->position->rotx;
}

float ClientModManager1_GetLocalOrientationY(ClientModManager1 const *self)
{
	return self->game->player->position->roty;
}

float ClientModManager1_GetLocalOrientationZ(ClientModManager1 const *self)
{
	return self->game->player->position->rotz;
}

float ClientModManager1_GetLocalPositionX(ClientModManager1 const *self)
{
	return self->game->player->position->x;
}

float ClientModManager1_GetLocalPositionY(ClientModManager1 const *self)
{
	return self->game->player->position->y;
}

float ClientModManager1_GetLocalPositionZ(ClientModManager1 const *self)
{
	return self->game->player->position->z;
}

DictionaryStringString const *ClientModManager1_GetPerformanceInfo(ClientModManager1 const *self)
{
	return self->game->performanceinfo;
}

GamePlatform const *ClientModManager1_GetPlatform(ClientModManager1 const *self)
{
	return self->game->platform;
}

int ClientModManager1_GetWindowHeight(ClientModManager1 const *self)
{
	return self->game->platform->vtbl->getCanvasHeight(self->game->platform);
}

int ClientModManager1_GetWindowWidth(ClientModManager1 const *self)
{
	return self->game->platform->vtbl->getCanvasWidth(self->game->platform);
}

BitmapCi const *ClientModManager1_GrabScreenshot(ClientModManager1 const *self)
{
	return self->game->platform->vtbl->grabScreenshot(self->game->platform);
}

cibool ClientModManager1_IsFreemoveAllowed(ClientModManager1 const *self)
{
	return self->game->allowFreemove;
}

void ClientModManager1_MakeScreenshot(ClientModManager1 const *self)
{
	self->game->platform->vtbl->saveScreenshot(self->game->platform);
}

void ClientModManager1_OrthoMode(ClientModManager1 const *self)
{
	Game_OrthoMode(self->game, self->base.vtbl->getWindowWidth(&self->base), self->base.vtbl->getWindowHeight(&self->base));
}

void ClientModManager1_PerspectiveMode(ClientModManager1 const *self)
{
	Game_PerspectiveMode(self->game);
}

void ClientModManager1_SendChatMessage(ClientModManager1 const *self, const char *message)
{
	Game_SendChat(self->game, message);
}

void ClientModManager1_SetFreemove(ClientModManager1 const *self, int level)
{
	Controls_SetFreemove(self->game->controls, level);
}

void ClientModManager1_SetLocalOrientation(ClientModManager1 const *self, float glx, float gly, float glz)
{
	self->game->player->position->rotx = glx;
	self->game->player->position->roty = gly;
	self->game->player->position->rotz = glz;
}

void ClientModManager1_SetLocalPosition(ClientModManager1 const *self, float glx, float gly, float glz)
{
	self->game->player->position->x = glx;
	self->game->player->position->y = gly;
	self->game->player->position->z = glz;
}

void ClientModManager1_ShowGui(ClientModManager1 const *self, int level)
{
	if (level == 0) {
		self->game->eNABLE_DRAW2D = FALSE;
	}
	else {
		self->game->eNABLE_DRAW2D = TRUE;
	}
}

int ClientModManager1_WhiteTexture(ClientModManager1 const *self)
{
	return Game_WhiteTexture(self->game);
}

static void ClientPacketHandler_Construct(ClientPacketHandler *self, const ClientPacketHandlerVtbl *vtbl)
{
	self->vtbl = vtbl;
	self->one = 1;
}

static void ClientPacketHandlerDialog_Construct(ClientPacketHandlerDialog *self, const ClientPacketHandlerVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ClientPacketHandlerDialog;
	ClientPacketHandler_Construct(&self->base, vtbl);
}

ClientPacketHandlerDialog *ClientPacketHandlerDialog_New(void)
{
	ClientPacketHandlerDialog *self = (ClientPacketHandlerDialog *) malloc(sizeof(ClientPacketHandlerDialog));
	if (self != NULL)
		ClientPacketHandlerDialog_Construct(self, NULL);
	return self;
}

void ClientPacketHandlerDialog_Delete(ClientPacketHandlerDialog *self)
{
	free(self);
}

static GameScreen *ClientPacketHandlerDialog_ConvertDialog(ClientPacketHandlerDialog const *self, Game const *game, Packet_Dialog const *p)
{
	DialogScreen *s = DialogScreen_New();
	s->base.widgets = (MenuWidget const **) malloc(p->widgetsCount * sizeof(MenuWidget const *));
	s->base.widgetCount = p->widgetsCount;
	{
		int i;
		for (i = 0; i < p->widgetsCount; i++) {
			Packet_Widget const *a = p->widgets[i];
			MenuWidget *b = MenuWidget_New();
			if (a->type == 1) {
				b->type = WidgetType_LABEL;
			}
			if (a->type == 0) {
				b->type = WidgetType_BUTTON;
			}
			if (a->type == 2) {
				b->type = WidgetType_TEXTBOX;
			}
			b->x = a->x;
			b->y = a->y;
			b->sizex = a->width;
			b->sizey = a->height_;
			b->text = a->text;
			if (b->text != NULL) {
				b->text = game->platform->vtbl->stringReplace(game->platform, b->text, "!SERVER_IP!", game->serverInfo->connectdata->ip);
			}
			if (b->text != NULL) {
				b->text = game->platform->vtbl->stringReplace(game->platform, b->text, "!SERVER_PORT!", game->platform->vtbl->intToString(game->platform, game->serverInfo->connectdata->port));
			}
			b->color = a->color;
			if (a->font != NULL) {
				b->font = FontCi_New();
				b->font->family = Game_ValidFont(game, a->font->familyName);
				b->font->size = Game_DeserializeFloat(game, a->font->sizeFloat);
				b->font->style = a->font->fontStyle;
			}
			b->id = a->id;
			b->isbutton = a->clickKey != 0;
			if (strcmp(a->image, "Solid") == 0) {
				b->image = NULL;
			}
			else if (a->image != NULL) {
				b->image = StringTools_StringAppend(game->platform, a->image, ".png");
			}
			s->base.widgets[i] = b;
		}
	}
	{
		int i;
		for (i = 0; i < s->base.widgetCount; i++) {
			if (s->base.widgets[i] == NULL) {
				continue;
			}
			if (s->base.widgets[i]->type == WidgetType_TEXTBOX) {
				s->base.widgets[i]->editing = TRUE;
				break;
			}
		}
	}
	return &s->base;
}

void ClientPacketHandlerDialog_Handle(ClientPacketHandlerDialog const *self, Game *game, Packet_Server const *packet)
{
	Packet_ServerDialog const *d = packet->dialog;
	if (d->dialog == NULL) {
		if (Game_GetDialogId(game, d->dialogId) != -1 && game->dialogs[Game_GetDialogId(game, d->dialogId)]->value->isModal != 0) {
			Game_GuiStateBackToGame(game);
		}
		if (Game_GetDialogId(game, d->dialogId) != -1) {
			game->dialogs[Game_GetDialogId(game, d->dialogId)] = NULL;
		}
		if (Game_DialogsCount_(game) == 0) {
			Game_SetFreeMouse(game, FALSE);
		}
	}
	else {
		VisibleDialog *d2 = VisibleDialog_New();
		d2->key = d->dialogId;
		d2->value = d->dialog;
		d2->screen = ClientPacketHandlerDialog_ConvertDialog(self, game, d2->value);
		d2->screen->game = game;
		if (Game_GetDialogId(game, d->dialogId) == -1) {
			{
				int i;
				for (i = 0; i < game->dialogsCount; i++) {
					if (game->dialogs[i] == NULL) {
						game->dialogs[i] = d2;
						break;
					}
				}
			}
		}
		else {
			game->dialogs[Game_GetDialogId(game, d->dialogId)] = d2;
		}
		if (d->dialog->isModal != 0) {
			game->guistate = GuiState_MODAL_DIALOG;
			Game_SetFreeMouse(game, TRUE);
		}
	}
}

static void ClientPacketHandlerEntityDespawn_Construct(ClientPacketHandlerEntityDespawn *self, const ClientPacketHandlerVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ClientPacketHandlerEntityDespawn;
	ClientPacketHandler_Construct(&self->base, vtbl);
}

ClientPacketHandlerEntityDespawn *ClientPacketHandlerEntityDespawn_New(void)
{
	ClientPacketHandlerEntityDespawn *self = (ClientPacketHandlerEntityDespawn *) malloc(sizeof(ClientPacketHandlerEntityDespawn));
	if (self != NULL)
		ClientPacketHandlerEntityDespawn_Construct(self, NULL);
	return self;
}

void ClientPacketHandlerEntityDespawn_Delete(ClientPacketHandlerEntityDespawn *self)
{
	free(self);
}

void ClientPacketHandlerEntityDespawn_Handle(ClientPacketHandlerEntityDespawn const *self, Game const *game, Packet_Server const *packet)
{
	if (game->entities[packet->entityDespawn->id] != NULL) {
		if (game->entities[packet->entityDespawn->id]->drawModel != NULL && game->entities[packet->entityDespawn->id]->drawModel->downloadSkin) {
			int currentTex = game->entities[packet->entityDespawn->id]->drawModel->currentTexture;
			if (currentTex > 0 && currentTex != Game_GetTexture(game, "mineplayer.png")) {
				game->entities[packet->entityDespawn->id]->drawModel->currentTexture = -1;
				Game_DeleteTexture(game, game->entities[packet->entityDespawn->id]->drawName->name);
			}
		}
	}
	game->entities[packet->entityDespawn->id] = NULL;
}

static void ClientPacketHandlerEntityPosition_Construct(ClientPacketHandlerEntityPosition *self, const ClientPacketHandlerVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ClientPacketHandlerEntityPosition;
	ClientPacketHandler_Construct(&self->base, vtbl);
}

ClientPacketHandlerEntityPosition *ClientPacketHandlerEntityPosition_New(void)
{
	ClientPacketHandlerEntityPosition *self = (ClientPacketHandlerEntityPosition *) malloc(sizeof(ClientPacketHandlerEntityPosition));
	if (self != NULL)
		ClientPacketHandlerEntityPosition_Construct(self, NULL);
	return self;
}

void ClientPacketHandlerEntityPosition_Delete(ClientPacketHandlerEntityPosition *self)
{
	free(self);
}

void ClientPacketHandlerEntityPosition_Handle(ClientPacketHandlerEntityPosition const *self, Game const *game, Packet_Server const *packet)
{
	Entity *entity = game->entities[packet->entityPosition->id];
	EntityPosition_ *pos = ClientPacketHandlerEntitySpawn_ToClientEntityPosition(packet->entityPosition->positionAndOrientation);
	entity->networkPosition = pos;
	entity->networkPosition->positionLoaded = TRUE;
	entity->networkPosition->lastUpdateMilliseconds = game->platform->vtbl->timeMillisecondsFromStart(game->platform);
	if (packet->entityPosition->id == game->localPlayerId) {
		game->player->position->x = pos->x;
		game->player->position->y = pos->y;
		game->player->position->z = pos->z;
		game->player->position->rotx = pos->rotx;
		game->player->position->roty = pos->roty;
		game->player->position->rotz = pos->rotz;
		entity->networkPosition = NULL;
	}
	else if (entity->push != NULL) {
		entity->push->xFloat = packet->entityPosition->positionAndOrientation->x;
		entity->push->yFloat = packet->entityPosition->positionAndOrientation->z;
		entity->push->zFloat = packet->entityPosition->positionAndOrientation->y;
	}
}

static void ClientPacketHandlerEntitySpawn_Construct(ClientPacketHandlerEntitySpawn *self, const ClientPacketHandlerVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ClientPacketHandlerEntitySpawn;
	ClientPacketHandler_Construct(&self->base, vtbl);
}

ClientPacketHandlerEntitySpawn *ClientPacketHandlerEntitySpawn_New(void)
{
	ClientPacketHandlerEntitySpawn *self = (ClientPacketHandlerEntitySpawn *) malloc(sizeof(ClientPacketHandlerEntitySpawn));
	if (self != NULL)
		ClientPacketHandlerEntitySpawn_Construct(self, NULL);
	return self;
}

void ClientPacketHandlerEntitySpawn_Delete(ClientPacketHandlerEntitySpawn *self)
{
	free(self);
}

void ClientPacketHandlerEntitySpawn_Handle(ClientPacketHandlerEntitySpawn const *self, Game *game, Packet_Server const *packet)
{
	Entity *entity = game->entities[packet->entitySpawn->id];
	if (entity == NULL) {
		entity = Entity_New();
	}
	ClientPacketHandlerEntitySpawn_ToClientEntity(game, packet->entitySpawn->entity_, entity, packet->entitySpawn->id != game->localPlayerId);
	game->entities[packet->entitySpawn->id] = entity;
	if (packet->entitySpawn->id == game->localPlayerId) {
		entity->networkPosition = NULL;
		game->player = entity;
		if (!game->spawned) {
			entity->scripts[entity->scriptsCount++] = &ScriptCharacterPhysics_New()->base;
			Game_MapLoaded(game);
			game->spawned = TRUE;
		}
	}
}

Entity const *ClientPacketHandlerEntitySpawn_ToClientEntity(Game const *game, Packet_ServerEntity const *entity, Entity *old, cibool updatePosition)
{
	if (entity->position != NULL) {
		if (old->position == NULL || updatePosition) {
			old->networkPosition = ClientPacketHandlerEntitySpawn_ToClientEntityPosition(entity->position);
			old->networkPosition->positionLoaded = TRUE;
			old->networkPosition->lastUpdateMilliseconds = game->platform->vtbl->timeMillisecondsFromStart(game->platform);
			old->position = ClientPacketHandlerEntitySpawn_ToClientEntityPosition(entity->position);
		}
	}
	if (entity->drawModel != NULL) {
		old->drawModel = EntityDrawModel_New();
		old->drawModel->eyeHeight = Game_DeserializeFloat(game, entity->drawModel->eyeHeight);
		old->drawModel->modelHeight = Game_DeserializeFloat(game, entity->drawModel->modelHeight);
		old->drawModel->texture_ = entity->drawModel->texture_;
		old->drawModel->model_ = entity->drawModel->model_;
		if (old->drawModel->model_ == NULL) {
			old->drawModel->model_ = "player.txt";
		}
		old->drawModel->downloadSkin = entity->drawModel->downloadSkin != 0;
	}
	if (entity->drawName_ != NULL) {
		old->drawName = DrawName_New();
		if (entity->drawName_->color != NULL) {
			old->drawName->name = game->platform->vtbl->stringFormat2(game->platform, "{0}{1}", entity->drawName_->color, entity->drawName_->name);
		}
		else {
			old->drawName->name = entity->drawName_->name;
		}
		if (!game->platform->vtbl->stringStartsWithIgnoreCase(game->platform, old->drawName->name, "&")) {
			old->drawName->name = game->platform->vtbl->stringFormat(game->platform, "&f{0}", old->drawName->name);
		}
		old->drawName->onlyWhenSelected = entity->drawName_->onlyWhenSelected;
		old->drawName->clientAutoComplete = entity->drawName_->clientAutoComplete;
	}
	if (entity->drawText != NULL) {
		float one_;
		old->drawText = EntityDrawText_New();
		old->drawText->text = entity->drawText->text;
		one_ = 1;
		old->drawText->dx = one_ * entity->drawText->dx / 32;
		old->drawText->dy = one_ * entity->drawText->dy / 32;
		old->drawText->dz = one_ * entity->drawText->dz / 32;
	}
	else {
		old->drawText = NULL;
	}
	if (entity->drawBlock != NULL) {
	}
	if (entity->push != NULL) {
		old->push = Packet_ServerExplosion_New();
		old->push->rangeFloat = entity->push->rangeFloat;
	}
	else {
		old->push = NULL;
	}
	old->usable = entity->usable;
	if (entity->drawArea != NULL) {
		old->drawArea = EntityDrawArea_New();
		old->drawArea->x = entity->drawArea->x;
		old->drawArea->y = entity->drawArea->y;
		old->drawArea->z = entity->drawArea->z;
		old->drawArea->sizex = entity->drawArea->sizex;
		old->drawArea->sizey = entity->drawArea->sizey;
		old->drawArea->sizez = entity->drawArea->sizez;
	}
	else {
		old->drawArea = NULL;
	}
	return old;
}

EntityPosition_ *ClientPacketHandlerEntitySpawn_ToClientEntityPosition(Packet_PositionAndOrientation const *pos)
{
	float one = 1;
	EntityPosition_ *p = EntityPosition__New();
	p->x = one * pos->x / 32;
	p->y = one * pos->y / 32;
	p->z = one * pos->z / 32;
	p->rotx = Game_Angle256ToRad(pos->pitch);
	p->roty = Game_Angle256ToRad(pos->heading);
	return p;
}

Packet_Client const *ClientPackets_ActiveMaterialSlot(int ActiveMaterial)
{
	Packet_Client *p = Packet_Client_New();
	{
		p->id = 56;
		p->activeMaterialSlot = Packet_ClientActiveMaterialSlot_New();
		p->activeMaterialSlot->activeMaterialSlot = ActiveMaterial;
	}
	return p;
}

Packet_Client const *ClientPackets_Chat(const char *s, int isTeamchat)
{
	Packet_ClientMessage *p = Packet_ClientMessage_New();
	Packet_Client *pp;
	p->message = s;
	p->isTeamchat = isTeamchat;
	pp = Packet_Client_New();
	pp->id = 13;
	pp->message = p;
	return pp;
}

Packet_Client const *ClientPackets_Craft(int x, int y, int z, int recipeId)
{
	Packet_ClientCraft *cmd = Packet_ClientCraft_New();
	Packet_Client *p;
	cmd->x = x;
	cmd->y = y;
	cmd->z = z;
	cmd->recipeId = recipeId;
	p = Packet_Client_New();
	p->id = 9;
	p->craft = cmd;
	return p;
}

Packet_Client const *ClientPackets_CreateLoginPacket(GamePlatform const *platform, const char *username, const char *verificationKey)
{
	Packet_ClientIdentification *p = Packet_ClientIdentification_New();
	Packet_Client *pp;
	{
		p->username = username;
		p->mdProtocolVersion = platform->vtbl->getGameVersion(platform);
		p->verificationKey = verificationKey;
	}
	pp = Packet_Client_New();
	pp->id = 0;
	pp->identification = p;
	return pp;
}

Packet_Client const *ClientPackets_CreateLoginPacket_(GamePlatform const *platform, const char *username, const char *verificationKey, const char *serverPassword)
{
	Packet_ClientIdentification *p = Packet_ClientIdentification_New();
	Packet_Client *pp;
	{
		p->username = username;
		p->mdProtocolVersion = platform->vtbl->getGameVersion(platform);
		p->verificationKey = verificationKey;
		p->serverPassword = serverPassword;
	}
	pp = Packet_Client_New();
	pp->id = 0;
	pp->identification = p;
	return pp;
}

Packet_Client const *ClientPackets_Death(int reason, int sourcePlayer)
{
	Packet_Client *p = Packet_Client_New();
	p->id = 60;
	p->death = Packet_ClientDeath_New();
	{
		p->death->reason = reason;
		p->death->sourcePlayer = sourcePlayer;
	}
	return p;
}

Packet_Client const *ClientPackets_DialogClick(const char *widgetId, const char **textValues, int textValuesCount)
{
	Packet_Client *p = Packet_Client_New();
	p->id = 14;
	p->dialogClick_ = Packet_ClientDialogClick_New();
	p->dialogClick_->widgetId = widgetId;
	Packet_ClientDialogClick_SetTextBoxValue(p->dialogClick_, textValues, textValuesCount, textValuesCount);
	return p;
}

Packet_Client const *ClientPackets_FillArea(int startx, int starty, int startz, int endx, int endy, int endz, int blockType, int ActiveMaterial)
{
	Packet_ClientFillArea *p = Packet_ClientFillArea_New();
	Packet_Client *pp;
	{
		p->x1 = startx;
		p->y1 = starty;
		p->z1 = startz;
		p->x2 = endx;
		p->y2 = endy;
		p->z2 = endz;
		p->blockType = blockType;
		p->materialSlot = ActiveMaterial;
	}
	pp = Packet_Client_New();
	pp->id = 510;
	pp->fillArea = p;
	return pp;
}

Packet_Client const *ClientPackets_GameResolution(int width, int height)
{
	Packet_ClientGameResolution *p = Packet_ClientGameResolution_New();
	Packet_Client *pp;
	p->width = width;
	p->height = height;
	pp = Packet_Client_New();
	pp->id = 10;
	pp->gameResolution = p;
	return pp;
}

Packet_Client const *ClientPackets_Health(int currentHealth)
{
	Packet_Client *p = Packet_Client_New();
	{
		p->id = 52;
		p->health = Packet_ClientHealth_New();
		p->health->currentHealth = currentHealth;
	}
	return p;
}

static Packet_Client const *ClientPackets_HitEntity(int entityId)
{
	Packet_Client *p = Packet_Client_New();
	p->id = 61;
	p->entityInteraction = Packet_ClientEntityInteraction_New();
	p->entityInteraction->entityId = entityId;
	p->entityInteraction->interactionType = 1;
	return p;
}

Packet_Client const *ClientPackets_InventoryClick(Packet_InventoryPosition *pos)
{
	Packet_ClientInventoryAction *p = Packet_ClientInventoryAction_New();
	Packet_Client *pp;
	p->a = pos;
	p->action = 0;
	pp = Packet_Client_New();
	pp->id = 51;
	pp->inventoryAction = p;
	return pp;
}

Packet_Client const *ClientPackets_Leave(int reason)
{
	Packet_Client *p = Packet_Client_New();
	p->id = 57;
	p->leave = Packet_ClientLeave_New();
	p->leave->reason = reason;
	return p;
}

Packet_Client const *ClientPackets_MonsterHit(int damage)
{
	Packet_ClientHealth *p = Packet_ClientHealth_New();
	Packet_Client *packet;
	p->currentHealth = damage;
	packet = Packet_Client_New();
	packet->id = 53;
	packet->health = p;
	return packet;
}

Packet_Client const *ClientPackets_MoveToInventory(Packet_InventoryPosition *from)
{
	Packet_ClientInventoryAction *p = Packet_ClientInventoryAction_New();
	Packet_Client *pp;
	p->a = from;
	p->action = 2;
	pp = Packet_Client_New();
	pp->id = 51;
	pp->inventoryAction = p;
	return pp;
}

Packet_Client const *ClientPackets_Oxygen(int currentOxygen)
{
	Packet_Client *packet = Packet_Client_New();
	packet->id = 59;
	packet->oxygen = Packet_ClientOxygen_New();
	packet->oxygen->currentOxygen = currentOxygen;
	return packet;
}

Packet_Client const *ClientPackets_PingReply(void)
{
	Packet_ClientPingReply const *p = Packet_ClientPingReply_New();
	Packet_Client *pp = Packet_Client_New();
	pp->id = 1;
	pp->pingReply = p;
	return pp;
}

Packet_Client const *ClientPackets_PositionAndOrientation(Game const *game, int playerId, float positionX, float positionY, float positionZ, float orientationX, float orientationY, float orientationZ, unsigned char stance)
{
	Packet_ClientPositionAndOrientation *p = Packet_ClientPositionAndOrientation_New();
	Packet_Client *pp;
	{
		p->playerId = playerId;
		p->x = game->platform->vtbl->floatToInt(game->platform, positionX * 32);
		p->y = game->platform->vtbl->floatToInt(game->platform, positionY * 32);
		p->z = game->platform->vtbl->floatToInt(game->platform, positionZ * 32);
		p->heading = game->platform->vtbl->floatToInt(game->platform, Game_RadToAngle256(orientationY));
		p->pitch = game->platform->vtbl->floatToInt(game->platform, Game_RadToAngle256(orientationX));
		p->stance = stance;
	}
	pp = Packet_Client_New();
	pp->id = 8;
	pp->positionAndOrientation = p;
	return pp;
}

Packet_Client const *ClientPackets_Reload(void)
{
	Packet_Client *p = Packet_Client_New();
	p->id = 58;
	p->reload = Packet_ClientReload_New();
	return p;
}

Packet_Client const *ClientPackets_RequestBlob(Game const *game, const char **required, int requiredCount)
{
	Packet_ClientRequestBlob *p = Packet_ClientRequestBlob_New();
	Packet_Client *pp;
	if (GameVersionHelper_ServerVersionAtLeast(game->platform, game->serverGameVersion, 2014, 4, 13)) {
		p->requestedMd5 = Packet_StringList_New();
		Packet_StringList_SetItems(p->requestedMd5, required, requiredCount, requiredCount);
	}
	pp = Packet_Client_New();
	pp->id = 50;
	pp->requestBlob = p;
	return pp;
}

Packet_Client const *ClientPackets_ServerQuery(void)
{
	Packet_ClientServerQuery const *p1 = Packet_ClientServerQuery_New();
	Packet_Client *pp = Packet_Client_New();
	pp->id = 64;
	pp->query = p1;
	return pp;
}

Packet_Client const *ClientPackets_SetBlock(int x, int y, int z, int mode, int type, int materialslot)
{
	Packet_ClientSetBlock *p = Packet_ClientSetBlock_New();
	Packet_Client *pp;
	{
		p->x = x;
		p->y = y;
		p->z = z;
		p->mode = mode;
		p->blockType = type;
		p->materialSlot = materialslot;
	}
	pp = Packet_Client_New();
	pp->id = 5;
	pp->setBlock = p;
	return pp;
}

Packet_Client const *ClientPackets_SpecialKeyRespawn(void)
{
	Packet_Client *p = Packet_Client_New();
	{
		p->id = 55;
		p->specialKey_ = Packet_ClientSpecialKey_New();
		p->specialKey_->key_ = 0;
	}
	return p;
}

Packet_Client const *ClientPackets_SpecialKeySelectTeam(void)
{
	Packet_Client *p = Packet_Client_New();
	{
		p->id = 55;
		p->specialKey_ = Packet_ClientSpecialKey_New();
		p->specialKey_->key_ = 3;
	}
	return p;
}

Packet_Client const *ClientPackets_SpecialKeySetSpawn(void)
{
	Packet_Client *p = Packet_Client_New();
	{
		p->id = 55;
		p->specialKey_ = Packet_ClientSpecialKey_New();
		p->specialKey_->key_ = 1;
	}
	return p;
}

Packet_Client const *ClientPackets_SpecialKeyTabPlayerList(void)
{
	Packet_Client *p = Packet_Client_New();
	p->id = 55;
	p->specialKey_ = Packet_ClientSpecialKey_New();
	p->specialKey_->key_ = 2;
	return p;
}

static Packet_Client const *ClientPackets_UseEntity(int entityId)
{
	Packet_Client *p = Packet_Client_New();
	p->id = 61;
	p->entityInteraction = Packet_ClientEntityInteraction_New();
	p->entityInteraction->entityId = entityId;
	p->entityInteraction->interactionType = 0;
	return p;
}

Packet_Client const *ClientPackets_WearItem(Packet_InventoryPosition *from, Packet_InventoryPosition *to)
{
	Packet_ClientInventoryAction *p = Packet_ClientInventoryAction_New();
	Packet_Client *pp;
	p->a = from;
	p->b = to;
	p->action = 1;
	pp = Packet_Client_New();
	pp->id = 51;
	pp->inventoryAction = p;
	return pp;
}

static void ClientSimple_Construct(ClientSimple *self)
{
	self->inventory = Packet_Inventory_New();
	Packet_Inventory_SetRightHand(self->inventory, (Packet_Item const **) malloc(10 * sizeof(Packet_Item const *)), 10, 10);
	{
		int i;
		for (i = 0; i < 10; i++) {
			self->inventory->rightHand[i] = Packet_Item_New();
		}
	}
}

ClientSimple *ClientSimple_New(void)
{
	ClientSimple *self = (ClientSimple *) malloc(sizeof(ClientSimple));
	if (self != NULL)
		ClientSimple_Construct(self);
	return self;
}

void ClientSimple_Delete(ClientSimple *self)
{
	free(self);
}

static void Config3d_Construct(Config3d *self)
{
	self->eNABLE_BACKFACECULLING = TRUE;
	self->eNABLE_TRANSPARENCY = TRUE;
	self->eNABLE_MIPMAPS = TRUE;
	self->eNABLE_VISIBILITY_CULLING = FALSE;
	self->viewdistance = 128;
}

Config3d *Config3d_New(void)
{
	Config3d *self = (Config3d *) malloc(sizeof(Config3d));
	if (self != NULL)
		Config3d_Construct(self);
	return self;
}

void Config3d_Delete(Config3d *self)
{
	free(self);
}

cibool Config3d_GetEnableMipmaps(Config3d const *self)
{
	return self->eNABLE_MIPMAPS;
}

cibool Config3d_GetEnableTransparency(Config3d const *self)
{
	return self->eNABLE_TRANSPARENCY;
}

float Config3d_GetViewDistance(Config3d const *self)
{
	return self->viewdistance;
}

void Config3d_SetEnableMipmaps(Config3d *self, cibool value)
{
	self->eNABLE_MIPMAPS = value;
}

void Config3d_SetEnableTransparency(Config3d *self, cibool value)
{
	self->eNABLE_TRANSPARENCY = value;
}

void Config3d_SetViewDistance(Config3d *self, float value)
{
	self->viewdistance = value;
}

ConnectData *ConnectData_New(void)
{
	ConnectData *self = (ConnectData *) malloc(sizeof(ConnectData));
	return self;
}

void ConnectData_Delete(ConnectData *self)
{
	free(self);
}

ConnectData const *ConnectData_FromUri(UriCi const *uri)
{
	ConnectData *c = ConnectData_New();
	c = ConnectData_New();
	c->ip = UriCi_GetIp(uri);
	c->port = 25565;
	c->username = "gamer";
	if (UriCi_GetPort(uri) != -1) {
		c->port = UriCi_GetPort(uri);
	}
	if (DictionaryStringString_ContainsKey(UriCi_GetGet(uri), "user")) {
		c->username = DictionaryStringString_Get(UriCi_GetGet(uri), "user");
	}
	if (DictionaryStringString_ContainsKey(UriCi_GetGet(uri), "auth")) {
		c->auth = DictionaryStringString_Get(UriCi_GetGet(uri), "auth");
	}
	if (DictionaryStringString_ContainsKey(UriCi_GetGet(uri), "serverPassword")) {
		c->isServePasswordProtected = MiscCi_ReadBool(DictionaryStringString_Get(UriCi_GetGet(uri), "serverPassword"));
	}
	return c;
}

cibool ConnectData_GetIsServePasswordProtected(ConnectData const *self)
{
	return self->isServePasswordProtected;
}

void ConnectData_SetIp(ConnectData *self, const char *value)
{
	self->ip = value;
}

void ConnectData_SetIsServePasswordProtected(ConnectData *self, cibool value)
{
	self->isServePasswordProtected = value;
}

void ConnectData_SetPort(ConnectData *self, int value)
{
	self->port = value;
}

void ConnectData_SetServerPassword(ConnectData *self, const char *value)
{
	self->serverPassword = value;
}

void ConnectData_SetUsername(ConnectData *self, const char *value)
{
	self->username = value;
}

ConnectedPlayer *ConnectedPlayer_New(void)
{
	ConnectedPlayer *self = (ConnectedPlayer *) malloc(sizeof(ConnectedPlayer));
	return self;
}

void ConnectedPlayer_Delete(ConnectedPlayer *self)
{
	free(self);
}

Controls *Controls_New(void)
{
	Controls *self = (Controls *) malloc(sizeof(Controls));
	return self;
}

void Controls_Delete(Controls *self)
{
	free(self);
}

int Controls_GetFreemove(Controls const *self)
{
	if (!self->freemove) {
		return 0;
	}
	if (self->noclip) {
		return 2;
	}
	else {
		return 1;
	}
}

void Controls_SetFreemove(Controls *self, int level)
{
	if (level == 0) {
		self->freemove = FALSE;
		self->noclip = FALSE;
	}
	if (level == 1) {
		self->freemove = TRUE;
		self->noclip = FALSE;
	}
	if (level == 2) {
		self->freemove = TRUE;
		self->noclip = TRUE;
	}
}

CraftingTableTool *CraftingTableTool_New(void)
{
	CraftingTableTool *self = (CraftingTableTool *) malloc(sizeof(CraftingTableTool));
	return self;
}

void CraftingTableTool_Delete(CraftingTableTool *self)
{
	free(self);
}

int const *CraftingTableTool_GetOnTable(CraftingTableTool const *self, Vector3IntRef const *const *table, int tableCount, IntRef *retCount)
{
	int *ontable = (int *) malloc(2048 * sizeof(int ));
	int ontableCount = 0;
	{
		int i;
		for (i = 0; i < tableCount; i++) {
			Vector3IntRef const *v = table[i];
			int t = self->d_Map->vtbl->getBlock(self->d_Map, v->x, v->y, v->z + 1);
			ontable[ontableCount++] = t;
		}
	}
	retCount->value = ontableCount;
	return ontable;
}

Vector3IntRef const *const *CraftingTableTool_GetTable(CraftingTableTool const *self, int posx, int posy, int posz, IntRef *retCount)
{
	Vector3IntRef const **l = (Vector3IntRef const **) malloc(2048 * sizeof(Vector3IntRef const *));
	int lCount = 0;
	Vector3IntRef const **todo = (Vector3IntRef const **) malloc(2048 * sizeof(Vector3IntRef const *));
	int todoCount = 0;
	todo[todoCount++] = Vector3IntRef_Create(posx, posy, posz);
	for (;;) {
		Vector3IntRef const *p;
		Vector3IntRef const *a;
		Vector3IntRef const *b;
		Vector3IntRef const *c;
		Vector3IntRef const *d;
		if (todoCount == 0 || lCount >= 2000) {
			break;
		}
		p = todo[todoCount - 1];
		todoCount--;
		if (CraftingTableTool_Vector3IntRefArrayContains(self, l, lCount, p)) {
			continue;
		}
		l[lCount++] = p;
		a = Vector3IntRef_Create(p->x + 1, p->y, p->z);
		if (self->d_Map->vtbl->getBlock(self->d_Map, a->x, a->y, a->z) == GameData_BlockIdCraftingTable(self->d_Data)) {
			todo[todoCount++] = a;
		}
		b = Vector3IntRef_Create(p->x - 1, p->y, p->z);
		if (self->d_Map->vtbl->getBlock(self->d_Map, b->x, b->y, b->z) == GameData_BlockIdCraftingTable(self->d_Data)) {
			todo[todoCount++] = b;
		}
		c = Vector3IntRef_Create(p->x, p->y + 1, p->z);
		if (self->d_Map->vtbl->getBlock(self->d_Map, c->x, c->y, c->z) == GameData_BlockIdCraftingTable(self->d_Data)) {
			todo[todoCount++] = c;
		}
		d = Vector3IntRef_Create(p->x, p->y - 1, p->z);
		if (self->d_Map->vtbl->getBlock(self->d_Map, d->x, d->y, d->z) == GameData_BlockIdCraftingTable(self->d_Data)) {
			todo[todoCount++] = d;
		}
	}
	retCount->value = lCount;
	return l;
}

static cibool CraftingTableTool_Vector3IntRefArrayContains(CraftingTableTool const *self, Vector3IntRef const *const *l, int lCount, Vector3IntRef const *p)
{
	{
		int i;
		for (i = 0; i < lCount; i++) {
			if (l[i]->x == p->x && l[i]->y == p->y && l[i]->z == p->z) {
				return TRUE;
			}
		}
	}
	return FALSE;
}

ModelData const *CubeModelData_GetCubeModelData(void)
{
	ModelData *m = ModelData_New();
	float *xyz = (float *) malloc(72 * sizeof(float ));
	float *uv;
	{
		int i;
		for (i = 0; i < 72; i++) {
			xyz[i] = CubeModelData_cubeVertices[i];
		}
	}
	ModelData_setXyz(m, xyz);
	uv = (float *) malloc(48 * sizeof(float ));
	{
		int i;
		for (i = 0; i < 48; i++) {
			uv[i] = CubeModelData_cubeTextureCoords[i];
		}
	}
	ModelData_setUv(m, uv);
	ModelData_SetVerticesCount(m, 24);
	ModelData_setIndices(m, CubeModelData_cubeVertexIndices);
	ModelData_SetIndicesCount(m, 36);
	return m;
}

void CuboidRenderer_AddVertex(ModelData *model, float x, float y, float z, float u, float v, int color)
{
	model->xyz[ModelData_GetXyzCount(model) + 0] = x;
	model->xyz[ModelData_GetXyzCount(model) + 1] = y;
	model->xyz[ModelData_GetXyzCount(model) + 2] = z;
	model->uv[ModelData_GetUvCount(model) + 0] = u;
	model->uv[ModelData_GetUvCount(model) + 1] = v;
	model->rgba[ModelData_GetRgbaCount(model) + 0] = Game_IntToByte(Game_ColorR(color));
	model->rgba[ModelData_GetRgbaCount(model) + 1] = Game_IntToByte(Game_ColorG(color));
	model->rgba[ModelData_GetRgbaCount(model) + 2] = Game_IntToByte(Game_ColorB(color));
	model->rgba[ModelData_GetRgbaCount(model) + 3] = Game_IntToByte(Game_ColorA(color));
	model->verticesCount++;
}

RectangleFloat const **CuboidRenderer_CuboidNet(float tsizex, float tsizey, float tsizez, float tstartx, float tstarty)
{
	RectangleFloat const **coords = (RectangleFloat const **) malloc(6 * sizeof(RectangleFloat const *));
	{
		coords[0] = RectangleFloat_Create(tsizez + tstartx, tsizez + tstarty, tsizex, tsizey);
		coords[1] = RectangleFloat_Create(2 * tsizez + tsizex + tstartx, tsizez + tstarty, tsizex, tsizey);
		coords[2] = RectangleFloat_Create(tstartx, tsizez + tstarty, tsizez, tsizey);
		coords[3] = RectangleFloat_Create(tsizez + tsizex + tstartx, tsizez + tstarty, tsizez, tsizey);
		coords[4] = RectangleFloat_Create(tsizez + tstartx, tstarty, tsizex, tsizez);
		coords[5] = RectangleFloat_Create(tsizez + tsizex + tstartx, tstarty, tsizex, tsizez);
	}
	return coords;
}

void CuboidRenderer_CuboidNetNormalize(RectangleFloat const **coords, float texturewidth, float textureheight)
{
	float AtiArtifactFix = 0.15f;
	{
		int i;
		for (i = 0; i < 6; i++) {
			float x = (coords[i]->x + AtiArtifactFix) / texturewidth;
			float y = (coords[i]->y + AtiArtifactFix) / textureheight;
			float w = (coords[i]->x + coords[i]->width - AtiArtifactFix) / texturewidth - x;
			float h = (coords[i]->y + coords[i]->height - AtiArtifactFix) / textureheight - y;
			coords[i] = RectangleFloat_Create(x, y, w, h);
		}
	}
}

void CuboidRenderer_DrawCuboid(Game const *game, float posX, float posY, float posZ, float sizeX, float sizeY, float sizeZ, RectangleFloat const *const *texturecoords, float light)
{
	ModelData *data = ModelData_New();
	int light255;
	int color;
	RectangleFloat const *rect;
	data->xyz = (float *) malloc(72 * sizeof(float ));
	data->uv = (float *) malloc(48 * sizeof(float ));
	data->rgba = (unsigned char *) malloc(96 * sizeof(unsigned char ));
	light255 = game->platform->vtbl->floatToInt(game->platform, light * 255);
	color = Game_ColorFromArgb(255, light255, light255, light255);
	rect = texturecoords[0];
	CuboidRenderer_AddVertex(data, posX, posY, posZ, rect->x, RectangleFloat_Bottom(rect), color);
	CuboidRenderer_AddVertex(data, posX, posY, posZ + sizeZ, rect->x + rect->width, RectangleFloat_Bottom(rect), color);
	CuboidRenderer_AddVertex(data, posX, posY + sizeY, posZ + sizeZ, rect->x + rect->width, rect->y, color);
	CuboidRenderer_AddVertex(data, posX, posY + sizeY, posZ, rect->x, rect->y, color);
	rect = texturecoords[1];
	CuboidRenderer_AddVertex(data, posX + sizeX, posY, posZ, rect->x, RectangleFloat_Bottom(rect), color);
	CuboidRenderer_AddVertex(data, posX + sizeX, posY, posZ + sizeZ, rect->x + rect->width, RectangleFloat_Bottom(rect), color);
	CuboidRenderer_AddVertex(data, posX + sizeX, posY + sizeY, posZ + sizeZ, rect->x + rect->width, rect->y, color);
	CuboidRenderer_AddVertex(data, posX + sizeX, posY + sizeY, posZ, rect->x, rect->y, color);
	rect = texturecoords[2];
	CuboidRenderer_AddVertex(data, posX + sizeX, posY, posZ, rect->x, RectangleFloat_Bottom(rect), color);
	CuboidRenderer_AddVertex(data, posX, posY, posZ, rect->x + rect->width, RectangleFloat_Bottom(rect), color);
	CuboidRenderer_AddVertex(data, posX, posY + sizeY, posZ, rect->x + rect->width, rect->y, color);
	CuboidRenderer_AddVertex(data, posX + sizeX, posY + sizeY, posZ, rect->x, rect->y, color);
	rect = texturecoords[3];
	CuboidRenderer_AddVertex(data, posX + sizeX, posY, posZ + sizeZ, rect->x + rect->width, RectangleFloat_Bottom(rect), color);
	CuboidRenderer_AddVertex(data, posX, posY, posZ + sizeZ, rect->x, RectangleFloat_Bottom(rect), color);
	CuboidRenderer_AddVertex(data, posX, posY + sizeY, posZ + sizeZ, rect->x, rect->y, color);
	CuboidRenderer_AddVertex(data, posX + sizeX, posY + sizeY, posZ + sizeZ, rect->x + rect->width, rect->y, color);
	rect = texturecoords[4];
	CuboidRenderer_AddVertex(data, posX, posY + sizeY, posZ, rect->x, RectangleFloat_Bottom(rect), color);
	CuboidRenderer_AddVertex(data, posX, posY + sizeY, posZ + sizeZ, rect->x + rect->width, RectangleFloat_Bottom(rect), color);
	CuboidRenderer_AddVertex(data, posX + sizeX, posY + sizeY, posZ + sizeZ, rect->x + rect->width, rect->y, color);
	CuboidRenderer_AddVertex(data, posX + sizeX, posY + sizeY, posZ, rect->x, rect->y, color);
	rect = texturecoords[5];
	CuboidRenderer_AddVertex(data, posX, posY, posZ, rect->x, RectangleFloat_Bottom(rect), color);
	CuboidRenderer_AddVertex(data, posX, posY, posZ + sizeZ, rect->x + rect->width, RectangleFloat_Bottom(rect), color);
	CuboidRenderer_AddVertex(data, posX + sizeX, posY, posZ + sizeZ, rect->x + rect->width, rect->y, color);
	CuboidRenderer_AddVertex(data, posX + sizeX, posY, posZ, rect->x, rect->y, color);
	data->indices = (int *) malloc(36 * sizeof(int ));
	{
		int i;
		for (i = 0; i < 6; i++) {
			data->indices[i * 6 + 0] = i * 4 + 3;
			data->indices[i * 6 + 1] = i * 4 + 2;
			data->indices[i * 6 + 2] = i * 4 + 0;
			data->indices[i * 6 + 3] = i * 4 + 2;
			data->indices[i * 6 + 4] = i * 4 + 1;
			data->indices[i * 6 + 5] = i * 4 + 0;
		}
	}
	data->indicesCount = 36;
	game->platform->vtbl->glDisableCullFace(game->platform);
	Game_DrawModelData(game, data);
	game->platform->vtbl->glEnableCullFace(game->platform);
}

void CuboidRenderer_DrawCuboid2(Game const *game, float posX, float posY, float posZ, float sizeX, float sizeY, float sizeZ, RectangleFloat const *const *texturecoords, float light)
{
	ModelData *data = ModelData_New();
	int light255;
	int color;
	RectangleFloat const *rect;
	data->xyz = (float *) malloc(72 * sizeof(float ));
	data->uv = (float *) malloc(48 * sizeof(float ));
	data->rgba = (unsigned char *) malloc(96 * sizeof(unsigned char ));
	light255 = game->platform->vtbl->floatToInt(game->platform, light * 255);
	color = Game_ColorFromArgb(255, light255, light255, light255);
	rect = texturecoords[2];
	CuboidRenderer_AddVertex(data, posX, posY, posZ, rect->x, RectangleFloat_Bottom(rect), color);
	CuboidRenderer_AddVertex(data, posX, posY, posZ + sizeZ, rect->x + rect->width, RectangleFloat_Bottom(rect), color);
	CuboidRenderer_AddVertex(data, posX, posY + sizeY, posZ + sizeZ, rect->x + rect->width, rect->y, color);
	CuboidRenderer_AddVertex(data, posX, posY + sizeY, posZ, rect->x, rect->y, color);
	rect = texturecoords[3];
	CuboidRenderer_AddVertex(data, posX + sizeX, posY, posZ + sizeZ, rect->x, RectangleFloat_Bottom(rect), color);
	CuboidRenderer_AddVertex(data, posX + sizeX, posY, posZ, rect->x + rect->width, RectangleFloat_Bottom(rect), color);
	CuboidRenderer_AddVertex(data, posX + sizeX, posY + sizeY, posZ, rect->x + rect->width, rect->y, color);
	CuboidRenderer_AddVertex(data, posX + sizeX, posY + sizeY, posZ + sizeZ, rect->x, rect->y, color);
	rect = texturecoords[1];
	CuboidRenderer_AddVertex(data, posX + sizeX, posY, posZ, rect->x, RectangleFloat_Bottom(rect), color);
	CuboidRenderer_AddVertex(data, posX, posY, posZ, rect->x + rect->width, RectangleFloat_Bottom(rect), color);
	CuboidRenderer_AddVertex(data, posX, posY + sizeY, posZ, rect->x + rect->width, rect->y, color);
	CuboidRenderer_AddVertex(data, posX + sizeX, posY + sizeY, posZ, rect->x, rect->y, color);
	rect = texturecoords[0];
	CuboidRenderer_AddVertex(data, posX + sizeX, posY, posZ + sizeZ, rect->x + rect->width, RectangleFloat_Bottom(rect), color);
	CuboidRenderer_AddVertex(data, posX, posY, posZ + sizeZ, rect->x, RectangleFloat_Bottom(rect), color);
	CuboidRenderer_AddVertex(data, posX, posY + sizeY, posZ + sizeZ, rect->x, rect->y, color);
	CuboidRenderer_AddVertex(data, posX + sizeX, posY + sizeY, posZ + sizeZ, rect->x + rect->width, rect->y, color);
	rect = texturecoords[4];
	CuboidRenderer_AddVertex(data, posX, posY + sizeY, posZ, rect->x, rect->y, color);
	CuboidRenderer_AddVertex(data, posX, posY + sizeY, posZ + sizeZ, rect->x, RectangleFloat_Bottom(rect), color);
	CuboidRenderer_AddVertex(data, posX + sizeX, posY + sizeY, posZ + sizeZ, rect->x + rect->width, RectangleFloat_Bottom(rect), color);
	CuboidRenderer_AddVertex(data, posX + sizeX, posY + sizeY, posZ, rect->x + rect->width, rect->y, color);
	rect = texturecoords[5];
	CuboidRenderer_AddVertex(data, posX, posY, posZ, rect->x, rect->y, color);
	CuboidRenderer_AddVertex(data, posX, posY, posZ + sizeZ, rect->x, RectangleFloat_Bottom(rect), color);
	CuboidRenderer_AddVertex(data, posX + sizeX, posY, posZ + sizeZ, rect->x + rect->width, RectangleFloat_Bottom(rect), color);
	CuboidRenderer_AddVertex(data, posX + sizeX, posY, posZ, rect->x + rect->width, rect->y, color);
	data->indices = (int *) malloc(36 * sizeof(int ));
	{
		int i;
		for (i = 0; i < 6; i++) {
			data->indices[i * 6 + 0] = i * 4 + 3;
			data->indices[i * 6 + 1] = i * 4 + 2;
			data->indices[i * 6 + 2] = i * 4 + 0;
			data->indices[i * 6 + 3] = i * 4 + 2;
			data->indices[i * 6 + 4] = i * 4 + 1;
			data->indices[i * 6 + 5] = i * 4 + 0;
		}
	}
	data->indicesCount = 36;
	game->platform->vtbl->glDisableCullFace(game->platform);
	Game_DrawModelData(game, data);
	game->platform->vtbl->glEnableCullFace(game->platform);
}

static void DelegateGetBlockHeight_Construct(DelegateGetBlockHeight *self, const DelegateGetBlockHeightVtbl *vtbl)
{
	self->vtbl = vtbl;
}

static void DelegateIsBlockEmpty_Construct(DelegateIsBlockEmpty *self, const DelegateIsBlockEmptyVtbl *vtbl)
{
	self->vtbl = vtbl;
}

static void DialogScreen_Construct(DialogScreen *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = (const ClientModVtbl *) &CiVtbl_DialogScreen;
	GameScreen_Construct(&self->base, vtbl);
}

DialogScreen *DialogScreen_New(void)
{
	DialogScreen *self = (DialogScreen *) malloc(sizeof(DialogScreen));
	if (self != NULL)
		DialogScreen_Construct(self, NULL);
	return self;
}

void DialogScreen_Delete(DialogScreen *self)
{
	free(self);
}

void DialogScreen_OnButton(DialogScreen const *self, MenuWidget const *w)
{
	if (w->isbutton) {
		const char **textValues = (const char **) malloc(self->base.widgetCount * sizeof(const char *));
		{
			int i;
			for (i = 0; i < self->base.widgetCount; i++) {
				const char *s = self->base.widgets[i]->text;
				if (s == NULL) {
					s = "";
				}
				textValues[i] = s;
			}
		}
		Game_SendPacketClient(self->base.game, ClientPackets_DialogClick(w->id, textValues, self->base.widgetCount));
	}
}

static void DictionaryStringAudioData_Construct(DictionaryStringAudioData *self)
{
	self->keys = (const char **) malloc(1024 * sizeof(const char *));
	{
		int i;
		for (i = 0; i < 1024; i++) {
			self->keys[i] = NULL;
		}
	}
	self->values = (AudioData const **) malloc(1024 * sizeof(AudioData const *));
	{
		int i;
		for (i = 0; i < 1024; i++) {
			self->values[i] = NULL;
		}
	}
}

DictionaryStringAudioData *DictionaryStringAudioData_New(void)
{
	DictionaryStringAudioData *self = (DictionaryStringAudioData *) malloc(sizeof(DictionaryStringAudioData));
	if (self != NULL)
		DictionaryStringAudioData_Construct(self);
	return self;
}

void DictionaryStringAudioData_Delete(DictionaryStringAudioData *self)
{
	free(self);
}

static cibool DictionaryStringAudioData_Contains(DictionaryStringAudioData const *self, const char *key)
{
	int id = DictionaryStringAudioData_GetId(self, key);
	return id != -1;
}

static AudioData const *DictionaryStringAudioData_GetById(DictionaryStringAudioData const *self, int id)
{
	return self->values[id];
}

static int DictionaryStringAudioData_GetId(DictionaryStringAudioData const *self, const char *key)
{
	{
		int i;
		for (i = 0; i < 1024; i++) {
			if (strcmp(self->keys[i], key) == 0) {
				return i;
			}
		}
	}
	return -1;
}

static int DictionaryStringAudioData_Set(DictionaryStringAudioData const *self, const char *key, AudioData const *bmp)
{
	int id = DictionaryStringAudioData_GetId(self, key);
	if (id != -1) {
		self->values[id] = bmp;
		return id;
	}
	{
		int i;
		for (i = 0; i < 1024; i++) {
			if (self->keys[i] == NULL) {
				self->keys[i] = key;
				self->values[i] = bmp;
				return i;
			}
		}
	}
	return -1;
}

static void DictionaryStringAudioSample_Construct(DictionaryStringAudioSample *self)
{
	self->max = 1024;
	self->count = 0;
	self->keys = (const char **) malloc(self->max * sizeof(const char *));
	self->values = (AudioSampleCi const **) malloc(self->max * sizeof(AudioSampleCi const *));
}

DictionaryStringAudioSample *DictionaryStringAudioSample_New(void)
{
	DictionaryStringAudioSample *self = (DictionaryStringAudioSample *) malloc(sizeof(DictionaryStringAudioSample));
	if (self != NULL)
		DictionaryStringAudioSample_Construct(self);
	return self;
}

void DictionaryStringAudioSample_Delete(DictionaryStringAudioSample *self)
{
	free(self);
}

cibool DictionaryStringAudioSample_Contains(DictionaryStringAudioSample const *self, const char *key)
{
	int index = DictionaryStringAudioSample_GetIndex(self, key);
	return index != -1;
}

AudioSampleCi const *DictionaryStringAudioSample_Get(DictionaryStringAudioSample const *self, const char *key)
{
	int index = DictionaryStringAudioSample_GetIndex(self, key);
	return self->values[index];
}

int DictionaryStringAudioSample_GetIndex(DictionaryStringAudioSample const *self, const char *key)
{
	{
		int i;
		for (i = 0; i < self->count; i++) {
			if (strcmp(self->keys[i], key) == 0) {
				return i;
			}
		}
	}
	return -1;
}

void DictionaryStringAudioSample_Set(DictionaryStringAudioSample *self, const char *key, AudioSampleCi const *value)
{
	int index = DictionaryStringAudioSample_GetIndex(self, key);
	if (index != -1) {
		self->values[index] = value;
		return;
	}
	self->keys[self->count] = key;
	self->values[self->count] = value;
	self->count++;
}

static void DictionaryStringByteArray_Construct(DictionaryStringByteArray *self)
{
	self->items = (StringByteArray const **) malloc(1024 * sizeof(StringByteArray const *));
	self->itemsCount = 1024;
}

static unsigned char const *DictionaryStringByteArray_Get(DictionaryStringByteArray const *self, const char *name)
{
	{
		int i;
		for (i = 0; i < self->itemsCount; i++) {
			if (self->items[i] == NULL) {
				continue;
			}
			if (Game_StringEquals(self->items[i]->name, name)) {
				return self->items[i]->data;
			}
		}
	}
	return NULL;
}

static void DictionaryStringByteArray_Set(DictionaryStringByteArray const *self, const char *name, unsigned char const *value)
{
	{
		int i;
		for (i = 0; i < self->itemsCount; i++) {
			if (self->items[i] == NULL) {
				continue;
			}
			if (Game_StringEquals(self->items[i]->name, name)) {
				self->items[i]->data = value;
				return;
			}
		}
	}
	{
		int i;
		for (i = 0; i < self->itemsCount; i++) {
			if (self->items[i] == NULL) {
				self->items[i] = StringByteArray_New();
				self->items[i]->name = name;
				self->items[i]->data = value;
				return;
			}
		}
	}
}

static void DictionaryStringInt1024_Construct(DictionaryStringInt1024 *self)
{
	self->items = (KeyValueStringInt const **) malloc(1024 * sizeof(KeyValueStringInt const *));
	self->count = 0;
}

DictionaryStringInt1024 *DictionaryStringInt1024_New(void)
{
	DictionaryStringInt1024 *self = (DictionaryStringInt1024 *) malloc(sizeof(DictionaryStringInt1024));
	if (self != NULL)
		DictionaryStringInt1024_Construct(self);
	return self;
}

void DictionaryStringInt1024_Delete(DictionaryStringInt1024 *self)
{
	free(self);
}

static cibool DictionaryStringInt1024_Contains(DictionaryStringInt1024 const *self, const char *key)
{
	{
		int i;
		for (i = 0; i < self->count; i++) {
			if (self->items[i] == NULL) {
				continue;
			}
			if (Game_StringEquals(self->items[i]->key, key)) {
				return TRUE;
			}
		}
	}
	return FALSE;
}

static int DictionaryStringInt1024_Get(DictionaryStringInt1024 const *self, const char *key)
{
	{
		int i;
		for (i = 0; i < self->count; i++) {
			if (self->items[i] == NULL) {
				continue;
			}
			if (Game_StringEquals(self->items[i]->key, key)) {
				return self->items[i]->value;
			}
		}
	}
	return -1;
}

cibool DictionaryStringInt1024_Remove(DictionaryStringInt1024 const *self, const char *key)
{
	{
		int i;
		for (i = 0; i < self->count; i++) {
			if (self->items[i] == NULL) {
				continue;
			}
			if (Game_StringEquals(self->items[i]->key, key)) {
				self->items[i] = NULL;
				return TRUE;
			}
		}
	}
	return FALSE;
}

void DictionaryStringInt1024_Set(DictionaryStringInt1024 *self, const char *key, int value)
{
	KeyValueStringInt *k;
	{
		int i;
		for (i = 0; i < self->count; i++) {
			if (self->items[i] == NULL) {
				continue;
			}
			if (strcmp(self->items[i]->key, key) == 0) {
				self->items[i]->value = value;
				return;
			}
		}
	}
	{
		int i;
		for (i = 0; i < self->count; i++) {
			if (self->items[i] == NULL) {
				self->items[i] = KeyValueStringInt_New();
				self->items[i]->key = key;
				self->items[i]->value = value;
				return;
			}
		}
	}
	k = KeyValueStringInt_New();
	k->key = key;
	k->value = value;
	self->items[self->count++] = k;
}

static void DictionaryStringString_Construct(DictionaryStringString *self)
{
	DictionaryStringString_Start(self, 64);
}

DictionaryStringString *DictionaryStringString_New(void)
{
	DictionaryStringString *self = (DictionaryStringString *) malloc(sizeof(DictionaryStringString));
	if (self != NULL)
		DictionaryStringString_Construct(self);
	return self;
}

void DictionaryStringString_Delete(DictionaryStringString *self)
{
	free(self);
}

static cibool DictionaryStringString_ContainsKey(DictionaryStringString const *self, const char *key)
{
	{
		int i;
		for (i = 0; i < self->count; i++) {
			if (self->items[i] == NULL) {
				continue;
			}
			if (Game_StringEquals(self->items[i]->key, key)) {
				return TRUE;
			}
		}
	}
	return FALSE;
}

static const char *DictionaryStringString_Get(DictionaryStringString const *self, const char *key)
{
	{
		int i;
		for (i = 0; i < self->count; i++) {
			if (self->items[i] == NULL) {
				continue;
			}
			if (Game_StringEquals(self->items[i]->key, key)) {
				return self->items[i]->value;
			}
		}
	}
	return NULL;
}

static void DictionaryStringString_Remove(DictionaryStringString const *self, const char *key)
{
	{
		int i;
		for (i = 0; i < self->count; i++) {
			if (self->items[i] == NULL) {
				continue;
			}
			if (Game_StringEquals(self->items[i]->key, key)) {
				self->items[i] = NULL;
			}
		}
	}
}

void DictionaryStringString_Set(DictionaryStringString const *self, const char *key, const char *value)
{
	{
		int i;
		for (i = 0; i < self->count; i++) {
			if (self->items[i] == NULL) {
				continue;
			}
			if (Game_StringEquals(self->items[i]->key, key)) {
				self->items[i]->value = value;
				return;
			}
		}
	}
	{
		int i;
		for (i = 0; i < self->count; i++) {
			if (self->items[i] == NULL) {
				self->items[i] = KeyValueStringString_New();
				self->items[i]->key = key;
				self->items[i]->value = value;
				return;
			}
		}
	}
}

void DictionaryStringString_Start(DictionaryStringString *self, int count_)
{
	self->items = (KeyValueStringString const **) malloc(count_ * sizeof(KeyValueStringString const *));
	self->count = count_;
}

static void DictionaryVector3Float_Construct(DictionaryVector3Float *self)
{
	self->itemsCount = 16384;
	self->items = (Vector3Float const **) malloc(self->itemsCount * sizeof(Vector3Float const *));
}

DictionaryVector3Float *DictionaryVector3Float_New(void)
{
	DictionaryVector3Float *self = (DictionaryVector3Float *) malloc(sizeof(DictionaryVector3Float));
	if (self != NULL)
		DictionaryVector3Float_Construct(self);
	return self;
}

void DictionaryVector3Float_Delete(DictionaryVector3Float *self)
{
	free(self);
}

static void DictionaryVector3Float_Clear(DictionaryVector3Float const *self)
{
	{
		int i;
		for (i = 0; i < self->itemsCount; i++) {
			self->items[i] = NULL;
		}
	}
}

static cibool DictionaryVector3Float_ContainsKey(DictionaryVector3Float const *self, int x, int y, int z)
{
	return DictionaryVector3Float_ItemIndex(self, x, y, z) != -1;
}

static int DictionaryVector3Float_Count(DictionaryVector3Float const *self)
{
	int count = 0;
	{
		int i;
		for (i = 0; i < self->itemsCount; i++) {
			if (self->items[i] != NULL) {
				count++;
			}
		}
	}
	return count;
}

static float DictionaryVector3Float_Get(DictionaryVector3Float const *self, int x, int y, int z)
{
	return self->items[DictionaryVector3Float_ItemIndex(self, x, y, z)]->value;
}

static int DictionaryVector3Float_ItemIndex(DictionaryVector3Float const *self, int x, int y, int z)
{
	{
		int i;
		for (i = 0; i < self->itemsCount; i++) {
			Vector3Float const *item;
			if (self->items[i] == NULL) {
				continue;
			}
			item = self->items[i];
			if (item->x == x && item->y == y && item->z == z) {
				return i;
			}
		}
	}
	return -1;
}

static void DictionaryVector3Float_Remove(DictionaryVector3Float const *self, int x, int y, int z)
{
	if (DictionaryVector3Float_ItemIndex(self, x, y, z) == -1) {
		return;
	}
	self->items[DictionaryVector3Float_ItemIndex(self, x, y, z)] = NULL;
}

static void DictionaryVector3Float_Set(DictionaryVector3Float const *self, int x, int y, int z, float value)
{
	int index = DictionaryVector3Float_ItemIndex(self, x, y, z);
	if (index != -1) {
		self->items[index]->value = value;
	}
	else {
		{
			int i;
			for (i = 0; i < self->itemsCount; i++) {
				if (self->items[i] == NULL) {
					Vector3Float *item = Vector3Float_New();
					item->x = x;
					item->y = y;
					item->z = z;
					item->value = value;
					self->items[i] = item;
					return;
				}
			}
		}
	}
}

VehicleDirection12 const *DirectionUtils_PossibleNewRails3(TileEnterDirection enter_at)
{
	VehicleDirection12 *ret = (VehicleDirection12 *) malloc(3 * sizeof(VehicleDirection12 ));
	switch (enter_at) {
	case TileEnterDirection_LEFT:
		ret[0] = VehicleDirection12_UP_LEFT_UP;
		ret[1] = VehicleDirection12_HORIZONTAL_RIGHT;
		ret[2] = VehicleDirection12_DOWN_LEFT_DOWN;
		break;
	case TileEnterDirection_DOWN:
		ret[0] = VehicleDirection12_DOWN_LEFT_LEFT;
		ret[1] = VehicleDirection12_VERTICAL_UP;
		ret[2] = VehicleDirection12_DOWN_RIGHT_RIGHT;
		break;
	case TileEnterDirection_UP:
		ret[0] = VehicleDirection12_UP_LEFT_LEFT;
		ret[1] = VehicleDirection12_VERTICAL_DOWN;
		ret[2] = VehicleDirection12_UP_RIGHT_RIGHT;
		break;
	case TileEnterDirection_RIGHT:
		ret[0] = VehicleDirection12_UP_RIGHT_UP;
		ret[1] = VehicleDirection12_HORIZONTAL_LEFT;
		ret[2] = VehicleDirection12_DOWN_RIGHT_DOWN;
		break;
	default:
		return NULL;
	}
	return ret;
}

int DirectionUtils_RailDirectionFlagsCount(int railDirectionFlags)
{
	int count = 0;
	if ((railDirectionFlags & DirectionUtils_ToRailDirectionFlags(RailDirection_DOWN_LEFT)) != 0) {
		count++;
	}
	if ((railDirectionFlags & DirectionUtils_ToRailDirectionFlags(RailDirection_DOWN_RIGHT)) != 0) {
		count++;
	}
	if ((railDirectionFlags & DirectionUtils_ToRailDirectionFlags(RailDirection_HORIZONTAL)) != 0) {
		count++;
	}
	if ((railDirectionFlags & DirectionUtils_ToRailDirectionFlags(RailDirection_UP_LEFT)) != 0) {
		count++;
	}
	if ((railDirectionFlags & DirectionUtils_ToRailDirectionFlags(RailDirection_UP_RIGHT)) != 0) {
		count++;
	}
	if ((railDirectionFlags & DirectionUtils_ToRailDirectionFlags(RailDirection_VERTICAL)) != 0) {
		count++;
	}
	return count;
}

TileEnterDirection DirectionUtils_ResultEnter(TileExitDirection direction)
{
	switch (direction) {
	case TileExitDirection_UP:
		return TileEnterDirection_DOWN;
	case TileExitDirection_DOWN:
		return TileEnterDirection_UP;
	case TileExitDirection_LEFT:
		return TileEnterDirection_RIGHT;
	case TileExitDirection_RIGHT:
		return TileEnterDirection_LEFT;
	default:
		return TileEnterDirection_DOWN;
	}
}

TileExitDirection DirectionUtils_ResultExit(VehicleDirection12 direction)
{
	switch (direction) {
	case VehicleDirection12_HORIZONTAL_LEFT:
		return TileExitDirection_LEFT;
	case VehicleDirection12_HORIZONTAL_RIGHT:
		return TileExitDirection_RIGHT;
	case VehicleDirection12_VERTICAL_UP:
		return TileExitDirection_UP;
	case VehicleDirection12_VERTICAL_DOWN:
		return TileExitDirection_DOWN;
	case VehicleDirection12_UP_LEFT_UP:
		return TileExitDirection_UP;
	case VehicleDirection12_UP_LEFT_LEFT:
		return TileExitDirection_LEFT;
	case VehicleDirection12_UP_RIGHT_UP:
		return TileExitDirection_UP;
	case VehicleDirection12_UP_RIGHT_RIGHT:
		return TileExitDirection_RIGHT;
	case VehicleDirection12_DOWN_LEFT_DOWN:
		return TileExitDirection_DOWN;
	case VehicleDirection12_DOWN_LEFT_LEFT:
		return TileExitDirection_LEFT;
	case VehicleDirection12_DOWN_RIGHT_DOWN:
		return TileExitDirection_DOWN;
	case VehicleDirection12_DOWN_RIGHT_RIGHT:
		return TileExitDirection_RIGHT;
	default:
		return TileExitDirection_DOWN;
	}
}

VehicleDirection12 DirectionUtils_Reverse(VehicleDirection12 direction)
{
	switch (direction) {
	case VehicleDirection12_HORIZONTAL_LEFT:
		return VehicleDirection12_HORIZONTAL_RIGHT;
	case VehicleDirection12_HORIZONTAL_RIGHT:
		return VehicleDirection12_HORIZONTAL_LEFT;
	case VehicleDirection12_VERTICAL_UP:
		return VehicleDirection12_VERTICAL_DOWN;
	case VehicleDirection12_VERTICAL_DOWN:
		return VehicleDirection12_VERTICAL_UP;
	case VehicleDirection12_UP_LEFT_UP:
		return VehicleDirection12_UP_LEFT_LEFT;
	case VehicleDirection12_UP_LEFT_LEFT:
		return VehicleDirection12_UP_LEFT_UP;
	case VehicleDirection12_UP_RIGHT_UP:
		return VehicleDirection12_UP_RIGHT_RIGHT;
	case VehicleDirection12_UP_RIGHT_RIGHT:
		return VehicleDirection12_UP_RIGHT_UP;
	case VehicleDirection12_DOWN_LEFT_DOWN:
		return VehicleDirection12_DOWN_LEFT_LEFT;
	case VehicleDirection12_DOWN_LEFT_LEFT:
		return VehicleDirection12_DOWN_LEFT_DOWN;
	case VehicleDirection12_DOWN_RIGHT_DOWN:
		return VehicleDirection12_DOWN_RIGHT_RIGHT;
	case VehicleDirection12_DOWN_RIGHT_RIGHT:
		return VehicleDirection12_DOWN_RIGHT_DOWN;
	default:
		return VehicleDirection12_DOWN_LEFT_DOWN;
	}
}

RailDirection DirectionUtils_ToRailDirection(VehicleDirection12 direction)
{
	switch (direction) {
	case VehicleDirection12_HORIZONTAL_LEFT:
		return RailDirection_HORIZONTAL;
	case VehicleDirection12_HORIZONTAL_RIGHT:
		return RailDirection_HORIZONTAL;
	case VehicleDirection12_VERTICAL_UP:
		return RailDirection_VERTICAL;
	case VehicleDirection12_VERTICAL_DOWN:
		return RailDirection_VERTICAL;
	case VehicleDirection12_UP_LEFT_UP:
		return RailDirection_UP_LEFT;
	case VehicleDirection12_UP_LEFT_LEFT:
		return RailDirection_UP_LEFT;
	case VehicleDirection12_UP_RIGHT_UP:
		return RailDirection_UP_RIGHT;
	case VehicleDirection12_UP_RIGHT_RIGHT:
		return RailDirection_UP_RIGHT;
	case VehicleDirection12_DOWN_LEFT_DOWN:
		return RailDirection_DOWN_LEFT;
	case VehicleDirection12_DOWN_LEFT_LEFT:
		return RailDirection_DOWN_LEFT;
	case VehicleDirection12_DOWN_RIGHT_DOWN:
		return RailDirection_DOWN_RIGHT;
	case VehicleDirection12_DOWN_RIGHT_RIGHT:
		return RailDirection_DOWN_RIGHT;
	default:
		return RailDirection_DOWN_LEFT;
	}
}

int DirectionUtils_ToRailDirectionFlags(RailDirection direction)
{
	switch (direction) {
	case RailDirection_DOWN_LEFT:
		return 16;
	case RailDirection_DOWN_RIGHT:
		return 32;
	case RailDirection_HORIZONTAL:
		return 1;
	case RailDirection_UP_LEFT:
		return 4;
	case RailDirection_UP_RIGHT:
		return 8;
	case RailDirection_VERTICAL:
		return 2;
	default:
		return 0;
	}
}

int DirectionUtils_ToVehicleDirection12Flags(VehicleDirection12 direction)
{
	switch (direction) {
	case VehicleDirection12_HORIZONTAL_LEFT:
		return 1;
	case VehicleDirection12_HORIZONTAL_RIGHT:
		return 2;
	case VehicleDirection12_VERTICAL_UP:
		return 4;
	case VehicleDirection12_VERTICAL_DOWN:
		return 8;
	case VehicleDirection12_UP_LEFT_UP:
		return 16;
	case VehicleDirection12_UP_LEFT_LEFT:
		return 32;
	case VehicleDirection12_UP_RIGHT_UP:
		return 64;
	case VehicleDirection12_UP_RIGHT_RIGHT:
		return 128;
	case VehicleDirection12_DOWN_LEFT_DOWN:
		return 256;
	case VehicleDirection12_DOWN_LEFT_LEFT:
		return 512;
	case VehicleDirection12_DOWN_RIGHT_DOWN:
		return 1024;
	case VehicleDirection12_DOWN_RIGHT_RIGHT:
		return 2048;
	default:
		return 0;
	}
}

int DirectionUtils_ToVehicleDirection12Flags_(VehicleDirection12 const *directions, int directionsCount)
{
	int flags = 0;
	{
		int i;
		for (i = 0; i < directionsCount; i++) {
			VehicleDirection12 d = directions[i];
			flags = flags | DirectionUtils_ToVehicleDirection12Flags(d);
		}
	}
	return flags;
}

DisplayResolutionCi *DisplayResolutionCi_New(void)
{
	DisplayResolutionCi *self = (DisplayResolutionCi *) malloc(sizeof(DisplayResolutionCi));
	return self;
}

void DisplayResolutionCi_Delete(DisplayResolutionCi *self)
{
	free(self);
}

int DisplayResolutionCi_GetBitsPerPixel(DisplayResolutionCi const *self)
{
	return self->bitsPerPixel;
}

int DisplayResolutionCi_GetHeight(DisplayResolutionCi const *self)
{
	return self->height;
}

float DisplayResolutionCi_GetRefreshRate(DisplayResolutionCi const *self)
{
	return self->refreshRate;
}

int DisplayResolutionCi_GetWidth(DisplayResolutionCi const *self)
{
	return self->width;
}

void DisplayResolutionCi_SetBitsPerPixel(DisplayResolutionCi *self, int value)
{
	self->bitsPerPixel = value;
}

void DisplayResolutionCi_SetHeight(DisplayResolutionCi *self, int value)
{
	self->height = value;
}

void DisplayResolutionCi_SetRefreshRate(DisplayResolutionCi *self, float value)
{
	self->refreshRate = value;
}

void DisplayResolutionCi_SetWidth(DisplayResolutionCi *self, int value)
{
	self->width = value;
}

Draw2dData *Draw2dData_New(void)
{
	Draw2dData *self = (Draw2dData *) malloc(sizeof(Draw2dData));
	return self;
}

void Draw2dData_Delete(Draw2dData *self)
{
	free(self);
}

DrawName *DrawName_New(void)
{
	DrawName *self = (DrawName *) malloc(sizeof(DrawName));
	return self;
}

void DrawName_Delete(DrawName *self)
{
	free(self);
}

static void DrawWireframeCube_Construct(DrawWireframeCube *self)
{
	self->one = 1;
}

DrawWireframeCube *DrawWireframeCube_New(void)
{
	DrawWireframeCube *self = (DrawWireframeCube *) malloc(sizeof(DrawWireframeCube));
	if (self != NULL)
		DrawWireframeCube_Construct(self);
	return self;
}

void DrawWireframeCube_Delete(DrawWireframeCube *self)
{
	free(self);
}

void DrawWireframeCube_DrawWireframeCube_(DrawWireframeCube *self, Game const *game, float posx, float posy, float posz, float scalex, float scaley, float scalez)
{
	float half;
	game->platform->vtbl->gLLineWidth(game->platform, 2);
	game->platform->vtbl->bindTexture2d(game->platform, 0);
	if (self->wireframeCube == NULL) {
		ModelData const *data = WireframeCube_Get();
		self->wireframeCube = game->platform->vtbl->createModel(game->platform, data);
	}
	Game_GLPushMatrix(game);
	Game_GLTranslate(game, posx, posy, posz);
	half = self->one / 2;
	Game_GLScale(game, scalex * half, scaley * half, scalez * half);
	Game_DrawModel(game, self->wireframeCube);
	Game_GLPopMatrix(game);
}

static void DummyIpEndPoint_Construct(DummyIpEndPoint *self, const IPEndPointCiVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_DummyIpEndPoint;
	IPEndPointCi_Construct(&self->base, vtbl);
}

DummyIpEndPoint *DummyIpEndPoint_New(void)
{
	DummyIpEndPoint *self = (DummyIpEndPoint *) malloc(sizeof(DummyIpEndPoint));
	if (self != NULL)
		DummyIpEndPoint_Construct(self, NULL);
	return self;
}

void DummyIpEndPoint_Delete(DummyIpEndPoint *self)
{
	free(self);
}

const char *DummyIpEndPoint_AddressToString(DummyIpEndPoint const *self)
{
	return "127.0.0.1";
}

static void DummyNetClient_Construct(DummyNetClient *self, const NetClientVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_DummyNetClient;
	NetClient_Construct(&self->base, vtbl);
}

DummyNetClient *DummyNetClient_New(void)
{
	DummyNetClient *self = (DummyNetClient *) malloc(sizeof(DummyNetClient));
	if (self != NULL)
		DummyNetClient_Construct(self, NULL);
	return self;
}

void DummyNetClient_Delete(DummyNetClient *self)
{
	free(self);
}

NetConnection const *DummyNetClient_Connect(DummyNetClient const *self, const char *ip, int port)
{
	return &DummyNetConnection_New()->base;
}

NetIncomingMessage const *DummyNetClient_ReadMessage(DummyNetClient const *self)
{
	NetIncomingMessage *msg = NULL;
	self->platform->vtbl->monitorEnter(self->platform, self->network->clientReceiveBufferLock);
	{
		if (QueueByteArray_Count(self->network->clientReceiveBuffer) > 0) {
			ByteArray const *b;
			msg = NetIncomingMessage_New();
			b = QueueByteArray_Dequeue(self->network->clientReceiveBuffer);
			msg->message = b->data;
			msg->messageLength = b->length;
		}
	}
	self->platform->vtbl->monitorExit(self->platform, self->network->clientReceiveBufferLock);
	return msg;
}

void DummyNetClient_SendMessage(DummyNetClient const *self, INetOutgoingMessage const *message, MyNetDeliveryMethod method)
{
	self->platform->vtbl->monitorEnter(self->platform, self->network->serverReceiveBufferLock);
	{
		INetOutgoingMessage const *msg = message;
		ByteArray *b = ByteArray_New();
		b->data = msg->message;
		b->length = msg->messageLength;
		QueueByteArray_Enqueue(self->network->serverReceiveBuffer, b);
	}
	self->platform->vtbl->monitorExit(self->platform, self->network->serverReceiveBufferLock);
}

void DummyNetClient_SetNetwork(DummyNetClient *self, DummyNetwork const *network_)
{
	self->network = network_;
}

void DummyNetClient_SetPlatform(DummyNetClient *self, GamePlatform const *gamePlatform)
{
	self->platform = gamePlatform;
}

void DummyNetClient_Start(DummyNetClient const *self)
{
}

static void DummyNetConnection_Construct(DummyNetConnection *self, const NetConnectionVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_DummyNetConnection;
	NetConnection_Construct(&self->base, vtbl);
}

DummyNetConnection *DummyNetConnection_New(void)
{
	DummyNetConnection *self = (DummyNetConnection *) malloc(sizeof(DummyNetConnection));
	if (self != NULL)
		DummyNetConnection_Construct(self, NULL);
	return self;
}

void DummyNetConnection_Delete(DummyNetConnection *self)
{
	free(self);
}

cibool DummyNetConnection_EqualsConnection(DummyNetConnection const *self, NetConnection const *connection)
{
	return TRUE;
}

IPEndPointCi const *DummyNetConnection_RemoteEndPoint(DummyNetConnection const *self)
{
	return &DummyIpEndPoint_New()->base;
}

void DummyNetConnection_SendMessage(DummyNetConnection const *self, INetOutgoingMessage const *msg, MyNetDeliveryMethod method, int sequenceChannel)
{
	self->platform->vtbl->monitorEnter(self->platform, self->network->clientReceiveBufferLock);
	{
		INetOutgoingMessage const *msg2 = msg;
		ByteArray *b = ByteArray_New();
		b->data = msg2->message;
		b->length = msg2->messageLength;
		QueueByteArray_Enqueue(self->network->clientReceiveBuffer, b);
	}
	self->platform->vtbl->monitorExit(self->platform, self->network->clientReceiveBufferLock);
}

void DummyNetConnection_Update(DummyNetConnection const *self)
{
}

DummyNetOutgoingMessage *DummyNetOutgoingMessage_New(void)
{
	DummyNetOutgoingMessage *self = (DummyNetOutgoingMessage *) malloc(sizeof(DummyNetOutgoingMessage));
	return self;
}

void DummyNetOutgoingMessage_Delete(DummyNetOutgoingMessage *self)
{
	free(self);
}

static void DummyNetServer_Construct(DummyNetServer *self, const NetServerVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_DummyNetServer;
	NetServer_Construct(&self->base, vtbl);
	self->connectedClient = DummyNetConnection_New();
}

DummyNetServer *DummyNetServer_New(void)
{
	DummyNetServer *self = (DummyNetServer *) malloc(sizeof(DummyNetServer));
	if (self != NULL)
		DummyNetServer_Construct(self, NULL);
	return self;
}

void DummyNetServer_Delete(DummyNetServer *self)
{
	free(self);
}

NetIncomingMessage const *DummyNetServer_ReadMessage(DummyNetServer *self)
{
	NetIncomingMessage *msg;
	self->connectedClient->network = self->network;
	self->connectedClient->platform = self->platform;
	msg = NULL;
	self->platform->vtbl->monitorEnter(self->platform, self->network->serverReceiveBufferLock);
	{
		if (QueueByteArray_Count(self->network->serverReceiveBuffer) > 0) {
			if (!self->receivedAnyMessage) {
				self->receivedAnyMessage = TRUE;
				msg = NetIncomingMessage_New();
				msg->type = NetworkMessageType_CONNECT;
				msg->senderConnection = &self->connectedClient->base;
			}
			else {
				ByteArray const *b;
				msg = NetIncomingMessage_New();
				b = QueueByteArray_Dequeue(self->network->serverReceiveBuffer);
				msg->message = b->data;
				msg->messageLength = b->length;
				msg->senderConnection = &self->connectedClient->base;
			}
		}
	}
	self->platform->vtbl->monitorExit(self->platform, self->network->serverReceiveBufferLock);
	return msg;
}

void DummyNetServer_SetNetwork(DummyNetServer *self, DummyNetwork const *dummyNetwork)
{
	self->network = dummyNetwork;
}

void DummyNetServer_SetPlatform(DummyNetServer *self, GamePlatform const *gamePlatform)
{
	self->platform = gamePlatform;
}

void DummyNetServer_SetPort(DummyNetServer const *self, int port)
{
}

void DummyNetServer_Start(DummyNetServer const *self)
{
}

static void DummyNetwork_Construct(DummyNetwork *self)
{
	DummyNetwork_Clear(self);
}

DummyNetwork *DummyNetwork_New(void)
{
	DummyNetwork *self = (DummyNetwork *) malloc(sizeof(DummyNetwork));
	if (self != NULL)
		DummyNetwork_Construct(self);
	return self;
}

void DummyNetwork_Delete(DummyNetwork *self)
{
	free(self);
}

void DummyNetwork_Clear(DummyNetwork *self)
{
	self->serverReceiveBuffer = QueueByteArray_New();
	self->clientReceiveBuffer = QueueByteArray_New();
}

void DummyNetwork_Start(DummyNetwork *self, MonitorObject const *lock1, MonitorObject const *lock2)
{
	self->serverReceiveBufferLock = lock1;
	self->clientReceiveBufferLock = lock2;
}

static void EnetEvent_Construct(EnetEvent *self, const EnetEventVtbl *vtbl)
{
	self->vtbl = vtbl;
}

EnetEventRef *EnetEventRef_New(void)
{
	EnetEventRef *self = (EnetEventRef *) malloc(sizeof(EnetEventRef));
	return self;
}

void EnetEventRef_Delete(EnetEventRef *self)
{
	free(self);
}

static void EnetNetClient_Construct(EnetNetClient *self, const NetClientVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_EnetNetClient;
	NetClient_Construct(&self->base, vtbl);
}

EnetNetClient *EnetNetClient_New(void)
{
	EnetNetClient *self = (EnetNetClient *) malloc(sizeof(EnetNetClient));
	if (self != NULL)
		EnetNetClient_Construct(self, NULL);
	return self;
}

void EnetNetClient_Delete(EnetNetClient *self)
{
	free(self);
}

NetConnection const *EnetNetClient_Connect(EnetNetClient *self, const char *ip, int port)
{
	self->peer = self->platform->vtbl->enetHostConnect(self->platform, self->host, ip, port, 1234, 200);
	self->connected = TRUE;
	return NULL;
}

static void EnetNetClient_DoSendPacket(EnetNetClient const *self, INetOutgoingMessage const *msg)
{
	INetOutgoingMessage const *msg1 = msg;
	self->platform->vtbl->enetPeerSend(self->platform, self->peer, 0, msg1->message, msg1->messageLength, 1);
}

NetIncomingMessage const *EnetNetClient_ReadMessage(EnetNetClient *self)
{
	EnetEventRef const *event_;
	if (!self->connected) {
		return NULL;
	}
	if (QueueNetIncomingMessage_Count(self->messages) > 0) {
		return QueueNetIncomingMessage_Dequeue(self->messages);
	}
	if (self->connected2) {
		while (QueueINetOutgoingMessage_Count(self->tosend) > 0) {
			INetOutgoingMessage const *msg = QueueINetOutgoingMessage_Dequeue(self->tosend);
			EnetNetClient_DoSendPacket(self, msg);
		}
	}
	event_ = EnetEventRef_New();
	if (self->platform->vtbl->enetHostService(self->platform, self->host, 0, event_)) {
		do {
			switch (event_->e->vtbl->type(event_->e)) {
				unsigned char *data;
				int dataLength;
				NetIncomingMessage *msg;
			case EnetEventType_CONNECT:
				self->connected2 = TRUE;
				break;
			case EnetEventType_RECEIVE:
				data = event_->e->vtbl->packet(event_->e)->vtbl->getBytes(event_->e->vtbl->packet(event_->e));
				dataLength = event_->e->vtbl->packet(event_->e)->vtbl->getBytesCount(event_->e->vtbl->packet(event_->e));
				event_->e->vtbl->packet(event_->e)->vtbl->dispose(event_->e->vtbl->packet(event_->e));
				msg = NetIncomingMessage_New();
				msg->message = data;
				msg->messageLength = dataLength;
				QueueNetIncomingMessage_Enqueue(self->messages, msg);
				break;
			}
		}
		while (self->platform->vtbl->enetHostCheckEvents(self->platform, self->host, event_));
	}
	if (QueueNetIncomingMessage_Count(self->messages) > 0) {
		return QueueNetIncomingMessage_Dequeue(self->messages);
	}
	return NULL;
}

void EnetNetClient_SendMessage(EnetNetClient const *self, INetOutgoingMessage const *message, MyNetDeliveryMethod method)
{
	INetOutgoingMessage const *msg = message;
	if (!self->connected2) {
		QueueINetOutgoingMessage_Enqueue(self->tosend, msg);
		return;
	}
	EnetNetClient_DoSendPacket(self, msg);
}

void EnetNetClient_SetPlatform(EnetNetClient *self, GamePlatform const *platform_)
{
	self->platform = platform_;
}

void EnetNetClient_Start(EnetNetClient *self)
{
	self->host = self->platform->vtbl->enetCreateHost(self->platform);
	self->platform->vtbl->enetHostInitialize(self->platform, self->host, NULL, 1, 0, 0, 0);
	self->tosend = QueueINetOutgoingMessage_New();
	self->messages = QueueNetIncomingMessage_New();
}

static void EnetNetConnection_Construct(EnetNetConnection *self, const NetConnectionVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_EnetNetConnection;
	NetConnection_Construct(&self->base, vtbl);
}

EnetNetConnection *EnetNetConnection_New(void)
{
	EnetNetConnection *self = (EnetNetConnection *) malloc(sizeof(EnetNetConnection));
	if (self != NULL)
		EnetNetConnection_Construct(self, NULL);
	return self;
}

void EnetNetConnection_Delete(EnetNetConnection *self)
{
	free(self);
}

cibool EnetNetConnection_EqualsConnection(EnetNetConnection const *self, NetConnection const *connection)
{
	return self->peer->vtbl->userData(self->peer) == self->platform->vtbl->castToEnetNetConnection(self->platform, connection)->peer->vtbl->userData(self->platform->vtbl->castToEnetNetConnection(self->platform, connection)->peer);
}

IPEndPointCi const *EnetNetConnection_RemoteEndPoint(EnetNetConnection const *self)
{
	return &IPEndPointCiDefault_Create(self->peer->vtbl->getRemoteAddress(self->peer)->vtbl->addressToString(self->peer->vtbl->getRemoteAddress(self->peer)))->base;
}

void EnetNetConnection_SendMessage(EnetNetConnection const *self, INetOutgoingMessage const *msg, MyNetDeliveryMethod method, int sequenceChannel)
{
	INetOutgoingMessage const *msg1 = msg;
	self->platform->vtbl->enetPeerSend(self->platform, self->peer, 0, msg1->message, msg1->messageLength, 1);
}

void EnetNetConnection_Update(EnetNetConnection const *self)
{
}

static void EnetNetServer_Construct(EnetNetServer *self, const NetServerVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_EnetNetServer;
	NetServer_Construct(&self->base, vtbl);
	self->event_ = EnetEventRef_New();
	self->messages = QueueNetIncomingMessage_New();
}

EnetNetServer *EnetNetServer_New(void)
{
	EnetNetServer *self = (EnetNetServer *) malloc(sizeof(EnetNetServer));
	if (self != NULL)
		EnetNetServer_Construct(self, NULL);
	return self;
}

void EnetNetServer_Delete(EnetNetServer *self)
{
	free(self);
}

NetIncomingMessage const *EnetNetServer_ReadMessage(EnetNetServer *self)
{
	if (QueueNetIncomingMessage_Count(self->messages) > 0) {
		return QueueNetIncomingMessage_Dequeue(self->messages);
	}
	if (self->platform->vtbl->enetHostService(self->platform, self->host, 0, self->event_)) {
		do {
			switch (self->event_->e->vtbl->type(self->event_->e)) {
			case EnetEventType_CONNECT:
				{
					EnetPeer const *peer = self->event_->e->vtbl->peer(self->event_->e);
					EnetNetConnection *senderConnectionConnect;
					NetIncomingMessage *message;
					peer->vtbl->setUserData(peer, self->clientid++);
					senderConnectionConnect = EnetNetConnection_New();
					senderConnectionConnect->platform = self->platform;
					senderConnectionConnect->peer = self->event_->e->vtbl->peer(self->event_->e);
					message = NetIncomingMessage_New();
					message->senderConnection = &senderConnectionConnect->base;
					message->type = NetworkMessageType_CONNECT;
					QueueNetIncomingMessage_Enqueue(self->messages, message);
				}
				break;
			case EnetEventType_RECEIVE:
				{
					unsigned char *data = self->event_->e->vtbl->packet(self->event_->e)->vtbl->getBytes(self->event_->e->vtbl->packet(self->event_->e));
					EnetNetConnection *senderConnectionReceive;
					NetIncomingMessage *message;
					self->event_->e->vtbl->packet(self->event_->e)->vtbl->dispose(self->event_->e->vtbl->packet(self->event_->e));
					senderConnectionReceive = EnetNetConnection_New();
					senderConnectionReceive->platform = self->platform;
					senderConnectionReceive->peer = self->event_->e->vtbl->peer(self->event_->e);
					message = NetIncomingMessage_New();
					message->senderConnection = &senderConnectionReceive->base;
					message->message = data;
					message->type = NetworkMessageType_DATA;
					QueueNetIncomingMessage_Enqueue(self->messages, message);
				}
				break;
			case EnetEventType_DISCONNECT:
				{
					EnetNetConnection *senderConnectionDisconnect = EnetNetConnection_New();
					NetIncomingMessage *message;
					senderConnectionDisconnect->platform = self->platform;
					senderConnectionDisconnect->peer = self->event_->e->vtbl->peer(self->event_->e);
					message = NetIncomingMessage_New();
					message->senderConnection = &senderConnectionDisconnect->base;
					message->type = NetworkMessageType_DISCONNECT;
					QueueNetIncomingMessage_Enqueue(self->messages, message);
				}
				break;
			}
		}
		while (self->platform->vtbl->enetHostCheckEvents(self->platform, self->host, self->event_));
	}
	if (QueueNetIncomingMessage_Count(self->messages) > 0) {
		return QueueNetIncomingMessage_Dequeue(self->messages);
	}
	return NULL;
}

void EnetNetServer_SetPort(EnetNetServer *self, int port)
{
	self->port = port;
}

void EnetNetServer_Start(EnetNetServer *self)
{
	self->host = self->platform->vtbl->enetCreateHost(self->platform);
	self->platform->vtbl->enetHostInitializeServer(self->platform, self->host, self->port, 256);
}

static void EnetPacket_Construct(EnetPacket *self, const EnetPacketVtbl *vtbl)
{
	self->vtbl = vtbl;
}

static void EnetPeer_Construct(EnetPeer *self, const EnetPeerVtbl *vtbl)
{
	self->vtbl = vtbl;
}

static void Entity_Construct(Entity *self)
{
	self->scripts = (EntityScript const **) malloc(8 * sizeof(EntityScript const *));
	self->scriptsCount = 0;
}

Entity *Entity_New(void)
{
	Entity *self = (Entity *) malloc(sizeof(Entity));
	if (self != NULL)
		Entity_Construct(self);
	return self;
}

void Entity_Delete(Entity *self)
{
	free(self);
}

EntityDrawArea *EntityDrawArea_New(void)
{
	EntityDrawArea *self = (EntityDrawArea *) malloc(sizeof(EntityDrawArea));
	return self;
}

void EntityDrawArea_Delete(EntityDrawArea *self)
{
	free(self);
}

static void EntityDrawModel_Construct(EntityDrawModel *self)
{
	self->currentTexture = -1;
}

EntityDrawModel *EntityDrawModel_New(void)
{
	EntityDrawModel *self = (EntityDrawModel *) malloc(sizeof(EntityDrawModel));
	if (self != NULL)
		EntityDrawModel_Construct(self);
	return self;
}

void EntityDrawModel_Delete(EntityDrawModel *self)
{
	free(self);
}

EntityDrawText *EntityDrawText_New(void)
{
	EntityDrawText *self = (EntityDrawText *) malloc(sizeof(EntityDrawText));
	return self;
}

void EntityDrawText_Delete(EntityDrawText *self)
{
	free(self);
}

EntityPosition_ *EntityPosition__New(void)
{
	EntityPosition_ *self = (EntityPosition_ *) malloc(sizeof(EntityPosition_));
	return self;
}

void EntityPosition__Delete(EntityPosition_ *self)
{
	free(self);
}

static void EntityScript_Construct(EntityScript *self, const EntityScriptVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_EntityScript;
	self->vtbl = vtbl;
}

void EntityScript_OnNewFrameFixed(EntityScript const *self, Game const *game, int entity, float dt)
{
}

Expires *Expires_New(void)
{
	Expires *self = (Expires *) malloc(sizeof(Expires));
	return self;
}

void Expires_Delete(Expires *self)
{
	free(self);
}

static Expires *Expires_Create(float p)
{
	Expires *expires = Expires_New();
	expires->totalTime = p;
	expires->timeLeft = p;
	return expires;
}

FastQueueInt *FastQueueInt_New(void)
{
	FastQueueInt *self = (FastQueueInt *) malloc(sizeof(FastQueueInt));
	return self;
}

void FastQueueInt_Delete(FastQueueInt *self)
{
	free(self);
}

void FastQueueInt_Clear(FastQueueInt *self)
{
	self->count = 0;
}

void FastQueueInt_Initialize(FastQueueInt *self, int maxCount)
{
	self->maxCount = maxCount;
	self->values = (int *) malloc(maxCount * sizeof(int ));
	self->count = 0;
	self->start = 0;
	self->end = 0;
}

int FastQueueInt_Pop(FastQueueInt *self)
{
	int value = self->values[self->start];
	self->count--;
	self->start++;
	if (self->start >= self->maxCount) {
		self->start = 0;
	}
	return value;
}

void FastQueueInt_Push(FastQueueInt *self, int value)
{
	self->values[self->end] = value;
	self->count++;
	self->end++;
	if (self->end >= self->maxCount) {
		self->end = 0;
	}
}

FastStackInt *FastStackInt_New(void)
{
	FastStackInt *self = (FastStackInt *) malloc(sizeof(FastStackInt));
	return self;
}

void FastStackInt_Delete(FastStackInt *self)
{
	free(self);
}

void FastStackInt_Clear(FastStackInt *self)
{
	self->count = 0;
}

static int FastStackInt_Count_(FastStackInt const *self)
{
	return self->count;
}

void FastStackInt_Initialize(FastStackInt *self, int maxCount)
{
	self->valuesLength = maxCount;
	self->values = (int *) malloc(maxCount * sizeof(int ));
}

int FastStackInt_Pop(FastStackInt *self)
{
	self->count--;
	return self->values[self->count];
}

void FastStackInt_Push(FastStackInt *self, int value)
{
	while (self->count >= self->valuesLength) {
		int *values2 = (int *) malloc(self->valuesLength * 2 * sizeof(int ));
		{
			int i;
			for (i = 0; i < self->valuesLength; i++) {
				values2[i] = self->values[i];
			}
		}
		self->values = values2;
		self->valuesLength = self->valuesLength * 2;
	}
	self->values[self->count] = value;
	self->count++;
}

FloatRef *FloatRef_New(void)
{
	FloatRef *self = (FloatRef *) malloc(sizeof(FloatRef));
	return self;
}

void FloatRef_Delete(FloatRef *self)
{
	free(self);
}

FloatRef *FloatRef_Create(float value_)
{
	FloatRef *f = FloatRef_New();
	f->value = value_;
	return f;
}

float FloatRef_GetValue(FloatRef const *self)
{
	return self->value;
}

void FloatRef_SetValue(FloatRef *self, float value_)
{
	self->value = value_;
}

FontCi *FontCi_New(void)
{
	FontCi *self = (FontCi *) malloc(sizeof(FontCi));
	return self;
}

void FontCi_Delete(FontCi *self)
{
	free(self);
}

static FontCi const *FontCi_Create(const char *family_, float size_, int style_)
{
	FontCi *f = FontCi_New();
	f->family = family_;
	f->size = size_;
	f->style = style_;
	return f;
}

FrustumCulling *FrustumCulling_New(void)
{
	FrustumCulling *self = (FrustumCulling *) malloc(sizeof(FrustumCulling));
	return self;
}

void FrustumCulling_Delete(FrustumCulling *self)
{
	free(self);
}

void FrustumCulling_CalcFrustumEquations(FrustumCulling *self)
{
	float t;
	float const *matModelView = self->d_GetCameraMatrix->vtbl->getModelViewMatrix(self->d_GetCameraMatrix);
	float const *matProjection = self->d_GetCameraMatrix->vtbl->getProjectionMatrix(self->d_GetCameraMatrix);
	float *matFrustum = Mat4_Create();
	Mat4_Multiply(matFrustum, matProjection, matModelView);
	{
		float const *clip1 = matFrustum;
		{
			self->frustum00 = clip1[3] - clip1[0];
			self->frustum01 = clip1[7] - clip1[4];
			self->frustum02 = clip1[11] - clip1[8];
			self->frustum03 = clip1[15] - clip1[12];
			t = self->platform->vtbl->mathSqrt(self->platform, self->frustum00 * self->frustum00 + self->frustum01 * self->frustum01 + self->frustum02 * self->frustum02);
			self->frustum00 /= t;
			self->frustum01 /= t;
			self->frustum02 /= t;
			self->frustum03 /= t;
			self->frustum10 = clip1[3] + clip1[0];
			self->frustum11 = clip1[7] + clip1[4];
			self->frustum12 = clip1[11] + clip1[8];
			self->frustum13 = clip1[15] + clip1[12];
			t = self->platform->vtbl->mathSqrt(self->platform, self->frustum10 * self->frustum10 + self->frustum11 * self->frustum11 + self->frustum12 * self->frustum12);
			self->frustum10 /= t;
			self->frustum11 /= t;
			self->frustum12 /= t;
			self->frustum13 /= t;
			self->frustum20 = clip1[3] + clip1[1];
			self->frustum21 = clip1[7] + clip1[5];
			self->frustum22 = clip1[11] + clip1[9];
			self->frustum23 = clip1[15] + clip1[13];
			t = self->platform->vtbl->mathSqrt(self->platform, self->frustum20 * self->frustum20 + self->frustum21 * self->frustum21 + self->frustum22 * self->frustum22);
			self->frustum20 /= t;
			self->frustum21 /= t;
			self->frustum22 /= t;
			self->frustum23 /= t;
			self->frustum30 = clip1[3] - clip1[1];
			self->frustum31 = clip1[7] - clip1[5];
			self->frustum32 = clip1[11] - clip1[9];
			self->frustum33 = clip1[15] - clip1[13];
			t = self->platform->vtbl->mathSqrt(self->platform, self->frustum30 * self->frustum30 + self->frustum31 * self->frustum31 + self->frustum32 * self->frustum32);
			self->frustum30 /= t;
			self->frustum31 /= t;
			self->frustum32 /= t;
			self->frustum33 /= t;
			self->frustum40 = clip1[3] - clip1[2];
			self->frustum41 = clip1[7] - clip1[6];
			self->frustum42 = clip1[11] - clip1[10];
			self->frustum43 = clip1[15] - clip1[14];
			t = self->platform->vtbl->mathSqrt(self->platform, self->frustum40 * self->frustum40 + self->frustum41 * self->frustum41 + self->frustum42 * self->frustum42);
			self->frustum40 /= t;
			self->frustum41 /= t;
			self->frustum42 /= t;
			self->frustum43 /= t;
			self->frustum50 = clip1[3] + clip1[2];
			self->frustum51 = clip1[7] + clip1[6];
			self->frustum52 = clip1[11] + clip1[10];
			self->frustum53 = clip1[15] + clip1[14];
			t = self->platform->vtbl->mathSqrt(self->platform, self->frustum50 * self->frustum50 + self->frustum51 * self->frustum51 + self->frustum52 * self->frustum52);
			self->frustum50 /= t;
			self->frustum51 /= t;
			self->frustum52 /= t;
			self->frustum53 /= t;
		}
	}
}

cibool FrustumCulling_SphereInFrustum(FrustumCulling const *self, float x, float y, float z, float radius)
{
	float d = 0;
	d = self->frustum00 * x + self->frustum01 * y + self->frustum02 * z + self->frustum03;
	if (d <= -radius)
		return FALSE;
	d = self->frustum10 * x + self->frustum11 * y + self->frustum12 * z + self->frustum13;
	if (d <= -radius)
		return FALSE;
	d = self->frustum20 * x + self->frustum21 * y + self->frustum22 * z + self->frustum23;
	if (d <= -radius)
		return FALSE;
	d = self->frustum30 * x + self->frustum31 * y + self->frustum32 * z + self->frustum33;
	if (d <= -radius)
		return FALSE;
	d = self->frustum40 * x + self->frustum41 * y + self->frustum42 * z + self->frustum43;
	if (d <= -radius)
		return FALSE;
	d = self->frustum50 * x + self->frustum51 * y + self->frustum52 * z + self->frustum53;
	if (d <= -radius)
		return FALSE;
	return TRUE;
}

static void Game_Construct(Game *self)
{
	self->one = 1;
	self->map = Map_New();
	self->performanceinfo = DictionaryStringString_New();
	self->audioEnabled = TRUE;
	self->autoJumpEnabled = FALSE;
	self->playerPositionSpawnX = 15 + self->one / 2;
	self->playerPositionSpawnY = 64;
	self->playerPositionSpawnZ = 15 + self->one / 2;
	self->textureId = (int const **) malloc(1024 * sizeof(int const *));
	{
		int i;
		for (i = 0; i < 1024; i++) {
			self->textureId[i] = (int *) malloc(6 * sizeof(int ));
		}
	}
	self->textureIdForInventory = (int *) malloc(1024 * sizeof(int ));
	self->language = Language_New();
	self->lastplacedblockX = -1;
	self->lastplacedblockY = -1;
	self->lastplacedblockZ = -1;
	self->mLightLevels = (float *) malloc(16 * sizeof(float ));
	self->sunlight_ = 15;
	self->mvMatrix = StackMatrix4_New();
	self->pMatrix = StackMatrix4_New();
	StackMatrix4_Push(self->mvMatrix, Mat4_Create());
	StackMatrix4_Push(self->pMatrix, Mat4_Create());
	self->whitetexture = -1;
	self->cachedTextTexturesMax = 1024;
	self->cachedTextTextures = (CachedTextTexture const **) malloc(self->cachedTextTexturesMax * sizeof(CachedTextTexture const *));
	{
		int i;
		for (i = 0; i < self->cachedTextTexturesMax; i++) {
			self->cachedTextTextures[i] = NULL;
		}
	}
	self->packetLen = IntRef_New();
	self->eNABLE_DRAW2D = TRUE;
	self->allowFreemove = TRUE;
	self->enableCameraControl = TRUE;
	self->textures = DictionaryStringInt1024_New();
	self->serverInfo = ServerInformation_New();
	self->menustate = MenuState_New();
	self->mouseleftclick = FALSE;
	self->mouseleftdeclick = FALSE;
	self->wasmouseleft = FALSE;
	self->mouserightclick = FALSE;
	self->mouserightdeclick = FALSE;
	self->wasmouseright = FALSE;
	self->eNABLE_LAG = 0;
	self->znear = self->one / 10;
	self->cameraMatrix = GetCameraMatrix_New();
	self->eNABLE_ZFAR = TRUE;
	self->totalAmmo = (int *) malloc(1024 * sizeof(int ));
	self->loadedAmmo = (int *) malloc(1024 * sizeof(int ));
	self->allowedFontsCount = 1;
	self->allowedFonts = (const char **) malloc(self->allowedFontsCount * sizeof(const char *));
	self->allowedFonts[0] = "Verdana";
	self->fov = Game_GetPi() / 3;
	self->cameratype = CameraType_FPP;
	self->eNABLE_TPP_VIEW = FALSE;
	self->basemovespeed = 5;
	self->movespeed = 5;
	self->radiusWhenMoving = self->one * 3 / 10;
	self->playervelocity = Vector3Ref_New();
	self->localPlayerId = -1;
	self->dialogs = (VisibleDialog const **) malloc(512 * sizeof(VisibleDialog const *));
	self->dialogsCount = 512;
	self->blockHealth = DictionaryVector3Float_New();
	self->playertexturedefault = -1;
	self->a = AnimationState_New();
	self->constRotationSpeed = self->one * 180 / 20;
	self->modmanager = ClientModManager1_New();
	self->particleEffectBlockBreak = ModDrawParticleEffectBlockBreak_New();
	self->pICK_DISTANCE = 4.1f;
	self->selectedmodelid = -1;
	self->grenadetime = 3;
	self->rotationspeed = self->one * 15 / 100;
	self->entities = (Entity const **) malloc(4096 * sizeof(Entity const *));
	{
		int i;
		for (i = 0; i < 4096; i++) {
			self->entities[i] = NULL;
		}
	}
	self->entitiesCount = 512;
	self->playerPushDistance = 2;
	self->keyboardState = (cibool *) malloc(256 * sizeof(cibool ));
	{
		int i;
		for (i = 0; i < 256; i++) {
			self->keyboardState[i] = FALSE;
		}
	}
	self->keyboardStateRaw = (cibool *) malloc(256 * sizeof(cibool ));
	{
		int i;
		for (i = 0; i < 256; i++) {
			self->keyboardStateRaw[i] = FALSE;
		}
	}
	self->overheadcameradistance = 10;
	self->tppcameradistance = 3;
	self->tPP_CAMERA_DISTANCE_MIN = 1;
	self->tPP_CAMERA_DISTANCE_MAX = 10;
	self->options = OptionsCi_New();
	self->overheadcameraK = Kamera_New();
	self->fillAreaLimit = 200;
	self->speculativeCount = 0;
	self->speculative = (Speculative const **) malloc(8192 * sizeof(Speculative const *));
	self->typinglog = (const char **) malloc(16384 * sizeof(const char *));
	self->typinglogCount = 0;
	self->newBlockTypes = (Packet_BlockType const **) malloc(1024 * sizeof(Packet_BlockType const *));
	self->localplayeranim = AnimationState_New();
	self->localplayeranimationhint = AnimationHint_New();
	self->enable_move = TRUE;
	self->handTexture = -1;
	self->modelViewInverted = (float *) malloc(16 * sizeof(float ));
	self->gLScaleTempVec3 = Vec3_Create();
	self->gLRotateTempVec3 = Vec3_Create();
	self->gLTranslateTempVec3 = Vec3_Create();
	self->identityMatrix = Mat4_Identity_(Mat4_Create());
	self->set3dProjectionTempMat4 = Mat4_Create();
	self->getAsset = (const char **) malloc(2048 * sizeof(const char *));
	self->playerStats = Packet_ServerPlayerStats_New();
	self->mLightLevels = (float *) malloc(16 * sizeof(float ));
	{
		int i;
		for (i = 0; i < 16; i++) {
			self->mLightLevels[i] = self->one * i / 15;
		}
	}
	self->soundnow = BoolRef_New();
	self->camera = Mat4_Create();
	self->packetHandlers = (ClientPacketHandler const **) malloc(256 * sizeof(ClientPacketHandler const *));
	self->player = Entity_New();
	self->player->position = EntityPosition__New();
	self->currentlyAttackedEntity = -1;
	self->chatLinesMax = 1;
	self->chatLines = (Chatline const **) malloc(self->chatLinesMax * sizeof(Chatline const *));
	self->chatLineLength = 64;
	self->audio = AudioControl_New();
	self->cameraEyeX = -1;
	self->cameraEyeY = -1;
	self->cameraEyeZ = -1;
	self->controls = Controls_New();
	self->movedz = 0;
	self->taskScheduler = TaskScheduler_New();
	self->commitActions = ListAction_Create(16384);
	self->constWallDistance = 0.3f;
	self->mouseSmoothing = TRUE;
}

Game *Game_New(void)
{
	Game *self = (Game *) malloc(sizeof(Game));
	if (self != NULL)
		Game_Construct(self);
	return self;
}

void Game_Delete(Game *self)
{
	free(self);
}

void Game_AddChatline(Game *self, const char *s)
{
	Game const *game = self;
	cibool containsLink;
	const char *linkTarget;
	int now;
	if (game->platform->vtbl->stringEmpty(game->platform, s)) {
		return;
	}
	containsLink = FALSE;
	linkTarget = "";
	if (game->platform->vtbl->stringContains(game->platform, s, "http://")) {
		IntRef const *r;
		const char *const *temp;
		containsLink = TRUE;
		r = IntRef_New();
		temp = game->platform->vtbl->stringSplit(game->platform, s, " ", r);
		{
			int i;
			for (i = 0; i < r->value; i++) {
				if (game->platform->vtbl->stringIndexOf(game->platform, temp[i], "http://") != -1) {
					linkTarget = temp[i];
					break;
				}
			}
		}
	}
	if (game->platform->vtbl->stringContains(game->platform, s, "https://")) {
		IntRef const *r;
		const char *const *temp;
		containsLink = TRUE;
		r = IntRef_New();
		temp = game->platform->vtbl->stringSplit(game->platform, s, " ", r);
		{
			int i;
			for (i = 0; i < r->value; i++) {
				if (game->platform->vtbl->stringIndexOf(game->platform, temp[i], "https://") != -1) {
					linkTarget = temp[i];
					break;
				}
			}
		}
	}
	now = game->platform->vtbl->timeMillisecondsFromStart(game->platform);
	if ((int) strlen(s) > self->chatLineLength) {
		{
			int i;
			for (i = 0; i <= (int) strlen(s) / self->chatLineLength; i++) {
				int displayLength = self->chatLineLength;
				if ((int) strlen(s) - i * self->chatLineLength < self->chatLineLength) {
					displayLength = (int) strlen(s) - i * self->chatLineLength;
				}
				if (containsLink)
					Game_ChatLinesAdd(self, Chatline_CreateClickable(StringTools_StringSubstring(game->platform, s, i * self->chatLineLength, displayLength), now, linkTarget));
				else
					Game_ChatLinesAdd(self, Chatline_Create(StringTools_StringSubstring(game->platform, s, i * self->chatLineLength, displayLength), now));
			}
		}
	}
	else {
		if (containsLink)
			Game_ChatLinesAdd(self, Chatline_CreateClickable(s, now, linkTarget));
		else
			Game_ChatLinesAdd(self, Chatline_Create(s, now));
	}
}

void Game_AddMod(Game *self, ClientMod const *mod)
{
	self->clientmods[self->clientmodsCount++] = mod;
	mod->vtbl->start(mod, &self->modmanager->base);
}

static void Game_AddSpeculative(Game *self, Speculative const *s_)
{
	{
		int i;
		for (i = 0; i < self->speculativeCount; i++) {
			if (self->speculative[i] == NULL) {
				self->speculative[i] = s_;
				return;
			}
		}
	}
	self->speculative[self->speculativeCount++] = s_;
}

static float Game_Angle256ToRad(int value)
{
	float one_ = 1;
	return one_ * value / 255 * Game_GetPi() * 2;
}

static void Game_ApplyDamageToPlayer(Game const *self, int damage, int damageSource, int sourceId)
{
	self->playerStats->currentHealth -= damage;
	if (self->playerStats->currentHealth <= 0) {
		self->playerStats->currentHealth = 0;
		Game_AudioPlay(self, "death.wav");
		Game_SendPacketClient(self, ClientPackets_Death(damageSource, sourceId));
	}
	else {
		Game_AudioPlay(self, self->rnd->vtbl->next(self->rnd) % 2 == 0 ? "grunt1.wav" : "grunt2.wav");
	}
	Game_SendPacketClient(self, ClientPackets_Health(self->playerStats->currentHealth));
}

void Game_AudioPlay(Game const *self, const char *file)
{
	if (!self->audioEnabled) {
		return;
	}
	Game_AudioPlayAt(self, file, Game_EyesPosX(self), Game_EyesPosY(self), Game_EyesPosZ(self));
}

void Game_AudioPlayAt(Game const *self, const char *file, float x, float y, float z)
{
	const char *file_;
	Sound_ *s;
	if (file == NULL) {
		return;
	}
	if (!self->audioEnabled) {
		return;
	}
	if (self->assetsLoadProgress->value != 1) {
		return;
	}
	file_ = self->platform->vtbl->stringReplace(self->platform, file, ".wav", ".ogg");
	if (Game_GetFileLength(self, file_) == 0) {
		self->platform->vtbl->consoleWriteLine(self->platform, self->platform->vtbl->stringFormat(self->platform, "File not found: {0}", file));
		return;
	}
	s = Sound__New();
	s->name = file_;
	s->x = x;
	s->y = y;
	s->z = z;
	AudioControl_Add(self->audio, s);
}

void Game_AudioPlayLoop(Game const *self, const char *file, cibool play, cibool restart)
{
	const char *file_;
	if (!self->audioEnabled && play) {
		return;
	}
	if (self->assetsLoadProgress->value != 1) {
		return;
	}
	file_ = self->platform->vtbl->stringReplace(self->platform, file, ".wav", ".ogg");
	if (Game_GetFileLength(self, file_) == 0) {
		self->platform->vtbl->consoleWriteLine(self->platform, self->platform->vtbl->stringFormat(self->platform, "File not found: {0}", file));
		return;
	}
	if (play) {
		Sound_ *s = NULL;
		cibool alreadyPlaying = FALSE;
		{
			int i;
			for (i = 0; i < self->audio->soundsCount; i++) {
				if (self->audio->sounds[i] == NULL) {
					continue;
				}
				if (strcmp(self->audio->sounds[i]->name, file_) == 0) {
					alreadyPlaying = TRUE;
					s = self->audio->sounds[i];
				}
			}
		}
		if (!alreadyPlaying) {
			s = Sound__New();
			s->name = file_;
			s->loop = TRUE;
			AudioControl_Add(self->audio, s);
		}
		s->x = Game_EyesPosX(self);
		s->y = Game_EyesPosY(self);
		s->z = Game_EyesPosZ(self);
	}
	else {
		{
			int i;
			for (i = 0; i < self->audio->soundsCount; i++) {
				if (self->audio->sounds[i] == NULL) {
					continue;
				}
				if (strcmp(self->audio->sounds[i]->name, file_) == 0) {
					self->audio->sounds[i]->stop = TRUE;
				}
			}
		}
	}
}

static IntRef const *Game_BlockInHand(Game const *self)
{
	Packet_Item const *item = self->d_Inventory->rightHand[self->activeMaterial];
	if (item != NULL && item->itemClass == 0) {
		return IntRef_Create(item->blockId);
	}
	return NULL;
}

static int Game_BlockUnderPlayer(Game const *self)
{
	int blockunderplayer;
	if (!Map_IsValidPos(self->map, self->platform->vtbl->floatToInt(self->platform, self->player->position->x), self->platform->vtbl->floatToInt(self->platform, self->player->position->z), self->platform->vtbl->floatToInt(self->platform, self->player->position->y) - 1)) {
		return -1;
	}
	blockunderplayer = Map_GetBlock(self->map, self->platform->vtbl->floatToInt(self->platform, self->player->position->x), self->platform->vtbl->floatToInt(self->platform, self->player->position->z), self->platform->vtbl->floatToInt(self->platform, self->player->position->y) - 1);
	return blockunderplayer;
}

cibool Game_BoolCommandArgument(Game const *self, const char *arguments)
{
	arguments = self->platform->vtbl->stringTrim(self->platform, arguments);
	return strcmp(arguments, "") == 0 || strcmp(arguments, "1") == 0 || strcmp(arguments, "on") == 0 || strcmp(arguments, "yes") == 0;
}

int const *Game_ByteArrayToUshortArray(unsigned char const *input, int inputLength)
{
	int outputLength = inputLength / 2;
	int *output = (int *) malloc(outputLength * sizeof(int ));
	{
		int i;
		for (i = 0; i < outputLength; i++) {
			output[i] = (input[i * 2 + 1] << 8) + input[i * 2];
		}
	}
	return output;
}

static void Game_CacheAsset(Game const *self, Asset const *asset)
{
	if (asset->md5 == NULL) {
		return;
	}
	if (!self->platform->vtbl->isChecksum(self->platform, asset->md5)) {
		return;
	}
	if (!self->platform->vtbl->isCached(self->platform, asset->md5)) {
		self->platform->vtbl->saveAssetToCache(self->platform, asset);
	}
}

void Game_CameraChange(Game *self)
{
	if (self->follow != NULL) {
		return;
	}
	if (self->cameratype == CameraType_FPP) {
		self->cameratype = CameraType_TPP;
		self->eNABLE_TPP_VIEW = TRUE;
	}
	else if (self->cameratype == CameraType_TPP) {
		self->cameratype = CameraType_OVERHEAD;
		self->overheadcamera = TRUE;
		Game_SetFreeMouse(self, TRUE);
		self->eNABLE_TPP_VIEW = TRUE;
		self->playerdestination = Vector3Ref_Create(self->player->position->x, self->player->position->y, self->player->position->z);
	}
	else if (self->cameratype == CameraType_OVERHEAD) {
		self->cameratype = CameraType_FPP;
		Game_SetFreeMouse(self, FALSE);
		self->eNABLE_TPP_VIEW = FALSE;
		self->overheadcamera = FALSE;
	}
	else {
		self->platform->vtbl->throwException(self->platform, "");
	}
}

const char *Game_CharToString(Game const *self, int c)
{
	int *arr = (int *) malloc(1 * sizeof(int ));
	arr[0] = c;
	return self->platform->vtbl->charArrayToString(self->platform, arr, 1);
}

static void Game_ChatLinesAdd(Game *self, Chatline const *chatline)
{
	if (self->chatLinesCount >= self->chatLinesMax) {
		Chatline const **lines2 = (Chatline const **) malloc(self->chatLinesMax * 2 * sizeof(Chatline const *));
		{
			int i;
			for (i = 0; i < self->chatLinesMax; i++) {
				lines2[i] = self->chatLines[i];
			}
		}
		self->chatLines = lines2;
		self->chatLinesMax *= 2;
	}
	self->chatLines[self->chatLinesCount++] = chatline;
}

static void Game_ChatLog(Game const *self, const char *p)
{
	if (!self->platform->vtbl->chatLog(self->platform, self->serverInfo->serverName, p)) {
		self->platform->vtbl->consoleWriteLine(self->platform, self->platform->vtbl->stringFormat(self->platform, Language_CannotWriteChatLog(self->language), self->serverInfo->serverName));
	}
}

void Game_Circle3i(Game *self, float x, float y, float radius)
{
	float angle;
	int n;
	Game_GLPushMatrix(self);
	Game_GLLoadIdentity(self);
	n = 32;
	if (self->circleModelData == NULL) {
		self->circleModelData = ModelData_New();
		ModelData_setMode(self->circleModelData, 1);
		self->circleModelData->indices = (int *) malloc(n * 2 * sizeof(int ));
		self->circleModelData->xyz = (float *) malloc(3 * n * sizeof(float ));
		self->circleModelData->rgba = (unsigned char *) malloc(4 * n * sizeof(unsigned char ));
		self->circleModelData->uv = (float *) malloc(2 * n * sizeof(float ));
		self->circleModelData->indicesCount = n * 2;
		self->circleModelData->verticesCount = n;
	}
	{
		int i;
		for (i = 0; i < n; i++) {
			self->circleModelData->indices[i * 2] = i;
			self->circleModelData->indices[i * 2 + 1] = (i + 1) % n;
		}
	}
	{
		int i;
		for (i = 0; i < n; i++) {
			angle = i * 2 * Game_GetPi() / n;
			self->circleModelData->xyz[i * 3 + 0] = x + self->platform->vtbl->mathCos(self->platform, angle) * radius;
			self->circleModelData->xyz[i * 3 + 1] = y + self->platform->vtbl->mathSin(self->platform, angle) * radius;
			self->circleModelData->xyz[i * 3 + 2] = 0;
		}
	}
	{
		int i;
		for (i = 0; i < 4 * n; i++) {
			self->circleModelData->rgba[i] = 255;
		}
	}
	{
		int i;
		for (i = 0; i < 2 * n; i++) {
			self->circleModelData->uv[i] = 0;
		}
	}
	Game_DrawModelData(self, self->circleModelData);
	Game_GLPopMatrix(self);
}

static void Game_ClientCommand(Game *self, const char *s_)
{
	IntRef const *ssCount;
	const char *const *ss;
	if (strcmp(s_, "") == 0) {
		return;
	}
	ssCount = IntRef_New();
	ss = self->platform->vtbl->stringSplit(self->platform, s_, " ", ssCount);
	if (StringTools_StringStartsWith(self->platform, s_, ".")) {
		const char *strFreemoveNotAllowed = Language_FreemoveNotAllowed(self->language);
		const char *cmd = StringTools_StringSubstringToEnd(self->platform, ss[0], 1);
		const char *arguments;
		if (self->platform->vtbl->stringIndexOf(self->platform, s_, " ") == -1) {
			arguments = "";
		}
		else {
			arguments = StringTools_StringSubstringToEnd(self->platform, s_, self->platform->vtbl->stringIndexOf(self->platform, s_, " "));
		}
		arguments = self->platform->vtbl->stringTrim(self->platform, arguments);
		if (strcmp(cmd, "clients") == 0) {
			Game_Log(self, "Clients:");
			{
				int i;
				for (i = 0; i < self->entitiesCount; i++) {
					Entity const *entity = self->entities[i];
					if (entity == NULL) {
						continue;
					}
					if (entity->drawName == NULL) {
						continue;
					}
					if (!entity->drawName->clientAutoComplete) {
						continue;
					}
					Game_Log(self, self->platform->vtbl->stringFormat2(self->platform, "{0} {1}", self->platform->vtbl->intToString(self->platform, i), self->entities[i]->drawName->name));
				}
			}
		}
		else if (strcmp(cmd, "reconnect") == 0) {
			Game_Reconnect(self);
		}
		else if (strcmp(cmd, "m") == 0) {
			self->mouseSmoothing = !self->mouseSmoothing;
			if (self->mouseSmoothing) {
				Game_Log(self, "Mouse smoothing enabled.");
			}
			else {
				Game_Log(self, "Mouse smoothing disabled.");
			}
		}
		else if (strcmp(cmd, "pos") == 0) {
			self->eNABLE_DRAWPOSITION = Game_BoolCommandArgument(self, arguments);
		}
		else if (strcmp(cmd, "noclip") == 0) {
			if (self->allowFreemove) {
				self->stopPlayerMove = TRUE;
				if (Game_BoolCommandArgument(self, arguments)) {
					Controls_SetFreemove(self->controls, 2);
				}
				else {
					Controls_SetFreemove(self->controls, 0);
				}
			}
			else {
				Game_Log(self, strFreemoveNotAllowed);
				return;
			}
		}
		else if (strcmp(cmd, "freemove") == 0) {
			if (self->allowFreemove) {
				self->stopPlayerMove = TRUE;
				if (Game_BoolCommandArgument(self, arguments)) {
					Controls_SetFreemove(self->controls, 1);
				}
				else {
					Controls_SetFreemove(self->controls, 0);
				}
			}
			else {
				Game_Log(self, strFreemoveNotAllowed);
				return;
			}
		}
		else if (strcmp(cmd, "gui") == 0) {
			self->eNABLE_DRAW2D = Game_BoolCommandArgument(self, arguments);
		}
		else if (strcmp(arguments, "") != 0) {
			if (strcmp(cmd, "fog") == 0) {
				int foglevel;
				foglevel = self->platform->vtbl->intParse(self->platform, arguments);
				{
					int foglevel2 = foglevel;
					if (foglevel2 > 1024) {
						foglevel2 = 1024;
					}
					if (foglevel2 % 2 == 0) {
						foglevel2--;
					}
					self->d_Config3d->viewdistance = foglevel2;
				}
				Game_OnResize(self);
			}
			else if (strcmp(cmd, "fov") == 0) {
				int arg = self->platform->vtbl->intParse(self->platform, arguments);
				int minfov = 1;
				int maxfov = 179;
				if (!self->issingleplayer) {
					minfov = 60;
				}
				if (arg < minfov || arg > maxfov) {
					Game_Log(self, self->platform->vtbl->stringFormat2(self->platform, "Valid field of view: {0}-{1}", self->platform->vtbl->intToString(self->platform, minfov), self->platform->vtbl->intToString(self->platform, maxfov)));
				}
				else {
					float fov_ = 2 * Game_GetPi() * self->one * arg / 360;
					self->fov = fov_;
					Game_OnResize(self);
				}
			}
			else if (strcmp(cmd, "movespeed") == 0) {
				if (self->allowFreemove) {
					if (self->platform->vtbl->floatParse(self->platform, arguments) <= 500) {
						self->movespeed = self->basemovespeed * self->platform->vtbl->floatParse(self->platform, arguments);
						Game_AddChatline(self, self->platform->vtbl->stringFormat(self->platform, "Movespeed: {0}x", arguments));
					}
					else {
						Game_AddChatline(self, "Entered movespeed to high! max. 500x");
					}
				}
				else {
					Game_Log(self, strFreemoveNotAllowed);
					return;
				}
			}
			else if (strcmp(cmd, "serverinfo") == 0) {
				IntRef const *splitCount = IntRef_New();
				const char *const *split = self->platform->vtbl->stringSplit(self->platform, arguments, ":", splitCount);
				if (splitCount->value == 2) {
					QueryClient *qClient = QueryClient_New();
					QueryClient_SetPlatform(qClient, self->platform);
					QueryClient_PerformQuery(qClient, split[0], self->platform->vtbl->intParse(self->platform, split[1]));
					if (qClient->querySuccess) {
						QueryResult const *r = QueryClient_GetResult(qClient);
						Game_AddChatline(self, r->gameMode);
						Game_AddChatline(self, self->platform->vtbl->intToString(self->platform, r->mapSizeX));
						Game_AddChatline(self, self->platform->vtbl->intToString(self->platform, r->mapSizeY));
						Game_AddChatline(self, self->platform->vtbl->intToString(self->platform, r->mapSizeZ));
						Game_AddChatline(self, self->platform->vtbl->intToString(self->platform, r->maxPlayers));
						Game_AddChatline(self, r->mOTD);
						Game_AddChatline(self, r->name);
						Game_AddChatline(self, self->platform->vtbl->intToString(self->platform, r->playerCount));
						Game_AddChatline(self, r->playerList);
						Game_AddChatline(self, self->platform->vtbl->intToString(self->platform, r->port));
						Game_AddChatline(self, r->publicHash);
						Game_AddChatline(self, r->serverVersion);
					}
					Game_AddChatline(self, QueryClient_GetServerMessage(qClient));
				}
			}
		}
		else {
			const char *chatline = StringTools_StringSubstring(self->platform, self->guiTypingBuffer, 0, MathCi_MinInt((int) strlen(self->guiTypingBuffer), 256));
			Game_SendChat(self, chatline);
		}
		{
			int i;
			for (i = 0; i < self->clientmodsCount; i++) {
				ClientCommandArgs *args = ClientCommandArgs_New();
				args->arguments = arguments;
				args->command = cmd;
				self->clientmods[i]->vtbl->onClientCommand(self->clientmods[i], self, args);
			}
		}
	}
	else {
		const char *chatline = StringTools_StringSubstring(self->platform, self->guiTypingBuffer, 0, MathCi_MinInt(StringTools_StringLength(self->platform, self->guiTypingBuffer), 4096));
		Game_SendChat(self, chatline);
	}
}

int Game_ColorA(int color)
{
	unsigned char a = Game_IntToByte(color >> 24);
	return a;
}

int Game_ColorB(int color)
{
	unsigned char b = Game_IntToByte(color);
	return b;
}

int Game_ColorFromArgb(int a, int r, int g, int b)
{
	int iCol = (a << 24) | (r << 16) | (g << 8) | b;
	return iCol;
}

int Game_ColorG(int color)
{
	unsigned char g = Game_IntToByte(color >> 8);
	return g;
}

int Game_ColorR(int color)
{
	unsigned char r = Game_IntToByte(color >> 16);
	return r;
}

ModelData const *Game_CombineModelData(Game const *self, ModelData const *const *modelDatas, int count)
{
	ModelData *ret = ModelData_New();
	int totalIndices = 0;
	int totalVertices = 0;
	{
		int i;
		for (i = 0; i < count; i++) {
			ModelData const *m = modelDatas[i];
			totalIndices += m->indicesCount;
			totalVertices += m->verticesCount;
		}
	}
	ret->indices = (int *) malloc(totalIndices * sizeof(int ));
	ret->xyz = (float *) malloc(totalVertices * 3 * sizeof(float ));
	ret->uv = (float *) malloc(totalVertices * 2 * sizeof(float ));
	ret->rgba = (unsigned char *) malloc(totalVertices * 4 * sizeof(unsigned char ));
	{
		int i;
		for (i = 0; i < count; i++) {
			ModelData const *m = modelDatas[i];
			int retVerticesCount = ret->verticesCount;
			int retIndicesCount = ret->indicesCount;
			{
				int k;
				for (k = 0; k < m->indicesCount; k++) {
					ret->indices[ret->indicesCount++] = m->indices[k] + retVerticesCount;
				}
			}
			{
				int k;
				for (k = 0; k < m->verticesCount * 3; k++) {
					ret->xyz[retVerticesCount * 3 + k] = m->xyz[k];
				}
			}
			{
				int k;
				for (k = 0; k < m->verticesCount * 2; k++) {
					ret->uv[retVerticesCount * 2 + k] = m->uv[k];
				}
			}
			{
				int k;
				for (k = 0; k < m->verticesCount * 4; k++) {
					ret->rgba[retVerticesCount * 4 + k] = m->rgba[k];
				}
			}
			ret->verticesCount += m->verticesCount;
		}
	}
	return ret;
}

static void Game_Connect(Game const *self, const char *serverAddress, int port, const char *username, const char *auth)
{
	self->main->vtbl->start(self->main);
	self->main->vtbl->connect(self->main, serverAddress, port);
	Game_SendPacketClient(self, ClientPackets_CreateLoginPacket(self->platform, username, auth));
}

static void Game_Connect_(Game const *self, const char *serverAddress, int port, const char *username, const char *auth, const char *serverPassword)
{
	self->main->vtbl->start(self->main);
	self->main->vtbl->connect(self->main, serverAddress, port);
	Game_SendPacketClient(self, ClientPackets_CreateLoginPacket_(self->platform, username, auth, serverPassword));
}

static void Game_Connect__(Game *self)
{
	if (self->connectdata->serverPassword == NULL || strcmp(self->connectdata->serverPassword, "") == 0) {
		Game_Connect(self, self->connectdata->ip, self->connectdata->port, self->connectdata->username, self->connectdata->auth);
	}
	else {
		Game_Connect_(self, self->connectdata->ip, self->connectdata->port, self->connectdata->username, self->connectdata->auth, self->connectdata->serverPassword);
	}
	Game_MapLoadingStart(self);
}

static Entity *Game_CreateBulletEntity(Game const *self, float fromX, float fromY, float fromZ, float toX, float toY, float toZ, float speed)
{
	Entity *entity = Entity_New();
	Bullet_ *bullet = Bullet__New();
	bullet->fromX = fromX;
	bullet->fromY = fromY;
	bullet->fromZ = fromZ;
	bullet->toX = toX;
	bullet->toY = toY;
	bullet->toZ = toZ;
	bullet->speed = speed;
	entity->bullet = bullet;
	entity->sprite = Sprite_New();
	entity->sprite->image = "Sponge.png";
	entity->sprite->size = 4;
	entity->sprite->animationcount = 0;
	return entity;
}

static float Game_CurrentAimRadius(Game const *self)
{
	Packet_Item const *item = self->d_Inventory->rightHand[self->activeMaterial];
	float radius;
	if (item == NULL || item->itemClass != 0) {
		return 0;
	}
	radius = Game_DeserializeFloat(self, self->blocktypes[item->blockId]->aimRadiusFloat) / 800 * Game_Width(self);
	if (self->ironSights) {
		radius = Game_DeserializeFloat(self, self->blocktypes[item->blockId]->ironSightsAimRadiusFloat) / 800 * Game_Width(self);
	}
	return radius + self->radiusWhenMoving * radius * MathCi_MinFloat(Vector3Ref_Length(self->playervelocity) / self->movespeed, 1);
}

static float Game_CurrentRecoil(Game const *self)
{
	Packet_Item const *item = self->d_Inventory->rightHand[self->activeMaterial];
	if (item == NULL || item->itemClass != 0) {
		return 0;
	}
	return Game_DeserializeFloat(self, self->blocktypes[item->blockId]->recoilFloat);
}

static cibool Game_DeleteTexture(Game const *self, const char *name)
{
	if (name != NULL && DictionaryStringInt1024_Contains(self->textures, name)) {
		int id = DictionaryStringInt1024_Get(self->textures, name);
		DictionaryStringInt1024_Remove(self->textures, name);
		self->platform->vtbl->gLDeleteTexture(self->platform, id);
		return TRUE;
	}
	return FALSE;
}

void Game_DeleteUnusedCachedTextTextures(Game const *self)
{
	int now = self->platform->vtbl->timeMillisecondsFromStart(self->platform);
	{
		int i;
		for (i = 0; i < self->cachedTextTexturesMax; i++) {
			CachedTextTexture const *t = self->cachedTextTextures[i];
			if (t == NULL) {
				continue;
			}
			if (self->one * (now - t->texture->lastuseMilliseconds) / 1000 > 1) {
				self->platform->vtbl->gLDeleteTexture(self->platform, t->texture->textureId);
				self->cachedTextTextures[i] = NULL;
			}
		}
	}
}

static float Game_DeserializeFloat(Game const *self, int value)
{
	return self->one * value / 32;
}

static int Game_DialogsCount_(Game const *self)
{
	int count = 0;
	{
		int i;
		for (i = 0; i < self->dialogsCount; i++) {
			if (self->dialogs[i] != NULL) {
				count++;
			}
		}
	}
	return count;
}

void Game_Dispose(Game const *self)
{
	{
		int i;
		for (i = 0; i < self->clientmodsCount; i++) {
			if (self->clientmods[i] == NULL) {
				continue;
			}
			self->clientmods[i]->vtbl->dispose(self->clientmods[i], self);
		}
	}
	{
		int i;
		for (i = 0; i < self->textures->count; i++) {
			if (self->textures->items[i] == NULL) {
				continue;
			}
			self->platform->vtbl->gLDeleteTexture(self->platform, self->textures->items[i]->value);
		}
	}
	{
		int i;
		for (i = 0; i < self->cachedTextTexturesMax; i++) {
			if (self->cachedTextTextures[i] == NULL) {
				continue;
			}
			if (self->cachedTextTextures[i]->texture == NULL) {
				continue;
			}
			self->platform->vtbl->gLDeleteTexture(self->platform, self->cachedTextTextures[i]->texture->textureId);
		}
	}
}

float Game_Dist(Game const *self, float x1, float y1, float z1, float x2, float y2, float z2)
{
	float dx = x2 - x1;
	float dy = y2 - y1;
	float dz = z2 - z1;
	return self->platform->vtbl->mathSqrt(self->platform, dx * dx + dy * dy + dz * dz);
}

static void Game_Draw2d(Game *self, float dt)
{
	if (!self->eNABLE_DRAW2D) {
		return;
	}
	Game_OrthoMode(self, Game_Width(self), Game_Height(self));
	{
		int i;
		for (i = 0; i < self->clientmodsCount; i++) {
			if (self->clientmods[i] == NULL) {
				continue;
			}
			self->clientmods[i]->vtbl->onNewFrameDraw2d(self->clientmods[i], self, dt);
		}
	}
	Game_PerspectiveMode(self);
}

void Game_Draw2dBitmapFile(Game *self, const char *filename, float x, float y, float w, float h)
{
	Game_Draw2dTexture(self, Game_GetTexture(self, filename), x, y, w, h, NULL, 0, Game_ColorFromArgb(255, 255, 255, 255), FALSE);
}

void Game_Draw2dText(Game *self, const char *text, FontCi const *font, float x, float y, IntRef const *color, cibool enabledepthtest)
{
	Text_ *t;
	CachedTexture *ct;
	if (text == NULL || strcmp(self->platform->vtbl->stringTrim(self->platform, text), "") == 0) {
		return;
	}
	if (color == NULL) {
		color = IntRef_Create(Game_ColorFromArgb(255, 255, 255, 255));
	}
	t = Text__New();
	t->text = text;
	t->color = color->value;
	t->fontsize = font->size;
	t->fontfamily = font->family;
	t->fontstyle = font->style;
	if (Game_GetCachedTextTexture(self, t) == NULL) {
		ct = Game_MakeTextTexture(self, t);
		if (ct == NULL) {
			return;
		}
		{
			int i;
			for (i = 0; i < self->cachedTextTexturesMax; i++) {
				if (self->cachedTextTextures[i] == NULL) {
					CachedTextTexture *ct1 = CachedTextTexture_New();
					ct1->text = t;
					ct1->texture = ct;
					self->cachedTextTextures[i] = ct1;
					break;
				}
			}
		}
	}
	ct = Game_GetCachedTextTexture(self, t);
	ct->lastuseMilliseconds = self->platform->vtbl->timeMillisecondsFromStart(self->platform);
	self->platform->vtbl->gLDisableAlphaTest(self->platform);
	Game_Draw2dTexture(self, ct->textureId, x, y, ct->sizeX, ct->sizeY, NULL, 0, Game_ColorFromArgb(255, 255, 255, 255), enabledepthtest);
	self->platform->vtbl->gLEnableAlphaTest(self->platform);
	Game_DeleteUnusedCachedTextTextures(self);
}

static void Game_Draw2dText1(Game *self, const char *text, int x, int y, int fontsize, IntRef const *color, cibool enabledepthtest)
{
	FontCi *font = FontCi_New();
	font->family = "Arial";
	font->size = fontsize;
	Game_Draw2dText(self, text, font, x, y, color, enabledepthtest);
}

void Game_Draw2dTexture(Game *self, int textureid, float x1, float y1, float width, float height, IntRef const *inAtlasId, int atlastextures, int color, cibool enabledepthtest)
{
	if (color == Game_ColorFromArgb(255, 255, 255, 255) && inAtlasId == NULL) {
		Game_Draw2dTextureSimple(self, textureid, x1, y1, width, height, enabledepthtest);
	}
	else {
		Game_Draw2dTextureInAtlas(self, textureid, x1, y1, width, height, inAtlasId, atlastextures, color, enabledepthtest);
	}
}

static void Game_Draw2dTextureInAtlas(Game const *self, int textureid, float x1, float y1, float width, float height, IntRef const *inAtlasId, int atlastextures, int color, cibool enabledepthtest)
{
	RectFRef *rect = RectFRef_Create(0, 0, 1, 1);
	ModelData const *data;
	if (inAtlasId != NULL) {
		TextureAtlasCi_TextureCoords2d(inAtlasId->value, atlastextures, rect);
	}
	self->platform->vtbl->glDisableCullFace(self->platform);
	self->platform->vtbl->glEnableTexture2d(self->platform);
	self->platform->vtbl->bindTexture2d(self->platform, textureid);
	if (!enabledepthtest) {
		self->platform->vtbl->glDisableDepthTest(self->platform);
	}
	data = QuadModelData_GetQuadModelData2(rect->x, rect->y, rect->w, rect->h, x1, y1, width, height, Game_IntToByte(Game_ColorR(color)), Game_IntToByte(Game_ColorG(color)), Game_IntToByte(Game_ColorB(color)), Game_IntToByte(Game_ColorA(color)));
	Game_DrawModelData(self, data);
	if (!enabledepthtest) {
		self->platform->vtbl->glEnableDepthTest(self->platform);
	}
	self->platform->vtbl->glEnableCullFace(self->platform);
	self->platform->vtbl->glEnableTexture2d(self->platform);
}

void Game_Draw2dTexturePart(Game const *self, int textureid, float srcwidth, float srcheight, float dstx, float dsty, float dstwidth, float dstheight, int color, cibool enabledepthtest)
{
	RectFRef const *rect = RectFRef_Create(0, 0, srcwidth, srcheight);
	ModelData const *data;
	self->platform->vtbl->glDisableCullFace(self->platform);
	self->platform->vtbl->glEnableTexture2d(self->platform);
	self->platform->vtbl->bindTexture2d(self->platform, textureid);
	if (!enabledepthtest) {
		self->platform->vtbl->glDisableDepthTest(self->platform);
	}
	data = QuadModelData_GetQuadModelData2(rect->x, rect->y, rect->w, rect->h, dstx, dsty, dstwidth, dstheight, Game_IntToByte(Game_ColorR(color)), Game_IntToByte(Game_ColorG(color)), Game_IntToByte(Game_ColorB(color)), Game_IntToByte(Game_ColorA(color)));
	Game_DrawModelData(self, data);
	if (!enabledepthtest) {
		self->platform->vtbl->glEnableDepthTest(self->platform);
	}
	self->platform->vtbl->glEnableCullFace(self->platform);
	self->platform->vtbl->glEnableTexture2d(self->platform);
}

static void Game_Draw2dTextureSimple(Game *self, int textureid, float x1, float y1, float width, float height, cibool enabledepthtest)
{
	RectFRef const *rect = RectFRef_Create(0, 0, 1, 1);
	self->platform->vtbl->glDisableCullFace(self->platform);
	self->platform->vtbl->glEnableTexture2d(self->platform);
	self->platform->vtbl->bindTexture2d(self->platform, textureid);
	if (!enabledepthtest) {
		self->platform->vtbl->glDisableDepthTest(self->platform);
	}
	if (self->quadModel == NULL) {
		self->quadModel = self->platform->vtbl->createModel(self->platform, QuadModelData_GetQuadModelData());
	}
	Game_GLPushMatrix(self);
	Game_GLTranslate(self, x1, y1, 0);
	Game_GLScale(self, width, height, 0);
	Game_GLScale(self, self->one / 2, self->one / 2, 0);
	Game_GLTranslate(self, self->one, self->one, 0);
	Game_DrawModel(self, self->quadModel);
	Game_GLPopMatrix(self);
	if (!enabledepthtest) {
		self->platform->vtbl->glEnableDepthTest(self->platform);
	}
	self->platform->vtbl->glEnableCullFace(self->platform);
	self->platform->vtbl->glEnableTexture2d(self->platform);
}

void Game_Draw2dTextures(Game const *self, Draw2dData const *const *todraw, int todrawLength, int textureid)
{
	ModelData const **modelDatas = (ModelData const **) malloc(512 * sizeof(ModelData const *));
	int modelDatasCount = 0;
	ModelData const *combined;
	{
		int i;
		for (i = 0; i < todrawLength; i++) {
			Draw2dData const *d = todraw[i];
			float x1 = d->x1;
			float y1 = d->y1;
			float width = d->width;
			float height = d->height;
			IntRef const *inAtlasId = d->inAtlasId;
			int textureId = textureid;
			int color = d->color;
			RectFRef *rect = RectFRef_Create(0, 0, 1, 1);
			ModelData const *modelData;
			if (inAtlasId != NULL) {
				TextureAtlasCi_TextureCoords2d(inAtlasId->value, Game_texturesPacked(self), rect);
			}
			modelData = QuadModelData_GetQuadModelData2(rect->x, rect->y, rect->w, rect->h, x1, y1, width, height, Game_IntToByte(Game_ColorR(color)), Game_IntToByte(Game_ColorG(color)), Game_IntToByte(Game_ColorB(color)), Game_IntToByte(Game_ColorA(color)));
			modelDatas[modelDatasCount++] = modelData;
		}
	}
	combined = Game_CombineModelData(self, modelDatas, modelDatasCount);
	self->platform->vtbl->glDisableCullFace(self->platform);
	self->platform->vtbl->glEnableTexture2d(self->platform);
	self->platform->vtbl->bindTexture2d(self->platform, textureid);
	self->platform->vtbl->glDisableDepthTest(self->platform);
	Game_DrawModelData(self, combined);
	self->platform->vtbl->glEnableDepthTest(self->platform);
	self->platform->vtbl->glDisableCullFace(self->platform);
	self->platform->vtbl->glEnableTexture2d(self->platform);
}

void Game_DrawModel(Game const *self, Model const *model)
{
	Game_SetMatrixUniformModelView(self);
	self->platform->vtbl->drawModel(self->platform, model);
}

void Game_DrawModelData(Game const *self, ModelData const *data)
{
	Game_SetMatrixUniformModelView(self);
	self->platform->vtbl->drawModelData(self->platform, data);
}

void Game_DrawModels(Game const *self, Model const *const *model, int count)
{
	Game_SetMatrixUniformModelView(self);
	self->platform->vtbl->drawModels(self->platform, model, count);
}

static cibool Game_EnablePlayerUpdatePosition(Game const *self, int kKey)
{
	return TRUE;
}

static cibool Game_EnablePlayerUpdatePositionContainsKey(Game const *self, int kKey)
{
	return FALSE;
}

static void Game_EntityAddLocal(Game *self, Entity *entity)
{
	{
		int i;
		for (i = 256; i < self->entitiesCount; i++) {
			if (self->entities[i] == NULL) {
				self->entities[i] = entity;
				return;
			}
		}
	}
	self->entities[self->entitiesCount++] = entity;
}

void Game_EscapeMenuStart(Game *self)
{
	self->guistate = GuiState_ESCAPE_MENU;
	self->menustate = MenuState_New();
	self->platform->vtbl->exitMousePointerLock(self->platform);
	self->escapeMenuRestart = TRUE;
}

static void Game_ExitAndSwitchServer(Game *self, Packet_ServerRedirect const *newServer)
{
	if (self->issingleplayer) {
		self->platform->vtbl->singlePlayerServerExit(self->platform);
	}
	self->redirectTo = newServer;
	self->exitToMainMenu = TRUE;
}

static void Game_ExitToMainMenu_(Game *self)
{
	if (self->issingleplayer) {
		self->platform->vtbl->singlePlayerServerExit(self->platform);
	}
	self->redirectTo = NULL;
	self->exitToMainMenu = TRUE;
}

float Game_EyesPosX(Game const *self)
{
	return self->player->position->x;
}

float Game_EyesPosY(Game const *self)
{
	return self->player->position->y + Game_GetCharacterEyesHeight(self);
}

float Game_EyesPosZ(Game const *self)
{
	return self->player->position->z;
}

static float Game_FloorFloat(Game const *self, float a)
{
	if (a >= 0) {
		return self->platform->vtbl->floatToInt(self->platform, a);
	}
	else {
		return self->platform->vtbl->floatToInt(self->platform, a) - 1;
	}
}

static IntRef const *Game_FollowId(Game const *self)
{
	if (self->follow == NULL) {
		return NULL;
	}
	{
		int i;
		for (i = 0; i < self->entitiesCount; i++) {
			DrawName const *p;
			if (self->entities[i] == NULL) {
				continue;
			}
			if (self->entities[i]->drawName == NULL) {
				continue;
			}
			p = self->entities[i]->drawName;
			if (strcmp(p->name, self->follow) == 0) {
				return IntRef_Create(i);
			}
		}
	}
	return NULL;
}

static void Game_FrameTick(Game *self, float dt)
{
	NewFrameEventArgs *args_ = NewFrameEventArgs_New();
	float orientationX;
	float orientationY;
	float orientationZ;
	NewFrameEventArgs_SetDt(args_, dt);
	{
		int i;
		for (i = 0; i < self->clientmodsCount; i++) {
			self->clientmods[i]->vtbl->onNewFrameFixed(self->clientmods[i], self, args_);
		}
	}
	{
		int i;
		for (i = 0; i < self->entitiesCount; i++) {
			Entity const *e = self->entities[i];
			if (e == NULL) {
				continue;
			}
			{
				int k;
				for (k = 0; k < e->scriptsCount; k++) {
					e->scripts[k]->vtbl->onNewFrameFixed(e->scripts[k], self, i, dt);
				}
			}
		}
	}
	Game_RevertSpeculative(self, dt);
	if (self->guistate == GuiState_MAP_LOADING) {
		return;
	}
	orientationX = self->platform->vtbl->mathSin(self->platform, self->player->position->roty);
	orientationY = 0;
	orientationZ = -self->platform->vtbl->mathCos(self->platform, self->player->position->roty);
	self->platform->vtbl->audioUpdateListener(self->platform, Game_EyesPosX(self), Game_EyesPosY(self), Game_EyesPosZ(self), orientationX, orientationY, orientationZ);
	self->playervelocity->x = self->player->position->x - self->lastplayerpositionX;
	self->playervelocity->y = self->player->position->y - self->lastplayerpositionY;
	self->playervelocity->z = self->player->position->z - self->lastplayerpositionZ;
	self->playervelocity->x *= 75;
	self->playervelocity->y *= 75;
	self->playervelocity->z *= 75;
	self->lastplayerpositionX = self->player->position->x;
	self->lastplayerpositionY = self->player->position->y;
	self->lastplayerpositionZ = self->player->position->z;
}

void Game_GLLoadIdentity(Game const *self)
{
	if (self->currentMatrixModeProjection) {
		if (StackMatrix4_Count(self->pMatrix) > 0) {
			StackMatrix4_Pop(self->pMatrix);
		}
		StackMatrix4_Push(self->pMatrix, self->identityMatrix);
	}
	else {
		if (StackMatrix4_Count(self->mvMatrix) > 0) {
			StackMatrix4_Pop(self->mvMatrix);
		}
		StackMatrix4_Push(self->mvMatrix, self->identityMatrix);
	}
}

void Game_GLLoadMatrix(Game const *self, float const *m)
{
	if (self->currentMatrixModeProjection) {
		if (StackMatrix4_Count(self->pMatrix) > 0) {
			StackMatrix4_Pop(self->pMatrix);
		}
		StackMatrix4_Push(self->pMatrix, m);
	}
	else {
		if (StackMatrix4_Count(self->mvMatrix) > 0) {
			StackMatrix4_Pop(self->mvMatrix);
		}
		StackMatrix4_Push(self->mvMatrix, m);
	}
}

void Game_GLMatrixModeModelView(Game *self)
{
	self->currentMatrixModeProjection = FALSE;
}

void Game_GLMatrixModeProjection(Game *self)
{
	self->currentMatrixModeProjection = TRUE;
}

void Game_GLOrtho(Game const *self, float left, float right, float bottom, float top, float zNear, float zFar)
{
	if (self->currentMatrixModeProjection) {
		float *m = StackMatrix4_Peek(self->pMatrix);
		Mat4_Ortho(m, left, right, bottom, top, zNear, zFar);
	}
	else {
		self->platform->vtbl->throwException(self->platform, "GLOrtho");
	}
}

void Game_GLPopMatrix(Game const *self)
{
	if (self->currentMatrixModeProjection) {
		if (StackMatrix4_Count(self->pMatrix) > 1) {
			StackMatrix4_Pop(self->pMatrix);
		}
	}
	else {
		if (StackMatrix4_Count(self->mvMatrix) > 1) {
			StackMatrix4_Pop(self->mvMatrix);
		}
	}
}

void Game_GLPushMatrix(Game const *self)
{
	if (self->currentMatrixModeProjection) {
		StackMatrix4_Push(self->pMatrix, StackMatrix4_Peek(self->pMatrix));
	}
	else {
		StackMatrix4_Push(self->mvMatrix, StackMatrix4_Peek(self->mvMatrix));
	}
}

void Game_GLRotate(Game const *self, float angle, float x, float y, float z)
{
	float *m;
	angle /= 360;
	angle *= 2 * Game_GetPi();
	if (self->currentMatrixModeProjection) {
		m = StackMatrix4_Peek(self->pMatrix);
	}
	else {
		m = StackMatrix4_Peek(self->mvMatrix);
	}
	Vec3_Set(self->gLRotateTempVec3, x, y, z);
	Mat4_Rotate(m, m, angle, self->gLRotateTempVec3);
}

void Game_GLScale(Game const *self, float x, float y, float z)
{
	float *m;
	if (self->currentMatrixModeProjection) {
		m = StackMatrix4_Peek(self->pMatrix);
	}
	else {
		m = StackMatrix4_Peek(self->mvMatrix);
	}
	Vec3_Set(self->gLScaleTempVec3, x, y, z);
	Mat4_Scale(m, m, self->gLScaleTempVec3);
}

void Game_GLTranslate(Game const *self, float x, float y, float z)
{
	float *m;
	if (self->currentMatrixModeProjection) {
		m = StackMatrix4_Peek(self->pMatrix);
	}
	else {
		m = StackMatrix4_Peek(self->mvMatrix);
	}
	Vec3_Set(self->gLTranslateTempVec3, x, y, z);
	Mat4_Translate(m, m, self->gLTranslateTempVec3);
}

static CachedTexture *Game_GetCachedTextTexture(Game const *self, Text_ const *t)
{
	{
		int i;
		for (i = 0; i < self->cachedTextTexturesMax; i++) {
			CachedTextTexture const *ct = self->cachedTextTextures[i];
			if (ct == NULL) {
				continue;
			}
			if (Text__Equals_(ct->text, t)) {
				return ct->texture;
			}
		}
	}
	return NULL;
}

static int Game_GetCameraBlock(Game const *self)
{
	int bx = Game_MathFloor(self, self->cameraEyeX);
	int by = Game_MathFloor(self, self->cameraEyeZ);
	int bz = Game_MathFloor(self, self->cameraEyeY);
	if (!Map_IsValidPos(self->map, bx, by, bz)) {
		return 0;
	}
	return Map_GetBlockValid(self->map, bx, by, bz);
}

static float Game_GetCharacterEyesHeight(Game const *self)
{
	return self->entities[self->localPlayerId]->drawModel->eyeHeight;
}

static float Game_GetCurrentBlockHealth(Game const *self, int x, int y, int z)
{
	int blocktype;
	if (DictionaryVector3Float_ContainsKey(self->blockHealth, x, y, z)) {
		return DictionaryVector3Float_Get(self->blockHealth, x, y, z);
	}
	blocktype = Map_GetBlock(self->map, x, y, z);
	return GameData_Strength(self->d_Data)[blocktype];
}

static int Game_GetDialogId(Game const *self, const char *name)
{
	{
		int i;
		for (i = 0; i < self->dialogsCount; i++) {
			if (self->dialogs[i] == NULL) {
				continue;
			}
			if (strcmp(self->dialogs[i]->key, name) == 0) {
				return i;
			}
		}
	}
	return -1;
}

static unsigned char const *Game_GetFile(Game const *self, const char *p)
{
	const char *pLowercase = self->platform->vtbl->stringToLower(self->platform, p);
	{
		int i;
		for (i = 0; i < self->assets->count; i++) {
			if (strcmp(self->assets->items[i]->name, pLowercase) == 0) {
				return self->assets->items[i]->data;
			}
		}
	}
	return NULL;
}

static int Game_GetFileLength(Game const *self, const char *p)
{
	const char *pLowercase = self->platform->vtbl->stringToLower(self->platform, p);
	{
		int i;
		for (i = 0; i < self->assets->count; i++) {
			if (strcmp(self->assets->items[i]->name, pLowercase) == 0) {
				return self->assets->items[i]->dataLength;
			}
		}
	}
	return 0;
}

cibool Game_GetFreeMouse(Game const *self)
{
	if (self->overheadcamera) {
		return TRUE;
	}
	return !self->platform->vtbl->isMousePointerLocked(self->platform);
}

static int Game_GetKey(Game const *self, int key)
{
	if (self->options == NULL) {
		return key;
	}
	if (self->options->keys[key] != 0) {
		return self->options->keys[key];
	}
	return key;
}

int Game_GetLight(Game const *self, int x, int y, int z)
{
	int light = Map_MaybeGetLight(self->map, x, y, z);
	if (light == -1) {
		if (x >= 0 && x < self->map->mapSizeX && y >= 0 && y < self->map->mapSizeY && z >= InfiniteMapChunked2d_GetBlock(self->d_Heightmap, x, y)) {
			return self->sunlight_;
		}
		else {
			return 0;
		}
	}
	else {
		return light;
	}
}

float Game_GetPi(void)
{
	float a = 3141592;
	return a / 1000000;
}

GamePlatform const *Game_GetPlatform(Game const *self)
{
	return self->platform;
}

static int Game_GetPlayerEyesBlock(Game const *self)
{
	float pX = self->player->position->x;
	float pY = self->player->position->y;
	float pZ = self->player->position->z;
	int bx;
	int by;
	int bz;
	pY += self->entities[self->localPlayerId]->drawModel->eyeHeight;
	bx = Game_MathFloor(self, pX);
	by = Game_MathFloor(self, pZ);
	bz = Game_MathFloor(self, pY);
	if (!Map_IsValidPos(self->map, bx, by, bz)) {
		if (pY < Game_WaterLevel(self)) {
			return -1;
		}
		return 0;
	}
	return Map_GetBlockValid(self->map, bx, by, bz);
}

int Game_GetPlayerEyesBlockX(Game const *self)
{
	return self->platform->vtbl->floatToInt(self->platform, Game_MathFloor(self, self->player->position->x));
}

int Game_GetPlayerEyesBlockY(Game const *self)
{
	return self->platform->vtbl->floatToInt(self->platform, Game_MathFloor(self, self->player->position->z));
}

int Game_GetPlayerEyesBlockZ(Game const *self)
{
	return self->platform->vtbl->floatToInt(self->platform, Game_MathFloor(self, self->player->position->y + self->entities[self->localPlayerId]->drawModel->eyeHeight));
}

static Packet_ServerRedirect const *Game_GetRedirect(Game const *self)
{
	return self->redirectTo;
}

static int Game_GetTexture(Game const *self, const char *p)
{
	if (!DictionaryStringInt1024_Contains(self->textures, p)) {
		BoolRef const *found = BoolRef_New();
		BitmapCi const *bmp = self->platform->vtbl->bitmapCreateFromPng(self->platform, Game_GetFile(self, p), Game_GetFileLength(self, p));
		int texture = self->platform->vtbl->loadTextureFromBitmap(self->platform, bmp);
		DictionaryStringInt1024_Set(self->textures, p, texture);
		self->platform->vtbl->bitmapDelete(self->platform, bmp);
	}
	return DictionaryStringInt1024_Get(self->textures, p);
}

static int Game_GetTextureOrLoad(Game const *self, const char *name, BitmapCi const *bmp)
{
	if (!DictionaryStringInt1024_Contains(self->textures, name)) {
		BoolRef const *found = BoolRef_New();
		DictionaryStringInt1024_Set(self->textures, name, self->platform->vtbl->loadTextureFromBitmap(self->platform, bmp));
	}
	return DictionaryStringInt1024_Get(self->textures, name);
}

static void Game_GotoDraw2d(Game *self, float dt)
{
	NewFrameEventArgs *args_;
	Game_SetAmbientLight(self, Game_ColorFromArgb(255, 255, 255, 255));
	Game_Draw2d(self, dt);
	args_ = NewFrameEventArgs_New();
	NewFrameEventArgs_SetDt(args_, dt);
	{
		int i;
		for (i = 0; i < self->clientmodsCount; i++) {
			self->clientmods[i]->vtbl->onNewFrame(self->clientmods[i], self, args_);
		}
	}
	self->mouseleftclick = self->mouserightclick = FALSE;
	self->mouseleftdeclick = self->mouserightdeclick = FALSE;
	if (!self->issingleplayer || (self->issingleplayer && self->platform->vtbl->singlePlayerServerLoaded(self->platform)) || !self->platform->vtbl->singlePlayerServerAvailable(self->platform)) {
		if (!self->startedconnecting) {
			self->startedconnecting = TRUE;
			Game_Connect__(self);
		}
	}
}

static void Game_GuiStateBackToGame(Game *self)
{
	self->guistate = GuiState_NORMAL;
	Game_SetFreeMouse(self, FALSE);
}

static void Game_HandleMaterialKeys(Game *self, int eKey)
{
	if (eKey == Game_GetKey(self, 110)) {
		self->activeMaterial = 0;
	}
	if (eKey == Game_GetKey(self, 111)) {
		self->activeMaterial = 1;
	}
	if (eKey == Game_GetKey(self, 112)) {
		self->activeMaterial = 2;
	}
	if (eKey == Game_GetKey(self, 113)) {
		self->activeMaterial = 3;
	}
	if (eKey == Game_GetKey(self, 114)) {
		self->activeMaterial = 4;
	}
	if (eKey == Game_GetKey(self, 115)) {
		self->activeMaterial = 5;
	}
	if (eKey == Game_GetKey(self, 116)) {
		self->activeMaterial = 6;
	}
	if (eKey == Game_GetKey(self, 117)) {
		self->activeMaterial = 7;
	}
	if (eKey == Game_GetKey(self, 118)) {
		self->activeMaterial = 8;
	}
	if (eKey == Game_GetKey(self, 109)) {
		self->activeMaterial = 9;
	}
}

static cibool Game_HasAsset(Game const *self, const char *md5, const char *name)
{
	{
		int i;
		for (i = 0; i < self->assets->count; i++) {
			if (strcmp(self->assets->items[i]->md5, md5) == 0) {
				if (strcmp(self->assets->items[i]->name, name) == 0) {
					return TRUE;
				}
			}
		}
	}
	return FALSE;
}

unsigned char Game_HeadingByte(Game const *self, float orientationX, float orientationY, float orientationZ)
{
	return Game_IntToByte(self->platform->vtbl->floatToInt(self->platform, orientationY % (2 * Game_GetPi()) / (2 * Game_GetPi()) * 256));
}

int Game_Height(Game const *self)
{
	return self->platform->vtbl->getCanvasHeight(self->platform);
}

unsigned char Game_IntToByte(int a)
{
	return (unsigned char) a;
}

static void Game_InvalidVersionAllow(Game *self)
{
	if (self->invalidVersionDrawMessage != NULL) {
		self->invalidVersionDrawMessage = NULL;
		Game_ProcessServerIdentification(self, self->invalidVersionPacketIdentification);
		self->invalidVersionPacketIdentification = NULL;
	}
}

static void Game_InventoryClick(Game const *self, Packet_InventoryPosition *pos)
{
	Game_SendPacketClient(self, ClientPackets_InventoryClick(pos));
}

static Packet_InventoryPosition *Game_InventoryPositionMainArea(Game const *self, int x, int y)
{
	Packet_InventoryPosition *pos = Packet_InventoryPosition_New();
	pos->type = 0;
	pos->areaX = x;
	pos->areaY = y;
	return pos;
}

static Packet_InventoryPosition *Game_InventoryPositionMaterialSelector(Game const *self, int materialId)
{
	Packet_InventoryPosition *pos = Packet_InventoryPosition_New();
	pos->type = 2;
	pos->materialId = materialId;
	return pos;
}

static void Game_InvokeMapLoadingProgress(Game *self, int progressPercent, int progressBytes, const char *status)
{
	self->maploadingprogress = MapLoadingProgressEventArgs_New();
	self->maploadingprogress->progressPercent = progressPercent;
	self->maploadingprogress->progressBytes = progressBytes;
	self->maploadingprogress->progressStatus = status;
}

static cibool Game_IsAnyPlayerInPos(Game const *self, int blockposX, int blockposY, int blockposZ)
{
	{
		int i;
		for (i = 0; i < self->entitiesCount; i++) {
			Entity const *e = self->entities[i];
			if (e == NULL) {
				continue;
			}
			if (e->drawModel == NULL) {
				continue;
			}
			if (e->networkPosition == NULL || (e->networkPosition != NULL && e->networkPosition->positionLoaded)) {
				if (Game_IsPlayerInPos(self, e->position->x, e->position->y, e->position->z, blockposX, blockposY, blockposZ, e->drawModel->modelHeight)) {
					return TRUE;
				}
			}
		}
	}
	return Game_IsPlayerInPos(self, self->player->position->x, self->player->position->y, self->player->position->z, blockposX, blockposY, blockposZ, self->player->drawModel->modelHeight);
}

cibool Game_IsEmptyForPhysics(Game const *self, Packet_BlockType const *block)
{
	return block->drawType == 9 || (block->walkableType != 2 && block->walkableType != 1);
}

static cibool Game_IsFillBlock(Game const *self, int blocktype)
{
	return blocktype == GameData_BlockIdFillArea(self->d_Data) || blocktype == GameData_BlockIdFillStart(self->d_Data) || blocktype == GameData_BlockIdCuboid(self->d_Data);
}

static cibool Game_IsLava(Game const *self, int blockType)
{
	const char *name = self->blocktypes[blockType]->name;
	if (name == NULL) {
		return FALSE;
	}
	return self->platform->vtbl->stringContains(self->platform, name, "Lava");
}

static cibool Game_IsPlayerInPos(Game const *self, float playerposX, float playerposY, float playerposZ, int blockposX, int blockposY, int blockposZ, float playerHeight)
{
	{
		int i;
		for (i = 0; i < Game_FloorFloat(self, playerHeight) + 1; i++) {
			if (ScriptCharacterPhysics_BoxPointDistance(blockposX, blockposZ, blockposY, blockposX + 1, blockposZ + 1, blockposY + 1, playerposX, playerposY + i + self->constWallDistance, playerposZ) < self->constWallDistance) {
				return TRUE;
			}
		}
	}
	return FALSE;
}

cibool Game_IsRail(Game const *self, Packet_BlockType const *block)
{
	return block->rail > 0;
}

static cibool Game_IsTileEmptyForPhysics(Game const *self, int x, int y, int z)
{
	int block;
	if (z >= self->map->mapSizeZ) {
		return TRUE;
	}
	if (x < 0 || y < 0 || z < 0) {
		return Controls_GetFreemove(self->controls) != 0;
	}
	if (x >= self->map->mapSizeX || y >= self->map->mapSizeY) {
		return Controls_GetFreemove(self->controls) != 0;
	}
	block = Map_GetBlockValid(self->map, x, y, z);
	return block == 0 || block == GameData_BlockIdFillArea(self->d_Data) || Game_IsWater(self, block);
}

static cibool Game_IsTileEmptyForPhysicsClose(Game const *self, int x, int y, int z)
{
	return Game_IsTileEmptyForPhysics(self, x, y, z) || (Map_IsValidPos(self->map, x, y, z) && self->blocktypes[Map_GetBlock(self->map, x, y, z)]->drawType == 11) || (Map_IsValidPos(self->map, x, y, z) && Game_IsEmptyForPhysics(self, self->blocktypes[Map_GetBlock(self->map, x, y, z)]));
}

cibool Game_IsTransparentForLight(Packet_BlockType const *b)
{
	return b->drawType != 1 && b->drawType != 8;
}

static cibool Game_IsUsableBlock(Game const *self, int blocktype)
{
	return GameData_IsRailTile(self->d_Data, blocktype) || self->blocktypes[blocktype]->isUsable;
}

static cibool Game_IsValid(Game const *self, int blocktype)
{
	return self->blocktypes[blocktype]->name != NULL;
}

static cibool Game_IsWater(Game const *self, int blockType)
{
	const char *name = self->blocktypes[blockType]->name;
	if (name == NULL) {
		return FALSE;
	}
	return self->platform->vtbl->stringContains(self->platform, name, "Water");
}

static cibool Game_IsWearingWeapon(Game const *self)
{
	return self->d_Inventory->rightHand[self->activeMaterial] != NULL;
}

static void Game_KeyDown(Game *self, int eKey)
{
	self->keyboardStateRaw[eKey] = TRUE;
	if (self->guistate != GuiState_MAP_LOADING) {
		{
			int i;
			for (i = 0; i < self->clientmodsCount; i++) {
				KeyEventArgs *args_ = KeyEventArgs_New();
				KeyEventArgs_SetKeyCode(args_, eKey);
				self->clientmods[i]->vtbl->onKeyDown(self->clientmods[i], self, args_);
				if (KeyEventArgs_GetHandled(args_)) {
					return;
				}
			}
		}
	}
	self->keyboardState[eKey] = TRUE;
	Game_InvalidVersionAllow(self);
	if (eKey == Game_GetKey(self, 15)) {
		float lagSeconds = self->one * (self->platform->vtbl->timeMillisecondsFromStart(self->platform) - self->lastReceivedMilliseconds) / 1000;
		if (lagSeconds >= 10 || self->guistate == GuiState_MAP_LOADING) {
			Game_Reconnect(self);
		}
	}
	if (eKey == Game_GetKey(self, 1) || eKey == Game_GetKey(self, 2)) {
		self->isShiftPressed = TRUE;
	}
	if (self->guistate == GuiState_NORMAL) {
		const char *strFreemoveNotAllowed = "You are not allowed to enable freemove.";
		int playerx;
		int playery;
		if (eKey == Game_GetKey(self, 10)) {
			if (!self->allowFreemove) {
				Game_Log(self, strFreemoveNotAllowed);
				return;
			}
			self->movespeed = self->basemovespeed * 1;
			Game_Log(self, "Move speed: 1x.");
		}
		if (eKey == Game_GetKey(self, 11)) {
			if (!self->allowFreemove) {
				Game_Log(self, strFreemoveNotAllowed);
				return;
			}
			self->movespeed = self->basemovespeed * 10;
			Game_Log(self, self->platform->vtbl->stringFormat(self->platform, Language_MoveSpeed(self->language), self->platform->vtbl->intToString(self->platform, 10)));
		}
		if (eKey == Game_GetKey(self, 12)) {
			if (!self->allowFreemove) {
				Game_Log(self, strFreemoveNotAllowed);
				return;
			}
			self->stopPlayerMove = TRUE;
			if (Controls_GetFreemove(self->controls) == 0) {
				Controls_SetFreemove(self->controls, 1);
				Game_Log(self, Language_MoveFree(self->language));
			}
			else if (Controls_GetFreemove(self->controls) == 1) {
				Controls_SetFreemove(self->controls, 2);
				Game_Log(self, Language_MoveFreeNoclip(self->language));
			}
			else if (Controls_GetFreemove(self->controls) == 2) {
				Controls_SetFreemove(self->controls, 0);
				Game_Log(self, Language_MoveNormal(self->language));
			}
		}
		if (eKey == Game_GetKey(self, 91)) {
			self->drawblockinfo = !self->drawblockinfo;
		}
		playerx = self->platform->vtbl->floatToInt(self->platform, self->player->position->x);
		playery = self->platform->vtbl->floatToInt(self->platform, self->player->position->z);
		if (playerx >= 0 && playerx < self->map->mapSizeX && playery >= 0 && playery < self->map->mapSizeY) {
			DictionaryStringString_Set(self->performanceinfo, "height", self->platform->vtbl->stringFormat(self->platform, "height:{0}", self->platform->vtbl->intToString(self->platform, InfiniteMapChunked2d_GetBlock(self->d_Heightmap, playerx, playery))));
		}
		if (eKey == Game_GetKey(self, 14)) {
			Game_CameraChange(self);
		}
		if (eKey == Game_GetKey(self, 121) || eKey == Game_GetKey(self, 80)) {
			if (self->cameratype == CameraType_OVERHEAD) {
				self->overheadcameradistance -= 1;
			}
			else if (self->cameratype == CameraType_TPP) {
				self->tppcameradistance -= 1;
			}
		}
		if (eKey == Game_GetKey(self, 120) || eKey == Game_GetKey(self, 79)) {
			if (self->cameratype == CameraType_OVERHEAD) {
				self->overheadcameradistance += 1;
			}
			else if (self->cameratype == CameraType_TPP) {
				self->tppcameradistance += 1;
			}
		}
		if (self->overheadcameradistance < self->tPP_CAMERA_DISTANCE_MIN) {
			self->overheadcameradistance = self->tPP_CAMERA_DISTANCE_MIN;
		}
		if (self->overheadcameradistance > self->tPP_CAMERA_DISTANCE_MAX) {
			self->overheadcameradistance = self->tPP_CAMERA_DISTANCE_MAX;
		}
		if (self->tppcameradistance < self->tPP_CAMERA_DISTANCE_MIN) {
			self->tppcameradistance = self->tPP_CAMERA_DISTANCE_MIN;
		}
		if (self->tppcameradistance > self->tPP_CAMERA_DISTANCE_MAX) {
			self->tppcameradistance = self->tPP_CAMERA_DISTANCE_MAX;
		}
		if (eKey == Game_GetKey(self, 15)) {
			Game_RedrawAllBlocks(self);
		}
		if (eKey == 17) {
			Game_ToggleVsync(self);
			if (self->eNABLE_LAG == 0) {
				Game_Log(self, Language_FrameRateVsync(self->language));
			}
			if (self->eNABLE_LAG == 1) {
				Game_Log(self, Language_FrameRateUnlimited(self->language));
			}
			if (self->eNABLE_LAG == 2) {
				Game_Log(self, Language_FrameRateLagSimulation(self->language));
			}
		}
		if (eKey == Game_GetKey(self, 52)) {
			Game_SendPacketClient(self, ClientPackets_SpecialKeyTabPlayerList());
		}
		if (eKey == Game_GetKey(self, 87)) {
			if (self->currentAttackedBlock != NULL) {
				int posX = self->currentAttackedBlock->x;
				int posY = self->currentAttackedBlock->y;
				int posZ = self->currentAttackedBlock->z;
				int blocktype = Map_GetBlock(self->map, self->currentAttackedBlock->x, self->currentAttackedBlock->y, self->currentAttackedBlock->z);
				if (Game_IsUsableBlock(self, blocktype)) {
					if (GameData_IsRailTile(self->d_Data, blocktype)) {
						self->player->position->x = posX + self->one / 2;
						self->player->position->y = posZ + 1;
						self->player->position->z = posY + self->one / 2;
						self->stopPlayerMove = TRUE;
						Controls_SetFreemove(self->controls, 0);
					}
					else {
						Game_SendSetBlock(self, posX, posY, posZ, 2, 0, self->activeMaterial);
					}
				}
			}
			if (self->currentlyAttackedEntity != -1) {
				if (self->entities[self->currentlyAttackedEntity]->usable) {
					{
						int i;
						for (i = 0; i < self->clientmodsCount; i++) {
							OnUseEntityArgs *args;
							if (self->clientmods[i] == NULL) {
								continue;
							}
							args = OnUseEntityArgs_New();
							args->entityId = self->currentlyAttackedEntity;
							self->clientmods[i]->vtbl->onUseEntity(self->clientmods[i], self, args);
						}
					}
					Game_SendPacketClient(self, ClientPackets_UseEntity(self->currentlyAttackedEntity));
				}
			}
		}
		if (eKey == Game_GetKey(self, 97)) {
			Game_Respawn(self);
		}
		if (eKey == Game_GetKey(self, 94)) {
			Game_SendPacketClient(self, ClientPackets_SpecialKeySelectTeam());
		}
		if (eKey == Game_GetKey(self, 98)) {
			Game_SendPacketClient(self, ClientPackets_SpecialKeySetSpawn());
			self->playerPositionSpawnX = self->player->position->x;
			self->playerPositionSpawnY = self->player->position->y;
			self->playerPositionSpawnZ = self->player->position->z;
			self->player->position->x = self->platform->vtbl->floatToInt(self->platform, self->player->position->x) + self->one / 2;
			self->player->position->z = self->platform->vtbl->floatToInt(self->platform, self->player->position->z) + self->one / 2;
		}
		if (eKey == Game_GetKey(self, 88)) {
			Game_ToggleFog(self);
			Game_Log(self, self->platform->vtbl->stringFormat(self->platform, Language_FogDistance(self->language), self->platform->vtbl->intToString(self->platform, self->platform->vtbl->floatToInt(self->platform, self->d_Config3d->viewdistance))));
			Game_OnResize(self);
		}
		if (eKey == Game_GetKey(self, 84)) {
			Game_ShowInventory(self);
			return;
		}
		Game_HandleMaterialKeys(self, eKey);
	}
	if (self->guistate == GuiState_INVENTORY) {
		if (eKey == Game_GetKey(self, 84) || eKey == Game_GetKey(self, 50)) {
			Game_GuiStateBackToGame(self);
		}
		return;
	}
	if (self->guistate == GuiState_MAP_LOADING) {
		if (eKey == Game_GetKey(self, 50)) {
			Game_ExitToMainMenu_(self);
		}
	}
	if (self->guistate == GuiState_CRAFTING_RECIPES) {
		if (eKey == Game_GetKey(self, 50)) {
			Game_GuiStateBackToGame(self);
		}
	}
	if (self->guistate == GuiState_NORMAL) {
		if (eKey == Game_GetKey(self, 50)) {
			Game_EscapeMenuStart(self);
			return;
		}
	}
}

static void Game_KeyPress(Game const *self, int eKeyChar)
{
	{
		int i;
		for (i = 0; i < self->clientmodsCount; i++) {
			KeyPressEventArgs *args_;
			if (self->clientmods[i] == NULL) {
				continue;
			}
			args_ = KeyPressEventArgs_New();
			KeyPressEventArgs_SetKeyChar(args_, eKeyChar);
			self->clientmods[i]->vtbl->onKeyPress(self->clientmods[i], self, args_);
			if (KeyPressEventArgs_GetHandled(args_)) {
				return;
			}
		}
	}
}

static void Game_KeyUp(Game *self, int eKey)
{
	self->keyboardStateRaw[eKey] = FALSE;
	{
		int i;
		for (i = 0; i < self->clientmodsCount; i++) {
			KeyEventArgs *args_ = KeyEventArgs_New();
			KeyEventArgs_SetKeyCode(args_, eKey);
			self->clientmods[i]->vtbl->onKeyUp(self->clientmods[i], self, args_);
			if (KeyEventArgs_GetHandled(args_)) {
				return;
			}
		}
	}
	self->keyboardState[eKey] = FALSE;
	if (eKey == Game_GetKey(self, 1) || eKey == Game_GetKey(self, 2)) {
		self->isShiftPressed = FALSE;
	}
}

static cibool Game_LavaSwimmingCamera(Game const *self)
{
	return Game_IsLava(self, Game_GetCameraBlock(self));
}

static float Game_Length(Game const *self, float x, float y, float z)
{
	return self->platform->vtbl->mathSqrt(self->platform, x * x + y * y + z * z);
}

static void Game_Log(Game *self, const char *p)
{
	Game_AddChatline(self, p);
}

static void Game_MainThreadOnRenderFrame(Game *self, float deltaTime)
{
	float constMouseDt;
	float dt;
	cibool drawgame;
	Game_UpdateResize(self);
	if (self->guistate == GuiState_MAP_LOADING) {
		self->platform->vtbl->glClearColorRgbaf(self->platform, 0, 0, 0, 1);
	}
	else {
		self->platform->vtbl->glClearColorRgbaf(self->platform, self->one * 0 / 255, self->one * 0 / 255, self->one * 0 / 255, self->one * 255 / 255);
	}
	self->mouseSmoothingAccum += deltaTime;
	constMouseDt = 1f / 300;
	while (self->mouseSmoothingAccum > constMouseDt) {
		self->mouseSmoothingAccum -= constMouseDt;
		Game_UpdateMouseViewportControl(self, constMouseDt);
	}
	self->platform->vtbl->applicationDoEvents(self->platform);
	self->accumulator += deltaTime;
	if (self->accumulator > 1) {
		self->accumulator = 1;
	}
	dt = self->one / 75;
	while (self->accumulator >= dt) {
		Game_FrameTick(self, dt);
		self->accumulator -= dt;
	}
	if (self->guistate == GuiState_MAP_LOADING) {
		Game_GotoDraw2d(self, deltaTime);
		return;
	}
	if (self->eNABLE_LAG == 2) {
		self->platform->vtbl->threadSpinWait(self->platform, 20000000);
	}
	Game_SetAmbientLight(self, Game_terraincolor(self));
	self->platform->vtbl->glClearColorBufferAndDepthBuffer(self->platform);
	self->platform->vtbl->bindTexture2d(self->platform, ITerrainTextures_terrainTexture(self->d_TerrainTextures));
	{
		int i;
		for (i = 0; i < self->clientmodsCount; i++) {
			if (self->clientmods[i] == NULL) {
				continue;
			}
			self->clientmods[i]->vtbl->onBeforeNewFrameDraw3d(self->clientmods[i], self, deltaTime);
		}
	}
	Game_GLMatrixModeModelView(self);
	Game_GLLoadMatrix(self, self->camera);
	self->cameraMatrix->lastmvmatrix = self->camera;
	FrustumCulling_CalcFrustumEquations(self->d_FrustumCulling);
	drawgame = self->guistate != GuiState_MAP_LOADING;
	if (drawgame) {
		self->platform->vtbl->glEnableDepthTest(self->platform);
		{
			int i;
			for (i = 0; i < self->clientmodsCount; i++) {
				if (self->clientmods[i] == NULL) {
					continue;
				}
				self->clientmods[i]->vtbl->onNewFrameDraw3d(self->clientmods[i], self, deltaTime);
			}
		}
	}
	Game_GotoDraw2d(self, deltaTime);
}

static CachedTexture *Game_MakeTextTexture(Game const *self, Text_ const *t)
{
	CachedTexture *ct = CachedTexture_New();
	BitmapCi const *bmp = TextColorRenderer_CreateTextTexture(self->textColorRenderer, t);
	ct->sizeX = self->platform->vtbl->bitmapGetWidth(self->platform, bmp);
	ct->sizeY = self->platform->vtbl->bitmapGetHeight(self->platform, bmp);
	ct->textureId = self->platform->vtbl->loadTextureFromBitmap(self->platform, bmp);
	self->platform->vtbl->bitmapDelete(self->platform, bmp);
	return ct;
}

static void Game_MapLoaded(Game *self)
{
	Game_RedrawAllBlocks(self);
	self->materialSlots = GameData_DefaultMaterialSlots(self->d_Data);
	Game_GuiStateBackToGame(self);
	self->playerPositionSpawnX = self->player->position->x;
	self->playerPositionSpawnY = self->player->position->y;
	self->playerPositionSpawnZ = self->player->position->z;
}

void Game_MapLoadingStart(Game *self)
{
	self->guistate = GuiState_MAP_LOADING;
	Game_SetFreeMouse(self, TRUE);
	self->maploadingprogress = MapLoadingProgressEventArgs_New();
	self->fontMapLoading = FontCi_Create("Arial", 14, 0);
}

int Game_MaterialSlots_(Game const *self, int i)
{
	Packet_Item const *item = self->d_Inventory->rightHand[i];
	int m = GameData_BlockIdDirt(self->d_Data);
	if (item != NULL && item->itemClass == 0) {
		m = self->d_Inventory->rightHand[i]->blockId;
	}
	return m;
}

int Game_MathFloor(Game const *self, float a)
{
	if (a >= 0) {
		return self->platform->vtbl->floatToInt(self->platform, a);
	}
	else {
		return self->platform->vtbl->floatToInt(self->platform, a) - 1;
	}
}

static void Game_MouseDown(Game *self, MouseEventArgs const *args)
{
	if (MouseEventArgs_GetButton(args) == 0) {
		self->mouseLeft = TRUE;
	}
	if (MouseEventArgs_GetButton(args) == 1) {
		self->mouseMiddle = TRUE;
	}
	if (MouseEventArgs_GetButton(args) == 2) {
		self->mouseRight = TRUE;
	}
	if (MouseEventArgs_GetButton(args) == 0) {
		self->mouseleftclick = TRUE;
	}
	if (MouseEventArgs_GetButton(args) == 2) {
		self->mouserightclick = TRUE;
	}
	{
		int i;
		for (i = 0; i < self->clientmodsCount; i++) {
			if (self->clientmods[i] == NULL) {
				continue;
			}
			self->clientmods[i]->vtbl->onMouseDown(self->clientmods[i], self, args);
		}
	}
	if (self->mousePointerLockShouldBe) {
		self->platform->vtbl->requestMousePointerLock(self->platform);
		self->mouseDeltaX = 0;
		self->mouseDeltaY = 0;
	}
	Game_InvalidVersionAllow(self);
}

void Game_MouseMove(Game *self, MouseEventArgs const *e)
{
	if (!MouseEventArgs_GetEmulated(e) || MouseEventArgs_GetForceUsage(e)) {
		self->mouseCurrentX = MouseEventArgs_GetX(e);
		self->mouseCurrentY = MouseEventArgs_GetY(e);
	}
	if (MouseEventArgs_GetEmulated(e) || MouseEventArgs_GetForceUsage(e)) {
		self->mouseDeltaX += MouseEventArgs_GetMovementX(e);
		self->mouseDeltaY += MouseEventArgs_GetMovementY(e);
	}
	{
		int i;
		for (i = 0; i < self->clientmodsCount; i++) {
			if (self->clientmods[i] == NULL) {
				continue;
			}
			self->clientmods[i]->vtbl->onMouseMove(self->clientmods[i], self, e);
		}
	}
}

static void Game_MouseUp(Game *self, MouseEventArgs const *args)
{
	if (MouseEventArgs_GetButton(args) == 0) {
		self->mouseLeft = FALSE;
	}
	if (MouseEventArgs_GetButton(args) == 1) {
		self->mouseMiddle = FALSE;
	}
	if (MouseEventArgs_GetButton(args) == 2) {
		self->mouseRight = FALSE;
	}
	if (MouseEventArgs_GetButton(args) == 0) {
		self->mouseleftdeclick = TRUE;
	}
	if (MouseEventArgs_GetButton(args) == 2) {
		self->mouserightdeclick = TRUE;
	}
	{
		int i;
		for (i = 0; i < self->clientmodsCount; i++) {
			if (self->clientmods[i] == NULL) {
				continue;
			}
			self->clientmods[i]->vtbl->onMouseUp(self->clientmods[i], self, args);
		}
	}
}

static void Game_MouseWheelChanged(Game *self, MouseWheelEventArgs const *e)
{
	float eDeltaPrecise = MouseWheelEventArgs_GetDeltaPrecise(e);
	if (self->keyboardState[Game_GetKey(self, 1)]) {
		if (self->cameratype == CameraType_OVERHEAD) {
			self->overheadcameradistance -= eDeltaPrecise;
			if (self->overheadcameradistance < self->tPP_CAMERA_DISTANCE_MIN) {
				self->overheadcameradistance = self->tPP_CAMERA_DISTANCE_MIN;
			}
			if (self->overheadcameradistance > self->tPP_CAMERA_DISTANCE_MAX) {
				self->overheadcameradistance = self->tPP_CAMERA_DISTANCE_MAX;
			}
		}
		if (self->cameratype == CameraType_TPP) {
			self->tppcameradistance -= eDeltaPrecise;
			if (self->tppcameradistance < self->tPP_CAMERA_DISTANCE_MIN) {
				self->tppcameradistance = self->tPP_CAMERA_DISTANCE_MIN;
			}
			if (self->tppcameradistance > self->tPP_CAMERA_DISTANCE_MAX) {
				self->tppcameradistance = self->tPP_CAMERA_DISTANCE_MAX;
			}
		}
	}
	{
		int i;
		for (i = 0; i < self->clientmodsCount; i++) {
			if (self->clientmods[i] == NULL) {
				continue;
			}
			self->clientmods[i]->vtbl->onMouseWheelChanged(self->clientmods[i], self, e);
		}
	}
}

static float Game_MoveSpeedNow(Game const *self)
{
	float movespeednow = self->movespeed;
	Packet_Item const *item;
	{
		int blockunderplayer = Game_BlockUnderPlayer(self);
		if (blockunderplayer != -1) {
			float floorSpeed = GameData_WalkSpeed(self->d_Data)[blockunderplayer];
			if (floorSpeed != 0) {
				movespeednow *= floorSpeed;
			}
		}
	}
	if (self->keyboardState[Game_GetKey(self, 1)]) {
		movespeednow *= self->one * 2 / 10;
	}
	item = self->d_Inventory->rightHand[self->activeMaterial];
	if (item != NULL && item->itemClass == 0) {
		float itemSpeed = Game_DeserializeFloat(self, self->blocktypes[item->blockId]->walkSpeedWhenUsedFloat);
		if (itemSpeed != 0) {
			movespeednow *= itemSpeed;
		}
		if (self->ironSights) {
			float ironSightsSpeed = Game_DeserializeFloat(self, self->blocktypes[item->blockId]->ironSightsMoveSpeedFloat);
			if (ironSightsSpeed != 0) {
				movespeednow *= ironSightsSpeed;
			}
		}
	}
	return movespeednow;
}

static void Game_MoveToInventory(Game const *self, Packet_InventoryPosition *from)
{
	Game_SendPacketClient(self, ClientPackets_MoveToInventory(from));
}

static BlockPosSide const *Game_Nearest(Game const *self, BlockPosSide const *const *pick2, int pick2Count, float x, float y, float z)
{
	float minDist = 1000000;
	BlockPosSide const *nearest = NULL;
	{
		int i;
		for (i = 0; i < pick2Count; i++) {
			float dist = Game_Dist(self, pick2[i]->blockPos[0], pick2[i]->blockPos[1], pick2[i]->blockPos[2], x, y, z);
			if (dist < minDist) {
				minDist = dist;
				nearest = pick2[i];
			}
		}
	}
	return nearest;
}

float Game_NextFloat(Game const *self, float min, float max)
{
	return self->rnd->vtbl->nextFloat(self->rnd) * (max - min) + min;
}

void Game_OnBackPressed(Game const *self)
{
}

static void Game_OnFocusChanged(Game *self)
{
	if (self->guistate == GuiState_NORMAL) {
		Game_EscapeMenuStart(self);
	}
}

void Game_OnRenderFrame(Game const *self, float deltaTime)
{
	TaskScheduler_Update(self->taskScheduler, self, deltaTime);
}

static void Game_OnResize(Game *self)
{
	self->platform->vtbl->glViewport(self->platform, 0, 0, Game_Width(self), Game_Height(self));
	Game_Set3dProjection2(self);
	if (self->sendResize) {
		Game_SendGameResolution(self);
	}
}

void Game_OnTouchEnd(Game *self, TouchEventArgs const *e)
{
	self->mouseCurrentX = 0;
	self->mouseCurrentY = 0;
	{
		int i;
		for (i = 0; i < self->clientmodsCount; i++) {
			if (self->clientmods[i] == NULL) {
				continue;
			}
			self->clientmods[i]->vtbl->onTouchEnd(self->clientmods[i], self, e);
			if (TouchEventArgs_GetHandled(e)) {
				return;
			}
		}
	}
}

void Game_OnTouchMove(Game const *self, TouchEventArgs const *e)
{
	{
		int i;
		for (i = 0; i < self->clientmodsCount; i++) {
			if (self->clientmods[i] == NULL) {
				continue;
			}
			self->clientmods[i]->vtbl->onTouchMove(self->clientmods[i], self, e);
			if (TouchEventArgs_GetHandled(e)) {
				return;
			}
		}
	}
}

void Game_OnTouchStart(Game *self, TouchEventArgs const *e)
{
	Game_InvalidVersionAllow(self);
	self->mouseCurrentX = TouchEventArgs_GetX(e);
	self->mouseCurrentY = TouchEventArgs_GetY(e);
	self->mouseleftclick = TRUE;
	{
		int i;
		for (i = 0; i < self->clientmodsCount; i++) {
			if (self->clientmods[i] == NULL) {
				continue;
			}
			self->clientmods[i]->vtbl->onTouchStart(self->clientmods[i], self, e);
			if (TouchEventArgs_GetHandled(e)) {
				return;
			}
		}
	}
}

void Game_OrthoMode(Game *self, int width, int height)
{
	Game_GLMatrixModeProjection(self);
	Game_GLPushMatrix(self);
	Game_GLLoadIdentity(self);
	Game_GLOrtho(self, 0, width, height, 0, 0, 1);
	Game_SetMatrixUniformProjection(self);
	Game_GLMatrixModeModelView(self);
	Game_GLPushMatrix(self);
	Game_GLLoadIdentity(self);
	Game_SetMatrixUniformModelView(self);
}

void Game_PerspectiveMode(Game *self)
{
	Game_GLMatrixModeProjection(self);
	Game_GLPopMatrix(self);
	Game_SetMatrixUniformProjection(self);
	Game_GLMatrixModeModelView(self);
	Game_GLPopMatrix(self);
	Game_SetMatrixUniformModelView(self);
}

BlockPosSide const *const *Game_Pick(Game const *self, BlockOctreeSearcher *s_, Line3D const *line, IntRef *retCount)
{
	int minX = self->platform->vtbl->floatToInt(self->platform, MathCi_MinFloat(line->start[0], line->end[0]));
	int minY = self->platform->vtbl->floatToInt(self->platform, MathCi_MinFloat(line->start[1], line->end[1]));
	int minZ = self->platform->vtbl->floatToInt(self->platform, MathCi_MinFloat(line->start[2], line->end[2]));
	int maxX;
	int maxY;
	int maxZ;
	int sizex;
	int sizey;
	int sizez;
	int size;
	BlockPosSide const **pick2;
	if (minX < 0) {
		minX = 0;
	}
	if (minY < 0) {
		minY = 0;
	}
	if (minZ < 0) {
		minZ = 0;
	}
	maxX = self->platform->vtbl->floatToInt(self->platform, MathCi_MaxFloat(line->start[0], line->end[0]));
	maxY = self->platform->vtbl->floatToInt(self->platform, MathCi_MaxFloat(line->start[1], line->end[1]));
	maxZ = self->platform->vtbl->floatToInt(self->platform, MathCi_MaxFloat(line->start[2], line->end[2]));
	if (maxX > self->map->mapSizeX) {
		maxX = self->map->mapSizeX;
	}
	if (maxY > self->map->mapSizeZ) {
		maxY = self->map->mapSizeZ;
	}
	if (maxZ > self->map->mapSizeY) {
		maxZ = self->map->mapSizeY;
	}
	sizex = maxX - minX + 1;
	sizey = maxY - minY + 1;
	sizez = maxZ - minZ + 1;
	size = BitTools_NextPowerOfTwo(MathCi_MaxInt(sizex, MathCi_MaxInt(sizey, sizez)));
	s_->startBox = Box3D_Create(minX, minY, minZ, size);
	pick2 = BlockOctreeSearcher_LineIntersection(s_, &IsBlockEmpty__Create(self)->base, &GetBlockHeight__Create(self)->base, line, retCount);
	Game_PickSort(self, pick2, retCount->value, line->start[0], line->start[1], line->start[2]);
	return pick2;
}

static void Game_PickSort(Game const *self, BlockPosSide const **pick, int pickCount, float x, float y, float z)
{
	cibool changed = FALSE;
	do {
		changed = FALSE;
		{
			int i;
			for (i = 0; i < pickCount - 1; i++) {
				float dist = Game_Dist(self, pick[i]->blockPos[0], pick[i]->blockPos[1], pick[i]->blockPos[2], x, y, z);
				float distNext = Game_Dist(self, pick[i + 1]->blockPos[0], pick[i + 1]->blockPos[1], pick[i + 1]->blockPos[2], x, y, z);
				if (dist > distNext) {
					BlockPosSide const *swapTemp;
					changed = TRUE;
					swapTemp = pick[i];
					pick[i] = pick[i + 1];
					pick[i + 1] = swapTemp;
				}
			}
		}
	}
	while (changed);
}

unsigned char Game_PitchByte(Game const *self, float orientationX, float orientationY, float orientationZ)
{
	float xx = (orientationX + Game_GetPi()) % (2 * Game_GetPi());
	xx = xx / (2 * Game_GetPi());
	return Game_IntToByte(self->platform->vtbl->floatToInt(self->platform, xx * 256));
}

void Game_PlaySoundAt(Game const *self, const char *name, float x, float y, float z)
{
	if (x == 0 && y == 0 && z == 0) {
		Game_AudioPlay(self, name);
	}
	else {
		Game_AudioPlayAt(self, name, x, z, y);
	}
}

static void Game_ProcessServerIdentification(Game *self, Packet_Server const *packet)
{
	Packet_StringList const *requiredMd5;
	Packet_StringList const *requiredName;
	int getCount;
	self->localPlayerId = packet->identification->assignedClientId;
	self->serverInfo->connectdata = self->connectdata;
	self->serverInfo->serverName = packet->identification->serverName;
	self->serverInfo->serverMotd = packet->identification->serverMotd;
	self->d_TerrainChunkTesselator->eNABLE_TEXTURE_TILING = packet->identification->renderHint_ == 0;
	requiredMd5 = packet->identification->requiredBlobMd5;
	requiredName = packet->identification->requiredBlobName;
	Game_ChatLog(self, "[GAME] Processed server identification");
	getCount = 0;
	if (requiredMd5 != NULL) {
		Game_ChatLog(self, self->platform->vtbl->stringFormat(self->platform, "[GAME] Server has {0} assets", self->platform->vtbl->intToString(self->platform, requiredMd5->itemsCount)));
		{
			int i;
			for (i = 0; i < requiredMd5->itemsCount; i++) {
				const char *md5 = requiredMd5->items[i];
				if (self->platform->vtbl->isCached(self->platform, md5)) {
					Asset const *cachedAsset = self->platform->vtbl->loadAssetFromCache(self->platform, md5);
					const char *name;
					if (requiredName != NULL) {
						name = requiredName->items[i];
					}
					else {
						name = cachedAsset->name;
					}
					Game_SetFile(self, name, cachedAsset->md5, cachedAsset->data, cachedAsset->dataLength);
				}
				else {
					if (requiredName != NULL) {
						if (!Game_HasAsset(self, md5, requiredName->items[i])) {
							self->getAsset[getCount++] = md5;
						}
					}
					else {
						self->getAsset[getCount++] = md5;
					}
				}
			}
		}
		Game_ChatLog(self, self->platform->vtbl->stringFormat(self->platform, "[GAME] Will download {0} missing assets", self->platform->vtbl->intToString(self->platform, getCount)));
	}
	Game_SendGameResolution(self);
	Game_ChatLog(self, "[GAME] Sent window resolution to server");
	self->sendResize = TRUE;
	Game_SendRequestBlob(self, self->getAsset, getCount);
	Game_ChatLog(self, "[GAME] Sent BLOB request");
	if (packet->identification->mapSizeX != self->map->mapSizeX || packet->identification->mapSizeY != self->map->mapSizeY || packet->identification->mapSizeZ != self->map->mapSizeZ) {
		Map_Reset(self->map, packet->identification->mapSizeX, packet->identification->mapSizeY, packet->identification->mapSizeZ);
		InfiniteMapChunked2d_Restart(self->d_Heightmap);
	}
	self->shadowssimple = packet->identification->disableShadows == 1 ? TRUE : FALSE;
	self->maxdrawdistance = 256;
	Game_ChatLog(self, "[GAME] Map initialized");
}

void Game_QueueActionCommit(Game const *self, Action_ const *action)
{
	ListAction_Add(self->commitActions, action);
}

static float Game_RadToAngle256(float value)
{
	return value / (2 * Game_GetPi()) * 255;
}

static void Game_Reconnect(Game *self)
{
	self->reconnect = TRUE;
}

static void Game_RedrawAllBlocks(Game *self)
{
	self->shouldRedrawAllBlocks = TRUE;
}

static void Game_RedrawBlock(Game const *self, int x, int y, int z)
{
	Map_SetBlockDirty(self->map, x, y, z);
}

static void Game_Respawn(Game *self)
{
	Game_SendPacketClient(self, ClientPackets_SpecialKeyRespawn());
	self->stopPlayerMove = TRUE;
}

static void Game_RevertSpeculative(Game const *self, float dt)
{
	{
		int i;
		for (i = 0; i < self->speculativeCount; i++) {
			Speculative const *s_ = self->speculative[i];
			if (s_ == NULL) {
				continue;
			}
			if (self->one * (self->platform->vtbl->timeMillisecondsFromStart(self->platform) - s_->timeMilliseconds) / 1000 > 2) {
				Game_RedrawBlock(self, s_->x, s_->y, s_->z);
				self->speculative[i] = NULL;
			}
		}
	}
}

float Game_Scale(Game const *self)
{
	if (self->platform->vtbl->isSmallScreen(self->platform)) {
		float scale = self->one * Game_Width(self) / 1280;
		return scale;
	}
	else {
		return self->one;
	}
}

static void Game_SendChat(Game const *self, const char *s)
{
	Game_SendPacketClient(self, ClientPackets_Chat(s, self->isTeamchat ? 1 : 0));
}

static void Game_SendFillArea(Game const *self, int startx, int starty, int startz, int endx, int endy, int endz, int blockType)
{
	Game_SendPacketClient(self, ClientPackets_FillArea(startx, starty, startz, endx, endy, endz, blockType, self->activeMaterial));
}

static void Game_SendGameResolution(Game const *self)
{
	Game_SendPacketClient(self, ClientPackets_GameResolution(Game_Width(self), Game_Height(self)));
}

static void Game_SendLeave(Game const *self, int reason)
{
	Game_SendPacketClient(self, ClientPackets_Leave(reason));
}

void Game_SendPacket(Game const *self, unsigned char const *packet, int packetLength)
{
	INetOutgoingMessage *msg = INetOutgoingMessage_New();
	INetOutgoingMessage_Write(msg, packet, packetLength);
	self->main->vtbl->sendMessage(self->main, msg, MyNetDeliveryMethod_RELIABLE_ORDERED);
}

void Game_SendPacketClient(Game const *self, Packet_Client const *packetClient)
{
	unsigned char const *packet = Game_Serialize(self, packetClient, self->packetLen);
	Game_SendPacket(self, packet, self->packetLen->value);
}

static void Game_SendPingReply(Game const *self)
{
	Game_SendPacketClient(self, ClientPackets_PingReply());
}

static void Game_SendRequestBlob(Game const *self, const char **required, int requiredCount)
{
	Game_SendPacketClient(self, ClientPackets_RequestBlob(self, required, requiredCount));
}

static void Game_SendSetBlock(Game const *self, int x, int y, int z, int mode, int type, int materialslot)
{
	Game_SendPacketClient(self, ClientPackets_SetBlock(x, y, z, mode, type, materialslot));
}

static void Game_SendSetBlockAndUpdateSpeculative(Game *self, int material, int x, int y, int z, int mode)
{
	Packet_Item const *item;
	Game_SendSetBlock(self, x, y, z, mode, material, self->activeMaterial);
	item = self->d_Inventory->rightHand[self->activeMaterial];
	if (item != NULL && item->itemClass == 0) {
		int blockid = material;
		Speculative *s_;
		if (mode == 0) {
			blockid = 0;
		}
		s_ = Speculative_New();
		s_->x = x;
		s_->y = y;
		s_->z = z;
		s_->blocktype = Map_GetBlock(self->map, x, y, z);
		s_->timeMilliseconds = self->platform->vtbl->timeMillisecondsFromStart(self->platform);
		Game_AddSpeculative(self, s_);
		Game_SetBlock(self, x, y, z, blockid);
		Game_RedrawBlock(self, x, y, z);
	}
	else {
	}
}

unsigned char const *Game_Serialize(Game const *self, Packet_Client const *packet, IntRef *retLength)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	unsigned char const *data;
	Packet_ClientSerializer_Serialize(&ms->base, packet);
	data = CitoMemoryStream_ToArray(ms);
	retLength->value = CitoMemoryStream_Length(ms);
	return data;
}

int Game_SerializeFloat(Game const *self, float p)
{
	return self->platform->vtbl->floatToInt(self->platform, p * 32);
}

void Game_Set3dProjection(Game *self, float zfar, float fov)
{
	float aspect_ratio = self->one * Game_Width(self) / Game_Height(self);
	Mat4_Perspective(self->set3dProjectionTempMat4, fov, aspect_ratio, self->znear, zfar);
	self->cameraMatrix->lastpmatrix = self->set3dProjectionTempMat4;
	Game_GLMatrixModeProjection(self);
	Game_GLLoadMatrix(self, self->set3dProjectionTempMat4);
	Game_SetMatrixUniformProjection(self);
}

static void Game_Set3dProjection1(Game *self, float zfar_)
{
	Game_Set3dProjection(self, zfar_, Game_currentfov(self));
}

static void Game_Set3dProjection2(Game *self)
{
	Game_Set3dProjection1(self, Game_zfar(self));
}

static void Game_SetAmbientLight(Game const *self, int color)
{
	int r = Game_ColorR(color);
	int g = Game_ColorG(color);
	int b = Game_ColorB(color);
	self->platform->vtbl->glLightModelAmbient(self->platform, r, g, b);
}

static void Game_SetBlock(Game *self, int x, int y, int z, int tileType)
{
	Map_SetBlockRaw(self->map, x, y, z, tileType);
	Map_SetChunkDirty(self->map, x / 16, y / 16, z / 16, TRUE, TRUE);
	Game_ShadowsOnSetBlock(self, x, y, z);
	self->lastplacedblockX = x;
	self->lastplacedblockY = y;
	self->lastplacedblockZ = z;
}

static void Game_SetCamera(Game *self, CameraType type)
{
	if (type == CameraType_FPP) {
		self->cameratype = CameraType_FPP;
		Game_SetFreeMouse(self, FALSE);
		self->eNABLE_TPP_VIEW = FALSE;
		self->overheadcamera = FALSE;
	}
	else if (type == CameraType_TPP) {
		self->cameratype = CameraType_TPP;
		self->eNABLE_TPP_VIEW = TRUE;
	}
	else {
		self->cameratype = CameraType_OVERHEAD;
		self->overheadcamera = TRUE;
		Game_SetFreeMouse(self, TRUE);
		self->eNABLE_TPP_VIEW = TRUE;
		self->playerdestination = Vector3Ref_Create(self->player->position->x, self->player->position->y, self->player->position->z);
	}
}

static void Game_SetCharacterEyesHeight(Game const *self, float value)
{
	self->entities[self->localPlayerId]->drawModel->eyeHeight = value;
}

void Game_SetFile(Game const *self, const char *name, const char *md5, unsigned char const *downloaded, int downloadedLength)
{
	const char *nameLowercase = self->platform->vtbl->stringToLower(self->platform, name);
	Asset *newAsset;
	if (strcmp(nameLowercase, "mousecursor.png") == 0) {
		self->platform->vtbl->setWindowCursor(self->platform, 0, 0, 32, 32, downloaded, downloadedLength);
	}
	newAsset = Asset_New();
	newAsset->data = downloaded;
	newAsset->dataLength = downloadedLength;
	newAsset->name = nameLowercase;
	newAsset->md5 = md5;
	{
		int i;
		for (i = 0; i < self->assets->count; i++) {
			if (self->assets->items[i] == NULL) {
				continue;
			}
			if (strcmp(self->assets->items[i]->name, nameLowercase) == 0) {
				if (self->options->useServerTextures) {
					self->assets->items[i] = newAsset;
				}
				Game_CacheAsset(self, newAsset);
				return;
			}
		}
	}
	self->assets->items[self->assets->count++] = newAsset;
	Game_CacheAsset(self, newAsset);
}

static void Game_SetFog(Game const *self)
{
	float density;
	int fogR;
	int fogG;
	int fogB;
	int fogA;
	if (self->d_Config3d->viewdistance >= 512) {
		return;
	}
	density = self->one * 25 / 10000;
	if (self->skySphereNight && !self->shadowssimple) {
		fogR = 0;
		fogG = 0;
		fogB = 0;
		fogA = 255;
	}
	else {
		fogR = 0;
		fogG = 0;
		fogB = 0;
		fogA = 255;
	}
	self->platform->vtbl->glEnableFog(self->platform);
	self->platform->vtbl->glHintFogHintNicest(self->platform);
	self->platform->vtbl->glFogFogModeExp2(self->platform);
	self->platform->vtbl->glFogFogColor(self->platform, fogR, fogG, fogB, fogA);
	self->platform->vtbl->glFogFogDensity(self->platform, density);
}

void Game_SetFreeMouse(Game *self, cibool value)
{
	self->mousePointerLockShouldBe = !value;
	if (value) {
		self->platform->vtbl->exitMousePointerLock(self->platform);
	}
	else {
		self->platform->vtbl->requestMousePointerLock(self->platform);
	}
}

void Game_SetMatrixUniformModelView(Game const *self)
{
	self->platform->vtbl->setMatrixUniformModelView(self->platform, StackMatrix4_Peek(self->mvMatrix));
}

void Game_SetMatrixUniformProjection(Game const *self)
{
	self->platform->vtbl->setMatrixUniformProjection(self->platform, StackMatrix4_Peek(self->pMatrix));
}

void Game_SetMatrixUniforms(Game const *self)
{
	self->platform->vtbl->setMatrixUniformProjection(self->platform, StackMatrix4_Peek(self->pMatrix));
	self->platform->vtbl->setMatrixUniformModelView(self->platform, StackMatrix4_Peek(self->mvMatrix));
}

void Game_SetPlatform(Game *self, GamePlatform const *value)
{
	self->platform = value;
}

static void Game_SetTileAndUpdate(Game *self, int x, int y, int z, int type)
{
	Game_SetBlock(self, x, y, z, type);
	Game_RedrawBlock(self, x, y, z);
}

static void Game_ShadowsOnSetBlock(Game const *self, int x, int y, int z)
{
	int oldheight = InfiniteMapChunked2d_GetBlock(self->d_Heightmap, x, y);
	int newheight;
	int min;
	int max;
	Game_UpdateColumnHeight(self, x, y);
	newheight = InfiniteMapChunked2d_GetBlock(self->d_Heightmap, x, y);
	min = MathCi_MinInt(oldheight, newheight);
	max = MathCi_MaxInt(oldheight, newheight);
	{
		int i;
		for (i = min; i < max; i++) {
			if (i / 16 != z / 16) {
				Map_SetChunkDirty(self->map, x / 16, y / 16, i / 16, TRUE, TRUE);
			}
		}
	}
	{
		int xx;
		for (xx = 0; xx < 3; xx++) {
			{
				int yy;
				for (yy = 0; yy < 3; yy++) {
					{
						int zz;
						for (zz = 0; zz < 3; zz++) {
							int cx = x / 16 + xx - 1;
							int cy = y / 16 + yy - 1;
							int cz = z / 16 + zz - 1;
							if (Map_IsValidChunkPos(self->map, cx, cy, cz)) {
								Map_SetChunkDirty(self->map, cx, cy, cz, TRUE, FALSE);
							}
						}
					}
				}
			}
		}
	}
}

void Game_ShowEscapeMenu(Game *self)
{
	self->guistate = GuiState_ESCAPE_MENU;
	self->menustate = MenuState_New();
	Game_SetFreeMouse(self, TRUE);
}

void Game_ShowInventory(Game *self)
{
	self->guistate = GuiState_INVENTORY;
	self->menustate = MenuState_New();
	Game_SetFreeMouse(self, TRUE);
}

void Game_Start(Game *self)
{
	GameData *gamedata;
	Config3d *config3d;
	ITerrainTextures *terrainTextures;
	FrustumCulling *frustumculling;
	TerrainChunkTesselatorCi *terrainchunktesselator;
	ModDrawParticleEffectBlockBreak const *particle;
	SunMoonRenderer *sunmoonrenderer;
	Packet_Inventory *inventory;
	GameDataItemsClient *dataItems;
	InventoryUtilClient *inventoryUtil;
	int maxTextureSize_;
	self->textColorRenderer = TextColorRenderer_New();
	self->textColorRenderer->platform = self->platform;
	self->language->platform = self->platform;
	Language_LoadTranslations(self->language);
	gamedata = GameData_New();
	GameData_Start(gamedata);
	config3d = Config3d_New();
	if (self->platform->vtbl->isFastSystem(self->platform)) {
		config3d->viewdistance = 128;
	}
	else {
		config3d->viewdistance = 32;
	}
	terrainTextures = ITerrainTextures_New();
	terrainTextures->game = self;
	self->d_TextureAtlasConverter = TextureAtlasConverter_New();
	self->d_TerrainTextures = terrainTextures;
	frustumculling = FrustumCulling_New();
	frustumculling->d_GetCameraMatrix = &self->cameraMatrix->base;
	frustumculling->platform = self->platform;
	self->d_FrustumCulling = frustumculling;
	terrainchunktesselator = TerrainChunkTesselatorCi_New();
	self->d_TerrainChunkTesselator = terrainchunktesselator;
	self->d_Batcher = MeshBatcher_New();
	self->d_Batcher->d_FrustumCulling = frustumculling;
	self->d_Batcher->game = self;
	self->d_FrustumCulling = frustumculling;
	self->d_Data = gamedata;
	self->d_DataMonsters = GameDataMonsters_New();
	self->d_Config3d = config3d;
	particle = ModDrawParticleEffectBlockBreak_New();
	self->particleEffectBlockBreak = particle;
	self->d_Data = gamedata;
	self->d_TerrainTextures = terrainTextures;
	Map_Reset(self->map, 256, 256, 128);
	sunmoonrenderer = SunMoonRenderer_New();
	self->d_SunMoonRenderer = sunmoonrenderer;
	self->d_SunMoonRenderer = sunmoonrenderer;
	self->d_Heightmap = InfiniteMapChunked2d_New();
	self->d_Heightmap->d_Map = self;
	InfiniteMapChunked2d_Restart(self->d_Heightmap);
	self->d_TerrainChunkTesselator = terrainchunktesselator;
	terrainchunktesselator->game = self;
	inventory = Packet_Inventory_New();
	inventory->rightHand = (Packet_Item const **) malloc(10 * sizeof(Packet_Item const *));
	dataItems = GameDataItemsClient_New();
	dataItems->game = self;
	inventoryUtil = InventoryUtilClient_New();
	self->d_Inventory = inventory;
	self->d_InventoryUtil = inventoryUtil;
	inventoryUtil->d_Inventory = inventory;
	inventoryUtil->d_Items = dataItems;
	self->d_Inventory = inventory;
	self->platform->vtbl->addOnCrash(self->platform, &OnCrashHandlerLeave_Create(self)->base);
	self->rnd = self->platform->vtbl->randomCreate(self->platform);
	self->clientmods = (ClientMod const **) malloc(128 * sizeof(ClientMod const *));
	self->clientmodsCount = 0;
	self->modmanager->game = self;
	Game_AddMod(self, &ModDrawMain_New()->base);
	Game_AddMod(self, &ModUpdateMain_New()->base);
	Game_AddMod(self, &ModNetworkProcess_New()->base);
	Game_AddMod(self, &ModUnloadRendererChunks_New()->base);
	Game_AddMod(self, &ModAutoCamera_New()->base);
	Game_AddMod(self, &ModFpsHistoryGraph_New()->base);
	Game_AddMod(self, &ModWalkSound_New()->base);
	Game_AddMod(self, &ModFallDamageToPlayer_New()->base);
	Game_AddMod(self, &ModBlockDamageToPlayer_New()->base);
	Game_AddMod(self, &ModLoadPlayerTextures_New()->base);
	Game_AddMod(self, &ModSendPosition_New()->base);
	Game_AddMod(self, &ModInterpolatePositions_New()->base);
	Game_AddMod(self, &ModRail_New()->base);
	Game_AddMod(self, &ModCompass_New()->base);
	Game_AddMod(self, &ModGrenade_New()->base);
	Game_AddMod(self, &ModBullet_New()->base);
	Game_AddMod(self, &ModExpire_New()->base);
	Game_AddMod(self, &ModReloadAmmo_New()->base);
	Game_AddMod(self, &ModPush_New()->base);
	if (self->platform->vtbl->isFastSystem(self->platform)) {
		Game_AddMod(self, &ModSkySphereAnimated_New()->base);
	}
	else {
		Game_AddMod(self, &ModSkySphereStatic_New()->base);
	}
	Game_AddMod(self, &sunmoonrenderer->base);
	Game_AddMod(self, &ModDrawTestModel_New()->base);
	Game_AddMod(self, &ModDrawLinesAroundSelectedBlock_New()->base);
	Game_AddMod(self, &ModDebugChunk_New()->base);
	Game_AddMod(self, &ModDrawArea_New()->base);
	Game_AddMod(self, &ModDrawTerrain_New()->base);
	Game_AddMod(self, &ModDrawPlayers_New()->base);
	Game_AddMod(self, &ModDrawPlayerNames_New()->base);
	Game_AddMod(self, &ModDrawText_New()->base);
	Game_AddMod(self, &ModDrawParticleEffectBlockBreak_New()->base);
	Game_AddMod(self, &ModDrawSprites_New()->base);
	Game_AddMod(self, &ModDrawMinecarts_New()->base);
	Game_AddMod(self, &ModDrawHand2d_New()->base);
	Game_AddMod(self, &ModDrawHand3d_New()->base);
	Game_AddMod(self, &ModGuiCrafting_New()->base);
	Game_AddMod(self, &ModDialog_New()->base);
	Game_AddMod(self, &ModPicking_New()->base);
	Game_AddMod(self, &ModClearInactivePlayersDrawInfo_New()->base);
	Game_AddMod(self, &ModCameraKeys_New()->base);
	Game_AddMod(self, &ModSendActiveMaterial_New()->base);
	Game_AddMod(self, &ModCamera_New()->base);
	Game_AddMod(self, &ModNetworkEntity_New()->base);
	Game_AddMod(self, &ModGuiInventory_New()->base);
	Game_AddMod(self, &ModGuiTouchButtons_New()->base.base);
	Game_AddMod(self, &ModGuiEscapeMenu_New()->base);
	Game_AddMod(self, &ModGuiMapLoading_New()->base);
	Game_AddMod(self, &ModDraw2dMisc_New()->base);
	Game_AddMod(self, &ModGuiPlayerStats_New()->base);
	Game_AddMod(self, &ModGuiChat_New()->base);
	Game_AddMod(self, &ModScreenshot_New()->base);
	Game_AddMod(self, &ModAudio_New()->base);
	self->s = BlockOctreeSearcher_New();
	self->s->platform = self->platform;
	self->lastReceivedMilliseconds = self->platform->vtbl->timeMillisecondsFromStart(self->platform);
	self->eNABLE_DRAW_TEST_CHARACTER = self->platform->vtbl->isDebuggerAttached(self->platform);
	maxTextureSize_ = self->platform->vtbl->glGetMaxTextureSize(self->platform);
	if (maxTextureSize_ < 1024) {
		maxTextureSize_ = 1024;
	}
	self->maxTextureSize = maxTextureSize_;
	Game_MapLoadingStart(self);
	self->platform->vtbl->glClearColorRgbaf(self->platform, 0, 0, 0, 1);
	if (self->d_Config3d->eNABLE_BACKFACECULLING) {
		self->platform->vtbl->glDepthMask(self->platform, TRUE);
		self->platform->vtbl->glEnableDepthTest(self->platform);
		self->platform->vtbl->glCullFaceBack(self->platform);
		self->platform->vtbl->glEnableCullFace(self->platform);
	}
	self->platform->vtbl->glEnableLighting(self->platform);
	self->platform->vtbl->glEnableColorMaterial(self->platform);
	self->platform->vtbl->glColorMaterialFrontAndBackAmbientAndDiffuse(self->platform);
	self->platform->vtbl->glShadeModelSmooth(self->platform);
}

void Game_StartTyping(Game *self)
{
	self->guiTyping = TypingState_TYPING;
	self->isTyping = TRUE;
	self->guiTypingBuffer = "";
	self->isTeamchat = FALSE;
}

void Game_StopTyping(Game *self)
{
	self->guiTyping = TypingState_NONE;
}

cibool Game_StringEquals(const char *strA, const char *strB)
{
	if (strA == NULL && strB == NULL) {
		return TRUE;
	}
	if (strA == NULL || strB == NULL) {
		return FALSE;
	}
	return strcmp(strA, strB) == 0;
}

static cibool Game_SwimmingBody(Game const *self)
{
	int block = Map_GetBlock(self->map, self->platform->vtbl->floatToInt(self->platform, self->player->position->x), self->platform->vtbl->floatToInt(self->platform, self->player->position->z), self->platform->vtbl->floatToInt(self->platform, self->player->position->y + 1));
	if (block == -1) {
		return TRUE;
	}
	return GameData_WalkableType1(self->d_Data)[block] == 1;
}

static cibool Game_SwimmingEyes(Game const *self)
{
	int eyesBlock = Game_GetPlayerEyesBlock(self);
	if (eyesBlock == -1) {
		return TRUE;
	}
	return GameData_WalkableType1(self->d_Data)[eyesBlock] == 1;
}

static int Game_TextSizeHeight(Game const *self, const char *s, int size)
{
	IntRef const *width = IntRef_New();
	IntRef const *height = IntRef_New();
	self->platform->vtbl->textSize(self->platform, s, size, width, height);
	return height->value;
}

static int Game_TextSizeWidth(Game const *self, const char *s, int size)
{
	IntRef const *width = IntRef_New();
	IntRef const *height = IntRef_New();
	self->platform->vtbl->textSize(self->platform, s, size, width, height);
	return width->value;
}

void Game_ToggleFog(Game *self)
{
	int *drawDistances = (int *) malloc(10 * sizeof(int ));
	int drawDistancesCount = 0;
	drawDistances[drawDistancesCount++] = 32;
	if (self->maxdrawdistance >= 64) {
		drawDistances[drawDistancesCount++] = 64;
	}
	if (self->maxdrawdistance >= 128) {
		drawDistances[drawDistancesCount++] = 128;
	}
	if (self->maxdrawdistance >= 256) {
		drawDistances[drawDistancesCount++] = 256;
	}
	if (self->maxdrawdistance >= 512) {
		drawDistances[drawDistancesCount++] = 512;
	}
	{
		int i;
		for (i = 0; i < drawDistancesCount; i++) {
			if (self->d_Config3d->viewdistance == drawDistances[i]) {
				self->d_Config3d->viewdistance = drawDistances[(i + 1) % drawDistancesCount];
				Game_RedrawAllBlocks(self);
				return;
			}
		}
	}
	self->d_Config3d->viewdistance = drawDistances[0];
	Game_RedrawAllBlocks(self);
}

static void Game_ToggleVsync(Game *self)
{
	self->eNABLE_LAG++;
	self->eNABLE_LAG = self->eNABLE_LAG % 3;
	Game_UseVsync(self);
}

void Game_Update(Game const *self, float dt)
{
	{
		int i;
		for (i = 0; i < self->clientmodsCount; i++) {
			if (self->clientmods[i] == NULL) {
				continue;
			}
			self->clientmods[i]->vtbl->onNewFrameReadOnlyMainThread(self->clientmods[i], self, dt);
		}
	}
}

static void Game_UpdateColumnHeight(Game const *self, int x, int y)
{
	int height = self->map->mapSizeZ - 1;
	{
		int i;
		for (i = self->map->mapSizeZ - 1; i >= 0; i--) {
			height = i;
			if (!Game_IsTransparentForLight(self->blocktypes[Map_GetBlock(self->map, x, y, i)])) {
				break;
			}
		}
	}
	InfiniteMapChunked2d_SetBlock(self->d_Heightmap, x, y, height);
}

static void Game_UpdateMouseViewportControl(Game *self, float dt)
{
	if (self->mouseSmoothing) {
		float constMouseSmoothing1 = 0.85f;
		float constMouseSmoothing2 = 0.8f;
		self->mouseSmoothingVelX = self->mouseSmoothingVelX + self->mouseDeltaX / 4 * constMouseSmoothing2;
		self->mouseSmoothingVelY = self->mouseSmoothingVelY + self->mouseDeltaY / 4 * constMouseSmoothing2;
		self->mouseSmoothingVelX = self->mouseSmoothingVelX * constMouseSmoothing1;
		self->mouseSmoothingVelY = self->mouseSmoothingVelY * constMouseSmoothing1;
	}
	else {
		self->mouseSmoothingVelX = self->mouseDeltaX;
		self->mouseSmoothingVelY = self->mouseDeltaY;
	}
	if (self->guistate == GuiState_NORMAL && self->enableCameraControl && self->platform->vtbl->focused(self->platform)) {
		if (!self->overheadcamera) {
			if (self->platform->vtbl->isMousePointerLocked(self->platform)) {
				self->player->position->roty += self->mouseSmoothingVelX * self->rotationspeed * 1f / 75;
				self->player->position->rotx += self->mouseSmoothingVelY * self->rotationspeed * 1f / 75;
				self->player->position->rotx = MathCi_ClampFloat(self->player->position->rotx, Game_GetPi() / 2 + self->one * 15 / 1000, Game_GetPi() / 2 + Game_GetPi() - self->one * 15 / 1000);
			}
			self->player->position->rotx += self->touchOrientationDy * self->constRotationSpeed * self->one / 75;
			self->player->position->roty += self->touchOrientationDx * self->constRotationSpeed * self->one / 75;
			self->touchOrientationDx = 0;
			self->touchOrientationDy = 0;
		}
		if (self->cameratype == CameraType_OVERHEAD) {
			if (self->mouseMiddle || self->mouseRight) {
				Kamera_TurnLeft(self->overheadcameraK, self->mouseDeltaX / 70);
				Kamera_TurnUp(self->overheadcameraK, self->mouseDeltaY / 3);
			}
		}
	}
	self->mouseDeltaX = 0;
	self->mouseDeltaY = 0;
}

static void Game_UpdateResize(Game *self)
{
	if (self->lastWidth != self->platform->vtbl->getCanvasWidth(self->platform) || self->lastHeight != self->platform->vtbl->getCanvasHeight(self->platform)) {
		self->lastWidth = self->platform->vtbl->getCanvasWidth(self->platform);
		self->lastHeight = self->platform->vtbl->getCanvasHeight(self->platform);
		Game_OnResize(self);
	}
}

void Game_UpdateTextRendererFont(Game const *self)
{
	self->platform->vtbl->setTextRendererFont(self->platform, self->font);
}

static void Game_UseInventory(Game *self, Packet_Inventory const *packet_Inventory)
{
	self->d_Inventory = packet_Inventory;
	self->d_InventoryUtil->d_Inventory = packet_Inventory;
}

static void Game_UseTerrainTextureAtlas2d(Game *self, BitmapCi const *atlas2d, int atlas2dWidth)
{
	int *terrainTextures1d_;
	int terrainTextures1dCount;
	self->terrainTexture = self->platform->vtbl->loadTextureFromBitmap(self->platform, atlas2d);
	terrainTextures1dCount = 0;
	{
		IntRef *atlasesidCount;
		BitmapCi const *const *atlases1d;
		self->terrainTexturesPerAtlas = Game_atlas1dheight(self) / (atlas2dWidth / Game_atlas2dtiles(self));
		atlasesidCount = IntRef_New();
		atlases1d = TextureAtlasConverter_Atlas2dInto1d(self->d_TextureAtlasConverter, self->platform, atlas2d, Game_atlas2dtiles(self), Game_atlas1dheight(self), atlasesidCount);
		terrainTextures1d_ = (int *) malloc(atlasesidCount->value * sizeof(int ));
		{
			int i;
			for (i = 0; i < atlasesidCount->value; i++) {
				BitmapCi const *bmp = atlases1d[i];
				int texture = self->platform->vtbl->loadTextureFromBitmap(self->platform, bmp);
				terrainTextures1d_[terrainTextures1dCount++] = texture;
				self->platform->vtbl->bitmapDelete(self->platform, bmp);
			}
		}
	}
	self->terrainTextures1d = terrainTextures1d_;
}

static void Game_UseTerrainTextures(Game *self, const char *const *textureIds, int textureIdsCount)
{
	int tilesize = 32;
	BitmapData_ const *atlas2d = BitmapData__Create(tilesize * Game_atlas2dtiles(self), tilesize * Game_atlas2dtiles(self));
	BitmapCi const *bitmap;
	{
		int i;
		for (i = 0; i < textureIdsCount; i++) {
			unsigned char const *fileData;
			BitmapCi const *bmp;
			int const *bmpPixels;
			int x;
			int y;
			if (textureIds[i] == NULL) {
				continue;
			}
			fileData = Game_GetFile(self, StringTools_StringAppend(self->platform, textureIds[i], ".png"));
			if (fileData == NULL) {
				fileData = Game_GetFile(self, "Unknown.png");
			}
			if (fileData == NULL) {
				continue;
			}
			bmp = self->platform->vtbl->bitmapCreateFromPng(self->platform, fileData, self->platform->vtbl->byteArrayLength(self->platform, fileData));
			if (self->platform->vtbl->bitmapGetWidth(self->platform, bmp) != tilesize) {
				self->platform->vtbl->bitmapDelete(self->platform, bmp);
				continue;
			}
			if (self->platform->vtbl->bitmapGetHeight(self->platform, bmp) != tilesize) {
				self->platform->vtbl->bitmapDelete(self->platform, bmp);
				continue;
			}
			bmpPixels = (int *) malloc(tilesize * tilesize * sizeof(int ));
			self->platform->vtbl->bitmapGetPixelsArgb(self->platform, bmp, bmpPixels);
			x = i % Game_texturesPacked(self);
			y = i / Game_texturesPacked(self);
			{
				int xx;
				for (xx = 0; xx < tilesize; xx++) {
					{
						int yy;
						for (yy = 0; yy < tilesize; yy++) {
							int c = bmpPixels[xx + yy * tilesize];
							BitmapData__SetPixel(atlas2d, x * tilesize + xx, y * tilesize + yy, c);
						}
					}
				}
			}
			self->platform->vtbl->bitmapDelete(self->platform, bmp);
		}
	}
	bitmap = self->platform->vtbl->bitmapCreate(self->platform, atlas2d->width, atlas2d->height);
	self->platform->vtbl->bitmapSetPixelsArgb(self->platform, bitmap, atlas2d->argb);
	Game_UseTerrainTextureAtlas2d(self, bitmap, atlas2d->width);
}

static void Game_UseVsync(Game const *self)
{
	self->platform->vtbl->setVSync(self->platform, self->eNABLE_LAG == 1 ? FALSE : TRUE);
}

static const char *Game_ValidFont(Game const *self, const char *family)
{
	{
		int i;
		for (i = 0; i < self->allowedFontsCount; i++) {
			if (strcmp(self->allowedFonts[i], family) == 0) {
				return family;
			}
		}
	}
	return self->allowedFonts[0];
}

cibool Game_Vec3Equal(Game const *self, float ax, float ay, float az, float bx, float by, float bz)
{
	return ax == bx && ay == by && az == bz;
}

static float Game_VectorAngleGet(Game const *self, float qX, float qY, float qZ)
{
	return self->platform->vtbl->mathAcos(self->platform, qX / Game_Length(self, qX, qY, qZ)) * MathCi_Sign(qZ);
}

float Game_WaterLevel(Game const *self)
{
	return self->map->mapSizeZ / 2;
}

static cibool Game_WaterSwimmingCamera(Game const *self)
{
	if (Game_GetCameraBlock(self) == -1) {
		return TRUE;
	}
	return Game_IsWater(self, Game_GetCameraBlock(self));
}

static cibool Game_WaterSwimmingEyes(Game const *self)
{
	if (Game_GetPlayerEyesBlock(self) == -1) {
		return TRUE;
	}
	return Game_IsWater(self, Game_GetPlayerEyesBlock(self));
}

float Game_WeaponAttackStrength(Game const *self)
{
	return Game_NextFloat(self, 2, 4);
}

static void Game_WearItem(Game const *self, Packet_InventoryPosition *from, Packet_InventoryPosition *to)
{
	Game_SendPacketClient(self, ClientPackets_WearItem(from, to));
}

int Game_WhiteTexture(Game *self)
{
	if (self->whitetexture == -1) {
		BitmapCi const *bmp = self->platform->vtbl->bitmapCreate(self->platform, 1, 1);
		int *pixels = (int *) malloc(1 * sizeof(int ));
		pixels[0] = Game_ColorFromArgb(255, 255, 255, 255);
		self->platform->vtbl->bitmapSetPixelsArgb(self->platform, bmp, pixels);
		self->whitetexture = self->platform->vtbl->loadTextureFromBitmap(self->platform, bmp);
	}
	return self->whitetexture;
}

int Game_Width(Game const *self)
{
	return self->platform->vtbl->getCanvasWidth(self->platform);
}

static int Game_atlas1dheight(Game const *self)
{
	return self->maxTextureSize;
}

static int Game_atlas2dtiles(Game const *self)
{
	return 32;
}

int Game_blockheight(Game const *self, int x, int y, int z_)
{
	{
		int z;
		for (z = z_; z >= 0; z--) {
			if (Map_GetBlock(self->map, x, y, z) != 0) {
				return z + 1;
			}
		}
	}
	return 0;
}

static float Game_currentfov(Game const *self)
{
	if (self->ironSights) {
		Packet_Item const *item = self->d_Inventory->rightHand[self->activeMaterial];
		if (item != NULL && item->itemClass == 0) {
			if (Game_DeserializeFloat(self, self->blocktypes[item->blockId]->ironSightsFovFloat) != 0) {
				return self->fov * Game_DeserializeFloat(self, self->blocktypes[item->blockId]->ironSightsFovFloat);
			}
		}
	}
	return self->fov;
}

float Game_getblockheight(Game const *self, int x, int y, int z)
{
	float RailHeight = self->one * 3 / 10;
	if (!Map_IsValidPos(self->map, x, y, z)) {
		return 1;
	}
	if (self->blocktypes[Map_GetBlock(self->map, x, y, z)]->rail != 0) {
		return RailHeight;
	}
	if (self->blocktypes[Map_GetBlock(self->map, x, y, z)]->drawType == 11) {
		return self->one / 2;
	}
	if (self->blocktypes[Map_GetBlock(self->map, x, y, z)]->drawType == 12) {
		return self->one / 20;
	}
	return 1;
}

static int Game_terraincolor(Game const *self)
{
	if (Game_WaterSwimmingCamera(self)) {
		return Game_ColorFromArgb(255, 78, 95, 140);
	}
	else if (Game_LavaSwimmingCamera(self)) {
		return Game_ColorFromArgb(255, 222, 101, 46);
	}
	else {
		return Game_ColorFromArgb(255, 255, 255, 255);
	}
}

static int Game_texturesPacked(Game const *self)
{
	return 32;
}

static int Game_xcenter(Game const *self, float width)
{
	return self->platform->vtbl->floatToInt(self->platform, self->platform->vtbl->getCanvasWidth(self->platform) / 2 - width / 2);
}

static int Game_ycenter(Game const *self, float height)
{
	return self->platform->vtbl->floatToInt(self->platform, self->platform->vtbl->getCanvasHeight(self->platform) / 2 - height / 2);
}

static float Game_zfar(Game const *self)
{
	if (self->d_Config3d->viewdistance >= 256) {
		return self->d_Config3d->viewdistance * 2;
	}
	return self->eNABLE_ZFAR ? self->d_Config3d->viewdistance : 99999;
}

static void GameData_Construct(GameData *self)
{
	self->mBlockIdEmpty = 0;
	self->mBlockIdDirt = -1;
	self->mBlockIdSponge = -1;
	self->mBlockIdTrampoline = -1;
	self->mBlockIdAdminium = -1;
	self->mBlockIdCompass = -1;
	self->mBlockIdLadder = -1;
	self->mBlockIdEmptyHand = -1;
	self->mBlockIdCraftingTable = -1;
	self->mBlockIdLava = -1;
	self->mBlockIdStationaryLava = -1;
	self->mBlockIdFillStart = -1;
	self->mBlockIdCuboid = -1;
	self->mBlockIdFillArea = -1;
	self->mBlockIdMinecart = -1;
	self->mBlockIdRailstart = -128;
}

GameData *GameData_New(void)
{
	GameData *self = (GameData *) malloc(sizeof(GameData));
	if (self != NULL)
		GameData_Construct(self);
	return self;
}

void GameData_Delete(GameData *self)
{
	free(self);
}

int GameData_BlockIdAdminium(GameData const *self)
{
	return self->mBlockIdAdminium;
}

int GameData_BlockIdCompass(GameData const *self)
{
	return self->mBlockIdCompass;
}

int GameData_BlockIdCraftingTable(GameData const *self)
{
	return self->mBlockIdCraftingTable;
}

int GameData_BlockIdCuboid(GameData const *self)
{
	return self->mBlockIdCuboid;
}

int GameData_BlockIdDirt(GameData const *self)
{
	return self->mBlockIdDirt;
}

int GameData_BlockIdEmpty(GameData const *self)
{
	return self->mBlockIdEmpty;
}

int GameData_BlockIdEmptyHand(GameData const *self)
{
	return self->mBlockIdEmptyHand;
}

int GameData_BlockIdFillArea(GameData const *self)
{
	return self->mBlockIdFillArea;
}

int GameData_BlockIdFillStart(GameData const *self)
{
	return self->mBlockIdFillStart;
}

int GameData_BlockIdLadder(GameData const *self)
{
	return self->mBlockIdLadder;
}

int GameData_BlockIdLava(GameData const *self)
{
	return self->mBlockIdLava;
}

int GameData_BlockIdMinecart(GameData const *self)
{
	return self->mBlockIdMinecart;
}

int GameData_BlockIdRailstart(GameData const *self)
{
	return self->mBlockIdRailstart;
}

int GameData_BlockIdSponge(GameData const *self)
{
	return self->mBlockIdSponge;
}

int GameData_BlockIdStationaryLava(GameData const *self)
{
	return self->mBlockIdStationaryLava;
}

int GameData_BlockIdTrampoline(GameData const *self)
{
	return self->mBlockIdTrampoline;
}

const char ***GameData_BreakSound(GameData const *self)
{
	return self->mBreakSound;
}

const char ***GameData_BuildSound(GameData const *self)
{
	return self->mBuildSound;
}

const char ***GameData_CloneSound(GameData const *self)
{
	return self->mCloneSound;
}

int *GameData_DamageToPlayer(GameData const *self)
{
	return self->mDamageToPlayer;
}

int const *GameData_DefaultMaterialSlots(GameData const *self)
{
	return self->mDefaultMaterialSlots;
}

static float GameData_DeserializeFloat(GameData const *self, int p)
{
	float one = 1;
	return one * p / 32;
}

static void GameData_Initialize(GameData *self, int count)
{
	self->mWhenPlayerPlacesGetsConvertedTo = (int *) malloc(count * sizeof(int ));
	self->mIsFlower = (cibool *) malloc(count * sizeof(cibool ));
	self->mRail = (int *) malloc(count * sizeof(int ));
	self->mWalkSpeed = (float *) malloc(count * sizeof(float ));
	{
		int i;
		for (i = 0; i < count; i++) {
			self->mWalkSpeed[i] = 1;
		}
	}
	self->mIsSlipperyWalk = (cibool *) malloc(count * sizeof(cibool ));
	self->mWalkSound = (const char *const **) malloc(count * sizeof(const char *const *));
	{
		int i;
		for (i = 0; i < count; i++) {
			self->mWalkSound[i] = (const char **) malloc(8 * sizeof(const char *));
		}
	}
	self->mBreakSound = (const char *const **) malloc(count * sizeof(const char *const *));
	{
		int i;
		for (i = 0; i < count; i++) {
			self->mBreakSound[i] = (const char **) malloc(8 * sizeof(const char *));
		}
	}
	self->mBuildSound = (const char *const **) malloc(count * sizeof(const char *const *));
	{
		int i;
		for (i = 0; i < count; i++) {
			self->mBuildSound[i] = (const char **) malloc(8 * sizeof(const char *));
		}
	}
	self->mCloneSound = (const char *const **) malloc(count * sizeof(const char *const *));
	{
		int i;
		for (i = 0; i < count; i++) {
			self->mCloneSound[i] = (const char **) malloc(8 * sizeof(const char *));
		}
	}
	self->mLightRadius = (int *) malloc(count * sizeof(int ));
	self->mStartInventoryAmount = (int *) malloc(count * sizeof(int ));
	self->mStrength = (float *) malloc(count * sizeof(float ));
	self->mDamageToPlayer = (int *) malloc(count * sizeof(int ));
	self->mWalkableType = (int *) malloc(count * sizeof(int ));
	self->mDefaultMaterialSlots = (int *) malloc(10 * sizeof(int ));
}

cibool *GameData_IsFlower(GameData const *self)
{
	return self->mIsFlower;
}

cibool GameData_IsRailTile(GameData const *self, int id)
{
	return id >= GameData_BlockIdRailstart(self) && id < GameData_BlockIdRailstart(self) + 64;
}

cibool *GameData_IsSlipperyWalk(GameData const *self)
{
	return self->mIsSlipperyWalk;
}

int *GameData_LightRadius(GameData const *self)
{
	return self->mLightRadius;
}

int *GameData_Rail(GameData const *self)
{
	return self->mRail;
}

cibool GameData_SetSpecialBlock(GameData *self, Packet_BlockType const *b, int id)
{
	switch (b->name) {
	case "Empty":
		self->mBlockIdEmpty = id;
		return TRUE;
	case "Dirt":
		self->mBlockIdDirt = id;
		return TRUE;
	case "Sponge":
		self->mBlockIdSponge = id;
		return TRUE;
	case "Trampoline":
		self->mBlockIdTrampoline = id;
		return TRUE;
	case "Adminium":
		self->mBlockIdAdminium = id;
		return TRUE;
	case "Compass":
		self->mBlockIdCompass = id;
		return TRUE;
	case "Ladder":
		self->mBlockIdLadder = id;
		return TRUE;
	case "EmptyHand":
		self->mBlockIdEmptyHand = id;
		return TRUE;
	case "CraftingTable":
		self->mBlockIdCraftingTable = id;
		return TRUE;
	case "Lava":
		self->mBlockIdLava = id;
		return TRUE;
	case "StationaryLava":
		self->mBlockIdStationaryLava = id;
		return TRUE;
	case "FillStart":
		self->mBlockIdFillStart = id;
		return TRUE;
	case "Cuboid":
		self->mBlockIdCuboid = id;
		return TRUE;
	case "FillArea":
		self->mBlockIdFillArea = id;
		return TRUE;
	case "Minecart":
		self->mBlockIdMinecart = id;
		return TRUE;
	case "Rail0":
		self->mBlockIdRailstart = id;
		return TRUE;
	default:
		return FALSE;
	}
}

void GameData_Start(GameData *self)
{
	GameData_Initialize(self, 1024);
}

int const *GameData_StartInventoryAmount(GameData const *self)
{
	return self->mStartInventoryAmount;
}

float *GameData_Strength(GameData const *self)
{
	return self->mStrength;
}

void GameData_Update(GameData const *self)
{
}

void GameData_UseBlockType(GameData *self, GamePlatform const *platform, int id, Packet_BlockType const *b)
{
	if (b->name == NULL) {
		return;
	}
	if (b->whenPlacedGetsConvertedTo != 0) {
		self->mWhenPlayerPlacesGetsConvertedTo[id] = b->whenPlacedGetsConvertedTo;
	}
	else {
		self->mWhenPlayerPlacesGetsConvertedTo[id] = id;
	}
	GameData_IsFlower(self)[id] = b->drawType == 5;
	GameData_Rail(self)[id] = b->rail;
	GameData_WalkSpeed(self)[id] = GameData_DeserializeFloat(self, b->walkSpeedFloat);
	GameData_IsSlipperyWalk(self)[id] = b->isSlipperyWalk;
	GameData_WalkSound(self)[id] = (const char **) malloc(8 * sizeof(const char *));
	GameData_BreakSound(self)[id] = (const char **) malloc(8 * sizeof(const char *));
	GameData_BuildSound(self)[id] = (const char **) malloc(8 * sizeof(const char *));
	GameData_CloneSound(self)[id] = (const char **) malloc(8 * sizeof(const char *));
	if (b->sounds != NULL) {
		{
			int i;
			for (i = 0; i < b->sounds->walkCount; i++) {
				GameData_WalkSound(self)[id][i] = StringTools_StringAppend(platform, b->sounds->walk[i], ".wav");
			}
		}
		{
			int i;
			for (i = 0; i < b->sounds->break1Count; i++) {
				GameData_BreakSound(self)[id][i] = StringTools_StringAppend(platform, b->sounds->break1[i], ".wav");
			}
		}
		{
			int i;
			for (i = 0; i < b->sounds->buildCount; i++) {
				GameData_BuildSound(self)[id][i] = StringTools_StringAppend(platform, b->sounds->build[i], ".wav");
			}
		}
		{
			int i;
			for (i = 0; i < b->sounds->cloneCount; i++) {
				GameData_CloneSound(self)[id][i] = StringTools_StringAppend(platform, b->sounds->clone[i], ".wav");
			}
		}
	}
	GameData_LightRadius(self)[id] = b->lightRadius;
	GameData_Strength(self)[id] = b->strength;
	GameData_DamageToPlayer(self)[id] = b->damageToPlayer;
	GameData_WalkableType1(self)[id] = b->walkableType;
	GameData_SetSpecialBlock(self, b, id);
}

void GameData_UseBlockTypes(GameData *self, GamePlatform const *platform, Packet_BlockType const *const *blocktypes, int count)
{
	{
		int i;
		for (i = 0; i < count; i++) {
			if (blocktypes[i] != NULL) {
				GameData_UseBlockType(self, platform, i, blocktypes[i]);
			}
		}
	}
}

const char ***GameData_WalkSound(GameData const *self)
{
	return self->mWalkSound;
}

float *GameData_WalkSpeed(GameData const *self)
{
	return self->mWalkSpeed;
}

int *GameData_WalkableType1(GameData const *self)
{
	return self->mWalkableType;
}

int const *GameData_WhenPlayerPlacesGetsConvertedTo(GameData const *self)
{
	return self->mWhenPlayerPlacesGetsConvertedTo;
}

GameDataItemsClient *GameDataItemsClient_New(void)
{
	GameDataItemsClient *self = (GameDataItemsClient *) malloc(sizeof(GameDataItemsClient));
	return self;
}

void GameDataItemsClient_Delete(GameDataItemsClient *self)
{
	free(self);
}

cibool GameDataItemsClient_CanWear(GameDataItemsClient const *self, int selectedWear, Packet_Item const *item)
{
	if (item == NULL) {
		return TRUE;
	}
	if (item == NULL) {
		return TRUE;
	}
	switch (selectedWear) {
	case 0:
		return item->itemClass == 0;
	case 1:
		return FALSE;
	case 2:
		return FALSE;
	case 3:
		return FALSE;
	case 4:
		return FALSE;
	default:
		return FALSE;
	}
}

const char *GameDataItemsClient_ItemGraphics(GameDataItemsClient const *self, Packet_Item const *item)
{
	return NULL;
}

const char *GameDataItemsClient_ItemInfo(GameDataItemsClient const *self, Packet_Item const *item)
{
	if (item->itemClass == 0) {
		return Language_Get(self->game->language, StringTools_StringAppend(self->game->platform, "Block_", self->game->blocktypes[item->blockId]->name));
	}
	self->game->platform->vtbl->throwException(self->game->platform, "ItemClass");
	return "ItemClass";
}

int GameDataItemsClient_ItemSizeX(GameDataItemsClient const *self, Packet_Item const *item)
{
	if (item->itemClass == 0) {
		return 1;
	}
	self->game->platform->vtbl->throwException(self->game->platform, "ItemClass");
	return 1;
}

int GameDataItemsClient_ItemSizeY(GameDataItemsClient const *self, Packet_Item const *item)
{
	if (item->itemClass == 0) {
		return 1;
	}
	self->game->platform->vtbl->throwException(self->game->platform, "ItemClass");
	return 1;
}

Packet_Item const *GameDataItemsClient_Stack(GameDataItemsClient const *self, Packet_Item const *itemA, Packet_Item const *itemB)
{
	if (itemA->itemClass == 0 && itemB->itemClass == 0) {
		Packet_Item *ret = Packet_Item_New();
		ret->itemClass = itemA->itemClass;
		ret->blockId = itemA->blockId;
		ret->blockCount = itemA->blockCount + itemB->blockCount;
		return ret;
	}
	else {
		return NULL;
	}
}

int const *GameDataItemsClient_TextureIdForInventory(GameDataItemsClient const *self)
{
	return self->game->textureIdForInventory;
}

static void GameDataMonsters_Construct(GameDataMonsters *self)
{
	int n = 5;
	self->monsterCode = (const char **) malloc(n * sizeof(const char *));
	self->monsterName = (const char **) malloc(n * sizeof(const char *));
	self->monsterSkin = (const char **) malloc(n * sizeof(const char *));
	self->monsterCode[0] = "imp.txt";
	self->monsterName[0] = "Imp";
	self->monsterSkin[0] = "imp.png";
	self->monsterCode[1] = "imp.txt";
	self->monsterName[1] = "Fire Imp";
	self->monsterSkin[1] = "impfire.png";
	self->monsterCode[2] = "dragon.txt";
	self->monsterName[2] = "Dragon";
	self->monsterSkin[2] = "dragon.png";
	self->monsterCode[3] = "zombie.txt";
	self->monsterName[3] = "Zombie";
	self->monsterSkin[3] = "zombie.png";
	self->monsterCode[4] = "cyclops.txt";
	self->monsterName[4] = "Cyclops";
	self->monsterSkin[4] = "cyclops.png";
}

GameDataMonsters *GameDataMonsters_New(void)
{
	GameDataMonsters *self = (GameDataMonsters *) malloc(sizeof(GameDataMonsters));
	if (self != NULL)
		GameDataMonsters_Construct(self);
	return self;
}

void GameDataMonsters_Delete(GameDataMonsters *self)
{
	free(self);
}

GameExit *GameExit_New(void)
{
	GameExit *self = (GameExit *) malloc(sizeof(GameExit));
	return self;
}

void GameExit_Delete(GameExit *self)
{
	free(self);
}

cibool GameExit_GetExit(GameExit const *self)
{
	return self->exit;
}

cibool GameExit_GetRestart(GameExit const *self)
{
	return self->restart;
}

void GameExit_SetExit(GameExit *self, cibool p)
{
	self->exit = p;
}

void GameExit_SetRestart(GameExit *self, cibool p)
{
	self->restart = p;
}

static void GamePlatform_Construct(GamePlatform *self, const GamePlatformVtbl *vtbl)
{
	self->vtbl = vtbl;
}

static void GameScreen_Construct(GameScreen *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = (const ClientModVtbl *) &CiVtbl_GameScreen;
	ClientMod_Construct(&self->base, vtbl);
	self->widgetCount = 64;
	self->widgets = (MenuWidget const **) malloc(self->widgetCount * sizeof(MenuWidget const *));
}

GameScreen *GameScreen_New(void)
{
	GameScreen *self = (GameScreen *) malloc(sizeof(GameScreen));
	if (self != NULL)
		GameScreen_Construct(self, NULL);
	return self;
}

void GameScreen_Delete(GameScreen *self)
{
	free(self);
}

const char *GameScreen_CharRepeat(GameScreen const *self, int c, int length)
{
	int *charArray = (int *) malloc(length * sizeof(int ));
	{
		int i;
		for (i = 0; i < length; i++) {
			charArray[i] = c;
		}
	}
	return self->game->platform->vtbl->charArrayToString(self->game->platform, charArray, length);
}

const char *GameScreen_CharToString(GameScreen const *self, int a)
{
	int *arr = (int *) malloc(1 * sizeof(int ));
	arr[0] = a;
	return self->game->platform->vtbl->charArrayToString(self->game->platform, arr, 1);
}

void GameScreen_DrawWidgets(GameScreen const *self)
{
	{
		int i;
		for (i = 0; i < self->widgetCount; i++) {
			MenuWidget const *w = self->widgets[i];
			if (w != NULL) {
				const char *text;
				if (!w->visible) {
					continue;
				}
				text = w->text;
				if (w->selected) {
					text = StringTools_StringAppend(self->game->platform, "&2", text);
				}
				if (w->type == WidgetType_BUTTON) {
					if (w->buttonStyle == ButtonStyle_TEXT) {
					}
					else {
						if (w->image != NULL) {
							Game_Draw2dBitmapFile(self->game, w->image, self->screenx + w->x, self->screeny + w->y, w->sizex, w->sizey);
						}
						else {
							Game_Draw2dTexture(self->game, Game_WhiteTexture(self->game), self->screenx + w->x, self->screeny + w->y, w->sizex, w->sizey, NULL, 0, w->color, FALSE);
						}
						Game_Draw2dText1(self->game, text, self->screenx + self->game->platform->vtbl->floatToInt(self->game->platform, w->x), self->screeny + self->game->platform->vtbl->floatToInt(self->game->platform, w->y + w->sizey / 2), self->game->platform->vtbl->floatToInt(self->game->platform, w->fontSize), NULL, FALSE);
					}
				}
				if (w->type == WidgetType_TEXTBOX) {
					if (w->password) {
						text = GameScreen_CharRepeat(self, 42, StringTools_StringLength(self->game->platform, w->text));
					}
					if (w->editing) {
						text = StringTools_StringAppend(self->game->platform, text, "_");
					}
					{
						Game_Draw2dText(self->game, text, w->font, self->screenx + w->x, self->screeny + w->y, NULL, FALSE);
					}
					{
					}
				}
				if (w->type == WidgetType_LABEL) {
					Game_Draw2dText(self->game, text, w->font, self->screenx + w->x, self->screeny + w->y, IntRef_Create(Game_ColorFromArgb(255, 0, 0, 0)), FALSE);
				}
				if (w->description != NULL) {
				}
			}
		}
	}
}

static void GameScreen_KeyDown(GameScreen const *self, KeyEventArgs const *e)
{
	{
		int i;
		for (i = 0; i < self->widgetCount; i++) {
			MenuWidget *w = self->widgets[i];
			if (w != NULL) {
				if (w->type == WidgetType_TEXTBOX) {
					if (w->editing) {
						int key = KeyEventArgs_GetKeyCode(e);
						if (KeyEventArgs_GetCtrlPressed(e) && key == 104) {
							if (self->game->platform->vtbl->clipboardContainsText(self->game->platform)) {
								w->text = StringTools_StringAppend(self->game->platform, w->text, self->game->platform->vtbl->clipboardGetText(self->game->platform));
							}
							return;
						}
						if (key == 53) {
							if (StringTools_StringLength(self->game->platform, w->text) > 0) {
								w->text = StringTools_StringSubstring(self->game->platform, w->text, 0, StringTools_StringLength(self->game->platform, w->text) - 1);
							}
							return;
						}
					}
				}
			}
		}
	}
}

static void GameScreen_KeyPress(GameScreen const *self, KeyPressEventArgs const *e)
{
	{
		int i;
		for (i = 0; i < self->widgetCount; i++) {
			MenuWidget *w = self->widgets[i];
			if (w != NULL) {
				if (w->type == WidgetType_TEXTBOX) {
					if (w->editing) {
						if (self->game->platform->vtbl->isValidTypingChar(self->game->platform, KeyPressEventArgs_GetKeyChar(e))) {
							w->text = StringTools_StringAppend(self->game->platform, w->text, GameScreen_CharToString(self, KeyPressEventArgs_GetKeyChar(e)));
						}
					}
				}
			}
		}
	}
}

static cibool GameScreen_MouseDown(GameScreen const *self, int x, int y)
{
	cibool handled = FALSE;
	cibool editingChange = FALSE;
	{
		int i;
		for (i = 0; i < self->widgetCount; i++) {
			MenuWidget *w = self->widgets[i];
			if (w != NULL) {
				if (w->type == WidgetType_BUTTON) {
					w->pressed = GameScreen_pointInRect(self, x, y, self->screenx + w->x, self->screeny + w->y, w->sizex, w->sizey);
					if (w->pressed) {
						handled = TRUE;
					}
				}
				if (w->type == WidgetType_TEXTBOX) {
					cibool wasEditing;
					w->pressed = GameScreen_pointInRect(self, x, y, self->screenx + w->x, self->screeny + w->y, w->sizex, w->sizey);
					if (w->pressed) {
						handled = TRUE;
					}
					wasEditing = w->editing;
					w->editing = w->pressed;
					if (w->editing && !wasEditing) {
						self->game->platform->vtbl->showKeyboard(self->game->platform, TRUE);
						editingChange = TRUE;
					}
					if (!w->editing && wasEditing && !editingChange) {
						self->game->platform->vtbl->showKeyboard(self->game->platform, FALSE);
					}
				}
			}
		}
	}
	return handled;
}

static void GameScreen_MouseMove(GameScreen const *self, MouseEventArgs const *e)
{
	if (MouseEventArgs_GetEmulated(e) && !MouseEventArgs_GetForceUsage(e)) {
		return;
	}
	{
		int i;
		for (i = 0; i < self->widgetCount; i++) {
			MenuWidget *w = self->widgets[i];
			if (w != NULL) {
				w->hover = GameScreen_pointInRect(self, MouseEventArgs_GetX(e), MouseEventArgs_GetY(e), self->screenx + w->x, self->screeny + w->y, w->sizex, w->sizey);
			}
		}
	}
}

static void GameScreen_MouseUp(GameScreen const *self, int x, int y)
{
	{
		int i;
		for (i = 0; i < self->widgetCount; i++) {
			MenuWidget *w = self->widgets[i];
			if (w != NULL) {
				w->pressed = FALSE;
			}
		}
	}
	{
		int i;
		for (i = 0; i < self->widgetCount; i++) {
			MenuWidget const *w = self->widgets[i];
			if (w != NULL) {
				if (w->type == WidgetType_BUTTON) {
					if (GameScreen_pointInRect(self, x, y, self->screenx + w->x, self->screeny + w->y, w->sizex, w->sizey)) {
						((const GameScreenVtbl *) self->base.vtbl)->onButton(self, w);
					}
				}
			}
		}
	}
}

void GameScreen_OnBackPressed(GameScreen const *self)
{
}

void GameScreen_OnButton(GameScreen const *self, MenuWidget const *w)
{
}

void GameScreen_OnKeyDown(GameScreen const *self, Game const *game_, KeyEventArgs const *args)
{
	GameScreen_KeyDown(self, args);
}

void GameScreen_OnKeyPress(GameScreen const *self, Game const *game_, KeyPressEventArgs const *args)
{
	GameScreen_KeyPress(self, args);
}

void GameScreen_OnMouseDown(GameScreen const *self, Game const *game_, MouseEventArgs const *args)
{
	GameScreen_MouseDown(self, MouseEventArgs_GetX(args), MouseEventArgs_GetY(args));
}

void GameScreen_OnMouseMove(GameScreen const *self, Game const *game_, MouseEventArgs const *args)
{
	GameScreen_MouseMove(self, args);
}

void GameScreen_OnMouseUp(GameScreen const *self, Game const *game_, MouseEventArgs const *args)
{
	GameScreen_MouseUp(self, MouseEventArgs_GetX(args), MouseEventArgs_GetY(args));
}

void GameScreen_OnMouseWheel(GameScreen const *self, MouseWheelEventArgs const *e)
{
}

void GameScreen_OnTouchEnd(GameScreen const *self, Game const *game_, TouchEventArgs const *e)
{
	GameScreen_ScreenOnTouchEnd(self, e);
}

void GameScreen_OnTouchStart(GameScreen const *self, Game const *game_, TouchEventArgs *e)
{
	GameScreen_ScreenOnTouchStart(self, e);
}

void GameScreen_ScreenOnTouchEnd(GameScreen const *self, TouchEventArgs const *e)
{
	GameScreen_MouseUp(self, TouchEventArgs_GetX(e), TouchEventArgs_GetY(e));
}

void GameScreen_ScreenOnTouchStart(GameScreen const *self, TouchEventArgs *e)
{
	TouchEventArgs_SetHandled(e, GameScreen_MouseDown(self, TouchEventArgs_GetX(e), TouchEventArgs_GetY(e)));
}

static cibool GameScreen_pointInRect(GameScreen const *self, float x, float y, float rx, float ry, float rw, float rh)
{
	return x >= rx && y >= ry && x < rx + rw && y < ry + rh;
}

static int GameVersionHelper_DateToInt(int year, int month, int day)
{
	return year * 10000 + month * 100 + day;
}

static cibool GameVersionHelper_IsVersionDate(GamePlatform const *platform, const char *version)
{
	IntRef const *versionCharsCount = IntRef_New();
	int const *versionChars = platform->vtbl->stringToCharArray(platform, version, versionCharsCount);
	if (versionCharsCount->value >= 10) {
		if (versionChars[4] == 45 && versionChars[7] == 45) {
			return TRUE;
		}
	}
	return FALSE;
}

cibool GameVersionHelper_ServerVersionAtLeast(GamePlatform const *platform, const char *serverGameVersion, int year, int month, int day)
{
	if (serverGameVersion == NULL) {
		return TRUE;
	}
	if (GameVersionHelper_VersionToInt(platform, serverGameVersion) < GameVersionHelper_DateToInt(year, month, day)) {
		return FALSE;
	}
	return TRUE;
}

static int GameVersionHelper_VersionToInt(GamePlatform const *platform, const char *version)
{
	int max = 1000000000;
	FloatRef const *year;
	FloatRef const *month;
	FloatRef const *day;
	if (!GameVersionHelper_IsVersionDate(platform, version)) {
		return max;
	}
	year = FloatRef_New();
	month = FloatRef_New();
	day = FloatRef_New();
	if (platform->vtbl->floatTryParse(platform, StringTools_StringSubstring(platform, version, 0, 4), year)) {
		if (platform->vtbl->floatTryParse(platform, StringTools_StringSubstring(platform, version, 5, 2), month)) {
			if (platform->vtbl->floatTryParse(platform, StringTools_StringSubstring(platform, version, 8, 2), day)) {
				int year_ = platform->vtbl->floatToInt(platform, year->value);
				int month_ = platform->vtbl->floatToInt(platform, month->value);
				int day_ = platform->vtbl->floatToInt(platform, day->value);
				return year_ * 10000 + month_ * 100 + day_;
			}
		}
	}
	return max;
}

static void GetBlockHeight__Construct(GetBlockHeight_ *self, const DelegateGetBlockHeightVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_GetBlockHeight_;
	DelegateGetBlockHeight_Construct(&self->base, vtbl);
}

GetBlockHeight_ *GetBlockHeight__New(void)
{
	GetBlockHeight_ *self = (GetBlockHeight_ *) malloc(sizeof(GetBlockHeight_));
	if (self != NULL)
		GetBlockHeight__Construct(self, NULL);
	return self;
}

void GetBlockHeight__Delete(GetBlockHeight_ *self)
{
	free(self);
}

GetBlockHeight_ const *GetBlockHeight__Create(Game const *w_)
{
	GetBlockHeight_ *g = GetBlockHeight__New();
	g->w = w_;
	return g;
}

float GetBlockHeight__GetBlockHeight(GetBlockHeight_ const *self, int x, int y, int z)
{
	return Game_getblockheight(self->w, x, y, z);
}

static void GetCameraMatrix_Construct(GetCameraMatrix *self, const IGetCameraMatrixVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_GetCameraMatrix;
	IGetCameraMatrix_Construct(&self->base, vtbl);
}

GetCameraMatrix *GetCameraMatrix_New(void)
{
	GetCameraMatrix *self = (GetCameraMatrix *) malloc(sizeof(GetCameraMatrix));
	if (self != NULL)
		GetCameraMatrix_Construct(self, NULL);
	return self;
}

void GetCameraMatrix_Delete(GetCameraMatrix *self)
{
	free(self);
}

float const *GetCameraMatrix_GetModelViewMatrix(GetCameraMatrix const *self)
{
	return self->lastmvmatrix;
}

float const *GetCameraMatrix_GetProjectionMatrix(GetCameraMatrix const *self)
{
	return self->lastpmatrix;
}

float GlMatrixMath_Abs(float len)
{
	if (len < 0) {
		return -len;
	}
	else {
		return len;
	}
}

float GlMatrixMath_GLMAT_EPSILON(void)
{
	float one = 1;
	return one / 1000000;
}

float GlMatrixMath_PI(void)
{
	float a = 3141592;
	return a / 1000000;
}

float GlMatrixMath_max(float a, float b)
{
	if (a > b) {
		return a;
	}
	else {
		return b;
	}
}

float GlMatrixMath_min(float a, float b)
{
	if (a < b) {
		return a;
	}
	else {
		return b;
	}
}

Grenade_ *Grenade__New(void)
{
	Grenade_ *self = (Grenade_ *) malloc(sizeof(Grenade_));
	return self;
}

void Grenade__Delete(Grenade_ *self)
{
	free(self);
}

static void HashSetVector3IntRef_Construct(HashSetVector3IntRef *self)
{
	self->max = 16;
	HashSetVector3IntRef_Start(self);
}

HashSetVector3IntRef *HashSetVector3IntRef_New(void)
{
	HashSetVector3IntRef *self = (HashSetVector3IntRef *) malloc(sizeof(HashSetVector3IntRef));
	if (self != NULL)
		HashSetVector3IntRef_Construct(self);
	return self;
}

void HashSetVector3IntRef_Delete(HashSetVector3IntRef *self)
{
	free(self);
}

void HashSetVector3IntRef_Set(HashSetVector3IntRef const *self, Vector3IntRef const *value)
{
	int i = 0;
	for (i = 0; i < self->max; i++) {
		if (self->values[i] == NULL) {
			break;
		}
		if (self->values[i]->x == value->x && self->values[i]->y == value->y && self->values[i]->z == value->z) {
			return;
		}
	}
	self->values[i] = Vector3IntRef_Create(value->x, value->y, value->z);
}

void HashSetVector3IntRef_Start(HashSetVector3IntRef *self)
{
	self->values = (Vector3IntRef const **) malloc(self->max * sizeof(Vector3IntRef const *));
}

HttpResponseCi *HttpResponseCi_New(void)
{
	HttpResponseCi *self = (HttpResponseCi *) malloc(sizeof(HttpResponseCi));
	return self;
}

void HttpResponseCi_Delete(HttpResponseCi *self)
{
	free(self);
}

cibool HttpResponseCi_GetDone(HttpResponseCi const *self)
{
	return self->done;
}

cibool HttpResponseCi_GetError(HttpResponseCi const *self)
{
	return self->error;
}

static const char *HttpResponseCi_GetString(HttpResponseCi const *self, GamePlatform const *platform)
{
	return platform->vtbl->stringFromUtf8ByteArray(platform, self->value, self->valueLength);
}

unsigned char const *HttpResponseCi_GetValue(HttpResponseCi const *self)
{
	return self->value;
}

int HttpResponseCi_GetValueLength(HttpResponseCi const *self)
{
	return self->valueLength;
}

void HttpResponseCi_SetDone(HttpResponseCi *self, cibool value_)
{
	self->done = value_;
}

void HttpResponseCi_SetError(HttpResponseCi *self, cibool value_)
{
	self->error = value_;
}

void HttpResponseCi_SetValue(HttpResponseCi *self, unsigned char const *value_)
{
	self->value = value_;
}

void HttpResponseCi_SetValueLength(HttpResponseCi *self, int value_)
{
	self->valueLength = value_;
}

static void IGetCameraMatrix_Construct(IGetCameraMatrix *self, const IGetCameraMatrixVtbl *vtbl)
{
	self->vtbl = vtbl;
}

static void IInterpolation_Construct(IInterpolation *self, const IInterpolationVtbl *vtbl)
{
	self->vtbl = vtbl;
}

static void IInventoryController_Construct(IInventoryController *self, const IInventoryControllerVtbl *vtbl)
{
	self->vtbl = vtbl;
}

static void IMapStorage2_Construct(IMapStorage2 *self, const IMapStorage2Vtbl *vtbl)
{
	self->vtbl = vtbl;
}

INetOutgoingMessage *INetOutgoingMessage_New(void)
{
	INetOutgoingMessage *self = (INetOutgoingMessage *) malloc(sizeof(INetOutgoingMessage));
	return self;
}

void INetOutgoingMessage_Delete(INetOutgoingMessage *self)
{
	free(self);
}

void INetOutgoingMessage_Write(INetOutgoingMessage *self, unsigned char const *source, int sourceCount)
{
	self->messageLength = sourceCount;
	self->message = (unsigned char *) malloc(sourceCount * sizeof(unsigned char ));
	{
		int i;
		for (i = 0; i < sourceCount; i++) {
			self->message[i] = source[i];
		}
	}
}

static void INetworkInterpolation_Construct(INetworkInterpolation *self, const INetworkInterpolationVtbl *vtbl)
{
	self->vtbl = vtbl;
}

static void IPEndPointCi_Construct(IPEndPointCi *self, const IPEndPointCiVtbl *vtbl)
{
	self->vtbl = vtbl;
}

static void IPEndPointCiDefault_Construct(IPEndPointCiDefault *self, const IPEndPointCiVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_IPEndPointCiDefault;
	IPEndPointCi_Construct(&self->base, vtbl);
}

IPEndPointCiDefault *IPEndPointCiDefault_New(void)
{
	IPEndPointCiDefault *self = (IPEndPointCiDefault *) malloc(sizeof(IPEndPointCiDefault));
	if (self != NULL)
		IPEndPointCiDefault_Construct(self, NULL);
	return self;
}

void IPEndPointCiDefault_Delete(IPEndPointCiDefault *self)
{
	free(self);
}

const char *IPEndPointCiDefault_AddressToString(IPEndPointCiDefault const *self)
{
	return self->address;
}

IPEndPointCiDefault const *IPEndPointCiDefault_Create(const char *address_)
{
	IPEndPointCiDefault *e = IPEndPointCiDefault_New();
	e->address = address_;
	return e;
}

ITerrainTextures *ITerrainTextures_New(void)
{
	ITerrainTextures *self = (ITerrainTextures *) malloc(sizeof(ITerrainTextures));
	return self;
}

void ITerrainTextures_Delete(ITerrainTextures *self)
{
	free(self);
}

int ITerrainTextures_terrainTexture(ITerrainTextures const *self)
{
	return self->game->terrainTexture;
}

int const *ITerrainTextures_terrainTextures1d(ITerrainTextures const *self)
{
	return self->game->terrainTextures1d;
}

int ITerrainTextures_terrainTexturesPerAtlas(ITerrainTextures const *self)
{
	return self->game->terrainTexturesPerAtlas;
}

int ITerrainTextures_texturesPacked(ITerrainTextures const *self)
{
	return Game_texturesPacked(self->game);
}

static void ImageOnLoadHandler_Construct(ImageOnLoadHandler *self, const ImageOnLoadHandlerVtbl *vtbl)
{
	self->vtbl = vtbl;
}

InfiniteMapChunked2d *InfiniteMapChunked2d_New(void)
{
	InfiniteMapChunked2d *self = (InfiniteMapChunked2d *) malloc(sizeof(InfiniteMapChunked2d));
	return self;
}

void InfiniteMapChunked2d_Delete(InfiniteMapChunked2d *self)
{
	free(self);
}

void InfiniteMapChunked2d_ClearChunk(InfiniteMapChunked2d const *self, int x, int y)
{
	int px = x / 16;
	int py = y / 16;
	self->chunks[MapUtilCi_Index2d(px, py, self->d_Map->map->mapSizeX / 16)] = NULL;
}

int InfiniteMapChunked2d_GetBlock(InfiniteMapChunked2d const *self, int x, int y)
{
	int const *chunk = InfiniteMapChunked2d_GetChunk(self, x, y);
	return chunk[MapUtilCi_Index2d(x % 16, y % 16, 16)];
}

int *InfiniteMapChunked2d_GetChunk(InfiniteMapChunked2d const *self, int x, int y)
{
	int *chunk = NULL;
	int kx = x / 16;
	int ky = y / 16;
	if (self->chunks[MapUtilCi_Index2d(kx, ky, self->d_Map->map->mapSizeX / 16)] == NULL) {
		chunk = (int *) malloc(256 * sizeof(int ));
		{
			int i;
			for (i = 0; i < 256; i++) {
				chunk[i] = 0;
			}
		}
		self->chunks[MapUtilCi_Index2d(kx, ky, self->d_Map->map->mapSizeX / 16)] = chunk;
	}
	chunk = self->chunks[MapUtilCi_Index2d(kx, ky, self->d_Map->map->mapSizeX / 16)];
	return chunk;
}

void InfiniteMapChunked2d_Restart(InfiniteMapChunked2d *self)
{
	int n = self->d_Map->map->mapSizeX / 16 * self->d_Map->map->mapSizeY / 16;
	self->chunks = (int const **) malloc(n * sizeof(int const *));
	{
		int i;
		for (i = 0; i < n; i++) {
			self->chunks[i] = NULL;
		}
	}
}

void InfiniteMapChunked2d_SetBlock(InfiniteMapChunked2d const *self, int x, int y, int blocktype)
{
	InfiniteMapChunked2d_GetChunk(self, x, y)[MapUtilCi_Index2d(x % 16, y % 16, 16)] = blocktype;
}

IntRef *IntRef_New(void)
{
	IntRef *self = (IntRef *) malloc(sizeof(IntRef));
	return self;
}

void IntRef_Delete(IntRef *self)
{
	free(self);
}

IntRef const *IntRef_Create(int value_)
{
	IntRef *intref = IntRef_New();
	intref->value = value_;
	return intref;
}

int IntRef_GetValue(IntRef const *self)
{
	return self->value;
}

void IntRef_SetValue(IntRef *self, int value_)
{
	self->value = value_;
}

int InterpolationCi_InterpolateColor(GamePlatform const *platform, float progress, int const *colors, int colorsLength)
{
	float one = 1;
	int colora = platform->vtbl->floatToInt(platform, (colorsLength - 1) * progress);
	int colorb;
	int a;
	int b;
	float p;
	int A;
	int R;
	int G;
	int B;
	if (colora < 0) {
		colora = 0;
	}
	if (colora >= colorsLength) {
		colora = colorsLength - 1;
	}
	colorb = colora + 1;
	if (colorb >= colorsLength) {
		colorb = colorsLength - 1;
	}
	a = colors[colora];
	b = colors[colorb];
	p = (progress - one * colora / (colorsLength - 1)) * (colorsLength - 1);
	A = platform->vtbl->floatToInt(platform, Game_ColorA(a) + (Game_ColorA(b) - Game_ColorA(a)) * p);
	R = platform->vtbl->floatToInt(platform, Game_ColorR(a) + (Game_ColorR(b) - Game_ColorR(a)) * p);
	G = platform->vtbl->floatToInt(platform, Game_ColorG(a) + (Game_ColorG(b) - Game_ColorG(a)) * p);
	B = platform->vtbl->floatToInt(platform, Game_ColorB(a) + (Game_ColorB(b) - Game_ColorB(a)) * p);
	return Game_ColorFromArgb(A, R, G, B);
}

static void Intersection_Construct(Intersection *self)
{
}

cibool Intersection_CheckLineBox(Box3D const *box, Line3D const *line, float *hit)
{
	return Intersection_CheckLineBox1(box->minEdge, box->maxEdge, line->start, line->end, hit);
}

cibool Intersection_CheckLineBox1(float const *B1, float const *B2, float const *L1, float const *L2, float *Hit)
{
	if (L2[0] < B1[0] && L1[0] < B1[0])
		return FALSE;
	if (L2[0] > B2[0] && L1[0] > B2[0])
		return FALSE;
	if (L2[1] < B1[1] && L1[1] < B1[1])
		return FALSE;
	if (L2[1] > B2[1] && L1[1] > B2[1])
		return FALSE;
	if (L2[2] < B1[2] && L1[2] < B1[2])
		return FALSE;
	if (L2[2] > B2[2] && L1[2] > B2[2])
		return FALSE;
	if (L1[0] > B1[0] && L1[0] < B2[0] && L1[1] > B1[1] && L1[1] < B2[1] && L1[2] > B1[2] && L1[2] < B2[2]) {
		Hit[0] = L1[0];
		Hit[1] = L1[1];
		Hit[2] = L1[2];
		return TRUE;
	}
	if ((Intersection_GetIntersection(L1[0] - B1[0], L2[0] - B1[0], L1, L2, Hit) && Intersection_InBox(Hit, B1, B2, 1)) || (Intersection_GetIntersection(L1[1] - B1[1], L2[1] - B1[1], L1, L2, Hit) && Intersection_InBox(Hit, B1, B2, 2)) || (Intersection_GetIntersection(L1[2] - B1[2], L2[2] - B1[2], L1, L2, Hit) && Intersection_InBox(Hit, B1, B2, 3)) || (Intersection_GetIntersection(L1[0] - B2[0], L2[0] - B2[0], L1, L2, Hit) && Intersection_InBox(Hit, B1, B2, 1)) || (Intersection_GetIntersection(L1[1] - B2[1], L2[1] - B2[1], L1, L2, Hit) && Intersection_InBox(Hit, B1, B2, 2)) || (Intersection_GetIntersection(L1[2] - B2[2], L2[2] - B2[2], L1, L2, Hit) && Intersection_InBox(Hit, B1, B2, 3)))
		return TRUE;
	return FALSE;
}

float const *Intersection_CheckLineBoxExact(Line3D const *line, Box3D const *box)
{
	float *dir_ = (float *) malloc(3 * sizeof(float ));
	float *hit;
	dir_[0] = line->end[0] - line->start[0];
	dir_[1] = line->end[1] - line->start[1];
	dir_[2] = line->end[2] - line->start[2];
	hit = (float *) malloc(3 * sizeof(float ));
	if (!Intersection_HitBoundingBox(box->minEdge, box->maxEdge, line->start, dir_, hit)) {
		return NULL;
	}
	return hit;
}

static cibool Intersection_GetIntersection(float fDst1, float fDst2, float const *P1, float const *P2, float *Hit)
{
	if (fDst1 * fDst2 >= 0)
		return FALSE;
	if (fDst1 == fDst2)
		return FALSE;
	Hit[0] = P1[0] + (P2[0] - P1[0]) * -fDst1 / (fDst2 - fDst1);
	Hit[1] = P1[1] + (P2[1] - P1[1]) * -fDst1 / (fDst2 - fDst1);
	Hit[2] = P1[2] + (P2[2] - P1[2]) * -fDst1 / (fDst2 - fDst1);
	return TRUE;
}

cibool Intersection_HitBoundingBox(float const *minB, float const *maxB, float *origin, float const *dir, float *coord)
{
	cibool inside = TRUE;
	unsigned char *quadrant = (unsigned char *) malloc(3 * sizeof(unsigned char ));
	int i;
	int whichPlane;
	float *maxT = (float *) malloc(3 * sizeof(float ));
	float *candidatePlane = (float *) malloc(3 * sizeof(float ));
	for (i = 0; i < 3; i++)
		if (origin[i] < minB[i]) {
			quadrant[i] = 1;
			candidatePlane[i] = minB[i];
			inside = FALSE;
		}
		else if (origin[i] > maxB[i]) {
			quadrant[i] = 0;
			candidatePlane[i] = maxB[i];
			inside = FALSE;
		}
		else {
			quadrant[i] = 2;
		}
	if (inside) {
		coord = origin;
		return TRUE;
	}
	for (i = 0; i < 3; i++)
		if (quadrant[i] != 2 && dir[i] != 0)
			maxT[i] = (candidatePlane[i] - origin[i]) / dir[i];
		else
			maxT[i] = -1;
	whichPlane = 0;
	for (i = 1; i < 3; i++)
		if (maxT[whichPlane] < maxT[i])
			whichPlane = i;
	if (maxT[whichPlane] < 0)
		return FALSE;
	for (i = 0; i < 3; i++)
		if (whichPlane != i) {
			coord[i] = origin[i] + maxT[whichPlane] * dir[i];
			if (coord[i] < minB[i] || coord[i] > maxB[i])
				return FALSE;
		}
		else {
			coord[i] = candidatePlane[i];
		}
	return TRUE;
}

static cibool Intersection_InBox(float const *Hit, float const *B1, float const *B2, int Axis)
{
	if (Axis == 1 && Hit[2] > B1[2] && Hit[2] < B2[2] && Hit[1] > B1[1] && Hit[1] < B2[1])
		return TRUE;
	if (Axis == 2 && Hit[2] > B1[2] && Hit[2] < B2[2] && Hit[0] > B1[0] && Hit[0] < B2[0])
		return TRUE;
	if (Axis == 3 && Hit[0] > B1[0] && Hit[0] < B2[0] && Hit[1] > B1[1] && Hit[1] < B2[1])
		return TRUE;
	return FALSE;
}

static void InventoryUtilClient_Construct(InventoryUtilClient *self)
{
	self->cellCountX = 12;
	self->cellCountY = 42;
}

InventoryUtilClient *InventoryUtilClient_New(void)
{
	InventoryUtilClient *self = (InventoryUtilClient *) malloc(sizeof(InventoryUtilClient));
	if (self != NULL)
		InventoryUtilClient_Construct(self);
	return self;
}

void InventoryUtilClient_Delete(InventoryUtilClient *self)
{
	free(self);
}

static IntRef const *InventoryUtilClient_FreeHand(InventoryUtilClient const *self, int ActiveMaterial_)
{
	IntRef const *freehand = NULL;
	if (self->d_Inventory->rightHand[ActiveMaterial_] == NULL)
		return IntRef_Create(ActiveMaterial_);
	{
		int i;
		for (i = 0; i < 10; i++) {
			if (self->d_Inventory->rightHand[i] == NULL) {
				return freehand;
			}
		}
	}
	return NULL;
}

cibool InventoryUtilClient_IsValidCell(InventoryUtilClient const *self, PointRef const *p)
{
	return !(p->x < 0 || p->y < 0 || p->x >= self->cellCountX || p->y >= self->cellCountY);
}

static PointRef const *InventoryUtilClient_ItemAtCell(InventoryUtilClient const *self, PointRef const *p)
{
	{
		int i;
		for (i = 0; i < self->d_Inventory->itemsCount; i++) {
			Packet_PositionItem const *k = self->d_Inventory->items[i];
			Packet_Item const *item = k->value_;
			{
				int x;
				for (x = 0; x < GameDataItemsClient_ItemSizeX(self->d_Items, item); x++) {
					{
						int y;
						for (y = 0; y < GameDataItemsClient_ItemSizeY(self->d_Items, item); y++) {
							int px = k->x + x;
							int py = k->y + y;
							if (p->x == px && p->y == py) {
								return PointRef_Create(k->x, k->y);
							}
						}
					}
				}
			}
		}
	}
	return NULL;
}

static Packet_Item const *InventoryUtilClient_ItemAtWearPlace(InventoryUtilClient const *self, int wearPlace, int activeMaterial)
{
	switch (wearPlace) {
	case 0:
		return self->d_Inventory->rightHand[activeMaterial];
	case 1:
		return self->d_Inventory->mainArmor;
	case 2:
		return self->d_Inventory->boots;
	case 3:
		return self->d_Inventory->helmet;
	case 4:
		return self->d_Inventory->gauntlet;
	default:
		return NULL;
	}
}

static PointRef const *const *InventoryUtilClient_ItemsAtArea(InventoryUtilClient const *self, int pX, int pY, int sizeX, int sizeY, IntRef *retCount)
{
	PointRef const **itemsAtArea = (PointRef const **) malloc(256 * sizeof(PointRef const *));
	int itemsAtAreaCount = 0;
	{
		int xx;
		for (xx = 0; xx < sizeX; xx++) {
			{
				int yy;
				for (yy = 0; yy < sizeY; yy++) {
					PointRef const *cell = PointRef_Create(pX + xx, pY + yy);
					if (!InventoryUtilClient_IsValidCell(self, cell)) {
						return NULL;
					}
					if (InventoryUtilClient_ItemAtCell(self, cell) != NULL) {
						cibool contains = FALSE;
						{
							int i;
							for (i = 0; i < itemsAtAreaCount; i++) {
								if (itemsAtArea[i] == NULL) {
									continue;
								}
								if (itemsAtArea[i]->x == InventoryUtilClient_ItemAtCell(self, cell)->x && itemsAtArea[i]->y == InventoryUtilClient_ItemAtCell(self, cell)->y) {
									contains = TRUE;
								}
							}
						}
						if (!contains) {
							itemsAtArea[itemsAtAreaCount++] = InventoryUtilClient_ItemAtCell(self, cell);
						}
					}
				}
			}
		}
	}
	retCount->value = itemsAtAreaCount;
	return itemsAtArea;
}

static void IsBlockEmpty__Construct(IsBlockEmpty_ *self, const DelegateIsBlockEmptyVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_IsBlockEmpty_;
	DelegateIsBlockEmpty_Construct(&self->base, vtbl);
}

IsBlockEmpty_ *IsBlockEmpty__New(void)
{
	IsBlockEmpty_ *self = (IsBlockEmpty_ *) malloc(sizeof(IsBlockEmpty_));
	if (self != NULL)
		IsBlockEmpty__Construct(self, NULL);
	return self;
}

void IsBlockEmpty__Delete(IsBlockEmpty_ *self)
{
	free(self);
}

IsBlockEmpty_ const *IsBlockEmpty__Create(Game const *w_)
{
	IsBlockEmpty_ *g = IsBlockEmpty__New();
	g->w = w_;
	return g;
}

cibool IsBlockEmpty__IsBlockEmpty(IsBlockEmpty_ const *self, int x, int y, int z)
{
	return Game_IsTileEmptyForPhysics(self->w, x, y, z);
}

static void Kamera_Construct(Kamera *self)
{
	self->one = 1;
	self->distance = 5;
	self->angle = 45;
	self->minimumDistance = 2;
	self->tt = 0;
	self->maximumAngle = 89;
	self->minimumAngle = 0;
	self->center = Vector3Ref_New();
}

Kamera *Kamera_New(void)
{
	Kamera *self = (Kamera *) malloc(sizeof(Kamera));
	if (self != NULL)
		Kamera_Construct(self);
	return self;
}

void Kamera_Delete(Kamera *self)
{
	free(self);
}

float Kamera_GetAngle(Kamera const *self)
{
	return self->angle;
}

static float Kamera_GetCameraHeightFromCenter(Kamera const *self, GamePlatform const *platform)
{
	return platform->vtbl->mathSin(platform, self->angle * Game_GetPi() / 180) * self->distance;
}

void Kamera_GetCenter(Kamera const *self, Vector3Ref *ret)
{
	ret->x = self->center->x;
	ret->y = self->center->y;
	ret->z = self->center->z;
}

float Kamera_GetDistance(Kamera const *self)
{
	return self->distance;
}

static float Kamera_GetFlatDistance(Kamera const *self, GamePlatform const *platform)
{
	return platform->vtbl->mathCos(platform, self->angle * Game_GetPi() / 180) * self->distance;
}

void Kamera_GetPosition(Kamera const *self, GamePlatform const *platform, Vector3Ref *ret)
{
	float cx = platform->vtbl->mathCos(platform, self->tt * self->one / 2) * Kamera_GetFlatDistance(self, platform) + self->center->x;
	float cy = platform->vtbl->mathSin(platform, self->tt * self->one / 2) * Kamera_GetFlatDistance(self, platform) + self->center->z;
	ret->x = cx;
	ret->y = self->center->y + Kamera_GetCameraHeightFromCenter(self, platform);
	ret->z = cy;
}

float Kamera_GetT(Kamera const *self)
{
	return self->tt;
}

void Kamera_Move(Kamera *self, CameraMove const *camera_move, float p)
{
	p *= 2;
	p *= 2;
	if (camera_move->turnLeft) {
		Kamera_TurnLeft(self, p);
	}
	if (camera_move->turnRight) {
		Kamera_TurnRight(self, p);
	}
	if (camera_move->distanceUp) {
		Kamera_SetDistance(self, Kamera_GetDistance(self) + p);
	}
	if (camera_move->distanceDown) {
		Kamera_SetDistance(self, Kamera_GetDistance(self) - p);
	}
	if (camera_move->angleUp) {
		self->angle += p * 10;
	}
	if (camera_move->angleDown) {
		self->angle -= p * 10;
	}
	Kamera_SetDistance(self, camera_move->distance);
	Kamera_SetValidAngle(self);
}

void Kamera_SetAngle(Kamera *self, float value)
{
	self->angle = value;
}

void Kamera_SetDistance(Kamera *self, float value)
{
	self->distance = value;
	if (self->distance < self->minimumDistance) {
		self->distance = self->minimumDistance;
	}
}

void Kamera_SetT(Kamera *self, float value)
{
	self->tt = value;
}

static void Kamera_SetValidAngle(Kamera *self)
{
	if (self->angle > self->maximumAngle) {
		self->angle = self->maximumAngle;
	}
	if (self->angle < self->minimumAngle) {
		self->angle = self->minimumAngle;
	}
}

void Kamera_TurnLeft(Kamera *self, float p)
{
	self->tt += p;
}

void Kamera_TurnRight(Kamera *self, float p)
{
	self->tt -= p;
}

void Kamera_TurnUp(Kamera *self, float p)
{
	self->angle += p;
	Kamera_SetValidAngle(self);
}

Key *Key_New(void)
{
	Key *self = (Key *) malloc(sizeof(Key));
	return self;
}

void Key_Delete(Key *self)
{
	free(self);
}

Key const *Key_Create(int field, int wireType)
{
	Key *k = Key_New();
	k->field = field;
	k->wireType = wireType;
	return k;
}

int Key_GetField(Key const *self)
{
	return self->field;
}

int Key_GetWireType(Key const *self)
{
	return self->wireType;
}

void Key_SetField(Key *self, int value)
{
	self->field = value;
}

void Key_SetWireType(Key *self, int value)
{
	self->wireType = value;
}

KeyEventArgs *KeyEventArgs_New(void)
{
	KeyEventArgs *self = (KeyEventArgs *) malloc(sizeof(KeyEventArgs));
	return self;
}

void KeyEventArgs_Delete(KeyEventArgs *self)
{
	free(self);
}

cibool KeyEventArgs_GetAltPressed(KeyEventArgs const *self)
{
	return self->modifierAlt;
}

cibool KeyEventArgs_GetCtrlPressed(KeyEventArgs const *self)
{
	return self->modifierCtrl;
}

cibool KeyEventArgs_GetHandled(KeyEventArgs const *self)
{
	return self->handled;
}

int KeyEventArgs_GetKeyCode(KeyEventArgs const *self)
{
	return self->keyCode;
}

cibool KeyEventArgs_GetShiftPressed(KeyEventArgs const *self)
{
	return self->modifierShift;
}

void KeyEventArgs_SetAltPressed(KeyEventArgs *self, cibool value)
{
	self->modifierAlt = value;
}

void KeyEventArgs_SetCtrlPressed(KeyEventArgs *self, cibool value)
{
	self->modifierCtrl = value;
}

void KeyEventArgs_SetHandled(KeyEventArgs *self, cibool value)
{
	self->handled = value;
}

void KeyEventArgs_SetKeyCode(KeyEventArgs *self, int value)
{
	self->keyCode = value;
}

void KeyEventArgs_SetShiftPressed(KeyEventArgs *self, cibool value)
{
	self->modifierShift = value;
}

static void KeyEventHandler_Construct(KeyEventHandler *self, const KeyEventHandlerVtbl *vtbl)
{
	self->vtbl = vtbl;
}

KeyHelp *KeyHelp_New(void)
{
	KeyHelp *self = (KeyHelp *) malloc(sizeof(KeyHelp));
	return self;
}

void KeyHelp_Delete(KeyHelp *self)
{
	free(self);
}

KeyPressEventArgs *KeyPressEventArgs_New(void)
{
	KeyPressEventArgs *self = (KeyPressEventArgs *) malloc(sizeof(KeyPressEventArgs));
	return self;
}

void KeyPressEventArgs_Delete(KeyPressEventArgs *self)
{
	free(self);
}

cibool KeyPressEventArgs_GetHandled(KeyPressEventArgs const *self)
{
	return self->handled;
}

int KeyPressEventArgs_GetKeyChar(KeyPressEventArgs const *self)
{
	return self->keyChar;
}

void KeyPressEventArgs_SetHandled(KeyPressEventArgs *self, cibool value)
{
	self->handled = value;
}

void KeyPressEventArgs_SetKeyChar(KeyPressEventArgs *self, int value)
{
	self->keyChar = value;
}

KeyValue *KeyValue_New(void)
{
	KeyValue *self = (KeyValue *) malloc(sizeof(KeyValue));
	return self;
}

void KeyValue_Delete(KeyValue *self)
{
	free(self);
}

KeyValue const *KeyValue_Create(Key const *key, unsigned char const *value)
{
	KeyValue *k = KeyValue_New();
	k->key_ = key;
	k->value = value;
	return k;
}

KeyValueStringInt *KeyValueStringInt_New(void)
{
	KeyValueStringInt *self = (KeyValueStringInt *) malloc(sizeof(KeyValueStringInt));
	return self;
}

void KeyValueStringInt_Delete(KeyValueStringInt *self)
{
	free(self);
}

KeyValueStringString *KeyValueStringString_New(void)
{
	KeyValueStringString *self = (KeyValueStringString *) malloc(sizeof(KeyValueStringString));
	return self;
}

void KeyValueStringString_Delete(KeyValueStringString *self)
{
	free(self);
}

Keyframe *Keyframe_New(void)
{
	Keyframe *self = (Keyframe *) malloc(sizeof(Keyframe));
	return self;
}

void Keyframe_Delete(Keyframe *self)
{
	free(self);
}

const char *KeyframeType_GetName(int p)
{
	if (p == 1) {
		return "pos";
	}
	if (p == 2) {
		return "rot";
	}
	if (p == 3) {
		return "siz";
	}
	if (p == 4) {
		return "piv";
	}
	if (p == 5) {
		return "sca";
	}
	return "";
}

int KeyframeType_GetValue(const char *p)
{
	if (strcmp(p, "pos") == 0) {
		return 1;
	}
	if (strcmp(p, "rot") == 0) {
		return 2;
	}
	if (strcmp(p, "siz") == 0) {
		return 3;
	}
	if (strcmp(p, "piv") == 0) {
		return 4;
	}
	if (strcmp(p, "sca") == 0) {
		return 5;
	}
	return 0;
}

static void Language_Construct(Language *self)
{
	self->stringsMax = 32768;
	self->stringsCount = 0;
	self->strings = (TranslatedString const **) malloc(self->stringsMax * sizeof(TranslatedString const *));
	self->loadedLanguagesCount = 0;
	self->loadedLanguagesMax = 64;
	self->loadedLanguages = (const char **) malloc(self->loadedLanguagesMax * sizeof(const char *));
}

Language *Language_New(void)
{
	Language *self = (Language *) malloc(sizeof(Language));
	if (self != NULL)
		Language_Construct(self);
	return self;
}

void Language_Delete(Language *self)
{
	free(self);
}

static void Language_Add(Language *self, const char *language, const char *id, const char *translated)
{
	TranslatedString *s;
	if (Language_IsNewLanguage(self, language)) {
		if (self->loadedLanguagesCount < self->loadedLanguagesMax) {
			self->loadedLanguages[self->loadedLanguagesCount] = language;
			self->loadedLanguagesCount++;
		}
	}
	if (self->stringsCount > self->stringsMax) {
		return;
	}
	if (Language_ContainsTranslation(self, language, id)) {
		return;
	}
	s = TranslatedString_New();
	s->language = language;
	s->id = id;
	s->translated = translated;
	self->strings[self->stringsCount++] = s;
}

static void Language_AddEnglish(Language *self)
{
	Language_Add(self, "en", "MainMenu_AssetsLoadProgress", "Loading... {0}%");
	Language_Add(self, "en", "MainMenu_Singleplayer", "Singleplayer");
	Language_Add(self, "en", "MainMenu_Multiplayer", "Multiplayer");
	Language_Add(self, "en", "MainMenu_Quit", "&cQuit");
	Language_Add(self, "en", "MainMenu_ButtonBack", "Back");
	Language_Add(self, "en", "MainMenu_SingleplayerButtonCreate", "Create or open...");
	Language_Add(self, "en", "MainMenu_Login", "Login");
	Language_Add(self, "en", "MainMenu_LoginUsername", "Username");
	Language_Add(self, "en", "MainMenu_LoginPassword", "Password");
	Language_Add(self, "en", "MainMenu_LoginRemember", "Remember me");
	Language_Add(self, "en", "MainMenu_ChoiceYes", "Yes");
	Language_Add(self, "en", "MainMenu_ChoiceNo", "No");
	Language_Add(self, "en", "MainMenu_LoginInvalid", "&4Invalid username or password");
	Language_Add(self, "en", "MainMenu_LoginConnecting", "Connecting...");
	Language_Add(self, "en", "MainMenu_MultiplayerConnect", "Connect");
	Language_Add(self, "en", "MainMenu_MultiplayerConnectIP", "Connect to IP");
	Language_Add(self, "en", "MainMenu_MultiplayerRefresh", "Refresh");
	Language_Add(self, "en", "MainMenu_MultiplayerLoading", "Loading...");
	Language_Add(self, "en", "MainMenu_ConnectToIpConnect", "Connect");
	Language_Add(self, "en", "MainMenu_ConnectToIpIp", "IP");
	Language_Add(self, "en", "MainMenu_ConnectToIpPort", "Port");
	Language_Add(self, "en", "CannotWriteChatLog", "Cannot write to chat log file {0}.");
	Language_Add(self, "en", "ChunkUpdates", "Chunk updates: {0}");
	Language_Add(self, "en", "Connecting", "Connecting...");
	Language_Add(self, "en", "ConnectingProgressKilobytes", "{0} KB");
	Language_Add(self, "en", "ConnectingProgressPercent", "{0}%");
	Language_Add(self, "en", "DefaultKeys", "Default keys");
	Language_Add(self, "en", "Exit", "Return to main menu");
	Language_Add(self, "en", "FogDistance", "Fog distance: {0}");
	Language_Add(self, "en", "FontOption", "Font: {0}");
	Language_Add(self, "en", "FrameRateLagSimulation", "Frame rate: lag simulation.");
	Language_Add(self, "en", "FrameRateUnlimited", "Frame rate: unlimited.");
	Language_Add(self, "en", "FrameRateVsync", "Frame rate: vsync.");
	Language_Add(self, "en", "FreemoveNotAllowed", "Freemove is not allowed on this server.");
	Language_Add(self, "en", "GameName", "Manic Digger");
	Language_Add(self, "en", "Graphics", "Graphics");
	Language_Add(self, "en", "InvalidVersionConnectAnyway", "Invalid game version. Local: {0}, Server: {1}. Do you want to connect anyway?");
	Language_Add(self, "en", "KeyBlockInfo", "Block information");
	Language_Add(self, "en", "KeyChange", "{0}: {1}");
	Language_Add(self, "en", "KeyChat", "Chat");
	Language_Add(self, "en", "KeyCraft", "Craft");
	Language_Add(self, "en", "KeyFreeMove", "Free move");
	Language_Add(self, "en", "KeyFullscreen", "Fullscreen");
	Language_Add(self, "en", "KeyJump", "Jump");
	Language_Add(self, "en", "KeyMoveBack", "Move back");
	Language_Add(self, "en", "KeyMoveFoward", "Move foward");
	Language_Add(self, "en", "KeyMoveLeft", "Move left");
	Language_Add(self, "en", "KeyMoveRight", "Move right");
	Language_Add(self, "en", "KeyMoveSpeed", "{0}x move speed");
	Language_Add(self, "en", "KeyPlayersList", "Players list");
	Language_Add(self, "en", "KeyReloadWeapon", "Reload weapon");
	Language_Add(self, "en", "KeyRespawn", "Respawn");
	Language_Add(self, "en", "KeyReverseMinecart", "Reverse minecart");
	Language_Add(self, "en", "Keys", "Keys");
	Language_Add(self, "en", "KeyScreenshot", "Screenshot");
	Language_Add(self, "en", "KeySetSpawnPosition", "Set spawn position");
	Language_Add(self, "en", "KeyShowMaterialSelector", "Open inventory");
	Language_Add(self, "en", "KeyTeamChat", "Team Chat");
	Language_Add(self, "en", "KeyTextEditor", "Texteditor");
	Language_Add(self, "en", "KeyThirdPersonCamera", "Third-person camera");
	Language_Add(self, "en", "KeyToggleFogDistance", "Toggle fog distance");
	Language_Add(self, "en", "KeyUse", "Use");
	Language_Add(self, "en", "MoveFree", "Move: Free.");
	Language_Add(self, "en", "MoveFreeNoclip", "Move: Free, Noclip.");
	Language_Add(self, "en", "MoveNormal", "Move: Normal.");
	Language_Add(self, "en", "MoveSpeed", "Move Speed: {0}.");
	Language_Add(self, "en", "NoMaterialsForCrafting", "No materials for crafting.");
	Language_Add(self, "en", "Off", "OFF");
	Language_Add(self, "en", "On", "ON");
	Language_Add(self, "en", "Options", "Options");
	Language_Add(self, "en", "Other", "Other");
	Language_Add(self, "en", "PressToUse", "(press {0} to use)");
	Language_Add(self, "en", "Respawn", "Respawn");
	Language_Add(self, "en", "ReturnToGame", "Return to game");
	Language_Add(self, "en", "ReturnToMainMenu", "Back");
	Language_Add(self, "en", "ReturnToOptionsMenu", "Return to options menu");
	Language_Add(self, "en", "ShadowsOption", "Shadows: {0}");
	Language_Add(self, "en", "SoundOption", "Sound: {0}");
	Language_Add(self, "en", "AutoJumpOption", "Auto Jump: {0}");
	Language_Add(self, "en", "ClientLanguageOption", "Language: {0}");
	Language_Add(self, "en", "SpawnPositionSet", "Spawn position set.");
	Language_Add(self, "en", "SpawnPositionSetTo", "Spawn position set to: {0}");
	Language_Add(self, "en", "Triangles", "Triangles: {0}");
	Language_Add(self, "en", "UseServerTexturesOption", "Use server textures (restart): {0}");
	Language_Add(self, "en", "ViewDistanceOption", "View distance: {0}");
	Language_Add(self, "en", "OptionSmoothShadows", "Smooth shadows: {0}");
	Language_Add(self, "en", "OptionFramerate", "Framerate: {0}");
	Language_Add(self, "en", "OptionResolution", "Resolution: {0}");
	Language_Add(self, "en", "OptionFullscreen", "Fullscreen: {0}");
	Language_Add(self, "en", "OptionDarkenSides", "Darken block sides: {0}");
	Language_Add(self, "en", "Server_CannotWriteLogFile", "Cannot write to server log file {0}.");
	Language_Add(self, "en", "Server_LoadingSavegame", "Loading savegame...");
	Language_Add(self, "en", "Server_CreatingSavegame", "Creating new savegame file.");
	Language_Add(self, "en", "Server_LoadedSavegame", "Savegame loaded: ");
	Language_Add(self, "en", "Server_ConfigNotFound", "Server configuration file not found, creating new.");
	Language_Add(self, "en", "Server_ConfigCorruptBackup", "ServerConfig corrupt! Created new. Backup saved as ServerConfig.txt.old");
	Language_Add(self, "en", "Server_ConfigCorruptNoBackup", "ServerConfig corrupt! Created new. COULD NOT BACKUP OLD!");
	Language_Add(self, "en", "Server_ConfigLoaded", "Server configuration loaded.");
	Language_Add(self, "en", "Server_ClientConfigNotFound", "Server client configuration file not found, creating new.");
	Language_Add(self, "en", "Server_ClientConfigGuestGroupNotFound", "Default guest group not found!");
	Language_Add(self, "en", "Server_ClientConfigRegisteredGroupNotFound", "Default registered group not found!");
	Language_Add(self, "en", "Server_ClientConfigLoaded", "Server client configuration loaded.");
	Language_Add(self, "en", "Server_InvalidSpawnCoordinates", "Invalid default spawn coordinates!");
	Language_Add(self, "en", "Server_ProgressDownloadingData", "Downloading data...");
	Language_Add(self, "en", "Server_ProgressGenerating", "Generating world...");
	Language_Add(self, "en", "Server_ProgressDownloadingMap", "Downloading map...");
	Language_Add(self, "en", "Server_NoChatPrivilege", "{0}Insufficient privileges to chat.");
	Language_Add(self, "en", "Server_FillAreaInvalid", "Fillarea is invalid or contains blocks in an area you are not allowed to build in.");
	Language_Add(self, "en", "Server_FillAreaTooLarge", "Fill area is too large.");
	Language_Add(self, "en", "Server_NoSpectatorBuild", "Spectators are not allowed to build.");
	Language_Add(self, "en", "Server_NoBuildPrivilege", "Insufficient privileges to build.");
	Language_Add(self, "en", "Server_NoBuildPermissionHere", "You need permission to build in this section of the world.");
	Language_Add(self, "en", "Server_NoSpectatorUse", "Spectators are not allowed to use blocks.");
	Language_Add(self, "en", "Server_NoUsePrivilege", "Insufficient privileges to use blocks.");
	Language_Add(self, "en", "Server_PlayerJoin", "Player {0} joins.");
	Language_Add(self, "en", "Server_PlayerDisconnect", "Player {0} disconnected.");
	Language_Add(self, "en", "Server_UsernameBanned", "Your username has been banned from this server.{0}");
	Language_Add(self, "en", "Server_NoGuests", "Guests are not allowed on this server. Login or register an account.");
	Language_Add(self, "en", "Server_UsernameInvalid", "Invalid username (allowed characters: a-z,A-Z,0-9,-,_; max. length: 16).");
	Language_Add(self, "en", "Server_PasswordInvalid", "Invalid server password.");
	Language_Add(self, "en", "Server_ClientException", "Your client threw an exception at server.");
	Language_Add(self, "en", "Server_IPBanned", "Your IP has been banned from this server.{0}");
	Language_Add(self, "en", "Server_TooManyPlayers", "Too many players! Try to connect later.");
	Language_Add(self, "en", "Server_HTTPServerError", "Cannot start HTTP server on TCP port {0}.");
	Language_Add(self, "en", "Server_HTTPServerStarted", "HTTP server listening on TCP port {0}.");
	Language_Add(self, "en", "Server_HeartbeatSent", "Heartbeat sent.");
	Language_Add(self, "en", "Server_HeartbeatError", "Unable to send heartbeat.");
	Language_Add(self, "en", "Server_BanlistLoaded", "Server banlist loaded.");
	Language_Add(self, "en", "Server_BanlistCorruptNoBackup", "Banlist corrupt! Created new. COULD NOT BACKUP OLD!");
	Language_Add(self, "en", "Server_BanlistCorrupt", "Banlist corrupt! Created new. Backup saved as ServerBanlist.txt.old");
	Language_Add(self, "en", "Server_BanlistNotFound", "Server banlist not found, creating new.");
	Language_Add(self, "en", "Server_SetupAccept", "y");
	Language_Add(self, "en", "Server_SetupEnableHTTP", "Dou you want to enable the builtin HTTP server? (Y/N)");
	Language_Add(self, "en", "Server_SetupMaxClients", "Enter the maximum number of clients (Default: 16)");
	Language_Add(self, "en", "Server_SetupMaxClientsInvalidValue", "Number may not be negative. Using default (16)");
	Language_Add(self, "en", "Server_SetupMaxClientsInvalidInput", "Invalid input. Using default (16)");
	Language_Add(self, "en", "Server_SetupPort", "Enter the port the server shall run on (Default: 25565)");
	Language_Add(self, "en", "Server_SetupPortInvalidValue", "Out of port range. Using default (25565)");
	Language_Add(self, "en", "Server_SetupPortInvalidInput", "Invalid input. Using default (25565)");
	Language_Add(self, "en", "Server_SetupWelcomeMessage", "Enter the welcome message (displayed when joining your server)");
	Language_Add(self, "en", "Server_SetupMOTD", "Enter the MOTD (displayed on server list)");
	Language_Add(self, "en", "Server_SetupName", "Please enter the server's name");
	Language_Add(self, "en", "Server_SetupPublic", "Do you want the server to be public (visible on the server list)? (Y/N)");
	Language_Add(self, "en", "Server_SetupQuestion", "Would you like to set up some basic parameters? (Y/N)");
	Language_Add(self, "en", "Server_SetupFirstStart", "It seems this is the first time you started this server.");
	Language_Add(self, "en", "Server_GameSaved", "Game saved. ({0} seconds)");
	Language_Add(self, "en", "Server_InvalidBackupName", "Invalid backup filename: ");
	Language_Add(self, "en", "Server_MonitorConfigLoaded", "Server monitor configuration loaded.");
	Language_Add(self, "en", "Server_MonitorConfigNotFound", "Server monitor configuration file not found, creating new.");
	Language_Add(self, "en", "Server_MonitorChatMuted", "Spam protection: {0} has been muted for {1} seconds.");
	Language_Add(self, "en", "Server_MonitorChatNotSent", "Spam protection: Your message has not been sent.");
	Language_Add(self, "en", "Server_MonitorBuildingDisabled", "{0} exceeds set block limit.");
	Language_Add(self, "en", "Server_CommandInvalidArgs", "Invalid arguments. Type /help to see command's usage.");
	Language_Add(self, "en", "Server_CommandInvalidSpawnPosition", "Invalid spawn position.");
	Language_Add(self, "en", "Server_CommandNonexistantPlayer", "{0}Player {1} does not exist.");
	Language_Add(self, "en", "Server_CommandInvalidPosition", "Invalid position.");
	Language_Add(self, "en", "Server_CommandInsufficientPrivileges", "{0}Insufficient privileges to access this command.");
	Language_Add(self, "en", "Server_CommandBackupFailed", "{0}Backup could not be created. Check filename.");
	Language_Add(self, "en", "Server_CommandBackupCreated", "{0}Backup created.");
	Language_Add(self, "en", "Server_CommandException", "Command exception.");
	Language_Add(self, "en", "Server_CommandUnknown", "Unknown command /");
	Language_Add(self, "en", "Server_CommandPlayerNotFound", "{0}Player {1} not found.");
	Language_Add(self, "en", "Server_CommandPMNoAnswer", "{0}No PM to answer.");
	Language_Add(self, "en", "Server_CommandGroupNotFound", "{0}Group {1} not found.");
	Language_Add(self, "en", "Server_CommandTargetGroupSuperior", "{0}The target group is superior your group.");
	Language_Add(self, "en", "Server_CommandTargetUserSuperior", "{0}Target user is superior or equal.");
	Language_Add(self, "en", "Server_CommandSetGroupTo", "{0}{1} set group of {2} to {3}.");
	Language_Add(self, "en", "Server_CommandOpTargetOffline", "{0}Player {1} is offline. Use /chgrp_offline command.");
	Language_Add(self, "en", "Server_CommandOpTargetOnline", "{0}Player {1} is online. Use /chgrp command.");
	Language_Add(self, "en", "Server_CommandInvalidGroup", "{0}Invalid group.");
	Language_Add(self, "en", "Server_CommandSetOfflineGroupTo", "{0}{1} set group of {2} to {3} (offline).");
	Language_Add(self, "en", "Server_CommandRemoveSuccess", "{0}Client {1} removed from config.");
	Language_Add(self, "en", "Server_CommandRemoveNotFound", "{0}No entry of client {1} found.");
	Language_Add(self, "en", "Server_CommandLoginNoPW", "{0}Group {1} doesn't allow password access.");
	Language_Add(self, "en", "Server_CommandLoginSuccess", "{0}{1} logs in group {2}.");
	Language_Add(self, "en", "Server_CommandLoginInfo", "Type /help see your available privileges.");
	Language_Add(self, "en", "Server_CommandLoginInvalidPassword", "{0}Invalid password.");
	Language_Add(self, "en", "Server_CommandWelcomeChanged", "{0}{1} set new welcome message: {2}");
	Language_Add(self, "en", "Server_CommandKickBanReason", " Reason: ");
	Language_Add(self, "en", "Server_CommandKickMessage", "{0}{1} was kicked by {2}.{3}");
	Language_Add(self, "en", "Server_CommandKickNotification", "You were kicked by an administrator.{0}");
	Language_Add(self, "en", "Server_CommandNonexistantID", "{0}Player ID {1} does not exist.");
	Language_Add(self, "en", "Server_CommandBanMessage", "{0}{1} was permanently banned by {2}.{3}");
	Language_Add(self, "en", "Server_CommandBanNotification", "You were permanently banned by an administrator.{0}");
	Language_Add(self, "en", "Server_CommandIPBanMessage", "{0}{1} was permanently IP banned by {2}.{3}");
	Language_Add(self, "en", "Server_CommandIPBanNotification", "You were permanently IP banned by an administrator.{0}");
	Language_Add(self, "en", "Server_CommandTimeBanMessage", "{0}{1} was banned by {2} for {3} minutes.{4}");
	Language_Add(self, "en", "Server_CommandTimeBanNotification", "You were banned by an administrator for {0} minutes.{1}");
	Language_Add(self, "en", "Server_CommandTimeIPBanMessage", "{0}{1} was IP banned by {2} for {3} minutes.{4}");
	Language_Add(self, "en", "Server_CommandTimeIPBanNotification", "You were IP banned by an administrator for {0} minutes.{1}");
	Language_Add(self, "en", "Server_CommandTimeBanInvalidValue", "Duration must be greater than 0!");
	Language_Add(self, "en", "Server_CommandBanOfflineTargetOnline", "{0}Player {1} is online. Use /ban command.");
	Language_Add(self, "en", "Server_CommandBanOfflineMessage", "{0}{1} (offline) was banned by {2}.{3}");
	Language_Add(self, "en", "Server_CommandUnbanSuccess", "{0}Player {1} unbanned.");
	Language_Add(self, "en", "Server_CommandUnbanIPNotFound", "{0}IP {1} not found.");
	Language_Add(self, "en", "Server_CommandUnbanIPSuccess", "{0}IP {1} unbanned.");
	Language_Add(self, "en", "Server_CommandGiveAll", "{0}Given all blocks to {1}");
	Language_Add(self, "en", "Server_CommandGiveSuccess", "{0}Given {1} {2} to {3}.");
	Language_Add(self, "en", "Server_CommandResetInventorySuccess", "{0}{1}reset inventory of {2}.");
	Language_Add(self, "en", "Server_CommandResetInventoryOfflineSuccess", "{0}{1}reset inventory of {2} (offline).");
	Language_Add(self, "en", "Server_CommandMonstersToggle", "{0} turned monsters {1}.");
	Language_Add(self, "en", "Server_CommandAreaAddIdInUse", "{0}Area ID already in use.");
	Language_Add(self, "en", "Server_CommandAreaAddSuccess", "{0}New area added: {1}");
	Language_Add(self, "en", "Server_CommandAreaDeleteNonexistant", "{0}Area does not exist.");
	Language_Add(self, "en", "Server_CommandAreaDeleteSuccess", "{0}Area deleted.");
	Language_Add(self, "en", "Server_CommandAnnouncementMessage", "{0}Announcement: {1}");
	Language_Add(self, "en", "Server_CommandSetSpawnInvalidCoordinates", "{0}Invalid spawn coordinates.");
	Language_Add(self, "en", "Server_CommandSetSpawnDefaultSuccess", "{0}Default spawn position set to {1},{2},{3}.");
	Language_Add(self, "en", "Server_CommandSetSpawnGroupSuccess", "{0}Spawn position of group {1} set to {2},{3},{4}.");
	Language_Add(self, "en", "Server_CommandSetSpawnPlayerSuccess", "{0}Spawn position of player {1} set to {2},{3},{4}.");
	Language_Add(self, "en", "Server_CommandPrivilegeAddHasAlready", "{0}Player {1} already has privilege {2}.");
	Language_Add(self, "en", "Server_CommandPrivilegeAddSuccess", "{0}New privilege for {1}: {2}");
	Language_Add(self, "en", "Server_CommandPrivilegeRemoveNoPriv", "{0}Player {1} doesn't have privilege {2}.");
	Language_Add(self, "en", "Server_CommandPrivilegeRemoveSuccess", "{0} {1} lost privilege: {2}");
	Language_Add(self, "en", "Server_CommandRestartSuccess", "{0}{1} restarted server.");
	Language_Add(self, "en", "Server_CommandShutdownSuccess", "{0}{1} shut down the server.");
	Language_Add(self, "en", "Server_CommandRestartModsSuccess", "{0}{1} restarted mods.");
	Language_Add(self, "en", "Server_CommandTeleportInvalidCoordinates", "{0}Invalid coordinates.");
	Language_Add(self, "en", "Server_CommandTeleportSuccess", "{0}New Position ({1},{2},{3}).");
	Language_Add(self, "en", "Server_CommandTeleportTargetMessage", "{0}You have been teleported to ({1},{2},{3}) by {4}.");
	Language_Add(self, "en", "Server_CommandTeleportSourceMessage", "{0}You teleported {1} to ({2},{3},{4}).");
	Language_Add(self, "en", "Server_CommandFillLimitDefaultSuccess", "{0}Default fill area limit set to {1}.");
	Language_Add(self, "en", "Server_CommandFillLimitGroupSuccess", "{0}Fill area limit of group {1} set to {2}.");
	Language_Add(self, "en", "Server_CommandFillLimitPlayerSuccess", "{0}Fill area limit of player {1} set to {2}.");
	Language_Add(self, "en", "Server_CommandInvalidType", "Invalid type.");
}

TranslatedString const *const *Language_AllStrings(Language const *self)
{
	return self->strings;
}

const char *Language_AutoJumpOption(Language const *self)
{
	return Language_Get(self, "AutoJumpOption");
}

const char *Language_CannotWriteChatLog(Language const *self)
{
	return Language_Get(self, "CannotWriteChatLog");
}

const char *Language_ChunkUpdates(Language const *self)
{
	return Language_Get(self, "ChunkUpdates");
}

const char *Language_ClientLanguageOption(Language const *self)
{
	return Language_Get(self, "ClientLanguageOption");
}

const char *Language_Connecting(Language const *self)
{
	return Language_Get(self, "Connecting");
}

const char *Language_ConnectingProgressKilobytes(Language const *self)
{
	return Language_Get(self, "ConnectingProgressKilobytes");
}

const char *Language_ConnectingProgressPercent(Language const *self)
{
	return Language_Get(self, "ConnectingProgressPercent");
}

static cibool Language_ContainsTranslation(Language const *self, const char *language, const char *id)
{
	{
		int i;
		for (i = 0; i < self->stringsCount; i++) {
			if (self->strings[i] == NULL) {
				continue;
			}
			if (strcmp(self->strings[i]->language, language) == 0) {
				if (strcmp(self->strings[i]->id, id) == 0) {
					return TRUE;
				}
			}
		}
	}
	return FALSE;
}

const char *Language_DefaultKeys(Language const *self)
{
	return Language_Get(self, "DefaultKeys");
}

const char *Language_Exit(Language const *self)
{
	return Language_Get(self, "Exit");
}

const char *Language_FogDistance(Language const *self)
{
	return Language_Get(self, "FogDistance");
}

const char *Language_FontOption(Language const *self)
{
	return Language_Get(self, "FontOption");
}

const char *Language_FrameRateLagSimulation(Language const *self)
{
	return Language_Get(self, "FrameRateLagSimulation");
}

const char *Language_FrameRateUnlimited(Language const *self)
{
	return Language_Get(self, "FrameRateUnlimited");
}

const char *Language_FrameRateVsync(Language const *self)
{
	return Language_Get(self, "FrameRateVsync");
}

const char *Language_FreemoveNotAllowed(Language const *self)
{
	return Language_Get(self, "FreemoveNotAllowed");
}

const char *Language_GameName(Language const *self)
{
	return Language_Get(self, "GameName");
}

const char *Language_Get(Language const *self, const char *id)
{
	const char *currentLanguage = "en";
	if (self->overrideLanguage != NULL) {
		currentLanguage = self->overrideLanguage;
	}
	else if (self->platform != NULL) {
		currentLanguage = self->platform->vtbl->getLanguageIso6391(self->platform);
	}
	{
		int i;
		for (i = 0; i < self->stringsCount; i++) {
			if (self->strings[i] == NULL) {
				continue;
			}
			if (strcmp(self->strings[i]->id, id) == 0 && strcmp(self->strings[i]->language, currentLanguage) == 0) {
				return self->strings[i]->translated;
			}
		}
	}
	{
		int i;
		for (i = 0; i < self->stringsCount; i++) {
			if (self->strings[i] == NULL) {
				continue;
			}
			if (strcmp(self->strings[i]->id, id) == 0 && strcmp(self->strings[i]->language, "en") == 0) {
				return self->strings[i]->translated;
			}
		}
	}
	return id;
}

const char *Language_GetUsedLanguage(Language const *self)
{
	const char *currentLanguage = "en";
	if (self->overrideLanguage != NULL) {
		currentLanguage = self->overrideLanguage;
	}
	else if (self->platform != NULL) {
		currentLanguage = self->platform->vtbl->getLanguageIso6391(self->platform);
	}
	return currentLanguage;
}

const char *Language_Graphics(Language const *self)
{
	return Language_Get(self, "Graphics");
}

const char *Language_InvalidVersionConnectAnyway(Language const *self)
{
	return Language_Get(self, "InvalidVersionConnectAnyway");
}

cibool Language_IsNewLanguage(Language const *self, const char *language)
{
	{
		int i;
		for (i = 0; i < self->loadedLanguagesMax; i++) {
			if (self->loadedLanguages[i] == NULL) {
				continue;
			}
			if (strcmp(self->loadedLanguages[i], language) == 0) {
				return FALSE;
			}
		}
	}
	return TRUE;
}

const char *Language_KeyBlockInfo(Language const *self)
{
	return Language_Get(self, "KeyBlockInfo");
}

const char *Language_KeyChange(Language const *self)
{
	return Language_Get(self, "KeyChange");
}

const char *Language_KeyChat(Language const *self)
{
	return Language_Get(self, "KeyChat");
}

const char *Language_KeyCraft(Language const *self)
{
	return Language_Get(self, "KeyCraft");
}

const char *Language_KeyFreeMove(Language const *self)
{
	return Language_Get(self, "KeyFreeMove");
}

const char *Language_KeyFullscreen(Language const *self)
{
	return Language_Get(self, "KeyFullscreen");
}

const char *Language_KeyJump(Language const *self)
{
	return Language_Get(self, "KeyJump");
}

const char *Language_KeyMoveBack(Language const *self)
{
	return Language_Get(self, "KeyMoveBack");
}

const char *Language_KeyMoveFoward(Language const *self)
{
	return Language_Get(self, "KeyMoveFoward");
}

const char *Language_KeyMoveLeft(Language const *self)
{
	return Language_Get(self, "KeyMoveLeft");
}

const char *Language_KeyMoveRight(Language const *self)
{
	return Language_Get(self, "KeyMoveRight");
}

const char *Language_KeyMoveSpeed(Language const *self)
{
	return Language_Get(self, "KeyMoveSpeed");
}

const char *Language_KeyPlayersList(Language const *self)
{
	return Language_Get(self, "KeyPlayersList");
}

const char *Language_KeyReloadWeapon(Language const *self)
{
	return Language_Get(self, "KeyReloadWeapon");
}

const char *Language_KeyRespawn(Language const *self)
{
	return Language_Get(self, "KeyRespawn");
}

const char *Language_KeyReverseMinecart(Language const *self)
{
	return Language_Get(self, "KeyReverseMinecart");
}

const char *Language_KeyScreenshot(Language const *self)
{
	return Language_Get(self, "KeyScreenshot");
}

const char *Language_KeySetSpawnPosition(Language const *self)
{
	return Language_Get(self, "KeySetSpawnPosition");
}

const char *Language_KeyShowMaterialSelector(Language const *self)
{
	return Language_Get(self, "KeyShowMaterialSelector");
}

const char *Language_KeyTeamChat(Language const *self)
{
	return Language_Get(self, "KeyTeamChat");
}

const char *Language_KeyTextEditor(Language const *self)
{
	return Language_Get(self, "KeyTextEditor");
}

const char *Language_KeyThirdPersonCamera(Language const *self)
{
	return Language_Get(self, "KeyThirdPersonCamera");
}

const char *Language_KeyToggleFogDistance(Language const *self)
{
	return Language_Get(self, "KeyToggleFogDistance");
}

const char *Language_KeyUse(Language const *self)
{
	return Language_Get(self, "KeyUse");
}

const char *Language_Keys(Language const *self)
{
	return Language_Get(self, "Keys");
}

void Language_LoadTranslations(Language *self)
{
	IntRef const *fileCount = IntRef_Create(0);
	const char *const *fileList = self->platform->vtbl->directoryGetFiles(self->platform, self->platform->vtbl->pathCombine(self->platform, "data", "localization"), fileCount);
	{
		int i;
		for (i = 0; i < fileCount->value; i++) {
			IntRef const *lineCount = IntRef_Create(0);
			const char *const *lineList = self->platform->vtbl->fileReadAllLines(self->platform, fileList[i], lineCount);
			{
				int j;
				for (j = 1; j < lineCount->value; j++) {
					IntRef const *splitCount;
					const char *const *splitList;
					if (self->platform->vtbl->stringEmpty(self->platform, lineList[j])) {
						continue;
					}
					splitCount = IntRef_Create(0);
					splitList = self->platform->vtbl->stringSplit(self->platform, lineList[j], "=", splitCount);
					if (splitCount->value >= 2) {
						Language_Add(self, lineList[0], splitList[0], splitList[1]);
					}
				}
			}
		}
	}
	Language_AddEnglish(self);
}

const char *Language_MoveFree(Language const *self)
{
	return Language_Get(self, "MoveFree");
}

const char *Language_MoveFreeNoclip(Language const *self)
{
	return Language_Get(self, "MoveFreeNoclip");
}

const char *Language_MoveNormal(Language const *self)
{
	return Language_Get(self, "MoveNormal");
}

const char *Language_MoveSpeed(Language const *self)
{
	return Language_Get(self, "MoveSpeed");
}

void Language_NextLanguage(Language *self)
{
	int languageIndex;
	if (self->overrideLanguage == NULL) {
		self->overrideLanguage = "en";
	}
	languageIndex = -1;
	{
		int i;
		for (i = 0; i < self->loadedLanguagesMax; i++) {
			if (self->loadedLanguages[i] == NULL) {
				continue;
			}
			if (strcmp(self->loadedLanguages[i], self->overrideLanguage) == 0) {
				languageIndex = i;
			}
		}
	}
	if (languageIndex < 0) {
		languageIndex = 0;
	}
	languageIndex++;
	if (languageIndex >= self->loadedLanguagesMax || languageIndex >= self->loadedLanguagesCount) {
		languageIndex = 0;
	}
	self->overrideLanguage = self->loadedLanguages[languageIndex];
}

const char *Language_NoMaterialsForCrafting(Language const *self)
{
	return Language_Get(self, "NoMaterialsForCrafting");
}

const char *Language_Off(Language const *self)
{
	return Language_Get(self, "Off");
}

const char *Language_On(Language const *self)
{
	return Language_Get(self, "On");
}

const char *Language_OptionFramerate(Language const *self)
{
	return Language_Get(self, "OptionFramerate");
}

const char *Language_OptionFullscreen(Language const *self)
{
	return Language_Get(self, "OptionFullscreen");
}

const char *Language_OptionResolution(Language const *self)
{
	return Language_Get(self, "OptionResolution");
}

const char *Language_OptionSmoothShadows(Language const *self)
{
	return Language_Get(self, "OptionSmoothShadows");
}

const char *Language_Options(Language const *self)
{
	return Language_Get(self, "Options");
}

const char *Language_Other(Language const *self)
{
	return Language_Get(self, "Other");
}

void Language_Override(Language *self, const char *language, const char *id, const char *translated)
{
	if (Language_IsNewLanguage(self, language)) {
		if (self->loadedLanguagesCount < self->loadedLanguagesMax) {
			self->loadedLanguages[self->loadedLanguagesCount] = language;
			self->loadedLanguagesCount++;
		}
	}
	if (!Language_ContainsTranslation(self, language, id)) {
		Language_Add(self, language, id, translated);
	}
	else {
		int replaceIndex = -1;
		{
			int i;
			for (i = 0; i < self->stringsCount; i++) {
				if (self->strings[i] == NULL) {
					continue;
				}
				if (strcmp(self->strings[i]->language, language) == 0) {
					if (strcmp(self->strings[i]->id, id) == 0) {
						replaceIndex = i;
						break;
					}
				}
			}
		}
		if (replaceIndex != -1) {
			TranslatedString *s = TranslatedString_New();
			s->language = language;
			s->id = id;
			s->translated = translated;
			self->strings[replaceIndex] = s;
		}
	}
}

const char *Language_PressToUse(Language const *self)
{
	return Language_Get(self, "PressToUse");
}

const char *Language_Respawn(Language const *self)
{
	return Language_Get(self, "Respawn");
}

const char *Language_ReturnToGame(Language const *self)
{
	return Language_Get(self, "ReturnToGame");
}

const char *Language_ReturnToMainMenu(Language const *self)
{
	return Language_Get(self, "ReturnToMainMenu");
}

const char *Language_ReturnToOptionsMenu(Language const *self)
{
	return Language_Get(self, "ReturnToOptionsMenu");
}

const char *Language_ServerBanlistCorrupt(Language const *self)
{
	return Language_Get(self, "Server_BanlistCorrupt");
}

const char *Language_ServerBanlistCorruptNoBackup(Language const *self)
{
	return Language_Get(self, "Server_BanlistCorruptNoBackup");
}

const char *Language_ServerBanlistLoaded(Language const *self)
{
	return Language_Get(self, "Server_BanlistLoaded");
}

const char *Language_ServerBanlistNotFound(Language const *self)
{
	return Language_Get(self, "Server_BanlistNotFound");
}

const char *Language_ServerCannotWriteLog(Language const *self)
{
	return Language_Get(self, "Server_CannotWriteLogFile");
}

const char *Language_ServerClientConfigGuestGroupNotFound(Language const *self)
{
	return Language_Get(self, "Server_ClientConfigGuestGroupNotFound");
}

const char *Language_ServerClientConfigLoaded(Language const *self)
{
	return Language_Get(self, "Server_ClientConfigLoaded");
}

const char *Language_ServerClientConfigNotFound(Language const *self)
{
	return Language_Get(self, "Server_ClientConfigNotFound");
}

const char *Language_ServerClientConfigRegisteredGroupNotFound(Language const *self)
{
	return Language_Get(self, "Server_ClientConfigRegisteredGroupNotFound");
}

const char *Language_ServerClientException(Language const *self)
{
	return Language_Get(self, "Server_ClientException");
}

const char *Language_ServerConfigCorruptBackup(Language const *self)
{
	return Language_Get(self, "Server_ConfigCorruptBackup");
}

const char *Language_ServerConfigCorruptNoBackup(Language const *self)
{
	return Language_Get(self, "Server_ConfigCorruptNoBackup");
}

const char *Language_ServerConfigLoaded(Language const *self)
{
	return Language_Get(self, "Server_ConfigLoaded");
}

const char *Language_ServerConfigNotFound(Language const *self)
{
	return Language_Get(self, "Server_ConfigNotFound");
}

const char *Language_ServerCreatingSavegame(Language const *self)
{
	return Language_Get(self, "Server_CreatingSavegame");
}

const char *Language_ServerFillAreaInvalid(Language const *self)
{
	return Language_Get(self, "Server_FillAreaInvalid");
}

const char *Language_ServerFillAreaTooLarge(Language const *self)
{
	return Language_Get(self, "Server_FillAreaTooLarge");
}

const char *Language_ServerGameSaved(Language const *self)
{
	return Language_Get(self, "Server_GameSaved");
}

const char *Language_ServerHTTPServerError(Language const *self)
{
	return Language_Get(self, "Server_HTTPServerError");
}

const char *Language_ServerHTTPServerStarted(Language const *self)
{
	return Language_Get(self, "Server_HTTPServerStarted");
}

const char *Language_ServerHeartbeatError(Language const *self)
{
	return Language_Get(self, "Server_HeartbeatError");
}

const char *Language_ServerHeartbeatSent(Language const *self)
{
	return Language_Get(self, "Server_HeartbeatSent");
}

const char *Language_ServerIPBanned(Language const *self)
{
	return Language_Get(self, "Server_IPBanned");
}

const char *Language_ServerInvalidBackupName(Language const *self)
{
	return Language_Get(self, "Server_InvalidBackupName");
}

const char *Language_ServerInvalidSpawnCoordinates(Language const *self)
{
	return Language_Get(self, "Server_InvalidSpawnCoordinates");
}

const char *Language_ServerLoadedSavegame(Language const *self)
{
	return Language_Get(self, "Server_LoadedSavegame");
}

const char *Language_ServerLoadingSavegame(Language const *self)
{
	return Language_Get(self, "Server_LoadingSavegame");
}

const char *Language_ServerMonitorBuildingDisabled(Language const *self)
{
	return Language_Get(self, "Server_MonitorBuildingDisabled");
}

const char *Language_ServerMonitorChatMuted(Language const *self)
{
	return Language_Get(self, "Server_MonitorChatMuted");
}

const char *Language_ServerMonitorChatNotSent(Language const *self)
{
	return Language_Get(self, "Server_MonitorChatNotSent");
}

const char *Language_ServerMonitorConfigLoaded(Language const *self)
{
	return Language_Get(self, "Server_MonitorConfigLoaded");
}

const char *Language_ServerMonitorConfigNotFound(Language const *self)
{
	return Language_Get(self, "Server_MonitorConfigNotFound");
}

const char *Language_ServerNoBuildPermissionHere(Language const *self)
{
	return Language_Get(self, "Server_NoBuildPermissionHere");
}

const char *Language_ServerNoBuildPrivilege(Language const *self)
{
	return Language_Get(self, "Server_NoBuildPrivilege");
}

const char *Language_ServerNoChatPrivilege(Language const *self)
{
	return Language_Get(self, "Server_NoChatPrivilege");
}

const char *Language_ServerNoGuests(Language const *self)
{
	return Language_Get(self, "Server_NoGuests");
}

const char *Language_ServerNoSpectatorBuild(Language const *self)
{
	return Language_Get(self, "Server_NoSpectatorBuild");
}

const char *Language_ServerNoSpectatorUse(Language const *self)
{
	return Language_Get(self, "Server_NoSpectatorUse");
}

const char *Language_ServerNoUsePrivilege(Language const *self)
{
	return Language_Get(self, "Server_NoUsePrivilege");
}

const char *Language_ServerPasswordInvalid(Language const *self)
{
	return Language_Get(self, "Server_PasswordInvalid");
}

const char *Language_ServerPlayerDisconnect(Language const *self)
{
	return Language_Get(self, "Server_PlayerDisconnect");
}

const char *Language_ServerPlayerJoin(Language const *self)
{
	return Language_Get(self, "Server_PlayerJoin");
}

const char *Language_ServerProgressDownloadingData(Language const *self)
{
	return Language_Get(self, "Server_ProgressDownloadingData");
}

const char *Language_ServerProgressDownloadingMap(Language const *self)
{
	return Language_Get(self, "Server_ProgressDownloadingMap");
}

const char *Language_ServerProgressGenerating(Language const *self)
{
	return Language_Get(self, "Server_ProgressGenerating");
}

const char *Language_ServerSetupAccept(Language const *self)
{
	return Language_Get(self, "Server_SetupAccept");
}

const char *Language_ServerSetupEnableHTTP(Language const *self)
{
	return Language_Get(self, "Server_SetupEnableHTTP");
}

const char *Language_ServerSetupFirstStart(Language const *self)
{
	return Language_Get(self, "Server_SetupFirstStart");
}

const char *Language_ServerSetupMOTD(Language const *self)
{
	return Language_Get(self, "Server_SetupMOTD");
}

const char *Language_ServerSetupMaxClients(Language const *self)
{
	return Language_Get(self, "Server_SetupMaxClients");
}

const char *Language_ServerSetupMaxClientsInvalidInput(Language const *self)
{
	return Language_Get(self, "Server_SetupMaxClientsInvalidInput");
}

const char *Language_ServerSetupMaxClientsInvalidValue(Language const *self)
{
	return Language_Get(self, "Server_SetupMaxClientsInvalidValue");
}

const char *Language_ServerSetupName(Language const *self)
{
	return Language_Get(self, "Server_SetupName");
}

const char *Language_ServerSetupPort(Language const *self)
{
	return Language_Get(self, "Server_SetupPort");
}

const char *Language_ServerSetupPortInvalidInput(Language const *self)
{
	return Language_Get(self, "Server_SetupPortInvalidInput");
}

const char *Language_ServerSetupPortInvalidValue(Language const *self)
{
	return Language_Get(self, "Server_SetupPortInvalidValue");
}

const char *Language_ServerSetupPublic(Language const *self)
{
	return Language_Get(self, "Server_SetupPublic");
}

const char *Language_ServerSetupQuestion(Language const *self)
{
	return Language_Get(self, "Server_SetupQuestion");
}

const char *Language_ServerSetupWelcomeMessage(Language const *self)
{
	return Language_Get(self, "Server_SetupWelcomeMessage");
}

const char *Language_ServerTooManyPlayers(Language const *self)
{
	return Language_Get(self, "Server_TooManyPlayers");
}

const char *Language_ServerUsernameBanned(Language const *self)
{
	return Language_Get(self, "Server_UsernameBanned");
}

const char *Language_ServerUsernameInvalid(Language const *self)
{
	return Language_Get(self, "Server_UsernameInvalid");
}

const char *Language_ShadowsOption(Language const *self)
{
	return Language_Get(self, "ShadowsOption");
}

const char *Language_SoundOption(Language const *self)
{
	return Language_Get(self, "SoundOption");
}

const char *Language_SpawnPositionSet(Language const *self)
{
	return Language_Get(self, "SpawnPositionSet");
}

const char *Language_SpawnPositionSetTo(Language const *self)
{
	return Language_Get(self, "SpawnPositionSetTo");
}

const char *Language_Triangles(Language const *self)
{
	return Language_Get(self, "Triangles");
}

const char *Language_UseServerTexturesOption(Language const *self)
{
	return Language_Get(self, "UseServerTexturesOption");
}

const char *Language_ViewDistanceOption(Language const *self)
{
	return Language_Get(self, "ViewDistanceOption");
}

static void LightBase_Construct(LightBase *self)
{
	self->flood = LightFlood_New();
	self->workData = (int *) malloc(4096 * sizeof(int ));
}

LightBase *LightBase_New(void)
{
	LightBase *self = (LightBase *) malloc(sizeof(LightBase));
	if (self != NULL)
		LightBase_Construct(self);
	return self;
}

void LightBase_Delete(LightBase *self)
{
	free(self);
}

void LightBase_CalculateChunkBaseLight(LightBase const *self, Game const *game, int cx, int cy, int cz, int const *dataLightRadius, cibool const *transparentForLight)
{
	Chunk const *chunk = Map_GetChunk_(game->map, cx, cy, cz);
	int sunlight;
	unsigned char *workLight;
	if (chunk->data != NULL) {
		{
			int i;
			for (i = 0; i < 4096; i++) {
				self->workData[i] = chunk->data[i];
			}
		}
	}
	if (chunk->dataInt != NULL) {
		{
			int i;
			for (i = 0; i < 4096; i++) {
				self->workData[i] = chunk->dataInt[i];
			}
		}
	}
	sunlight = game->sunlight_;
	workLight = chunk->baseLight;
	{
		int i;
		for (i = 0; i < 4096; i++) {
			workLight[i] = 0;
		}
	}
	LightBase_Sunlight(game, cx, cy, cz, workLight, dataLightRadius, sunlight);
	LightBase_SunlightFlood(self, self->workData, workLight, dataLightRadius, transparentForLight);
	LightBase_LightEmitting(self, self->workData, workLight, dataLightRadius, transparentForLight);
}

static int LightBase_GetLightHeight(Game const *game, int cx, int cy, int xx, int yy)
{
	int const *chunk = game->d_Heightmap->chunks[MapUtilCi_Index2d(cx, cy, game->map->mapSizeX / 16)];
	if (chunk == NULL) {
		return 0;
	}
	return chunk[MapUtilCi_Index2d(xx % 16, yy % 16, 16)];
}

static void LightBase_LightEmitting(LightBase const *self, int const *workportion, unsigned char *worklight, int const *dataLightRadius, cibool const *dataTransparent)
{
	{
		int pos;
		for (pos = 0; pos < 4096; pos++) {
			if (workportion[pos] >= 10) {
				if (dataLightRadius[workportion[pos]] != 0) {
					if (dataLightRadius[workportion[pos]] > worklight[pos]) {
						int xx = MapUtilCi_PosX(pos, 16, 16);
						int yy = MapUtilCi_PosY(pos, 16, 16);
						int zz = MapUtilCi_PosZ(pos, 16, 16);
						int l = dataLightRadius[workportion[pos]];
						worklight[pos] = Game_IntToByte(MathCi_MaxInt(l, worklight[pos]));
						LightFlood_FloodLight(self->flood, workportion, worklight, xx, yy, zz, dataLightRadius, dataTransparent);
					}
				}
			}
		}
	}
}

static void LightBase_Sunlight(Game const *game, int cx, int cy, int cz, unsigned char *worklight, int const *dataLightRadius, int sunlight)
{
	int baseheight = cz * 16;
	{
		int xx;
		for (xx = 0; xx < 16; xx++) {
			{
				int yy;
				for (yy = 0; yy < 16; yy++) {
					int height = LightBase_GetLightHeight(game, cx, cy, xx, yy);
					int h = height - baseheight;
					int pos;
					if (h < 0) {
						h = 0;
					}
					if (h > 16) {
						continue;
					}
					pos = (h * 16 + yy) * 16 + xx;
					{
						int zz;
						for (zz = h; zz < 16; zz++) {
							worklight[pos] = Game_IntToByte(sunlight);
							pos += 256;
						}
					}
				}
			}
		}
	}
}

static void LightBase_SunlightFlood(LightBase const *self, int const *workportion, unsigned char *worklight, int const *dataLightRadius, cibool const *dataTransparent)
{
	{
		int xx;
		for (xx = 0; xx < 16; xx++) {
			{
				int yy;
				for (yy = 0; yy < 16; yy++) {
					{
						int zz;
						for (zz = 0; zz < 16; zz++) {
							int pos = (zz * 16 + yy) * 16 + xx;
							int curlight;
							int posXPlus1;
							int posYPlus1;
							if (!dataTransparent[workportion[pos]]) {
								continue;
							}
							curlight = worklight[pos];
							posXPlus1 = pos + 1;
							posYPlus1 = pos + 16;
							if (xx + 1 < 16 && worklight[posXPlus1] != curlight && dataTransparent[workportion[posXPlus1]]) {
								LightFlood_FloodLight(self->flood, workportion, worklight, xx, yy, zz, dataLightRadius, dataTransparent);
								LightFlood_FloodLight(self->flood, workportion, worklight, xx + 1, yy, zz, dataLightRadius, dataTransparent);
							}
							if (yy + 1 < 16 && worklight[posYPlus1] != curlight && dataTransparent[workportion[posYPlus1]]) {
								LightFlood_FloodLight(self->flood, workportion, worklight, xx, yy, zz, dataLightRadius, dataTransparent);
								LightFlood_FloodLight(self->flood, workportion, worklight, xx, yy + 1, zz, dataLightRadius, dataTransparent);
							}
						}
					}
				}
			}
		}
	}
}

static void LightBetweenChunks_Construct(LightBetweenChunks *self)
{
	self->chunksLight = (unsigned char const **) malloc(27 * sizeof(unsigned char const *));
	{
		int i;
		for (i = 0; i < 27; i++) {
			self->chunksLight[i] = (unsigned char *) malloc(4096 * sizeof(unsigned char ));
		}
	}
	self->chunksData = (int const **) malloc(27 * sizeof(int const *));
	{
		int i;
		for (i = 0; i < 27; i++) {
			self->chunksData[i] = (int *) malloc(4096 * sizeof(int ));
		}
	}
	self->flood = LightFlood_New();
}

LightBetweenChunks *LightBetweenChunks_New(void)
{
	LightBetweenChunks *self = (LightBetweenChunks *) malloc(sizeof(LightBetweenChunks));
	if (self != NULL)
		LightBetweenChunks_Construct(self);
	return self;
}

void LightBetweenChunks_Delete(LightBetweenChunks *self)
{
	free(self);
}

static void LightBetweenChunks_ArrayFillByte(LightBetweenChunks const *self, unsigned char *arr, int n, unsigned char value)
{
	{
		int i;
		for (i = 0; i < n; i++) {
			arr[i] = value;
		}
	}
}

static void LightBetweenChunks_ArrayFillInt(LightBetweenChunks const *self, int *arr, int n, int value)
{
	{
		int i;
		for (i = 0; i < n; i++) {
			arr[i] = value;
		}
	}
}

void LightBetweenChunks_CalculateLightBetweenChunks(LightBetweenChunks const *self, Game const *game, int cx, int cy, int cz, int const *dataLightRadius, cibool const *dataTransparent)
{
	LightBetweenChunks_Input(self, game, cx, cy, cz);
	LightBetweenChunks_FloodBetweenChunks_(self, dataLightRadius, dataTransparent);
	LightBetweenChunks_Output(self, game, cx, cy, cz);
}

static void LightBetweenChunks_FloodBetweenChunks(LightBetweenChunks const *self, unsigned char const *const *chunksLight_, unsigned char const *cLight, unsigned char *dcLight, int cx, int cy, int cz, int dcx, int dcy, int dcz, int xx, int yy, int zz, int dxx, int dyy, int dzz, int const *dataLightRadius, cibool const *dataTransparent)
{
	int sourceLight = cLight[(zz * 16 + yy) * 16 + xx];
	int targetLight = dcLight[(dzz * 16 + dyy) * 16 + dxx];
	if (targetLight < sourceLight - 1) {
		dcLight[(dzz * 16 + dyy) * 16 + dxx] = Game_IntToByte(sourceLight - 1);
		LightFlood_FloodLight(self->flood, self->chunksData[(dcz * 3 + dcy) * 3 + dcx], dcLight, dxx, dyy, dzz, dataLightRadius, dataTransparent);
	}
}

static void LightBetweenChunks_FloodBetweenChunks_(LightBetweenChunks const *self, int const *dataLightRadius, cibool const *dataTransparent)
{
	{
		int i;
		for (i = 0; i < 2; i++) {
			{
				int x;
				for (x = 0; x < 3; x++) {
					{
						int y;
						for (y = 0; y < 3; y++) {
							{
								int z;
								for (z = 0; z < 3; z++) {
									unsigned char const *clight = self->chunksLight[(z * 3 + y) * 3 + x];
									if (z < 2) {
										unsigned char *dclight = self->chunksLight[((z + 1) * 3 + y) * 3 + x];
										{
											int xx;
											for (xx = 0; xx < 16; xx++) {
												{
													int yy;
													for (yy = 0; yy < 16; yy++) {
														LightBetweenChunks_FloodBetweenChunks(self, self->chunksLight, clight, dclight, x, y, z, x, y, z + 1, xx, yy, 15, xx, yy, 0, dataLightRadius, dataTransparent);
													}
												}
											}
										}
									}
									if (z > 0) {
										unsigned char *dclight = self->chunksLight[((z - 1) * 3 + y) * 3 + x];
										{
											int xx;
											for (xx = 0; xx < 16; xx++) {
												{
													int yy;
													for (yy = 0; yy < 16; yy++) {
														LightBetweenChunks_FloodBetweenChunks(self, self->chunksLight, clight, dclight, x, y, z, x, y, z - 1, xx, yy, 0, xx, yy, 15, dataLightRadius, dataTransparent);
													}
												}
											}
										}
									}
									if (x < 2) {
										unsigned char *dclight = self->chunksLight[(z * 3 + y) * 3 + x + 1];
										{
											int yy;
											for (yy = 0; yy < 16; yy++) {
												{
													int zz;
													for (zz = 0; zz < 16; zz++) {
														LightBetweenChunks_FloodBetweenChunks(self, self->chunksLight, clight, dclight, x, y, z, x + 1, y, z, 15, yy, zz, 0, yy, zz, dataLightRadius, dataTransparent);
													}
												}
											}
										}
									}
									if (x > 0) {
										unsigned char *dclight = self->chunksLight[(z * 3 + y) * 3 + x - 1];
										{
											int yy;
											for (yy = 0; yy < 16; yy++) {
												{
													int zz;
													for (zz = 0; zz < 16; zz++) {
														LightBetweenChunks_FloodBetweenChunks(self, self->chunksLight, clight, dclight, x, y, z, x - 1, y, z, 0, yy, zz, 15, yy, zz, dataLightRadius, dataTransparent);
													}
												}
											}
										}
									}
									if (y < 2) {
										unsigned char *dclight = self->chunksLight[(z * 3 + y + 1) * 3 + x];
										{
											int xx;
											for (xx = 0; xx < 16; xx++) {
												{
													int zz;
													for (zz = 0; zz < 16; zz++) {
														LightBetweenChunks_FloodBetweenChunks(self, self->chunksLight, clight, dclight, x, y, z, x, y + 1, z, xx, 15, zz, xx, 0, zz, dataLightRadius, dataTransparent);
													}
												}
											}
										}
									}
									if (y > 0) {
										unsigned char *dclight = self->chunksLight[(z * 3 + y - 1) * 3 + x];
										{
											int xx;
											for (xx = 0; xx < 16; xx++) {
												{
													int zz;
													for (zz = 0; zz < 16; zz++) {
														LightBetweenChunks_FloodBetweenChunks(self, self->chunksLight, clight, dclight, x, y, z, x, y - 1, z, xx, 0, zz, xx, 15, zz, dataLightRadius, dataTransparent);
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

static void LightBetweenChunks_Input(LightBetweenChunks const *self, Game const *game, int cx, int cy, int cz)
{
	{
		int x;
		for (x = 0; x < 3; x++) {
			{
				int y;
				for (y = 0; y < 3; y++) {
					{
						int z;
						for (z = 0; z < 3; z++) {
							int pcx = cx + x - 1;
							int pcy = cy + y - 1;
							int pcz = cz + z - 1;
							Chunk const *p;
							int *data;
							unsigned char *light;
							if (!Map_IsValidChunkPos(game->map, pcx, pcy, pcz)) {
								LightBetweenChunks_ArrayFillInt(self, self->chunksData[(z * 3 + y) * 3 + x], 4096, 0);
								LightBetweenChunks_ArrayFillByte(self, self->chunksLight[(z * 3 + y) * 3 + x], 4096, 0);
								continue;
							}
							p = Map_GetChunk_(game->map, pcx, pcy, pcz);
							data = self->chunksData[(z * 3 + y) * 3 + x];
							if (p->data != NULL) {
								{
									int i;
									for (i = 0; i < 4096; i++) {
										data[i] = p->data[i];
									}
								}
							}
							if (p->dataInt != NULL) {
								{
									int i;
									for (i = 0; i < 4096; i++) {
										data[i] = p->dataInt[i];
									}
								}
							}
							light = self->chunksLight[(z * 3 + y) * 3 + x];
							{
								int i;
								for (i = 0; i < 4096; i++) {
									light[i] = p->baseLight[i];
								}
							}
						}
					}
				}
			}
		}
	}
}

static void LightBetweenChunks_Output(LightBetweenChunks const *self, Game const *game, int cx, int cy, int cz)
{
	Chunk const *chunk = Map_GetChunk_(game->map, cx, cy, cz);
	{
		int x;
		for (x = 0; x < 18; x++) {
			{
				int y;
				for (y = 0; y < 18; y++) {
					{
						int z;
						for (z = 0; z < 18; z++) {
							int baseglobalx = 15 + x;
							int baseglobaly = 15 + y;
							int baseglobalz = 15 + z;
							unsigned char light = 15;
							int basecx = baseglobalx / 16;
							int basecy = baseglobaly / 16;
							int basecz = baseglobalz / 16;
							{
								int basexx = baseglobalx % 16;
								int baseyy = baseglobaly % 16;
								int basezz = baseglobalz % 16;
								light = self->chunksLight[(basecz * 3 + basecy) * 3 + basecx][(basezz * 16 + baseyy) * 16 + basexx];
							}
							chunk->rendered->light[(z * 18 + y) * 18 + x] = light;
						}
					}
				}
			}
		}
	}
}

static void LightFlood_Construct(LightFlood *self)
{
	self->q = FastQueueInt_New();
	FastQueueInt_Initialize(self->q, 1024);
}

LightFlood *LightFlood_New(void)
{
	LightFlood *self = (LightFlood *) malloc(sizeof(LightFlood));
	if (self != NULL)
		LightFlood_Construct(self);
	return self;
}

void LightFlood_Delete(LightFlood *self)
{
	free(self);
}

void LightFlood_FloodLight(LightFlood const *self, int const *chunk, unsigned char *light, int startx, int starty, int startz, int const *dataLightRadius, cibool const *dataTransparent)
{
	int start = (startz * 16 + starty) * 16 + startx;
	if (light[start] == 0) {
		return;
	}
	FastQueueInt_Clear(self->q);
	FastQueueInt_Push(self->q, start);
	for (;;) {
		int vPos;
		int vLight;
		int vBlock;
		int x;
		int y;
		int z;
		if (self->q->count == 0) {
			break;
		}
		vPos = FastQueueInt_Pop(self->q);
		vLight = light[vPos];
		if (vLight == 0) {
			continue;
		}
		vBlock = chunk[vPos];
		if (!dataTransparent[vBlock] && dataLightRadius[vBlock] == 0) {
			continue;
		}
		x = MapUtilCi_PosX(vPos, 16, 16);
		y = MapUtilCi_PosY(vPos, 16, 16);
		z = MapUtilCi_PosZ(vPos, 16, 16);
		if (x < 15) {
			LightFlood_Push(self->q, light, vLight, vPos + 1);
		}
		if (x > 0) {
			LightFlood_Push(self->q, light, vLight, vPos + -1);
		}
		if (y < 15) {
			LightFlood_Push(self->q, light, vLight, vPos + 16);
		}
		if (y > 0) {
			LightFlood_Push(self->q, light, vLight, vPos + -16);
		}
		if (z < 15) {
			LightFlood_Push(self->q, light, vLight, vPos + 256);
		}
		if (z > 0) {
			LightFlood_Push(self->q, light, vLight, vPos + -256);
		}
	}
}

static void LightFlood_Push(FastQueueInt *q_, unsigned char *light, int vLight, int newPos)
{
	if (light[newPos] < vLight - 1) {
		light[newPos] = Game_IntToByte(vLight - 1);
		FastQueueInt_Push(q_, newPos);
	}
}

Line3D *Line3D_New(void)
{
	Line3D *self = (Line3D *) malloc(sizeof(Line3D));
	return self;
}

void Line3D_Delete(Line3D *self)
{
	free(self);
}

ListAction *ListAction_New(void)
{
	ListAction *self = (ListAction *) malloc(sizeof(ListAction));
	return self;
}

void ListAction_Delete(ListAction *self)
{
	free(self);
}

static void ListAction_Add(ListAction *self, Action_ const *action)
{
	self->items[self->count++] = action;
}

static void ListAction_Clear(ListAction *self)
{
	{
		int i;
		for (i = 0; i < self->count; i++) {
			self->items[i] = NULL;
		}
	}
	self->count = 0;
}

static int ListAction_Count(ListAction const *self)
{
	return self->count;
}

ListAction *ListAction_Create(int max_)
{
	ListAction *l = ListAction_New();
	ListAction_Start(l, max_);
	return l;
}

static void ListAction_RemoveAt(ListAction *self, int index)
{
	{
		int i;
		for (i = index; i < self->count - 1; i++) {
			self->items[i] = self->items[i + 1];
		}
	}
	self->count--;
}

void ListAction_Start(ListAction *self, int max_)
{
	self->max = max_;
	self->items = (Action_ const **) malloc(max_ * sizeof(Action_ const *));
	self->count = 0;
}

ListBox3d *ListBox3d_New(void)
{
	ListBox3d *self = (ListBox3d *) malloc(sizeof(ListBox3d));
	return self;
}

void ListBox3d_Delete(ListBox3d *self)
{
	free(self);
}

static void ListConnectedPlayer_Construct(ListConnectedPlayer *self)
{
	self->items = (ConnectedPlayer const **) malloc(1024 * sizeof(ConnectedPlayer const *));
	self->count = 0;
}

ListConnectedPlayer *ListConnectedPlayer_New(void)
{
	ListConnectedPlayer *self = (ListConnectedPlayer *) malloc(sizeof(ListConnectedPlayer));
	if (self != NULL)
		ListConnectedPlayer_Construct(self);
	return self;
}

void ListConnectedPlayer_Delete(ListConnectedPlayer *self)
{
	free(self);
}

static void ListConnectedPlayer_Add(ListConnectedPlayer *self, ConnectedPlayer const *connectedPlayer)
{
	self->items[self->count++] = connectedPlayer;
}

static void ListConnectedPlayer_RemoveAt(ListConnectedPlayer *self, int at)
{
	{
		int i;
		for (i = at; i < self->count - 1; i++) {
			self->items[i] = self->items[i + 1];
		}
	}
	self->count--;
}

static void ListInfo_Construct(ListInfo *self)
{
	self->render = TRUE;
}

ListInfo *ListInfo_New(void)
{
	ListInfo *self = (ListInfo *) malloc(sizeof(ListInfo));
	if (self != NULL)
		ListInfo_Construct(self);
	return self;
}

void ListInfo_Delete(ListInfo *self)
{
	free(self);
}

LoginClientCi *LoginClientCi_New(void)
{
	LoginClientCi *self = (LoginClientCi *) malloc(sizeof(LoginClientCi));
	return self;
}

void LoginClientCi_Delete(LoginClientCi *self)
{
	free(self);
}

void LoginClientCi_Login(LoginClientCi *self, GamePlatform const *platform, const char *user, const char *password, const char *publicServerKey, const char *token, LoginResultRef *result, LoginData *resultLoginData_)
{
	self->loginResult = result;
	self->resultLoginData = resultLoginData_;
	result->value = LoginResult_CONNECTING;
	self->loginUser = user;
	self->loginPassword = password;
	self->loginToken = token;
	self->loginPublicServerKey = publicServerKey;
	self->shouldLogin = TRUE;
}

void LoginClientCi_Update(LoginClientCi *self, GamePlatform const *platform)
{
	if (self->loginResult == NULL) {
		return;
	}
	if (self->loginUrlResponse == NULL && self->loginUrl == NULL) {
		self->loginUrlResponse = HttpResponseCi_New();
		platform->vtbl->webClientDownloadDataAsync(platform, "http://manicdigger.sourceforge.net/login.php", self->loginUrlResponse);
	}
	if (self->loginUrlResponse != NULL && self->loginUrlResponse->done) {
		self->loginUrl = platform->vtbl->stringFromUtf8ByteArray(platform, self->loginUrlResponse->value, self->loginUrlResponse->valueLength);
		self->loginUrlResponse = NULL;
	}
	if (self->loginUrl != NULL) {
		if (self->shouldLogin) {
			const char *requestString;
			IntRef const *byteArrayLength;
			unsigned char const *byteArray;
			self->shouldLogin = FALSE;
			requestString = platform->vtbl->stringFormat4(platform, "username={0}&password={1}&server={2}&token={3}", self->loginUser, self->loginPassword, self->loginPublicServerKey, self->loginToken);
			byteArrayLength = IntRef_New();
			byteArray = platform->vtbl->stringToUtf8ByteArray(platform, requestString, byteArrayLength);
			self->loginResponse = HttpResponseCi_New();
			platform->vtbl->webClientUploadDataAsync(platform, self->loginUrl, byteArray, byteArrayLength->value, self->loginResponse);
		}
		if (self->loginResponse != NULL && self->loginResponse->done) {
			const char *responseString = platform->vtbl->stringFromUtf8ByteArray(platform, self->loginResponse->value, self->loginResponse->valueLength);
			IntRef const *linesCount;
			const char *const *lines;
			self->resultLoginData->passwordCorrect = !(platform->vtbl->stringContains(platform, responseString, "Wrong username") || platform->vtbl->stringContains(platform, responseString, "Incorrect username"));
			self->resultLoginData->serverCorrect = !platform->vtbl->stringContains(platform, responseString, "server");
			if (self->resultLoginData->passwordCorrect) {
				self->loginResult->value = LoginResult_OK;
			}
			else {
				self->loginResult->value = LoginResult_FAILED;
			}
			linesCount = IntRef_New();
			lines = platform->vtbl->readAllLines(platform, responseString, linesCount);
			if (linesCount->value >= 3) {
				self->resultLoginData->authCode = lines[0];
				self->resultLoginData->serverAddress = lines[1];
				self->resultLoginData->port = platform->vtbl->intParse(platform, lines[2]);
				self->resultLoginData->token = lines[3];
			}
			self->loginResponse = NULL;
		}
	}
}

LoginData *LoginData_New(void)
{
	LoginData *self = (LoginData *) malloc(sizeof(LoginData));
	return self;
}

void LoginData_Delete(LoginData *self)
{
	free(self);
}

LoginResultRef *LoginResultRef_New(void)
{
	LoginResultRef *self = (LoginResultRef *) malloc(sizeof(LoginResultRef));
	return self;
}

void LoginResultRef_Delete(LoginResultRef *self)
{
	free(self);
}

static void MainMenu_Construct(MainMenu *self)
{
	self->one = 1;
	self->textures = DictionaryStringInt1024_New();
	self->textTextures = (TextTexture const **) malloc(256 * sizeof(TextTexture const *));
	self->textTexturesCount = 0;
	self->screen = &ScreenMain_New()->base;
	self->screen->menu = self;
	self->loginClient = LoginClientCi_New();
	self->assets = AssetList_New();
	self->assetsLoadProgress = FloatRef_New();
}

MainMenu *MainMenu_New(void)
{
	MainMenu *self = (MainMenu *) malloc(sizeof(MainMenu));
	if (self != NULL)
		MainMenu_Construct(self);
	return self;
}

void MainMenu_Delete(MainMenu *self)
{
	free(self);
}

static void MainMenu_Animate(MainMenu *self, float dt)
{
	float maxDt = 1;
	if (dt > maxDt) {
		dt = maxDt;
	}
	if (self->xInv) {
		if (self->xRot <= -self->overlap) {
			self->xInv = FALSE;
			self->xSpeed = self->minspeed + self->rnd->vtbl->maxNext(self->rnd, 5);
		}
		self->xRot -= self->xSpeed * dt;
	}
	else {
		if (self->xRot >= self->overlap) {
			self->xInv = TRUE;
			self->xSpeed = self->minspeed + self->rnd->vtbl->maxNext(self->rnd, 5);
		}
		self->xRot += self->xSpeed * dt;
	}
	if (self->yInv) {
		if (self->yRot <= -self->overlap) {
			self->yInv = FALSE;
			self->ySpeed = self->minspeed + self->rnd->vtbl->maxNext(self->rnd, 5);
		}
		self->yRot -= self->ySpeed * dt;
	}
	else {
		if (self->yRot >= self->overlap) {
			self->yInv = TRUE;
			self->ySpeed = self->minspeed + self->rnd->vtbl->maxNext(self->rnd, 5);
		}
		self->yRot += self->ySpeed * dt;
	}
}

const char *MainMenu_CharRepeat(MainMenu const *self, int c, int length)
{
	int *charArray = (int *) malloc(length * sizeof(int ));
	{
		int i;
		for (i = 0; i < length; i++) {
			charArray[i] = c;
		}
	}
	return self->p->vtbl->charArrayToString(self->p, charArray, length);
}

const char *MainMenu_CharToString(MainMenu const *self, int a)
{
	int *arr = (int *) malloc(1 * sizeof(int ));
	arr[0] = a;
	return self->p->vtbl->charArrayToString(self->p, arr, 1);
}

static void MainMenu_ConnectToGame(MainMenu *self, LoginData const *loginResultData, const char *username)
{
	ConnectData *connectData = ConnectData_New();
	connectData->ip = loginResultData->serverAddress;
	connectData->port = loginResultData->port;
	connectData->auth = loginResultData->authCode;
	connectData->username = username;
	MainMenu_StartGame(self, FALSE, NULL, connectData);
}

void MainMenu_ConnectToSingleplayer(MainMenu *self, const char *filename)
{
	MainMenu_StartGame(self, TRUE, filename, NULL);
}

static void MainMenu_CreateAccount(MainMenu const *self, const char *user, const char *password, LoginResultRef *loginResult)
{
	if (strcmp(user, "") == 0 || strcmp(password, "") == 0) {
		loginResult->value = LoginResult_FAILED;
	}
	else {
		loginResult->value = LoginResult_OK;
	}
}

void MainMenu_Draw2dQuad(MainMenu *self, int textureid, float dx, float dy, float dw, float dh)
{
	Mat4_Identity_(self->mvMatrix);
	Mat4_Translate(self->mvMatrix, self->mvMatrix, Vec3_FromValues(dx, dy, 0));
	Mat4_Scale(self->mvMatrix, self->mvMatrix, Vec3_FromValues(dw, dh, 0));
	Mat4_Scale(self->mvMatrix, self->mvMatrix, Vec3_FromValues(self->one / 2, self->one / 2, 0));
	Mat4_Translate(self->mvMatrix, self->mvMatrix, Vec3_FromValues(self->one, self->one, 0));
	MainMenu_SetMatrixUniforms(self);
	if (self->cubeModel == NULL) {
		self->cubeModel = self->p->vtbl->createModel(self->p, QuadModelData_GetQuadModelData());
	}
	self->p->vtbl->bindTexture2d(self->p, textureid);
	self->p->vtbl->drawModel(self->p, self->cubeModel);
}

static void MainMenu_DrawBackground(MainMenu *self)
{
	int countX;
	int countY;
	self->backgroundW = 512;
	self->backgroundH = 512;
	self->windowX = self->p->vtbl->getCanvasWidth(self->p);
	self->windowY = self->p->vtbl->getCanvasHeight(self->p);
	countX = self->p->vtbl->floatToInt(self->p, (self->windowX + 2 * self->overlap) / self->backgroundW) + 1;
	countY = self->p->vtbl->floatToInt(self->p, (self->windowY + 2 * self->overlap) / self->backgroundH) + 1;
	{
		int x;
		for (x = 0; x < countX; x++) {
			{
				int y;
				for (y = 0; y < countY; y++) {
					MainMenu_Draw2dQuad(self, MainMenu_GetTexture(self, "background.png"), x * self->backgroundW + self->xRot - self->overlap, y * self->backgroundH + self->yRot - self->overlap, self->backgroundW, self->backgroundH);
				}
			}
		}
	}
}

static void MainMenu_DrawButton(MainMenu *self, const char *text, float fontSize, float dx, float dy, float dw, float dh, cibool pressed)
{
	MainMenu_Draw2dQuad(self, pressed ? MainMenu_GetTexture(self, "button_sel.png") : MainMenu_GetTexture(self, "button.png"), dx, dy, dw, dh);
	if (text != NULL && strcmp(text, "") != 0) {
		MainMenu_DrawText(self, text, fontSize, dx + dw / 2, dy + dh / 2, TextAlign_CENTER, TextBaseline_MIDDLE);
	}
}

static void MainMenu_DrawScene(MainMenu const *self, float dt)
{
	self->p->vtbl->glViewport(self->p, 0, 0, self->viewportWidth, self->viewportHeight);
	self->p->vtbl->glClearColorBufferAndDepthBuffer(self->p);
	self->p->vtbl->glDisableDepthTest(self->p);
	self->p->vtbl->glDisableCullFace(self->p);
	{
	}
	{
		Mat4_Identity_(self->pMatrix);
		Mat4_Ortho(self->pMatrix, 0, self->p->vtbl->getCanvasWidth(self->p), self->p->vtbl->getCanvasHeight(self->p), 0, 0, 10);
	}
	self->screen->vtbl->render(self->screen, dt);
}

static void MainMenu_DrawServerButton(MainMenu *self, const char *name, const char *motd, const char *gamemode, const char *playercount, float x, float y, float width, float height, const char *image)
{
	MainMenu_Draw2dQuad(self, MainMenu_GetTexture(self, "serverlist_entry_background.png"), x, y, width, height);
	MainMenu_Draw2dQuad(self, MainMenu_GetTexture(self, image), x, y, height, height);
	MainMenu_DrawText(self, name, 14, x + 70, y + 5, TextAlign_LEFT, TextBaseline_TOP);
	MainMenu_DrawText(self, gamemode, 12, x + width - 10, y + height - 5, TextAlign_RIGHT, TextBaseline_BOTTOM);
	MainMenu_DrawText(self, playercount, 12, x + width - 10, y + 5, TextAlign_RIGHT, TextBaseline_TOP);
	MainMenu_DrawText(self, motd, 12, x + 70, y + height - 5, TextAlign_LEFT, TextBaseline_BOTTOM);
}

static void MainMenu_DrawText(MainMenu *self, const char *text, float fontSize, float x, float y, TextAlign align, TextBaseline baseline)
{
	TextTexture const *t = MainMenu_GetTextTexture(self, text, fontSize);
	int dx = 0;
	int dy = 0;
	if (align == TextAlign_CENTER) {
		dx -= t->textwidth / 2;
	}
	if (align == TextAlign_RIGHT) {
		dx -= t->textwidth;
	}
	if (baseline == TextBaseline_MIDDLE) {
		dy -= t->textheight / 2;
	}
	if (baseline == TextBaseline_BOTTOM) {
		dy -= t->textheight;
	}
	MainMenu_Draw2dQuad(self, t->texture, x + dx, y + dy, t->texturewidth, t->textureheight);
}

static void MainMenu_Exit(MainMenu const *self)
{
	self->p->vtbl->exit(self->p);
}

static unsigned char const *MainMenu_GetFile(MainMenu const *self, const char *name)
{
	const char *pLowercase = self->p->vtbl->stringToLower(self->p, name);
	{
		int i;
		for (i = 0; i < self->assets->count; i++) {
			if (strcmp(self->assets->items[i]->name, pLowercase) == 0) {
				return self->assets->items[i]->data;
			}
		}
	}
	return NULL;
}

static int MainMenu_GetFileLength(MainMenu const *self, const char *name)
{
	const char *pLowercase = self->p->vtbl->stringToLower(self->p, name);
	{
		int i;
		for (i = 0; i < self->assets->count; i++) {
			if (strcmp(self->assets->items[i]->name, pLowercase) == 0) {
				return self->assets->items[i]->dataLength;
			}
		}
	}
	return 0;
}

static const char *const *MainMenu_GetSavegames(MainMenu const *self, IntRef *length)
{
	const char *const *files = self->p->vtbl->directoryGetFiles(self->p, self->p->vtbl->pathSavegames(self->p), length);
	const char **savegames = (const char **) malloc(length->value * sizeof(const char *));
	int count = 0;
	{
		int i;
		for (i = 0; i < length->value; i++) {
			if (MainMenu_StringEndsWith(self, files[i], ".mddbs")) {
				savegames[count++] = files[i];
			}
		}
	}
	length->value = count;
	return savegames;
}

float MainMenu_GetScale(MainMenu const *self)
{
	float scale;
	if (self->p->vtbl->isSmallScreen(self->p)) {
		scale = self->one * self->p->vtbl->getCanvasWidth(self->p) / 1280;
	}
	else {
		scale = self->one;
	}
	return scale;
}

static TextTexture const *MainMenu_GetTextTexture(MainMenu *self, const char *text, float fontSize)
{
	TextTexture *textTexture;
	Text_ *text_;
	BitmapCi const *textBitmap;
	int texture;
	IntRef const *textWidth;
	IntRef const *textHeight;
	{
		int i;
		for (i = 0; i < self->textTexturesCount; i++) {
			TextTexture const *t = self->textTextures[i];
			if (t == NULL) {
				continue;
			}
			if (strcmp(t->text, text) == 0 && t->size == fontSize) {
				return t;
			}
		}
	}
	textTexture = TextTexture_New();
	text_ = Text__New();
	text_->text = text;
	text_->fontsize = fontSize;
	text_->fontfamily = "Arial";
	text_->color = Game_ColorFromArgb(255, 255, 255, 255);
	textBitmap = TextColorRenderer_CreateTextTexture(self->textColorRenderer, text_);
	texture = self->p->vtbl->loadTextureFromBitmap(self->p, textBitmap);
	textWidth = IntRef_New();
	textHeight = IntRef_New();
	self->p->vtbl->textSize(self->p, text, fontSize, textWidth, textHeight);
	textTexture->texture = texture;
	textTexture->texturewidth = self->p->vtbl->floatToInt(self->p, self->p->vtbl->bitmapGetWidth(self->p, textBitmap));
	textTexture->textureheight = self->p->vtbl->floatToInt(self->p, self->p->vtbl->bitmapGetHeight(self->p, textBitmap));
	textTexture->text = text;
	textTexture->size = fontSize;
	textTexture->textwidth = textWidth->value;
	textTexture->textheight = textHeight->value;
	self->p->vtbl->bitmapDelete(self->p, textBitmap);
	self->textTextures[self->textTexturesCount++] = textTexture;
	return textTexture;
}

static int MainMenu_GetTexture(MainMenu const *self, const char *name)
{
	if (!DictionaryStringInt1024_Contains(self->textures, name)) {
		BoolRef const *found = BoolRef_New();
		BitmapCi const *bmp = self->p->vtbl->bitmapCreateFromPng(self->p, MainMenu_GetFile(self, name), MainMenu_GetFileLength(self, name));
		int texture = self->p->vtbl->loadTextureFromBitmap(self->p, bmp);
		DictionaryStringInt1024_Set(self->textures, name, texture);
		self->p->vtbl->bitmapDelete(self->p, bmp);
	}
	return DictionaryStringInt1024_Get(self->textures, name);
}

void MainMenu_HandleKeyDown(MainMenu const *self, KeyEventArgs const *e)
{
	self->currentlyPressedKeys[KeyEventArgs_GetKeyCode(e)] = TRUE;
	self->screen->vtbl->onKeyDown(self->screen, e);
}

void MainMenu_HandleKeyPress(MainMenu *self, KeyPressEventArgs const *e)
{
	if (KeyPressEventArgs_GetKeyChar(e) == 70 || KeyPressEventArgs_GetKeyChar(e) == 102) {
		self->filter += 1;
		if (self->filter == 3) {
			self->filter = 0;
		}
	}
	if (KeyPressEventArgs_GetKeyChar(e) == 96) {
		self->screen->vtbl->onBackPressed(self->screen);
	}
	self->screen->vtbl->onKeyPress(self->screen, e);
}

void MainMenu_HandleKeyUp(MainMenu const *self, KeyEventArgs const *e)
{
	self->currentlyPressedKeys[KeyEventArgs_GetKeyCode(e)] = FALSE;
	self->screen->vtbl->onKeyUp(self->screen, e);
}

void MainMenu_HandleMouseDown(MainMenu *self, MouseEventArgs const *e)
{
	self->mousePressed = TRUE;
	self->previousMouseX = MouseEventArgs_GetX(e);
	self->previousMouseY = MouseEventArgs_GetY(e);
	self->screen->vtbl->onMouseDown(self->screen, e);
}

void MainMenu_HandleMouseMove(MainMenu *self, MouseEventArgs const *e)
{
	float dx = MouseEventArgs_GetMovementX(e);
	float dy = MouseEventArgs_GetMovementY(e);
	self->previousMouseX = MouseEventArgs_GetX(e);
	self->previousMouseY = MouseEventArgs_GetY(e);
	if (self->mousePressed) {
	}
	self->screen->vtbl->onMouseMove(self->screen, e);
}

void MainMenu_HandleMouseUp(MainMenu *self, MouseEventArgs const *e)
{
	self->mousePressed = FALSE;
	self->screen->vtbl->onMouseUp(self->screen, e);
}

void MainMenu_HandleMouseWheel(MainMenu *self, MouseWheelEventArgs const *e)
{
	self->z += MouseWheelEventArgs_GetDeltaPrecise(e) / 5;
	self->screen->vtbl->onMouseWheel(self->screen, e);
}

void MainMenu_HandleTouchEnd(MainMenu const *self, TouchEventArgs const *e)
{
	self->screen->vtbl->onTouchEnd(self->screen, e);
}

void MainMenu_HandleTouchMove(MainMenu *self, TouchEventArgs const *e)
{
	float dx;
	float dy;
	self->screen->vtbl->onTouchMove(self->screen, e);
	if (TouchEventArgs_GetId(e) != self->touchId) {
		return;
	}
	dx = TouchEventArgs_GetX(e) - self->previousTouchX;
	dy = TouchEventArgs_GetY(e) - self->previousTouchY;
	self->previousTouchX = TouchEventArgs_GetX(e);
	self->previousTouchY = TouchEventArgs_GetY(e);
	self->ySpeed += dx / 10;
	self->xSpeed += dy / 10;
}

void MainMenu_HandleTouchStart(MainMenu *self, TouchEventArgs const *e)
{
	self->touchId = TouchEventArgs_GetId(e);
	self->previousTouchX = TouchEventArgs_GetX(e);
	self->previousTouchY = TouchEventArgs_GetY(e);
	self->screen->vtbl->onTouchStart(self->screen, e);
}

static void MainMenu_Login(MainMenu const *self, const char *user, const char *password, const char *serverHash, const char *token, LoginResultRef *loginResult, LoginData *loginResultData)
{
	if (strcmp(user, "") == 0 || (strcmp(password, "") == 0 && strcmp(token, "") == 0)) {
		loginResult->value = LoginResult_FAILED;
	}
	else {
		LoginClientCi_Login(self->loginClient, self->p, user, password, serverHash, token, loginResult, loginResultData);
	}
}

void MainMenu_OnNewFrame(MainMenu *self, NewFrameEventArgs const *args)
{
	if (!self->initialized) {
		self->initialized = TRUE;
		self->p->vtbl->initShaders(self->p);
		self->p->vtbl->glClearColorRgbaf(self->p, 0, 0, 0, 1);
		self->p->vtbl->glEnableDepthTest(self->p);
	}
	self->viewportWidth = self->p->vtbl->getCanvasWidth(self->p);
	self->viewportHeight = self->p->vtbl->getCanvasHeight(self->p);
	MainMenu_DrawScene(self, NewFrameEventArgs_GetDt(args));
	MainMenu_Animate(self, NewFrameEventArgs_GetDt(args));
	LoginClientCi_Update(self->loginClient, self->p);
}

static void MainMenu_SetMatrixUniforms(MainMenu const *self)
{
	self->p->vtbl->setMatrixUniformProjection(self->p, self->pMatrix);
	self->p->vtbl->setMatrixUniformModelView(self->p, self->mvMatrix);
}

void MainMenu_Start(MainMenu *self, GamePlatform const *p_)
{
	self->p = p_;
	self->lang = Language_New();
	self->lang->platform = self->p;
	Language_LoadTranslations(self->lang);
	self->p->vtbl->setTitle(self->p, Language_GameName(self->lang));
	self->textColorRenderer = TextColorRenderer_New();
	self->textColorRenderer->platform = p_;
	p_->vtbl->loadAssetsAsyc(p_, self->assets, self->assetsLoadProgress);
	self->overlap = 200;
	self->minspeed = 20;
	self->rnd = self->p->vtbl->randomCreate(self->p);
	self->xRot = 0;
	self->xInv = FALSE;
	self->xSpeed = self->minspeed + self->rnd->vtbl->maxNext(self->rnd, 5);
	self->yRot = 0;
	self->yInv = FALSE;
	self->ySpeed = self->minspeed + self->rnd->vtbl->maxNext(self->rnd, 5);
	self->z = -5;
	self->filter = 0;
	self->mvMatrix = Mat4_Create();
	self->pMatrix = Mat4_Create();
	self->currentlyPressedKeys = (cibool *) malloc(256 * sizeof(cibool ));
	self->p->vtbl->addOnNewFrame(self->p, &MainMenuNewFrameHandler_Create(self)->base);
	self->p->vtbl->addOnKeyEvent(self->p, &MainMenuKeyEventHandler_Create(self)->base);
	self->p->vtbl->addOnMouseEvent(self->p, &MainMenuMouseEventHandler_Create(self)->base);
	self->p->vtbl->addOnTouchEvent(self->p, &MainMenuTouchEventHandler_Create(self)->base);
}

static void MainMenu_StartConnectToIp(MainMenu *self)
{
	ScreenConnectToIp *screenConnectToIp = ScreenConnectToIp_New();
	self->screen = &screenConnectToIp->base;
	self->screen->menu = self;
	self->screen->vtbl->loadTranslations(self->screen);
}

void MainMenu_StartGame(MainMenu *self, cibool singleplayer, const char *singleplayerSavePath, ConnectData *connectData)
{
	ScreenGame *screenGame = ScreenGame_New();
	screenGame->base.menu = self;
	ScreenGame_Start(screenGame, self->p, singleplayer, singleplayerSavePath, connectData);
	self->screen = &screenGame->base;
}

static void MainMenu_StartLogin(MainMenu *self, const char *serverHash, const char *ip, int port)
{
	ScreenLogin *screenLogin = ScreenLogin_New();
	screenLogin->serverHash = serverHash;
	screenLogin->serverIp = ip;
	screenLogin->serverPort = port;
	self->screen = &screenLogin->base;
	self->screen->menu = self;
	self->screen->vtbl->loadTranslations(self->screen);
}

static void MainMenu_StartMainMenu(MainMenu *self)
{
	self->screen = &ScreenMain_New()->base;
	self->screen->menu = self;
	self->p->vtbl->exitMousePointerLock(self->p);
}

static void MainMenu_StartModifyWorld(MainMenu const *self)
{
}

static void MainMenu_StartMultiplayer(MainMenu *self)
{
	self->screen = &ScreenMultiplayer_New()->base;
	self->screen->menu = self;
	self->screen->vtbl->loadTranslations(self->screen);
}

static void MainMenu_StartNewWorld(MainMenu const *self)
{
}

static void MainMenu_StartSingleplayer(MainMenu *self)
{
	self->screen = &ScreenSingleplayer_New()->base;
	self->screen->menu = self;
	self->screen->vtbl->loadTranslations(self->screen);
}

cibool MainMenu_StringEndsWith(MainMenu const *self, const char *s, const char *value)
{
	return strcmp(StringTools_StringSubstring(self->p, s, MainMenu_StringLength(self, s) - MainMenu_StringLength(self, value), MainMenu_StringLength(self, value)), value) == 0;
}

int MainMenu_StringLength(MainMenu const *self, const char *a)
{
	IntRef const *length = IntRef_New();
	self->p->vtbl->stringToCharArray(self->p, a, length);
	return length->value;
}

static void MainMenuKeyEventHandler_Construct(MainMenuKeyEventHandler *self, const KeyEventHandlerVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_MainMenuKeyEventHandler;
	KeyEventHandler_Construct(&self->base, vtbl);
}

MainMenuKeyEventHandler *MainMenuKeyEventHandler_New(void)
{
	MainMenuKeyEventHandler *self = (MainMenuKeyEventHandler *) malloc(sizeof(MainMenuKeyEventHandler));
	if (self != NULL)
		MainMenuKeyEventHandler_Construct(self, NULL);
	return self;
}

void MainMenuKeyEventHandler_Delete(MainMenuKeyEventHandler *self)
{
	free(self);
}

MainMenuKeyEventHandler const *MainMenuKeyEventHandler_Create(MainMenu *l)
{
	MainMenuKeyEventHandler *h = MainMenuKeyEventHandler_New();
	h->l = l;
	return h;
}

void MainMenuKeyEventHandler_OnKeyDown(MainMenuKeyEventHandler const *self, KeyEventArgs const *e)
{
	MainMenu_HandleKeyDown(self->l, e);
}

void MainMenuKeyEventHandler_OnKeyPress(MainMenuKeyEventHandler const *self, KeyPressEventArgs const *e)
{
	MainMenu_HandleKeyPress(self->l, e);
}

void MainMenuKeyEventHandler_OnKeyUp(MainMenuKeyEventHandler const *self, KeyEventArgs const *e)
{
	MainMenu_HandleKeyUp(self->l, e);
}

static void MainMenuMouseEventHandler_Construct(MainMenuMouseEventHandler *self, const MouseEventHandlerVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_MainMenuMouseEventHandler;
	MouseEventHandler_Construct(&self->base, vtbl);
}

MainMenuMouseEventHandler *MainMenuMouseEventHandler_New(void)
{
	MainMenuMouseEventHandler *self = (MainMenuMouseEventHandler *) malloc(sizeof(MainMenuMouseEventHandler));
	if (self != NULL)
		MainMenuMouseEventHandler_Construct(self, NULL);
	return self;
}

void MainMenuMouseEventHandler_Delete(MainMenuMouseEventHandler *self)
{
	free(self);
}

MainMenuMouseEventHandler const *MainMenuMouseEventHandler_Create(MainMenu *l)
{
	MainMenuMouseEventHandler *h = MainMenuMouseEventHandler_New();
	h->l = l;
	return h;
}

void MainMenuMouseEventHandler_OnMouseDown(MainMenuMouseEventHandler const *self, MouseEventArgs const *e)
{
	MainMenu_HandleMouseDown(self->l, e);
}

void MainMenuMouseEventHandler_OnMouseMove(MainMenuMouseEventHandler const *self, MouseEventArgs const *e)
{
	MainMenu_HandleMouseMove(self->l, e);
}

void MainMenuMouseEventHandler_OnMouseUp(MainMenuMouseEventHandler const *self, MouseEventArgs const *e)
{
	MainMenu_HandleMouseUp(self->l, e);
}

void MainMenuMouseEventHandler_OnMouseWheel(MainMenuMouseEventHandler const *self, MouseWheelEventArgs const *e)
{
	MainMenu_HandleMouseWheel(self->l, e);
}

static void MainMenuNewFrameHandler_Construct(MainMenuNewFrameHandler *self, const NewFrameHandlerVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_MainMenuNewFrameHandler;
	NewFrameHandler_Construct(&self->base, vtbl);
}

MainMenuNewFrameHandler *MainMenuNewFrameHandler_New(void)
{
	MainMenuNewFrameHandler *self = (MainMenuNewFrameHandler *) malloc(sizeof(MainMenuNewFrameHandler));
	if (self != NULL)
		MainMenuNewFrameHandler_Construct(self, NULL);
	return self;
}

void MainMenuNewFrameHandler_Delete(MainMenuNewFrameHandler *self)
{
	free(self);
}

MainMenuNewFrameHandler const *MainMenuNewFrameHandler_Create(MainMenu *l)
{
	MainMenuNewFrameHandler *h = MainMenuNewFrameHandler_New();
	h->l = l;
	return h;
}

void MainMenuNewFrameHandler_OnNewFrame(MainMenuNewFrameHandler const *self, NewFrameEventArgs const *args)
{
	MainMenu_OnNewFrame(self->l, args);
}

static void MainMenuTouchEventHandler_Construct(MainMenuTouchEventHandler *self, const TouchEventHandlerVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_MainMenuTouchEventHandler;
	TouchEventHandler_Construct(&self->base, vtbl);
}

MainMenuTouchEventHandler *MainMenuTouchEventHandler_New(void)
{
	MainMenuTouchEventHandler *self = (MainMenuTouchEventHandler *) malloc(sizeof(MainMenuTouchEventHandler));
	if (self != NULL)
		MainMenuTouchEventHandler_Construct(self, NULL);
	return self;
}

void MainMenuTouchEventHandler_Delete(MainMenuTouchEventHandler *self)
{
	free(self);
}

MainMenuTouchEventHandler const *MainMenuTouchEventHandler_Create(MainMenu *l)
{
	MainMenuTouchEventHandler *h = MainMenuTouchEventHandler_New();
	h->l = l;
	return h;
}

void MainMenuTouchEventHandler_OnTouchEnd(MainMenuTouchEventHandler const *self, TouchEventArgs const *e)
{
	MainMenu_HandleTouchEnd(self->l, e);
}

void MainMenuTouchEventHandler_OnTouchMove(MainMenuTouchEventHandler const *self, TouchEventArgs const *e)
{
	MainMenu_HandleTouchMove(self->l, e);
}

void MainMenuTouchEventHandler_OnTouchStart(MainMenuTouchEventHandler const *self, TouchEventArgs const *e)
{
	MainMenu_HandleTouchStart(self->l, e);
}

Map *Map_New(void)
{
	Map *self = (Map *) malloc(sizeof(Map));
	return self;
}

void Map_Delete(Map *self)
{
	free(self);
}

void Map_CopyChunk(Map const *self, Chunk const *chunk, int *output)
{
	int n = 4096;
	if (chunk->dataInt != NULL) {
		{
			int i;
			for (i = 0; i < n; i++) {
				output[i] = chunk->dataInt[i];
			}
		}
	}
	else {
		{
			int i;
			for (i = 0; i < n; i++) {
				output[i] = chunk->data[i];
			}
		}
	}
}

void Map_FillChunk(Map const *self, Chunk *destination, int destinationchunksize, int sourcex, int sourcey, int sourcez, int const *source, int sourcechunksizeX, int sourcechunksizeY, int sourcechunksizeZ)
{
	{
		int x;
		for (x = 0; x < destinationchunksize; x++) {
			{
				int y;
				for (y = 0; y < destinationchunksize; y++) {
					{
						int z;
						for (z = 0; z < destinationchunksize; z++) {
							{
								Chunk_SetBlockInChunk(destination, (z * destinationchunksize + y) * destinationchunksize + x, source[((z + sourcez) * sourcechunksizeY + y + sourcey) * sourcechunksizeX + x + sourcex]);
							}
						}
					}
				}
			}
		}
	}
}

int Map_GetBlock(Map const *self, int x, int y, int z)
{
	if (!Map_IsValidPos(self, x, y, z)) {
		return 0;
	}
	return Map_GetBlockValid(self, x, y, z);
}

int Map_GetBlockValid(Map const *self, int x, int y, int z)
{
	int cx = x >> 4;
	int cy = y >> 4;
	int cz = z >> 4;
	int chunkpos = (cz * (self->mapSizeY >> 4) + cy) * (self->mapSizeX >> 4) + cx;
	if (self->chunks[chunkpos] == NULL) {
		return 0;
	}
	else {
		int pos = ((z & 15) * 16 + (y & 15)) * 16 + (x & 15);
		return Chunk_GetBlockInChunk(self->chunks[chunkpos], pos);
	}
}

Chunk *Map_GetChunk(Map const *self, int x, int y, int z)
{
	x = x / 16;
	y = y / 16;
	z = z / 16;
	return Map_GetChunk_(self, x, y, z);
}

Chunk const *Map_GetChunk_(Map const *self, int cx, int cy, int cz)
{
	int mapsizexchunks = self->mapSizeX / 16;
	int mapsizeychunks = self->mapSizeY / 16;
	Chunk const *chunk = self->chunks[(cz * mapsizeychunks + cy) * mapsizexchunks + cx];
	if (chunk == NULL) {
		Chunk *c = Chunk_New();
		c->data = (unsigned char *) malloc(4096 * sizeof(unsigned char ));
		c->baseLight = (unsigned char *) malloc(4096 * sizeof(unsigned char ));
		self->chunks[(cz * mapsizeychunks + cy) * mapsizexchunks + cx] = c;
		return self->chunks[(cz * mapsizeychunks + cy) * mapsizexchunks + cx];
	}
	return chunk;
}

void Map_GetMapPortion(Map const *self, int *outPortion, int x, int y, int z, int portionsizex, int portionsizey, int portionsizez)
{
	int outPortionCount = portionsizex * portionsizey * portionsizez;
	int mapchunksx;
	int mapchunksy;
	int mapchunksz;
	int mapsizechunks;
	{
		int i;
		for (i = 0; i < outPortionCount; i++) {
			outPortion[i] = 0;
		}
	}
	mapchunksx = self->mapSizeX / 16;
	mapchunksy = self->mapSizeY / 16;
	mapchunksz = self->mapSizeZ / 16;
	mapsizechunks = mapchunksx * mapchunksy * mapchunksz;
	{
		int xx;
		for (xx = 0; xx < portionsizex; xx++) {
			{
				int yy;
				for (yy = 0; yy < portionsizey; yy++) {
					{
						int zz;
						for (zz = 0; zz < portionsizez; zz++) {
							int cx = (x + xx) >> 4;
							int cy = (y + yy) >> 4;
							int cz = (z + zz) >> 4;
							int cpos = (cz * mapchunksy + cy) * mapchunksx + cx;
							Chunk const *chunk;
							int chunkGlobalX;
							int chunkGlobalY;
							int chunkGlobalZ;
							int inChunkX;
							int inChunkY;
							int inChunkZ;
							int pos;
							int block;
							if (cpos < 0 || cpos >= mapsizechunks) {
								continue;
							}
							chunk = self->chunks[cpos];
							if (chunk == NULL || !Chunk_ChunkHasData(chunk)) {
								continue;
							}
							chunkGlobalX = cx << 4;
							chunkGlobalY = cy << 4;
							chunkGlobalZ = cz << 4;
							inChunkX = x + xx - chunkGlobalX;
							inChunkY = y + yy - chunkGlobalY;
							inChunkZ = z + zz - chunkGlobalZ;
							pos = (((inChunkZ << 4) + inChunkY) << 4) + inChunkX;
							block = Chunk_GetBlockInChunk(chunk, pos);
							outPortion[(zz * portionsizey + yy) * portionsizex + xx] = block;
						}
					}
				}
			}
		}
	}
}

cibool Map_IsChunkRendered(Map const *self, int cx, int cy, int cz)
{
	Chunk const *c = self->chunks[MapUtilCi_Index3d(cx, cy, cz, Map_mapsizexchunks(self), Map_mapsizeychunks(self))];
	if (c == NULL) {
		return FALSE;
	}
	return c->rendered != NULL && c->rendered->ids != NULL;
}

cibool Map_IsValidChunkPos(Map const *self, int cx, int cy, int cz)
{
	return cx >= 0 && cy >= 0 && cz >= 0 && cx < self->mapSizeX / 16 && cy < self->mapSizeY / 16 && cz < self->mapSizeZ / 16;
}

cibool Map_IsValidPos(Map const *self, int x, int y, int z)
{
	if (x < 0 || y < 0 || z < 0) {
		return FALSE;
	}
	if (x >= self->mapSizeX || y >= self->mapSizeY || z >= self->mapSizeZ) {
		return FALSE;
	}
	return TRUE;
}

int Map_MaybeGetLight(Map const *self, int x, int y, int z)
{
	int light = -1;
	int cx = x / 16;
	int cy = y / 16;
	int cz = z / 16;
	if (Map_IsValidPos(self, x, y, z) && Map_IsValidChunkPos(self, cx, cy, cz)) {
		Chunk const *c = self->chunks[MapUtilCi_Index3d(cx, cy, cz, Map_mapsizexchunks(self), Map_mapsizeychunks(self))];
		if (c == NULL || c->rendered == NULL || c->rendered->light == NULL) {
			light = -1;
		}
		else {
			light = c->rendered->light[MapUtilCi_Index3d(x % 16 + 1, y % 16 + 1, z % 16 + 1, 18, 18)];
		}
	}
	return light;
}

void Map_Reset(Map *self, int sizex, int sizey, int sizez)
{
	self->mapSizeX = sizex;
	self->mapSizeY = sizey;
	self->mapSizeZ = sizez;
	self->chunks = (Chunk const **) malloc(sizex / 16 * sizey / 16 * sizez / 16 * sizeof(Chunk const *));
}

void Map_SetBlockDirty(Map const *self, int x, int y, int z)
{
	Vector3IntRef const *const *around = ModDrawTerrain_BlocksAround7(Vector3IntRef_Create(x, y, z));
	{
		int i;
		for (i = 0; i < 7; i++) {
			Vector3IntRef const *a = around[i];
			int xx = a->x;
			int yy = a->y;
			int zz = a->z;
			if (xx < 0 || yy < 0 || zz < 0 || xx >= self->mapSizeX || yy >= self->mapSizeY || zz >= self->mapSizeZ) {
				return;
			}
			Map_SetChunkDirty(self, xx / 16, yy / 16, zz / 16, TRUE, TRUE);
		}
	}
}

void Map_SetBlockRaw(Map const *self, int x, int y, int z, int tileType)
{
	Chunk *chunk = Map_GetChunk(self, x, y, z);
	int pos = (z % 16 * 16 + y % 16) * 16 + x % 16;
	Chunk_SetBlockInChunk(chunk, pos, tileType);
}

void Map_SetChunkDirty(Map const *self, int cx, int cy, int cz, cibool dirty, cibool blockschanged)
{
	Chunk *c;
	if (!Map_IsValidChunkPos(self, cx, cy, cz)) {
		return;
	}
	c = self->chunks[MapUtilCi_Index3d(cx, cy, cz, Map_mapsizexchunks(self), Map_mapsizeychunks(self))];
	if (c == NULL) {
		return;
	}
	if (c->rendered == NULL) {
		c->rendered = RenderedChunk_New();
	}
	c->rendered->dirty = dirty;
	if (blockschanged) {
		c->baseLightDirty = TRUE;
	}
}

void Map_SetChunksAroundDirty(Map const *self, int cx, int cy, int cz)
{
	if (Map_IsValidChunkPos(self, cx, cy, cz)) {
		Map_SetChunkDirty(self, cx - 1, cy, cz, TRUE, FALSE);
	}
	if (Map_IsValidChunkPos(self, cx - 1, cy, cz)) {
		Map_SetChunkDirty(self, cx - 1, cy, cz, TRUE, FALSE);
	}
	if (Map_IsValidChunkPos(self, cx + 1, cy, cz)) {
		Map_SetChunkDirty(self, cx + 1, cy, cz, TRUE, FALSE);
	}
	if (Map_IsValidChunkPos(self, cx, cy - 1, cz)) {
		Map_SetChunkDirty(self, cx, cy - 1, cz, TRUE, FALSE);
	}
	if (Map_IsValidChunkPos(self, cx, cy + 1, cz)) {
		Map_SetChunkDirty(self, cx, cy + 1, cz, TRUE, FALSE);
	}
	if (Map_IsValidChunkPos(self, cx, cy, cz - 1)) {
		Map_SetChunkDirty(self, cx, cy, cz - 1, TRUE, FALSE);
	}
	if (Map_IsValidChunkPos(self, cx, cy, cz + 1)) {
		Map_SetChunkDirty(self, cx, cy, cz + 1, TRUE, FALSE);
	}
}

void Map_SetMapPortion(Map const *self, int x, int y, int z, int const *chunk, int sizeX, int sizeY, int sizeZ)
{
	int chunksizex = sizeX;
	int chunksizey = sizeY;
	int chunksizez = sizeZ;
	int chunksize = 16;
	Chunk **localchunks = (Chunk const **) malloc(chunksizex / chunksize * chunksizey / chunksize * chunksizez / chunksize * sizeof(Chunk const *));
	{
		int cx;
		for (cx = 0; cx < chunksizex / chunksize; cx++) {
			{
				int cy;
				for (cy = 0; cy < chunksizey / chunksize; cy++) {
					{
						int cz;
						for (cz = 0; cz < chunksizex / chunksize; cz++) {
							localchunks[(cz * chunksizey / chunksize + cy) * chunksizex / chunksize + cx] = Map_GetChunk(self, x + cx * chunksize, y + cy * chunksize, z + cz * chunksize);
							Map_FillChunk(self, localchunks[(cz * chunksizey / chunksize + cy) * chunksizex / chunksize + cx], chunksize, cx * chunksize, cy * chunksize, cz * chunksize, chunk, sizeX, sizeY, sizeZ);
						}
					}
				}
			}
		}
	}
	{
		int xxx;
		for (xxx = 0; xxx < chunksizex; xxx += chunksize) {
			{
				int yyy;
				for (yyy = 0; yyy < chunksizex; yyy += chunksize) {
					{
						int zzz;
						for (zzz = 0; zzz < chunksizex; zzz += chunksize) {
							Map_SetChunkDirty(self, (x + xxx) / chunksize, (y + yyy) / chunksize, (z + zzz) / chunksize, TRUE, TRUE);
							Map_SetChunksAroundDirty(self, (x + xxx) / chunksize, (y + yyy) / chunksize, (z + zzz) / chunksize);
						}
					}
				}
			}
		}
	}
}

int Map_mapsizexchunks(Map const *self)
{
	return self->mapSizeX >> 4;
}

int Map_mapsizeychunks(Map const *self)
{
	return self->mapSizeY >> 4;
}

int Map_mapsizezchunks(Map const *self)
{
	return self->mapSizeZ >> 4;
}

MapLoadingProgressEventArgs *MapLoadingProgressEventArgs_New(void)
{
	MapLoadingProgressEventArgs *self = (MapLoadingProgressEventArgs *) malloc(sizeof(MapLoadingProgressEventArgs));
	return self;
}

void MapLoadingProgressEventArgs_Delete(MapLoadingProgressEventArgs *self)
{
	free(self);
}

static void MapStorage2_Construct(MapStorage2 *self, const IMapStorage2Vtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_MapStorage2;
	IMapStorage2_Construct(&self->base, vtbl);
}

MapStorage2 *MapStorage2_New(void)
{
	MapStorage2 *self = (MapStorage2 *) malloc(sizeof(MapStorage2));
	if (self != NULL)
		MapStorage2_Construct(self, NULL);
	return self;
}

void MapStorage2_Delete(MapStorage2 *self)
{
	free(self);
}

MapStorage2 const *MapStorage2_Create(Game *game)
{
	MapStorage2 *s = MapStorage2_New();
	s->game = game;
	return s;
}

int MapStorage2_GetBlock(MapStorage2 const *self, int x, int y, int z)
{
	return Map_GetBlock(self->game->map, x, y, z);
}

int MapStorage2_GetMapSizeX(MapStorage2 const *self)
{
	return self->game->map->mapSizeX;
}

int MapStorage2_GetMapSizeY(MapStorage2 const *self)
{
	return self->game->map->mapSizeY;
}

int MapStorage2_GetMapSizeZ(MapStorage2 const *self)
{
	return self->game->map->mapSizeZ;
}

void MapStorage2_SetBlock(MapStorage2 const *self, int x, int y, int z, int tileType)
{
	Game_SetBlock(self->game, x, y, z, tileType);
}

int MapUtilCi_Index2d(int x, int y, int sizex)
{
	return x + y * sizex;
}

int MapUtilCi_Index3d(int x, int y, int h, int sizex, int sizey)
{
	return (h * sizey + y) * sizex + x;
}

void MapUtilCi_Pos(int index, int sizex, int sizey, Vector3Ref *ret)
{
	int x = index % sizex;
	int y = index / sizex % sizey;
	int h = index / (sizex * sizey);
	ret->x = x;
	ret->y = y;
	ret->z = h;
}

static void MapUtilCi_PosInt(int index, int sizex, int sizey, Vector3IntRef *ret)
{
	int x = index % sizex;
	int y = index / sizex % sizey;
	int h = index / (sizex * sizey);
	ret->x = x;
	ret->y = y;
	ret->z = h;
}

int MapUtilCi_PosX(int index, int sizex, int sizey)
{
	return index % sizex;
}

int MapUtilCi_PosY(int index, int sizex, int sizey)
{
	return index / sizex % sizey;
}

int MapUtilCi_PosZ(int index, int sizex, int sizey)
{
	return index / (sizex * sizey);
}

float const *Mat2_Adjoint(float *output, float const *a)
{
	float a0 = a[0];
	output[0] = a[3];
	output[1] = -a[1];
	output[2] = -a[2];
	output[3] = a0;
	return output;
}

float const *Mat2_CloneIt(float const *a)
{
	float *output = (float *) malloc(4 * sizeof(float ));
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	output[3] = a[3];
	return output;
}

float const *Mat2_Copy(float *output, float const *a)
{
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	output[3] = a[3];
	return output;
}

float const *Mat2_Create(void)
{
	float *output = (float *) malloc(4 * sizeof(float ));
	output[0] = 1;
	output[1] = 0;
	output[2] = 0;
	output[3] = 1;
	return output;
}

float Mat2_Determinant(float const *a)
{
	return a[0] * a[3] - a[2] * a[1];
}

float const *Mat2_Identity_(float *output)
{
	output[0] = 1;
	output[1] = 0;
	output[2] = 0;
	output[3] = 1;
	return output;
}

float const *Mat2_Invert(float *output, float const *a)
{
	float a0 = a[0];
	float a1 = a[1];
	float a2 = a[2];
	float a3 = a[3];
	float det = a0 * a3 - a2 * a1;
	float one;
	if (det == 0) {
		return NULL;
	}
	one = 1;
	det = one / det;
	output[0] = a3 * det;
	output[1] = -a1 * det;
	output[2] = -a2 * det;
	output[3] = a0 * det;
	return output;
}

float const *Mat2_Mul(float *output, float const *a, float const *b)
{
	return Mat2_Multiply(output, a, b);
}

float const *Mat2_Multiply(float *output, float const *a, float const *b)
{
	float a0 = a[0];
	float a1 = a[1];
	float a2 = a[2];
	float a3 = a[3];
	float b0 = b[0];
	float b1 = b[1];
	float b2 = b[2];
	float b3 = b[3];
	output[0] = a0 * b0 + a1 * b2;
	output[1] = a0 * b1 + a1 * b3;
	output[2] = a2 * b0 + a3 * b2;
	output[3] = a2 * b1 + a3 * b3;
	return output;
}

float const *Mat2_Rotate(float *output, float const *a, float rad)
{
	float a0 = a[0];
	float a1 = a[1];
	float a2 = a[2];
	float a3 = a[3];
	float s = Platform_Sin(rad);
	float c = Platform_Cos(rad);
	output[0] = a0 * c + a1 * s;
	output[1] = a0 * -s + a1 * c;
	output[2] = a2 * c + a3 * s;
	output[3] = a2 * -s + a3 * c;
	return output;
}

float const *Mat2_Scale(float *output, float const *a, float const *v)
{
	float a0 = a[0];
	float a1 = a[1];
	float a2 = a[2];
	float a3 = a[3];
	float v0 = v[0];
	float v1 = v[1];
	output[0] = a0 * v0;
	output[1] = a1 * v1;
	output[2] = a2 * v0;
	output[3] = a3 * v1;
	return output;
}

float const *Mat2_Transpose(float *output, float const *a)
{
	output[0] = a[0];
	output[1] = a[2];
	output[2] = a[1];
	output[3] = a[3];
	return output;
}

float const *Mat2d_CloneIt(float const *a)
{
	float *output = (float *) malloc(6 * sizeof(float ));
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	output[3] = a[3];
	output[4] = a[4];
	output[5] = a[5];
	return output;
}

float const *Mat2d_Copy(float *output, float const *a)
{
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	output[3] = a[3];
	output[4] = a[4];
	output[5] = a[5];
	return output;
}

float const *Mat2d_Create(void)
{
	float *output = (float *) malloc(6 * sizeof(float ));
	output[0] = 1;
	output[1] = 0;
	output[2] = 0;
	output[3] = 1;
	output[4] = 0;
	output[5] = 0;
	return output;
}

float Mat2d_Determinant(float const *a)
{
	return a[0] * a[3] - a[1] * a[2];
}

float const *Mat2d_Identity_(float *output)
{
	output[0] = 1;
	output[1] = 0;
	output[2] = 0;
	output[3] = 1;
	output[4] = 0;
	output[5] = 0;
	return output;
}

float const *Mat2d_Invert(float *output, float const *a)
{
	float aa = a[0];
	float ab = a[1];
	float ac = a[2];
	float ad = a[3];
	float atx = a[4];
	float aty = a[5];
	float det = aa * ad - ab * ac;
	float one;
	if (det == 0) {
		return NULL;
	}
	one = 1;
	det = one / det;
	output[0] = ad * det;
	output[1] = -ab * det;
	output[2] = -ac * det;
	output[3] = aa * det;
	output[4] = (ac * aty - ad * atx) * det;
	output[5] = (ab * atx - aa * aty) * det;
	return output;
}

float const *Mat2d_Mul(float *output, float const *a, float const *b)
{
	return Mat2d_Multiply(output, a, b);
}

float const *Mat2d_Multiply(float *output, float const *a, float const *b)
{
	float aa = a[0];
	float ab = a[1];
	float ac = a[2];
	float ad = a[3];
	float atx = a[4];
	float aty = a[5];
	float ba = b[0];
	float bb = b[1];
	float bc = b[2];
	float bd = b[3];
	float btx = b[4];
	float bty = b[5];
	output[0] = aa * ba + ab * bc;
	output[1] = aa * bb + ab * bd;
	output[2] = ac * ba + ad * bc;
	output[3] = ac * bb + ad * bd;
	output[4] = ba * atx + bc * aty + btx;
	output[5] = bb * atx + bd * aty + bty;
	return output;
}

float const *Mat2d_Rotate(float *output, float const *a, float rad)
{
	float aa = a[0];
	float ab = a[1];
	float ac = a[2];
	float ad = a[3];
	float atx = a[4];
	float aty = a[5];
	float st = Platform_Sin(rad);
	float ct = Platform_Cos(rad);
	output[0] = aa * ct + ab * st;
	output[1] = -aa * st + ab * ct;
	output[2] = ac * ct + ad * st;
	output[3] = -ac * st + ct * ad;
	output[4] = ct * atx + st * aty;
	output[5] = ct * aty - st * atx;
	return output;
}

float const *Mat2d_Scale(float *output, float const *a, float const *v)
{
	float vx = v[0];
	float vy = v[1];
	output[0] = a[0] * vx;
	output[1] = a[1] * vy;
	output[2] = a[2] * vx;
	output[3] = a[3] * vy;
	output[4] = a[4] * vx;
	output[5] = a[5] * vy;
	return output;
}

float const *Mat2d_Translate(float *output, float const *a, float const *v)
{
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	output[3] = a[3];
	output[4] = a[4] + v[0];
	output[5] = a[5] + v[1];
	return output;
}

float const *Mat3_Adjoint(float *output, float const *a)
{
	float a00 = a[0];
	float a01 = a[1];
	float a02 = a[2];
	float a10 = a[3];
	float a11 = a[4];
	float a12 = a[5];
	float a20 = a[6];
	float a21 = a[7];
	float a22 = a[8];
	output[0] = a11 * a22 - a12 * a21;
	output[1] = a02 * a21 - a01 * a22;
	output[2] = a01 * a12 - a02 * a11;
	output[3] = a12 * a20 - a10 * a22;
	output[4] = a00 * a22 - a02 * a20;
	output[5] = a02 * a10 - a00 * a12;
	output[6] = a10 * a21 - a11 * a20;
	output[7] = a01 * a20 - a00 * a21;
	output[8] = a00 * a11 - a01 * a10;
	return output;
}

float const *Mat3_CloneIt(float const *a)
{
	float *output = (float *) malloc(9 * sizeof(float ));
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	output[3] = a[3];
	output[4] = a[4];
	output[5] = a[5];
	output[6] = a[6];
	output[7] = a[7];
	output[8] = a[8];
	return output;
}

float const *Mat3_Copy(float *output, float const *a)
{
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	output[3] = a[3];
	output[4] = a[4];
	output[5] = a[5];
	output[6] = a[6];
	output[7] = a[7];
	output[8] = a[8];
	return output;
}

float *Mat3_Create(void)
{
	float *output = (float *) malloc(9 * sizeof(float ));
	output[0] = 1;
	output[1] = 0;
	output[2] = 0;
	output[3] = 0;
	output[4] = 1;
	output[5] = 0;
	output[6] = 0;
	output[7] = 0;
	output[8] = 1;
	return output;
}

float Mat3_Determinant(float const *a)
{
	float a00 = a[0];
	float a01 = a[1];
	float a02 = a[2];
	float a10 = a[3];
	float a11 = a[4];
	float a12 = a[5];
	float a20 = a[6];
	float a21 = a[7];
	float a22 = a[8];
	return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}

float const *Mat3_FromMat2d(float *output, float const *a)
{
	output[0] = a[0];
	output[1] = a[1];
	output[2] = 0;
	output[3] = a[2];
	output[4] = a[3];
	output[5] = 0;
	output[6] = a[4];
	output[7] = a[5];
	output[8] = 1;
	return output;
}

float const *Mat3_FromMat4(float *output, float const *a)
{
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	output[3] = a[4];
	output[4] = a[5];
	output[5] = a[6];
	output[6] = a[8];
	output[7] = a[9];
	output[8] = a[10];
	return output;
}

float const *Mat3_FromQuat(float *output, float const *q)
{
	float x = q[0];
	float y = q[1];
	float z = q[2];
	float w = q[3];
	float x2 = x + x;
	float y2 = y + y;
	float z2 = z + z;
	float xx = x * x2;
	float xy = x * y2;
	float xz = x * z2;
	float yy = y * y2;
	float yz = y * z2;
	float zz = z * z2;
	float wx = w * x2;
	float wy = w * y2;
	float wz = w * z2;
	output[0] = 1 - (yy + zz);
	output[3] = xy + wz;
	output[6] = xz - wy;
	output[1] = xy - wz;
	output[4] = 1 - (xx + zz);
	output[7] = yz + wx;
	output[2] = xz + wy;
	output[5] = yz - wx;
	output[8] = 1 - (xx + yy);
	return output;
}

float const *Mat3_Identity_(float *output)
{
	output[0] = 1;
	output[1] = 0;
	output[2] = 0;
	output[3] = 0;
	output[4] = 1;
	output[5] = 0;
	output[6] = 0;
	output[7] = 0;
	output[8] = 1;
	return output;
}

float const *Mat3_Invert(float *output, float const *a)
{
	float a00 = a[0];
	float a01 = a[1];
	float a02 = a[2];
	float a10 = a[3];
	float a11 = a[4];
	float a12 = a[5];
	float a20 = a[6];
	float a21 = a[7];
	float a22 = a[8];
	float b01 = a22 * a11 - a12 * a21;
	float b11 = -a22 * a10 + a12 * a20;
	float b21 = a21 * a10 - a11 * a20;
	float det = a00 * b01 + a01 * b11 + a02 * b21;
	float one;
	if (det == 0) {
		return NULL;
	}
	one = 1;
	det = one / det;
	output[0] = b01 * det;
	output[1] = (-a22 * a01 + a02 * a21) * det;
	output[2] = (a12 * a01 - a02 * a11) * det;
	output[3] = b11 * det;
	output[4] = (a22 * a00 - a02 * a20) * det;
	output[5] = (-a12 * a00 + a02 * a10) * det;
	output[6] = b21 * det;
	output[7] = (-a21 * a00 + a01 * a20) * det;
	output[8] = (a11 * a00 - a01 * a10) * det;
	return output;
}

float const *Mat3_Mul(float *output, float const *a, float const *b)
{
	return Mat3_Multiply(output, a, b);
}

float const *Mat3_Multiply(float *output, float const *a, float const *b)
{
	float a00 = a[0];
	float a01 = a[1];
	float a02 = a[2];
	float a10 = a[3];
	float a11 = a[4];
	float a12 = a[5];
	float a20 = a[6];
	float a21 = a[7];
	float a22 = a[8];
	float b00 = b[0];
	float b01 = b[1];
	float b02 = b[2];
	float b10 = b[3];
	float b11 = b[4];
	float b12 = b[5];
	float b20 = b[6];
	float b21 = b[7];
	float b22 = b[8];
	output[0] = b00 * a00 + b01 * a10 + b02 * a20;
	output[1] = b00 * a01 + b01 * a11 + b02 * a21;
	output[2] = b00 * a02 + b01 * a12 + b02 * a22;
	output[3] = b10 * a00 + b11 * a10 + b12 * a20;
	output[4] = b10 * a01 + b11 * a11 + b12 * a21;
	output[5] = b10 * a02 + b11 * a12 + b12 * a22;
	output[6] = b20 * a00 + b21 * a10 + b22 * a20;
	output[7] = b20 * a01 + b21 * a11 + b22 * a21;
	output[8] = b20 * a02 + b21 * a12 + b22 * a22;
	return output;
}

float const *Mat3_NormalFromMat4(float *output, float const *a)
{
	float a00 = a[0];
	float a01 = a[1];
	float a02 = a[2];
	float a03 = a[3];
	float a10 = a[4];
	float a11 = a[5];
	float a12 = a[6];
	float a13 = a[7];
	float a20 = a[8];
	float a21 = a[9];
	float a22 = a[10];
	float a23 = a[11];
	float a30 = a[12];
	float a31 = a[13];
	float a32 = a[14];
	float a33 = a[15];
	float b00 = a00 * a11 - a01 * a10;
	float b01 = a00 * a12 - a02 * a10;
	float b02 = a00 * a13 - a03 * a10;
	float b03 = a01 * a12 - a02 * a11;
	float b04 = a01 * a13 - a03 * a11;
	float b05 = a02 * a13 - a03 * a12;
	float b06 = a20 * a31 - a21 * a30;
	float b07 = a20 * a32 - a22 * a30;
	float b08 = a20 * a33 - a23 * a30;
	float b09 = a21 * a32 - a22 * a31;
	float b10 = a21 * a33 - a23 * a31;
	float b11 = a22 * a33 - a23 * a32;
	float det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
	float one;
	if (det == 0) {
		return NULL;
	}
	one = 1;
	det = one / det;
	output[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	output[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	output[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
	output[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	output[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	output[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
	output[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	output[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	output[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
	return output;
}

float const *Mat3_Rotate(float *output, float const *a, float rad)
{
	float a00 = a[0];
	float a01 = a[1];
	float a02 = a[2];
	float a10 = a[3];
	float a11 = a[4];
	float a12 = a[5];
	float a20 = a[6];
	float a21 = a[7];
	float a22 = a[8];
	float s = Platform_Sin(rad);
	float c = Platform_Cos(rad);
	output[0] = c * a00 + s * a10;
	output[1] = c * a01 + s * a11;
	output[2] = c * a02 + s * a12;
	output[3] = c * a10 - s * a00;
	output[4] = c * a11 - s * a01;
	output[5] = c * a12 - s * a02;
	output[6] = a20;
	output[7] = a21;
	output[8] = a22;
	return output;
}

float const *Mat3_Scale(float *output, float const *a, float const *v)
{
	float x = v[0];
	float y = v[1];
	output[0] = x * a[0];
	output[1] = x * a[1];
	output[2] = x * a[2];
	output[3] = y * a[3];
	output[4] = y * a[4];
	output[5] = y * a[5];
	output[6] = a[6];
	output[7] = a[7];
	output[8] = a[8];
	return output;
}

float const *Mat3_Translate(float *output, float const *a, float const *v)
{
	float a00 = a[0];
	float a01 = a[1];
	float a02 = a[2];
	float a10 = a[3];
	float a11 = a[4];
	float a12 = a[5];
	float a20 = a[6];
	float a21 = a[7];
	float a22 = a[8];
	float x = v[0];
	float y = v[1];
	output[0] = a00;
	output[1] = a01;
	output[2] = a02;
	output[3] = a10;
	output[4] = a11;
	output[5] = a12;
	output[6] = x * a00 + y * a10 + a20;
	output[7] = x * a01 + y * a11 + a21;
	output[8] = x * a02 + y * a12 + a22;
	return output;
}

float const *Mat3_Transpose(float *output, float const *a)
{
	if (output == a) {
		float a01 = a[1];
		float a02 = a[2];
		float a12 = a[5];
		output[1] = a[3];
		output[2] = a[6];
		output[3] = a01;
		output[5] = a[7];
		output[6] = a02;
		output[7] = a12;
	}
	else {
		output[0] = a[0];
		output[1] = a[3];
		output[2] = a[6];
		output[3] = a[1];
		output[4] = a[4];
		output[5] = a[7];
		output[6] = a[2];
		output[7] = a[5];
		output[8] = a[8];
	}
	return output;
}

float const *Mat4_Adjoint(float *output, float const *a)
{
	float a00 = a[0];
	float a01 = a[1];
	float a02 = a[2];
	float a03 = a[3];
	float a10 = a[4];
	float a11 = a[5];
	float a12 = a[6];
	float a13 = a[7];
	float a20 = a[8];
	float a21 = a[9];
	float a22 = a[10];
	float a23 = a[11];
	float a30 = a[12];
	float a31 = a[13];
	float a32 = a[14];
	float a33 = a[15];
	output[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
	output[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
	output[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
	output[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
	output[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
	output[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
	output[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
	output[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
	output[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
	output[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
	output[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
	output[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
	output[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
	output[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
	output[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
	output[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
	return output;
}

float const *Mat4_CloneIt(float const *a)
{
	float *output = (float *) malloc(16 * sizeof(float ));
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	output[3] = a[3];
	output[4] = a[4];
	output[5] = a[5];
	output[6] = a[6];
	output[7] = a[7];
	output[8] = a[8];
	output[9] = a[9];
	output[10] = a[10];
	output[11] = a[11];
	output[12] = a[12];
	output[13] = a[13];
	output[14] = a[14];
	output[15] = a[15];
	return output;
}

float const *Mat4_Copy(float *output, float const *a)
{
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	output[3] = a[3];
	output[4] = a[4];
	output[5] = a[5];
	output[6] = a[6];
	output[7] = a[7];
	output[8] = a[8];
	output[9] = a[9];
	output[10] = a[10];
	output[11] = a[11];
	output[12] = a[12];
	output[13] = a[13];
	output[14] = a[14];
	output[15] = a[15];
	return output;
}

float *Mat4_Create(void)
{
	float *output = (float *) malloc(16 * sizeof(float ));
	output[0] = 1;
	output[1] = 0;
	output[2] = 0;
	output[3] = 0;
	output[4] = 0;
	output[5] = 1;
	output[6] = 0;
	output[7] = 0;
	output[8] = 0;
	output[9] = 0;
	output[10] = 1;
	output[11] = 0;
	output[12] = 0;
	output[13] = 0;
	output[14] = 0;
	output[15] = 1;
	return output;
}

float Mat4_Determinant(float const *a)
{
	float a00 = a[0];
	float a01 = a[1];
	float a02 = a[2];
	float a03 = a[3];
	float a10 = a[4];
	float a11 = a[5];
	float a12 = a[6];
	float a13 = a[7];
	float a20 = a[8];
	float a21 = a[9];
	float a22 = a[10];
	float a23 = a[11];
	float a30 = a[12];
	float a31 = a[13];
	float a32 = a[14];
	float a33 = a[15];
	float b00 = a00 * a11 - a01 * a10;
	float b01 = a00 * a12 - a02 * a10;
	float b02 = a00 * a13 - a03 * a10;
	float b03 = a01 * a12 - a02 * a11;
	float b04 = a01 * a13 - a03 * a11;
	float b05 = a02 * a13 - a03 * a12;
	float b06 = a20 * a31 - a21 * a30;
	float b07 = a20 * a32 - a22 * a30;
	float b08 = a20 * a33 - a23 * a30;
	float b09 = a21 * a32 - a22 * a31;
	float b10 = a21 * a33 - a23 * a31;
	float b11 = a22 * a33 - a23 * a32;
	return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}

float const *Mat4_FromQuat(float *output, float const *q)
{
	float x = q[0];
	float y = q[1];
	float z = q[2];
	float w = q[3];
	float x2 = x + x;
	float y2 = y + y;
	float z2 = z + z;
	float xx = x * x2;
	float xy = x * y2;
	float xz = x * z2;
	float yy = y * y2;
	float yz = y * z2;
	float zz = z * z2;
	float wx = w * x2;
	float wy = w * y2;
	float wz = w * z2;
	output[0] = 1 - (yy + zz);
	output[1] = xy + wz;
	output[2] = xz - wy;
	output[3] = 0;
	output[4] = xy - wz;
	output[5] = 1 - (xx + zz);
	output[6] = yz + wx;
	output[7] = 0;
	output[8] = xz + wy;
	output[9] = yz - wx;
	output[10] = 1 - (xx + yy);
	output[11] = 0;
	output[12] = 0;
	output[13] = 0;
	output[14] = 0;
	output[15] = 1;
	return output;
}

float const *Mat4_FromRotationTranslation(float *output, float const *q, float const *v)
{
	float x = q[0];
	float y = q[1];
	float z = q[2];
	float w = q[3];
	float x2 = x + x;
	float y2 = y + y;
	float z2 = z + z;
	float xx = x * x2;
	float xy = x * y2;
	float xz = x * z2;
	float yy = y * y2;
	float yz = y * z2;
	float zz = z * z2;
	float wx = w * x2;
	float wy = w * y2;
	float wz = w * z2;
	output[0] = 1 - (yy + zz);
	output[1] = xy + wz;
	output[2] = xz - wy;
	output[3] = 0;
	output[4] = xy - wz;
	output[5] = 1 - (xx + zz);
	output[6] = yz + wx;
	output[7] = 0;
	output[8] = xz + wy;
	output[9] = yz - wx;
	output[10] = 1 - (xx + yy);
	output[11] = 0;
	output[12] = v[0];
	output[13] = v[1];
	output[14] = v[2];
	output[15] = 1;
	return output;
}

float const *Mat4_Frustum(float *output, float left, float right, float bottom, float top, float near, float far)
{
	float rl = 1 / (right - left);
	float tb = 1 / (top - bottom);
	float nf = 1 / (near - far);
	output[0] = near * 2 * rl;
	output[1] = 0;
	output[2] = 0;
	output[3] = 0;
	output[4] = 0;
	output[5] = near * 2 * tb;
	output[6] = 0;
	output[7] = 0;
	output[8] = (right + left) * rl;
	output[9] = (top + bottom) * tb;
	output[10] = (far + near) * nf;
	output[11] = -1;
	output[12] = 0;
	output[13] = 0;
	output[14] = far * near * 2 * nf;
	output[15] = 0;
	return output;
}

float const *Mat4_Identity_(float *output)
{
	output[0] = 1;
	output[1] = 0;
	output[2] = 0;
	output[3] = 0;
	output[4] = 0;
	output[5] = 1;
	output[6] = 0;
	output[7] = 0;
	output[8] = 0;
	output[9] = 0;
	output[10] = 1;
	output[11] = 0;
	output[12] = 0;
	output[13] = 0;
	output[14] = 0;
	output[15] = 1;
	return output;
}

float const *Mat4_Invert(float *output, float const *a)
{
	float a00 = a[0];
	float a01 = a[1];
	float a02 = a[2];
	float a03 = a[3];
	float a10 = a[4];
	float a11 = a[5];
	float a12 = a[6];
	float a13 = a[7];
	float a20 = a[8];
	float a21 = a[9];
	float a22 = a[10];
	float a23 = a[11];
	float a30 = a[12];
	float a31 = a[13];
	float a32 = a[14];
	float a33 = a[15];
	float b00 = a00 * a11 - a01 * a10;
	float b01 = a00 * a12 - a02 * a10;
	float b02 = a00 * a13 - a03 * a10;
	float b03 = a01 * a12 - a02 * a11;
	float b04 = a01 * a13 - a03 * a11;
	float b05 = a02 * a13 - a03 * a12;
	float b06 = a20 * a31 - a21 * a30;
	float b07 = a20 * a32 - a22 * a30;
	float b08 = a20 * a33 - a23 * a30;
	float b09 = a21 * a32 - a22 * a31;
	float b10 = a21 * a33 - a23 * a31;
	float b11 = a22 * a33 - a23 * a32;
	float det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
	float one;
	if (det == 0) {
		return NULL;
	}
	one = 1;
	det = one / det;
	output[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	output[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	output[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	output[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
	output[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	output[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	output[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	output[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
	output[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
	output[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
	output[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
	output[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
	output[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
	output[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
	output[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
	output[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
	return output;
}

float const *Mat4_LookAt(float *output, float const *eye, float const *center, float const *up)
{
	float x0;
	float x1;
	float x2;
	float y0;
	float y1;
	float y2;
	float z0;
	float z1;
	float z2;
	float len;
	float eyex = eye[0];
	float eyey = eye[1];
	float eyez = eye[2];
	float upx = up[0];
	float upy = up[1];
	float upz = up[2];
	float centerx = center[0];
	float centery = center[1];
	float centerz = center[2];
	if (GlMatrixMath_Abs(eyex - centerx) < GlMatrixMath_GLMAT_EPSILON() && GlMatrixMath_Abs(eyey - centery) < GlMatrixMath_GLMAT_EPSILON() && GlMatrixMath_Abs(eyez - centerz) < GlMatrixMath_GLMAT_EPSILON()) {
		return Mat4_Identity_(output);
	}
	z0 = eyex - centerx;
	z1 = eyey - centery;
	z2 = eyez - centerz;
	len = 1 / Platform_Sqrt(z0 * z0 + z1 * z1 + z2 * z2);
	z0 *= len;
	z1 *= len;
	z2 *= len;
	x0 = upy * z2 - upz * z1;
	x1 = upz * z0 - upx * z2;
	x2 = upx * z1 - upy * z0;
	len = Platform_Sqrt(x0 * x0 + x1 * x1 + x2 * x2);
	if (len == 0) {
		x0 = 0;
		x1 = 0;
		x2 = 0;
	}
	else {
		len = 1 / len;
		x0 *= len;
		x1 *= len;
		x2 *= len;
	}
	y0 = z1 * x2 - z2 * x1;
	y1 = z2 * x0 - z0 * x2;
	y2 = z0 * x1 - z1 * x0;
	len = Platform_Sqrt(y0 * y0 + y1 * y1 + y2 * y2);
	if (len == 0) {
		y0 = 0;
		y1 = 0;
		y2 = 0;
	}
	else {
		len = 1 / len;
		y0 *= len;
		y1 *= len;
		y2 *= len;
	}
	output[0] = x0;
	output[1] = y0;
	output[2] = z0;
	output[3] = 0;
	output[4] = x1;
	output[5] = y1;
	output[6] = z1;
	output[7] = 0;
	output[8] = x2;
	output[9] = y2;
	output[10] = z2;
	output[11] = 0;
	output[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
	output[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
	output[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
	output[15] = 1;
	return output;
}

float const *Mat4_Mul(float *output, float const *a, float const *b)
{
	return Mat4_Multiply(output, a, b);
}

float const *Mat4_Multiply(float *output, float const *a, float const *b)
{
	float a00 = a[0];
	float a01 = a[1];
	float a02 = a[2];
	float a03 = a[3];
	float a10 = a[4];
	float a11 = a[5];
	float a12 = a[6];
	float a13 = a[7];
	float a20 = a[8];
	float a21 = a[9];
	float a22 = a[10];
	float a23 = a[11];
	float a30 = a[12];
	float a31 = a[13];
	float a32 = a[14];
	float a33 = a[15];
	float b0 = b[0];
	float b1 = b[1];
	float b2 = b[2];
	float b3 = b[3];
	output[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	output[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	output[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	output[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	b0 = b[4];
	b1 = b[5];
	b2 = b[6];
	b3 = b[7];
	output[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	output[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	output[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	output[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	b0 = b[8];
	b1 = b[9];
	b2 = b[10];
	b3 = b[11];
	output[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	output[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	output[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	output[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	b0 = b[12];
	b1 = b[13];
	b2 = b[14];
	b3 = b[15];
	output[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	output[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	output[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	output[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	return output;
}

float const *Mat4_Ortho(float *output, float left, float right, float bottom, float top, float near, float far)
{
	float lr = 1 / (left - right);
	float bt = 1 / (bottom - top);
	float nf = 1 / (near - far);
	output[0] = -2 * lr;
	output[1] = 0;
	output[2] = 0;
	output[3] = 0;
	output[4] = 0;
	output[5] = -2 * bt;
	output[6] = 0;
	output[7] = 0;
	output[8] = 0;
	output[9] = 0;
	output[10] = 2 * nf;
	output[11] = 0;
	output[12] = (left + right) * lr;
	output[13] = (top + bottom) * bt;
	output[14] = (far + near) * nf;
	output[15] = 1;
	return output;
}

float const *Mat4_Perspective(float *output, float fovy, float aspect, float near, float far)
{
	float one = 1;
	float f = one / Platform_Tan(fovy / 2);
	float nf = 1 / (near - far);
	output[0] = f / aspect;
	output[1] = 0;
	output[2] = 0;
	output[3] = 0;
	output[4] = 0;
	output[5] = f;
	output[6] = 0;
	output[7] = 0;
	output[8] = 0;
	output[9] = 0;
	output[10] = (far + near) * nf;
	output[11] = -1;
	output[12] = 0;
	output[13] = 0;
	output[14] = 2 * far * near * nf;
	output[15] = 0;
	return output;
}

float const *Mat4_Rotate(float *output, float const *a, float rad, float const *axis)
{
	float x = axis[0];
	float y = axis[1];
	float z = axis[2];
	float len = Platform_Sqrt(x * x + y * y + z * z);
	float s;
	float c;
	float t;
	float a00;
	float a01;
	float a02;
	float a03;
	float a10;
	float a11;
	float a12;
	float a13;
	float a20;
	float a21;
	float a22;
	float a23;
	float b00;
	float b01;
	float b02;
	float b10;
	float b11;
	float b12;
	float b20;
	float b21;
	float b22;
	if (GlMatrixMath_Abs(len) < GlMatrixMath_GLMAT_EPSILON()) {
		return NULL;
	}
	len = 1 / len;
	x *= len;
	y *= len;
	z *= len;
	s = Platform_Sin(rad);
	c = Platform_Cos(rad);
	t = 1 - c;
	a00 = a[0];
	a01 = a[1];
	a02 = a[2];
	a03 = a[3];
	a10 = a[4];
	a11 = a[5];
	a12 = a[6];
	a13 = a[7];
	a20 = a[8];
	a21 = a[9];
	a22 = a[10];
	a23 = a[11];
	b00 = x * x * t + c;
	b01 = y * x * t + z * s;
	b02 = z * x * t - y * s;
	b10 = x * y * t - z * s;
	b11 = y * y * t + c;
	b12 = z * y * t + x * s;
	b20 = x * z * t + y * s;
	b21 = y * z * t - x * s;
	b22 = z * z * t + c;
	output[0] = a00 * b00 + a10 * b01 + a20 * b02;
	output[1] = a01 * b00 + a11 * b01 + a21 * b02;
	output[2] = a02 * b00 + a12 * b01 + a22 * b02;
	output[3] = a03 * b00 + a13 * b01 + a23 * b02;
	output[4] = a00 * b10 + a10 * b11 + a20 * b12;
	output[5] = a01 * b10 + a11 * b11 + a21 * b12;
	output[6] = a02 * b10 + a12 * b11 + a22 * b12;
	output[7] = a03 * b10 + a13 * b11 + a23 * b12;
	output[8] = a00 * b20 + a10 * b21 + a20 * b22;
	output[9] = a01 * b20 + a11 * b21 + a21 * b22;
	output[10] = a02 * b20 + a12 * b21 + a22 * b22;
	output[11] = a03 * b20 + a13 * b21 + a23 * b22;
	if (a != output) {
		output[12] = a[12];
		output[13] = a[13];
		output[14] = a[14];
		output[15] = a[15];
	}
	return output;
}

float const *Mat4_RotateX(float *output, float const *a, float rad)
{
	float s = Platform_Sin(rad);
	float c = Platform_Cos(rad);
	float a10 = a[4];
	float a11 = a[5];
	float a12 = a[6];
	float a13 = a[7];
	float a20 = a[8];
	float a21 = a[9];
	float a22 = a[10];
	float a23 = a[11];
	if (a != output) {
		output[0] = a[0];
		output[1] = a[1];
		output[2] = a[2];
		output[3] = a[3];
		output[12] = a[12];
		output[13] = a[13];
		output[14] = a[14];
		output[15] = a[15];
	}
	output[4] = a10 * c + a20 * s;
	output[5] = a11 * c + a21 * s;
	output[6] = a12 * c + a22 * s;
	output[7] = a13 * c + a23 * s;
	output[8] = a20 * c - a10 * s;
	output[9] = a21 * c - a11 * s;
	output[10] = a22 * c - a12 * s;
	output[11] = a23 * c - a13 * s;
	return output;
}

float const *Mat4_RotateY(float *output, float const *a, float rad)
{
	float s = Platform_Sin(rad);
	float c = Platform_Cos(rad);
	float a00 = a[0];
	float a01 = a[1];
	float a02 = a[2];
	float a03 = a[3];
	float a20 = a[8];
	float a21 = a[9];
	float a22 = a[10];
	float a23 = a[11];
	if (a != output) {
		output[4] = a[4];
		output[5] = a[5];
		output[6] = a[6];
		output[7] = a[7];
		output[12] = a[12];
		output[13] = a[13];
		output[14] = a[14];
		output[15] = a[15];
	}
	output[0] = a00 * c - a20 * s;
	output[1] = a01 * c - a21 * s;
	output[2] = a02 * c - a22 * s;
	output[3] = a03 * c - a23 * s;
	output[8] = a00 * s + a20 * c;
	output[9] = a01 * s + a21 * c;
	output[10] = a02 * s + a22 * c;
	output[11] = a03 * s + a23 * c;
	return output;
}

float const *Mat4_RotateZ(float *output, float const *a, float rad)
{
	float s = Platform_Sin(rad);
	float c = Platform_Cos(rad);
	float a00 = a[0];
	float a01 = a[1];
	float a02 = a[2];
	float a03 = a[3];
	float a10 = a[4];
	float a11 = a[5];
	float a12 = a[6];
	float a13 = a[7];
	if (a != output) {
		output[8] = a[8];
		output[9] = a[9];
		output[10] = a[10];
		output[11] = a[11];
		output[12] = a[12];
		output[13] = a[13];
		output[14] = a[14];
		output[15] = a[15];
	}
	output[0] = a00 * c + a10 * s;
	output[1] = a01 * c + a11 * s;
	output[2] = a02 * c + a12 * s;
	output[3] = a03 * c + a13 * s;
	output[4] = a10 * c - a00 * s;
	output[5] = a11 * c - a01 * s;
	output[6] = a12 * c - a02 * s;
	output[7] = a13 * c - a03 * s;
	return output;
}

float const *Mat4_Scale(float *output, float const *a, float const *v)
{
	float x = v[0];
	float y = v[1];
	float z = v[2];
	output[0] = a[0] * x;
	output[1] = a[1] * x;
	output[2] = a[2] * x;
	output[3] = a[3] * x;
	output[4] = a[4] * y;
	output[5] = a[5] * y;
	output[6] = a[6] * y;
	output[7] = a[7] * y;
	output[8] = a[8] * z;
	output[9] = a[9] * z;
	output[10] = a[10] * z;
	output[11] = a[11] * z;
	output[12] = a[12];
	output[13] = a[13];
	output[14] = a[14];
	output[15] = a[15];
	return output;
}

float const *Mat4_Translate(float *output, float const *a, float const *v)
{
	float x = v[0];
	float y = v[1];
	float z = v[2];
	float a00;
	float a01;
	float a02;
	float a03;
	float a10;
	float a11;
	float a12;
	float a13;
	float a20;
	float a21;
	float a22;
	float a23;
	if (a == output) {
		output[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
		output[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
		output[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
		output[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
	}
	else {
		a00 = a[0];
		a01 = a[1];
		a02 = a[2];
		a03 = a[3];
		a10 = a[4];
		a11 = a[5];
		a12 = a[6];
		a13 = a[7];
		a20 = a[8];
		a21 = a[9];
		a22 = a[10];
		a23 = a[11];
		output[0] = a00;
		output[1] = a01;
		output[2] = a02;
		output[3] = a03;
		output[4] = a10;
		output[5] = a11;
		output[6] = a12;
		output[7] = a13;
		output[8] = a20;
		output[9] = a21;
		output[10] = a22;
		output[11] = a23;
		output[12] = a00 * x + a10 * y + a20 * z + a[12];
		output[13] = a01 * x + a11 * y + a21 * z + a[13];
		output[14] = a02 * x + a12 * y + a22 * z + a[14];
		output[15] = a03 * x + a13 * y + a23 * z + a[15];
	}
	return output;
}

float const *Mat4_Transpose(float *output, float const *a)
{
	if (output == a) {
		float a01 = a[1];
		float a02 = a[2];
		float a03 = a[3];
		float a12 = a[6];
		float a13 = a[7];
		float a23 = a[11];
		output[1] = a[4];
		output[2] = a[8];
		output[3] = a[12];
		output[4] = a01;
		output[6] = a[9];
		output[7] = a[13];
		output[8] = a02;
		output[9] = a12;
		output[11] = a[14];
		output[12] = a03;
		output[13] = a13;
		output[14] = a23;
	}
	else {
		output[0] = a[0];
		output[1] = a[4];
		output[2] = a[8];
		output[3] = a[12];
		output[4] = a[1];
		output[5] = a[5];
		output[6] = a[9];
		output[7] = a[13];
		output[8] = a[2];
		output[9] = a[6];
		output[10] = a[10];
		output[11] = a[14];
		output[12] = a[3];
		output[13] = a[7];
		output[14] = a[11];
		output[15] = a[15];
	}
	return output;
}

float MathCi_AbsFloat(float b)
{
	if (b >= 0) {
		return b;
	}
	else {
		return 0 - b;
	}
}

float MathCi_ClampFloat(float value, float min, float max)
{
	float result = value;
	if (value > max) {
		result = max;
	}
	if (value < min) {
		result = min;
	}
	return result;
}

int MathCi_ClampInt(int value, int min, int max)
{
	int result = value;
	if (value > max) {
		result = max;
	}
	if (value < min) {
		result = min;
	}
	return result;
}

float MathCi_MaxFloat(float a, float b)
{
	if (a >= b) {
		return a;
	}
	else {
		return b;
	}
}

int MathCi_MaxInt(int a, int b)
{
	if (a >= b) {
		return a;
	}
	else {
		return b;
	}
}

float MathCi_MinFloat(float a, float b)
{
	if (a <= b) {
		return a;
	}
	else {
		return b;
	}
}

int MathCi_MinInt(int a, int b)
{
	if (a <= b) {
		return a;
	}
	else {
		return b;
	}
}

int MathCi_Sign(float q)
{
	if (q < 0) {
		return -1;
	}
	else if (q == 0) {
		return 0;
	}
	else {
		return 1;
	}
}

MenuState *MenuState_New(void)
{
	MenuState *self = (MenuState *) malloc(sizeof(MenuState));
	return self;
}

void MenuState_Delete(MenuState *self)
{
	free(self);
}

static void MenuWidget_Construct(MenuWidget *self)
{
	self->visible = TRUE;
	self->fontSize = 14;
	self->nextWidget = -1;
	self->hasKeyboardFocus = FALSE;
}

MenuWidget *MenuWidget_New(void)
{
	MenuWidget *self = (MenuWidget *) malloc(sizeof(MenuWidget));
	if (self != NULL)
		MenuWidget_Construct(self);
	return self;
}

void MenuWidget_Delete(MenuWidget *self)
{
	free(self);
}

void MenuWidget_GetFocus(MenuWidget *self)
{
	self->hasKeyboardFocus = TRUE;
	if (self->type == WidgetType_TEXTBOX) {
		self->editing = TRUE;
	}
}

void MenuWidget_LoseFocus(MenuWidget *self)
{
	self->hasKeyboardFocus = FALSE;
	if (self->type == WidgetType_TEXTBOX) {
		self->editing = FALSE;
	}
}

static void MeshBatcher_Construct(MeshBatcher *self)
{
	int modelsMax = 16384;
	self->models = (ListInfo const **) malloc(modelsMax * sizeof(ListInfo const *));
	{
		int i;
		for (i = 0; i < modelsMax; i++) {
			self->models[i] = ListInfo_New();
		}
	}
	self->modelsCount = 0;
	self->bindTexture = TRUE;
	self->glTextures = (int *) malloc(10 * sizeof(int ));
	self->glTexturesLength = 10;
	self->empty = (int *) malloc(modelsMax * sizeof(int ));
	self->emptyCount = 0;
}

MeshBatcher *MeshBatcher_New(void)
{
	MeshBatcher *self = (MeshBatcher *) malloc(sizeof(MeshBatcher));
	if (self != NULL)
		MeshBatcher_Construct(self);
	return self;
}

void MeshBatcher_Delete(MeshBatcher *self)
{
	free(self);
}

int MeshBatcher_Add(MeshBatcher *self, ModelData const *modelData, cibool transparent, int texture, float centerX, float centerY, float centerZ, float radius)
{
	int id;
	Model const *model;
	ListInfo *li;
	if (self->emptyCount > 0) {
		id = self->empty[self->emptyCount - 1];
		self->emptyCount--;
	}
	else {
		id = self->modelsCount;
		self->modelsCount++;
	}
	model = self->game->platform->vtbl->createModel(self->game->platform, modelData);
	li = self->models[id];
	li->indicescount = ModelData_GetIndicesCount(modelData);
	li->centerX = centerX;
	li->centerY = centerY;
	li->centerZ = centerZ;
	li->radius = radius;
	li->transparent = transparent;
	li->empty = FALSE;
	li->texture = MeshBatcher_GetTextureId(self, texture);
	li->model = model;
	return id;
}

static int MeshBatcher_ArrayIndexOf(MeshBatcher const *self, int const *glTextures, int length, int glTexture)
{
	{
		int i;
		for (i = 0; i < length; i++) {
			if (glTextures[i] == glTexture) {
				return i;
			}
		}
	}
	return -1;
}

void MeshBatcher_Clear(MeshBatcher *self)
{
	int count = self->modelsCount;
	{
		int i;
		for (i = 0; i < count; i++) {
			if (!self->models[i]->empty) {
				MeshBatcher_Remove(self, i);
			}
		}
	}
}

void MeshBatcher_Draw(MeshBatcher *self, float playerPositionX, float playerPositionY, float playerPositionZ)
{
	MeshBatcher_UpdateCulling(self);
	MeshBatcher_SortListsByTexture(self);
	{
		int i;
		for (i = 0; i < 10; i++) {
			if (self->tocallSolid[i]->count == 0) {
				continue;
			}
			if (self->bindTexture) {
				self->game->platform->vtbl->bindTexture2d(self->game->platform, self->glTextures[i]);
			}
			Game_DrawModels(self->game, self->tocallSolid[i]->lists, self->tocallSolid[i]->count);
		}
	}
	self->game->platform->vtbl->glDisableCullFace(self->game->platform);
	{
		int i;
		for (i = 0; i < 10; i++) {
			if (self->tocallTransparent[i]->count == 0) {
				continue;
			}
			if (self->bindTexture) {
				self->game->platform->vtbl->bindTexture2d(self->game->platform, self->glTextures[i]);
			}
			Game_DrawModels(self->game, self->tocallTransparent[i]->lists, self->tocallTransparent[i]->count);
		}
	}
	self->game->platform->vtbl->glEnableCullFace(self->game->platform);
}

static int MeshBatcher_GetTextureId(MeshBatcher *self, int glTexture)
{
	int id = MeshBatcher_ArrayIndexOf(self, self->glTextures, self->glTexturesLength, glTexture);
	int increase;
	int *glTextures2;
	if (id != -1) {
		return id;
	}
	id = MeshBatcher_ArrayIndexOf(self, self->glTextures, self->glTexturesLength, 0);
	if (id != -1) {
		self->glTextures[id] = glTexture;
		return id;
	}
	increase = 10;
	glTextures2 = (int *) malloc((self->glTexturesLength + increase) * sizeof(int ));
	{
		int i;
		for (i = 0; i < self->glTexturesLength; i++) {
			glTextures2[i] = self->glTextures[i];
		}
	}
	self->glTextures = glTextures2;
	self->glTexturesLength = self->glTexturesLength + increase;
	self->glTextures[self->glTexturesLength - increase] = glTexture;
	return self->glTexturesLength - increase;
}

void MeshBatcher_Remove(MeshBatcher *self, int id)
{
	self->game->platform->vtbl->deleteModel(self->game->platform, self->models[id]->model);
	self->models[id]->empty = TRUE;
	self->empty[self->emptyCount++] = id;
}

static void MeshBatcher_SortListsByTexture(MeshBatcher *self)
{
	if (self->tocallSolid == NULL) {
		self->tocallSolid = (ToCall const **) malloc(10 * sizeof(ToCall const *));
		self->tocallTransparent = (ToCall const **) malloc(10 * sizeof(ToCall const *));
		{
			int i;
			for (i = 0; i < 10; i++) {
				self->tocallSolid[i] = ToCall_New();
				self->tocallTransparent[i] = ToCall_New();
			}
		}
		{
			int i;
			for (i = 0; i < 10; i++) {
				int max = 256;
				self->tocallSolid[i]->lists = (Model const **) malloc(max * sizeof(Model const *));
				self->tocallSolid[i]->max = max;
				self->tocallTransparent[i]->lists = (Model const **) malloc(max * sizeof(Model const *));
				self->tocallTransparent[i]->max = max;
			}
		}
	}
	{
		int i;
		for (i = 0; i < 10; i++) {
			self->tocallSolid[i]->count = 0;
			self->tocallTransparent[i]->count = 0;
		}
	}
	{
		int i;
		for (i = 0; i < self->modelsCount; i++) {
			ListInfo const *li = self->models[i];
			ToCall *tocall;
			if (!li->render) {
				continue;
			}
			if (li->empty) {
				continue;
			}
			if (!li->transparent) {
				tocall = self->tocallSolid[li->texture];
			}
			else {
				tocall = self->tocallTransparent[li->texture];
			}
			if (tocall->count >= tocall->max) {
				Model const *const *old = tocall->lists;
				Model const **new_ = (Model const **) malloc(tocall->max * 2 * sizeof(Model const *));
				{
					int k;
					for (k = 0; k < tocall->max; k++) {
						new_[k] = old[k];
					}
				}
				tocall->lists = new_;
				tocall->max = tocall->max * 2;
			}
			tocall->lists[tocall->count++] = self->models[i]->model;
		}
	}
}

int MeshBatcher_TotalTriangleCount(MeshBatcher const *self)
{
	int sum = 0;
	int count = self->modelsCount;
	{
		int i;
		for (i = 0; i < count; i++) {
			if (!self->models[i]->empty) {
				ListInfo const *li = self->models[i];
				if (li->render) {
					sum += li->indicescount;
				}
			}
		}
	}
	return sum / 3;
}

static void MeshBatcher_UpdateCulling(MeshBatcher const *self)
{
	int licount = self->modelsCount;
	{
		int i;
		for (i = 0; i < licount; i++) {
			ListInfo *li = self->models[i];
			float centerX = li->centerX;
			float centerY = li->centerY;
			float centerZ = li->centerZ;
			li->render = FrustumCulling_SphereInFrustum(self->d_FrustumCulling, centerX, centerY, centerZ, li->radius);
		}
	}
}

Minecart *Minecart_New(void)
{
	Minecart *self = (Minecart *) malloc(sizeof(Minecart));
	return self;
}

void Minecart_Delete(Minecart *self)
{
	free(self);
}

cibool MiscCi_ReadBool(const char *str)
{
	if (str == NULL) {
		return FALSE;
	}
	else {
		return strcmp(str, "0") != 0 && strcmp(str, "false") != 0 && strcmp(str, "False") != 0 && strcmp(str, "FALSE") != 0;
	}
}

unsigned char const *MiscCi_UshortArrayToByteArray(int const *input, int inputLength)
{
	int outputLength = inputLength * 2;
	unsigned char *output = (unsigned char *) malloc(outputLength * sizeof(unsigned char ));
	{
		int i;
		for (i = 0; i < inputLength; i++) {
			output[i * 2] = Game_IntToByte(input[i] & 255);
			output[i * 2 + 1] = Game_IntToByte((input[i] >> 8) & 255);
		}
	}
	return output;
}

float MiscCi_Vec3Length(float x, float y, float z)
{
	return Platform_Sqrt(x * x + y * y + z * z);
}

static void ModAudio_Construct(ModAudio *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModAudio;
	ClientMod_Construct(&self->base, vtbl);
	self->audioData = DictionaryStringAudioData_New();
	self->wasLoaded = FALSE;
}

ModAudio *ModAudio_New(void)
{
	ModAudio *self = (ModAudio *) malloc(sizeof(ModAudio));
	if (self != NULL)
		ModAudio_Construct(self, NULL);
	return self;
}

void ModAudio_Delete(ModAudio *self)
{
	free(self);
}

static AudioData const *ModAudio_GetAudioData(ModAudio const *self, Game const *game, const char *sound)
{
	if (!DictionaryStringAudioData_Contains(self->audioData, sound)) {
		AudioData const *a = game->platform->vtbl->audioDataCreate(game->platform, Game_GetFile(game, sound), Game_GetFileLength(game, sound));
		DictionaryStringAudioData_Set(self->audioData, sound, a);
	}
	return DictionaryStringAudioData_GetById(self->audioData, DictionaryStringAudioData_GetId(self->audioData, sound));
}

void ModAudio_OnNewFrame(ModAudio *self, Game const *game, NewFrameEventArgs const *args)
{
	if (game->assetsLoadProgress->value != 1) {
		return;
	}
	if (!self->wasLoaded) {
		self->wasLoaded = TRUE;
		ModAudio_Preload(self, game);
	}
	{
		int i;
		for (i = 0; i < game->audio->soundsCount; i++) {
			Sound_ *sound = game->audio->sounds[i];
			AudioData const *data;
			if (sound == NULL) {
				continue;
			}
			if (sound->audio != NULL) {
				continue;
			}
			data = ModAudio_GetAudioData(self, game, sound->name);
			if (game->platform->vtbl->audioDataLoaded(game->platform, data)) {
				sound->audio = game->platform->vtbl->audioCreate(game->platform, data);
				game->platform->vtbl->audioPlay(game->platform, sound->audio);
			}
		}
	}
	{
		int i;
		for (i = 0; i < game->audio->soundsCount; i++) {
			Sound_ const *sound = game->audio->sounds[i];
			if (sound == NULL) {
				continue;
			}
			if (sound->audio == NULL) {
				continue;
			}
			game->platform->vtbl->audioSetPosition(game->platform, sound->audio, sound->x, sound->y, sound->z);
		}
	}
	{
		int i;
		for (i = 0; i < game->audio->soundsCount; i++) {
			Sound_ const *sound = game->audio->sounds[i];
			if (sound == NULL) {
				continue;
			}
			if (sound->audio == NULL) {
				continue;
			}
			if (sound->stop) {
				game->platform->vtbl->audioDelete(game->platform, sound->audio);
				game->audio->sounds[i] = NULL;
			}
		}
	}
	{
		int i;
		for (i = 0; i < game->audio->soundsCount; i++) {
			Sound_ *sound = game->audio->sounds[i];
			if (sound == NULL) {
				continue;
			}
			if (sound->audio == NULL) {
				continue;
			}
			if (sound->loop) {
				if (game->platform->vtbl->audioFinished(game->platform, sound->audio) && sound->loop) {
					AudioData const *data = ModAudio_GetAudioData(self, game, sound->name);
					if (game->platform->vtbl->audioDataLoaded(game->platform, data)) {
						sound->audio = game->platform->vtbl->audioCreate(game->platform, data);
						game->platform->vtbl->audioPlay(game->platform, sound->audio);
					}
				}
			}
			else {
				if (game->platform->vtbl->audioFinished(game->platform, sound->audio)) {
					game->audio->sounds[i] = NULL;
				}
			}
		}
	}
}

static void ModAudio_Preload(ModAudio const *self, Game const *game)
{
	{
		int k;
		for (k = 0; k < game->assets->count; k++) {
			const char *s = game->assets->items[k]->name;
			const char *sound = game->platform->vtbl->stringReplace(game->platform, s, ".ogg", "");
			if (strcmp(s, sound) == 0) {
				continue;
			}
			ModAudio_GetAudioData(self, game, s);
		}
	}
}

static void ModAutoCamera_Construct(ModAutoCamera *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModAutoCamera;
	ClientMod_Construct(&self->base, vtbl);
}

ModAutoCamera *ModAutoCamera_New(void)
{
	ModAutoCamera *self = (ModAutoCamera *) malloc(sizeof(ModAutoCamera));
	if (self != NULL)
		ModAutoCamera_Construct(self, NULL);
	return self;
}

void ModAutoCamera_Delete(ModAutoCamera *self)
{
	free(self);
}

static float ModAutoCamera_Distance(ModAutoCamera const *self, CameraPoint const *a, CameraPoint const *b)
{
	float dx = a->positionGlX - b->positionGlX;
	float dy = a->positionGlY - b->positionGlY;
	float dz = a->positionGlZ - b->positionGlZ;
	return self->p->vtbl->mathSqrt(self->p, dx * dx + dy * dy + dz * dz);
}

cibool ModAutoCamera_OnClientCommand(ModAutoCamera *self, Game const *game, ClientCommandArgs const *args)
{
	if (strcmp(args->command, "cam") == 0) {
		IntRef const *argumentsLength = IntRef_New();
		const char *const *arguments = self->p->vtbl->stringSplit(self->p, args->arguments, " ", argumentsLength);
		if (strcmp(self->p->vtbl->stringTrim(self->p, args->arguments), "") == 0) {
			self->m->vtbl->displayNotification(self->m, "&6AutoCamera help.");
			self->m->vtbl->displayNotification(self->m, "&6.cam p&f - add a point to path");
			self->m->vtbl->displayNotification(self->m, "&6.cam start [real seconds]&f - play the path");
			self->m->vtbl->displayNotification(self->m, "&6.cam rec [real seconds] [video seconds]&f - play and record to .avi file");
			self->m->vtbl->displayNotification(self->m, "&6.cam stop&f - stop playing and recording");
			self->m->vtbl->displayNotification(self->m, "&6.cam clear&f - remove all points from path");
			self->m->vtbl->displayNotification(self->m, "&6.cam save&f - copy path points to clipboard");
			self->m->vtbl->displayNotification(self->m, "&6.cam load [points]&f - load path points");
			return TRUE;
		}
		if (strcmp(arguments[0], "p") == 0) {
			CameraPoint *point;
			self->m->vtbl->displayNotification(self->m, "Point defined.");
			point = CameraPoint_New();
			point->positionGlX = self->m->vtbl->getLocalPositionX(self->m);
			point->positionGlY = self->m->vtbl->getLocalPositionY(self->m);
			point->positionGlZ = self->m->vtbl->getLocalPositionZ(self->m);
			point->orientationGlX = self->m->vtbl->getLocalOrientationX(self->m);
			point->orientationGlY = self->m->vtbl->getLocalOrientationY(self->m);
			point->orientationGlZ = self->m->vtbl->getLocalOrientationZ(self->m);
			self->cameraPoints[self->cameraPointsCount++] = point;
		}
		if (strcmp(arguments[0], "start") == 0 || strcmp(arguments[0], "play") == 0 || strcmp(arguments[0], "rec") == 0) {
			float totalRecTime;
			if (!self->m->vtbl->isFreemoveAllowed(self->m)) {
				self->m->vtbl->displayNotification(self->m, "Free move not allowed.");
				return TRUE;
			}
			if (self->cameraPointsCount == 0) {
				self->m->vtbl->displayNotification(self->m, "No points defined. Enter points with \".cam p\" command.");
				return TRUE;
			}
			self->playingSpeed = 1;
			totalRecTime = -1;
			if (strcmp(arguments[0], "rec") == 0) {
				if (argumentsLength->value >= 3) {
					totalRecTime = self->p->vtbl->floatParse(self->p, arguments[2]);
				}
				self->avi = self->m->vtbl->aviWriterCreate(self->m);
				self->avi->vtbl->open(self->avi, self->p->vtbl->stringFormat(self->p, "{0}.avi", self->p->vtbl->timestamp(self->p)), 60, self->m->vtbl->getWindowWidth(self->m), self->m->vtbl->getWindowHeight(self->m));
			}
			if (argumentsLength->value >= 2) {
				float totalTime = self->p->vtbl->floatParse(self->p, arguments[1]);
				self->playingSpeed = ModAutoCamera_TotalDistance(self) / totalTime;
				if (totalRecTime == -1) {
					self->recspeed = 10;
				}
				else {
					self->recspeed = totalTime / totalRecTime;
				}
			}
			self->playingTime = 0;
			self->firstFrameDone = FALSE;
			self->previousPositionX = self->m->vtbl->getLocalPositionX(self->m);
			self->previousPositionY = self->m->vtbl->getLocalPositionY(self->m);
			self->previousPositionZ = self->m->vtbl->getLocalPositionZ(self->m);
			self->previousOrientationX = self->m->vtbl->getLocalOrientationX(self->m);
			self->previousOrientationY = self->m->vtbl->getLocalOrientationY(self->m);
			self->previousOrientationZ = self->m->vtbl->getLocalOrientationZ(self->m);
			self->m->vtbl->showGui(self->m, 0);
			self->previousFreemove = self->m->vtbl->getFreemove(self->m);
			self->m->vtbl->setFreemove(self->m, 2);
			self->m->vtbl->enableCameraControl(self->m, FALSE);
		}
		if (strcmp(arguments[0], "stop") == 0) {
			self->m->vtbl->displayNotification(self->m, "Camera stopped.");
			ModAutoCamera_Stop(self);
		}
		if (strcmp(arguments[0], "clear") == 0) {
			self->m->vtbl->displayNotification(self->m, "Camera points cleared.");
			self->cameraPointsCount = 0;
			ModAutoCamera_Stop(self);
		}
		if (strcmp(arguments[0], "save") == 0) {
			const char *s = "1,";
			{
				int i;
				for (i = 0; i < self->cameraPointsCount; i++) {
					CameraPoint const *point = self->cameraPoints[i];
					s = self->p->vtbl->stringFormat2(self->p, "{0}{1},", s, self->p->vtbl->intToString(self->p, self->p->vtbl->floatToInt(self->p, point->positionGlX * 100)));
					s = self->p->vtbl->stringFormat2(self->p, "{0}{1},", s, self->p->vtbl->intToString(self->p, self->p->vtbl->floatToInt(self->p, point->positionGlY * 100)));
					s = self->p->vtbl->stringFormat2(self->p, "{0}{1},", s, self->p->vtbl->intToString(self->p, self->p->vtbl->floatToInt(self->p, point->positionGlZ * 100)));
					s = self->p->vtbl->stringFormat2(self->p, "{0}{1},", s, self->p->vtbl->intToString(self->p, self->p->vtbl->floatToInt(self->p, point->orientationGlX * 1000)));
					s = self->p->vtbl->stringFormat2(self->p, "{0}{1},", s, self->p->vtbl->intToString(self->p, self->p->vtbl->floatToInt(self->p, point->orientationGlY * 1000)));
					s = self->p->vtbl->stringFormat2(self->p, "{0}{1}", s, self->p->vtbl->intToString(self->p, self->p->vtbl->floatToInt(self->p, point->orientationGlZ * 1000)));
					if (i != self->cameraPointsCount - 1) {
						s = self->p->vtbl->stringFormat(self->p, "{0},", s);
					}
				}
			}
			self->p->vtbl->clipboardSetText(self->p, s);
			self->m->vtbl->displayNotification(self->m, "Camera points copied to clipboard.");
		}
		if (strcmp(arguments[0], "load") == 0) {
			IntRef const *pointsLength = IntRef_New();
			const char *const *points = self->p->vtbl->stringSplit(self->p, arguments[1], ",", pointsLength);
			int n = (pointsLength->value - 1) / 6;
			self->cameraPointsCount = 0;
			{
				int i;
				for (i = 0; i < n; i++) {
					CameraPoint *point = CameraPoint_New();
					point->positionGlX = self->one * self->p->vtbl->intParse(self->p, points[1 + i * 6 + 0]) / 100;
					point->positionGlY = self->one * self->p->vtbl->intParse(self->p, points[1 + i * 6 + 1]) / 100;
					point->positionGlZ = self->one * self->p->vtbl->intParse(self->p, points[1 + i * 6 + 2]) / 100;
					point->orientationGlX = self->one * self->p->vtbl->intParse(self->p, points[1 + i * 6 + 3]) / 1000;
					point->orientationGlY = self->one * self->p->vtbl->intParse(self->p, points[1 + i * 6 + 4]) / 1000;
					point->orientationGlZ = self->one * self->p->vtbl->intParse(self->p, points[1 + i * 6 + 5]) / 1000;
					self->cameraPoints[self->cameraPointsCount++] = point;
				}
			}
			self->m->vtbl->displayNotification(self->m, self->p->vtbl->stringFormat(self->p, "Camera points loaded: {0}", self->p->vtbl->intToString(self->p, n)));
		}
		return TRUE;
	}
	return FALSE;
}

void ModAutoCamera_OnNewFrame(ModAutoCamera *self, Game const *game, NewFrameEventArgs const *args)
{
	float dt = NewFrameEventArgs_GetDt(args);
	float playingDist;
	float distA;
	int foundPoint;
	if (self->playingTime == -1) {
		return;
	}
	self->playingTime += dt;
	playingDist = self->playingTime * self->playingSpeed;
	ModAutoCamera_UpdateAvi(self, dt);
	distA = 0;
	foundPoint = -1;
	{
		int i;
		for (i = 0; i < self->cameraPointsCount - 1; i++) {
			CameraPoint const *a = self->cameraPoints[i];
			CameraPoint const *b = self->cameraPoints[i + 1];
			float dist = ModAutoCamera_Distance(self, a, b);
			if (playingDist >= distA && playingDist < distA + dist) {
				foundPoint = i;
				break;
			}
			distA += dist;
		}
	}
	if (foundPoint == -1) {
		ModAutoCamera_Stop(self);
		return;
	}
	{
		CameraPoint const *a = self->cameraPoints[foundPoint];
		CameraPoint const *b = self->cameraPoints[foundPoint + 1];
		CameraPoint const *aminus = a;
		CameraPoint const *bplus = b;
		float t;
		float x;
		float y;
		float z;
		float orientx;
		float orienty;
		float orientz;
		if (foundPoint - 1 >= 0) {
			aminus = self->cameraPoints[foundPoint - 1];
		}
		if (foundPoint + 2 < self->cameraPointsCount) {
			bplus = self->cameraPoints[foundPoint + 2];
		}
		t = (playingDist - distA) / ModAutoCamera_Distance(self, a, b);
		x = ModAutoCamera_q(t, aminus->positionGlX, a->positionGlX, b->positionGlX, bplus->positionGlX);
		y = ModAutoCamera_q(t, aminus->positionGlY, a->positionGlY, b->positionGlY, bplus->positionGlY);
		z = ModAutoCamera_q(t, aminus->positionGlZ, a->positionGlZ, b->positionGlZ, bplus->positionGlZ);
		self->m->vtbl->setLocalPosition(self->m, x, y, z);
		orientx = ModAutoCamera_q(t, aminus->orientationGlX, a->orientationGlX, b->orientationGlX, bplus->orientationGlX);
		orienty = ModAutoCamera_q(t, aminus->orientationGlY, a->orientationGlY, b->orientationGlY, bplus->orientationGlY);
		orientz = ModAutoCamera_q(t, aminus->orientationGlZ, a->orientationGlZ, b->orientationGlZ, bplus->orientationGlZ);
		self->m->vtbl->setLocalOrientation(self->m, orientx, orienty, orientz);
	}
}

void ModAutoCamera_Start(ModAutoCamera *self, ClientModManager const *modmanager)
{
	self->m = modmanager;
	self->p = modmanager->vtbl->getPlatform(modmanager);
	self->one = 1;
	self->cameraPoints = (CameraPoint const **) malloc(256 * sizeof(CameraPoint const *));
	self->cameraPointsCount = 0;
	self->playingTime = -1;
	self->position = (float *) malloc(3 * sizeof(float ));
	self->orientation = (float *) malloc(3 * sizeof(float ));
}

static void ModAutoCamera_Stop(ModAutoCamera *self)
{
	self->m->vtbl->showGui(self->m, 1);
	self->m->vtbl->enableCameraControl(self->m, TRUE);
	if (self->playingTime != -1) {
		self->m->vtbl->setFreemove(self->m, self->previousFreemove);
		self->m->vtbl->setLocalPosition(self->m, self->previousPositionX, self->previousPositionY, self->previousPositionZ);
		self->m->vtbl->setLocalOrientation(self->m, self->previousOrientationX, self->previousOrientationY, self->previousOrientationZ);
	}
	self->playingTime = -1;
	if (self->avi != NULL) {
		self->avi->vtbl->close(self->avi);
		self->avi = NULL;
	}
}

static float ModAutoCamera_TotalDistance(ModAutoCamera const *self)
{
	float totalDistance = 0;
	{
		int i;
		for (i = 0; i < self->cameraPointsCount - 1; i++) {
			CameraPoint const *a = self->cameraPoints[i];
			CameraPoint const *b = self->cameraPoints[i + 1];
			float dist = ModAutoCamera_Distance(self, a, b);
			totalDistance += dist;
		}
	}
	return totalDistance;
}

static void ModAutoCamera_UpdateAvi(ModAutoCamera *self, float dt)
{
	float totalTime;
	if (self->avi == NULL) {
		return;
	}
	if (!self->firstFrameDone) {
		self->firstFrameDone = TRUE;
		return;
	}
	self->writeAccum += dt;
	totalTime = self->playingSpeed * ModAutoCamera_TotalDistance(self);
	if (self->writeAccum >= self->one / 60 * self->recspeed) {
		BitmapCi const *bmp;
		self->writeAccum -= self->one / 60 * self->recspeed;
		bmp = self->m->vtbl->grabScreenshot(self->m);
		self->avi->vtbl->addFrame(self->avi, bmp);
		bmp->vtbl->dispose(bmp);
	}
}

float ModAutoCamera_q(float t, float p0, float p1, float p2, float p3)
{
	float one_ = 1;
	return one_ / 2 * (2 * p1 + (-p0 + p2) * t + (2 * p0 - 5 * p1 + 4 * p2 - p3) * t * t + (-p0 + 3 * p1 - 3 * p2 + p3) * t * t * t);
}

static void ModBlockDamageToPlayer_Construct(ModBlockDamageToPlayer *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModBlockDamageToPlayer;
	ClientMod_Construct(&self->base, vtbl);
	self->one = 1;
	self->blockDamageToPlayerTimer = TimerCi_Create(1, 2);
}

ModBlockDamageToPlayer *ModBlockDamageToPlayer_New(void)
{
	ModBlockDamageToPlayer *self = (ModBlockDamageToPlayer *) malloc(sizeof(ModBlockDamageToPlayer));
	if (self != NULL)
		ModBlockDamageToPlayer_Construct(self, NULL);
	return self;
}

void ModBlockDamageToPlayer_Delete(ModBlockDamageToPlayer *self)
{
	free(self);
}

void ModBlockDamageToPlayer_OnNewFrameFixed(ModBlockDamageToPlayer const *self, Game *game, NewFrameEventArgs const *args)
{
	if (game->guistate == GuiState_MAP_LOADING) {
		return;
	}
	if (Game_FollowId(game) == NULL) {
		ModBlockDamageToPlayer_UpdateBlockDamageToPlayer(self, game, NewFrameEventArgs_GetDt(args));
	}
}

static void ModBlockDamageToPlayer_UpdateBlockDamageToPlayer(ModBlockDamageToPlayer const *self, Game *game, float dt)
{
	float pX = game->player->position->x;
	float pY = game->player->position->y;
	float pZ = game->player->position->z;
	int block1;
	int block2;
	int damage;
	int deltaTime;
	pY += game->entities[game->localPlayerId]->drawModel->eyeHeight;
	block1 = 0;
	block2 = 0;
	if (Map_IsValidPos(game->map, Game_MathFloor(game, pX), Game_MathFloor(game, pZ), Game_MathFloor(game, pY))) {
		block1 = Map_GetBlock(game->map, game->platform->vtbl->floatToInt(game->platform, pX), game->platform->vtbl->floatToInt(game->platform, pZ), game->platform->vtbl->floatToInt(game->platform, pY));
	}
	if (Map_IsValidPos(game->map, Game_MathFloor(game, pX), Game_MathFloor(game, pZ), Game_MathFloor(game, pY) - 1)) {
		block2 = Map_GetBlock(game->map, game->platform->vtbl->floatToInt(game->platform, pX), game->platform->vtbl->floatToInt(game->platform, pZ), game->platform->vtbl->floatToInt(game->platform, pY) - 1);
	}
	damage = GameData_DamageToPlayer(game->d_Data)[block1] + GameData_DamageToPlayer(game->d_Data)[block2];
	if (damage > 0) {
		int hurtingBlock = block1;
		int times;
		if (hurtingBlock == 0 || GameData_DamageToPlayer(game->d_Data)[hurtingBlock] == 0) {
			hurtingBlock = block2;
		}
		times = TimerCi_Update(self->blockDamageToPlayerTimer, dt);
		{
			int i;
			for (i = 0; i < times; i++) {
				Game_ApplyDamageToPlayer(game, damage, 1, hurtingBlock);
			}
		}
	}
	deltaTime = game->platform->vtbl->floatToInt(game->platform, self->one * (game->platform->vtbl->timeMillisecondsFromStart(game->platform) - game->lastOxygenTickMilliseconds));
	if (deltaTime >= 1000) {
		if (Game_WaterSwimmingEyes(game)) {
			game->playerStats->currentOxygen -= 1;
			if (game->playerStats->currentOxygen <= 0) {
				int dmg;
				game->playerStats->currentOxygen = 0;
				dmg = game->platform->vtbl->floatToInt(game->platform, self->one * game->playerStats->maxHealth / 10);
				if (dmg < 1) {
					dmg = 1;
				}
				Game_ApplyDamageToPlayer(game, dmg, 2, block1);
			}
		}
		else {
			game->playerStats->currentOxygen = game->playerStats->maxOxygen;
		}
		if (GameVersionHelper_ServerVersionAtLeast(game->platform, game->serverGameVersion, 2014, 3, 31)) {
			Game_SendPacketClient(game, ClientPackets_Oxygen(game->playerStats->currentOxygen));
		}
		game->lastOxygenTickMilliseconds = game->platform->vtbl->timeMillisecondsFromStart(game->platform);
	}
}

static void ModBullet_Construct(ModBullet *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModBullet;
	ClientMod_Construct(&self->base, vtbl);
}

ModBullet *ModBullet_New(void)
{
	ModBullet *self = (ModBullet *) malloc(sizeof(ModBullet));
	if (self != NULL)
		ModBullet_Construct(self, NULL);
	return self;
}

void ModBullet_Delete(ModBullet *self)
{
	free(self);
}

void ModBullet_OnNewFrameDraw3d(ModBullet const *self, Game const *game, float dt)
{
	{
		int i;
		for (i = 0; i < game->entitiesCount; i++) {
			Entity const *entity = game->entities[i];
			Bullet_ *b;
			float dirX;
			float dirY;
			float dirZ;
			float length;
			float posX;
			float posY;
			float posZ;
			if (entity == NULL) {
				continue;
			}
			if (entity->bullet == NULL) {
				continue;
			}
			b = entity->bullet;
			if (b->progress < 1) {
				b->progress = 1;
			}
			dirX = b->toX - b->fromX;
			dirY = b->toY - b->fromY;
			dirZ = b->toZ - b->fromZ;
			length = Game_Dist(game, 0, 0, 0, dirX, dirY, dirZ);
			dirX /= length;
			dirY /= length;
			dirZ /= length;
			posX = b->fromX;
			posY = b->fromY;
			posZ = b->fromZ;
			posX += dirX * (b->progress + b->speed * dt);
			posY += dirY * (b->progress + b->speed * dt);
			posZ += dirZ * (b->progress + b->speed * dt);
			b->progress += b->speed * dt;
			entity->sprite->positionX = posX;
			entity->sprite->positionY = posY;
			entity->sprite->positionZ = posZ;
			if (b->progress > length) {
				game->entities[i] = NULL;
			}
		}
	}
}

static void ModCamera_Construct(ModCamera *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModCamera;
	ClientMod_Construct(&self->base, vtbl);
	self->overheadCamera_cameraEye = Vector3Ref_New();
	self->upVec3 = Vec3_FromValues(0, 1, 0);
}

ModCamera *ModCamera_New(void)
{
	ModCamera *self = (ModCamera *) malloc(sizeof(ModCamera));
	if (self != NULL)
		ModCamera_Construct(self, NULL);
	return self;
}

void ModCamera_Delete(ModCamera *self)
{
	free(self);
}

static float const *ModCamera_FppCamera(ModCamera const *self, Game *game)
{
	Vector3Ref *forward = Vector3Ref_New();
	Vector3Ref *cameraEye;
	Vector3Ref *cameraTarget;
	float playerEyeX;
	float playerEyeY;
	float playerEyeZ;
	float *ret;
	VectorTool_ToVectorInFixedSystem(0, 0, 1, game->player->position->rotx, game->player->position->roty, forward);
	cameraEye = Vector3Ref_New();
	cameraTarget = Vector3Ref_New();
	playerEyeX = game->player->position->x;
	playerEyeY = game->player->position->y + Game_GetCharacterEyesHeight(game);
	playerEyeZ = game->player->position->z;
	if (!game->eNABLE_TPP_VIEW) {
		cameraEye->x = playerEyeX;
		cameraEye->y = playerEyeY;
		cameraEye->z = playerEyeZ;
		cameraTarget->x = playerEyeX + forward->x;
		cameraTarget->y = playerEyeY + forward->y;
		cameraTarget->z = playerEyeZ + forward->z;
	}
	else {
		FloatRef *currentTppcameradistance;
		cameraEye->x = playerEyeX + forward->x * -game->tppcameradistance;
		cameraEye->y = playerEyeY + forward->y * -game->tppcameradistance;
		cameraEye->z = playerEyeZ + forward->z * -game->tppcameradistance;
		cameraTarget->x = playerEyeX;
		cameraTarget->y = playerEyeY;
		cameraTarget->z = playerEyeZ;
		currentTppcameradistance = FloatRef_Create(game->tppcameradistance);
		ModCamera_LimitThirdPersonCameraToWalls(self, game, cameraEye, cameraTarget, currentTppcameradistance);
	}
	ret = (float *) malloc(16 * sizeof(float ));
	Mat4_LookAt(ret, Vec3_FromValues(cameraEye->x, cameraEye->y, cameraEye->z), Vec3_FromValues(cameraTarget->x, cameraTarget->y, cameraTarget->z), self->upVec3);
	game->cameraEyeX = cameraEye->x;
	game->cameraEyeY = cameraEye->y;
	game->cameraEyeZ = cameraEye->z;
	return ret;
}

static void ModCamera_LimitThirdPersonCameraToWalls(ModCamera const *self, Game const *game, Vector3Ref *eye, Vector3Ref const *target, FloatRef *curtppcameradistance)
{
	float one = 1;
	Vector3Ref const *ray_start_point = target;
	Vector3Ref const *raytarget = eye;
	Line3D *pick = Line3D_New();
	float raydirX = raytarget->x - ray_start_point->x;
	float raydirY = raytarget->y - ray_start_point->y;
	float raydirZ = raytarget->z - ray_start_point->z;
	float raydirLength1 = Game_Length(game, raydirX, raydirY, raydirZ);
	IntRef *pick2Count;
	BlockPosSide const *const *pick2;
	float cameraDirectionX;
	float cameraDirectionY;
	float cameraDirectionZ;
	float raydirLength;
	raydirX /= raydirLength1;
	raydirY /= raydirLength1;
	raydirZ /= raydirLength1;
	raydirX = raydirX * (game->tppcameradistance + 1);
	raydirY = raydirY * (game->tppcameradistance + 1);
	raydirZ = raydirZ * (game->tppcameradistance + 1);
	pick->start = Vec3_FromValues(ray_start_point->x, ray_start_point->y, ray_start_point->z);
	pick->end = (float *) malloc(3 * sizeof(float ));
	pick->end[0] = ray_start_point->x + raydirX;
	pick->end[1] = ray_start_point->y + raydirY;
	pick->end[2] = ray_start_point->z + raydirZ;
	pick2Count = IntRef_New();
	pick2 = Game_Pick(game, game->s, pick, pick2Count);
	if (pick2Count->value > 0) {
		BlockPosSide const *pick2nearest = Game_Nearest(game, pick2, pick2Count->value, ray_start_point->x, ray_start_point->y, ray_start_point->z);
		float pickX = pick2nearest->blockPos[0] - target->x;
		float pickY = pick2nearest->blockPos[1] - target->y;
		float pickZ = pick2nearest->blockPos[2] - target->z;
		float pickdistance = Game_Length(game, pickX, pickY, pickZ);
		curtppcameradistance->value = MathCi_MinFloat(pickdistance - 1, curtppcameradistance->value);
		if (curtppcameradistance->value < one * 3 / 10) {
			curtppcameradistance->value = one * 3 / 10;
		}
	}
	cameraDirectionX = target->x - eye->x;
	cameraDirectionY = target->y - eye->y;
	cameraDirectionZ = target->z - eye->z;
	raydirLength = Game_Length(game, raydirX, raydirY, raydirZ);
	raydirX /= raydirLength;
	raydirY /= raydirLength;
	raydirZ /= raydirLength;
	eye->x = target->x + raydirX * curtppcameradistance->value;
	eye->y = target->y + raydirY * curtppcameradistance->value;
	eye->z = target->z + raydirZ * curtppcameradistance->value;
}

void ModCamera_OnBeforeNewFrameDraw3d(ModCamera const *self, Game *game, float deltaTime)
{
	if (game->overheadcamera) {
		game->camera = ModCamera_OverheadCamera(self, game);
	}
	else {
		game->camera = ModCamera_FppCamera(self, game);
	}
}

static float const *ModCamera_OverheadCamera(ModCamera const *self, Game *game)
{
	Vector3Ref *cameraEye;
	Vector3Ref const *cameraTarget;
	FloatRef *currentOverheadcameradistance;
	float *ret;
	Kamera_GetPosition(game->overheadcameraK, game->platform, self->overheadCamera_cameraEye);
	cameraEye = self->overheadCamera_cameraEye;
	cameraTarget = Vector3Ref_Create(game->overheadcameraK->center->x, game->overheadcameraK->center->y + Game_GetCharacterEyesHeight(game), game->overheadcameraK->center->z);
	currentOverheadcameradistance = FloatRef_Create(game->overheadcameradistance);
	ModCamera_LimitThirdPersonCameraToWalls(self, game, cameraEye, cameraTarget, currentOverheadcameradistance);
	ret = (float *) malloc(16 * sizeof(float ));
	Mat4_LookAt(ret, Vec3_FromValues(cameraEye->x, cameraEye->y, cameraEye->z), Vec3_FromValues(cameraTarget->x, cameraTarget->y, cameraTarget->z), self->upVec3);
	game->cameraEyeX = cameraEye->x;
	game->cameraEyeY = cameraEye->y;
	game->cameraEyeZ = cameraEye->z;
	return ret;
}

static void ModCameraKeys_Construct(ModCameraKeys *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModCameraKeys;
	ClientMod_Construct(&self->base, vtbl);
}

ModCameraKeys *ModCameraKeys_New(void)
{
	ModCameraKeys *self = (ModCameraKeys *) malloc(sizeof(ModCameraKeys));
	if (self != NULL)
		ModCameraKeys_Construct(self, NULL);
	return self;
}

void ModCameraKeys_Delete(ModCameraKeys *self)
{
	free(self);
}

void ModCameraKeys_OnNewFrameFixed(ModCameraKeys const *self, Game *game, NewFrameEventArgs const *args)
{
	float one = 1;
	float dt = NewFrameEventArgs_GetDt(args);
	cibool angleup;
	cibool angledown;
	float overheadcameraanglemovearea;
	float overheadcameraspeed;
	if (game->guistate == GuiState_MAP_LOADING) {
		return;
	}
	angleup = FALSE;
	angledown = FALSE;
	overheadcameraanglemovearea = one * 5 / 100;
	overheadcameraspeed = 3;
	game->controls->wantsjump = game->guistate == GuiState_NORMAL && game->guiTyping == TypingState_NONE && game->keyboardState[Game_GetKey(game, 51)];
	game->controls->wantsjumphalf = FALSE;
	game->controls->shiftkeydown = game->guistate == GuiState_NORMAL && game->guiTyping == TypingState_NONE && game->keyboardState[Game_GetKey(game, 1)];
	game->controls->movedx = 0;
	game->controls->movedy = 0;
	game->controls->moveup = FALSE;
	game->controls->movedown = FALSE;
	if (game->guistate == GuiState_NORMAL) {
		if (game->guiTyping == TypingState_NONE) {
			if (game->reachedwall_1blockhigh && (game->autoJumpEnabled || !game->platform->vtbl->isMousePointerLocked(game->platform))) {
				game->controls->wantsjump = TRUE;
			}
			if (game->reachedHalfBlock) {
				game->controls->wantsjumphalf = TRUE;
			}
			if (game->overheadcamera) {
				CameraMove *m = CameraMove_New();
				float toDest;
				if (game->keyboardState[Game_GetKey(game, 83)]) {
					Kamera_TurnRight(game->overheadcameraK, dt * overheadcameraspeed);
				}
				if (game->keyboardState[Game_GetKey(game, 86)]) {
					Kamera_TurnLeft(game->overheadcameraK, dt * overheadcameraspeed);
				}
				if (game->keyboardState[Game_GetKey(game, 105)]) {
					angleup = TRUE;
				}
				if (game->keyboardState[Game_GetKey(game, 101)]) {
					angledown = TRUE;
				}
				game->overheadcameraK->center->x = game->player->position->x;
				game->overheadcameraK->center->y = game->player->position->y;
				game->overheadcameraK->center->z = game->player->position->z;
				m->distance = game->overheadcameradistance;
				m->angleUp = angleup;
				m->angleDown = angledown;
				Kamera_Move(game->overheadcameraK, m, dt);
				toDest = Game_Dist(game, game->player->position->x, game->player->position->y, game->player->position->z, game->playerdestination->x + one / 2, game->playerdestination->y - one / 2, game->playerdestination->z + one / 2);
				if (toDest >= 1) {
					float qX;
					float qY;
					float qZ;
					float angle;
					game->controls->movedy += 1;
					if (game->reachedwall) {
						game->controls->wantsjump = TRUE;
					}
					qX = game->playerdestination->x - game->player->position->x;
					qY = game->playerdestination->y - game->player->position->y;
					qZ = game->playerdestination->z - game->player->position->z;
					angle = Game_VectorAngleGet(game, qX, qY, qZ);
					game->player->position->roty = Game_GetPi() / 2 + angle;
					game->player->position->rotx = Game_GetPi();
				}
			}
			else if (game->enable_move) {
				if (game->keyboardState[Game_GetKey(game, 105)]) {
					game->controls->movedy += 1;
				}
				if (game->keyboardState[Game_GetKey(game, 101)]) {
					game->controls->movedy += -1;
				}
				if (game->keyboardState[Game_GetKey(game, 83)]) {
					game->controls->movedx += -1;
					game->localplayeranimationhint->leanleft = TRUE;
					game->localstance = 1;
				}
				else {
					game->localplayeranimationhint->leanleft = FALSE;
				}
				if (game->keyboardState[Game_GetKey(game, 86)]) {
					game->controls->movedx += 1;
					game->localplayeranimationhint->leanright = TRUE;
					game->localstance = 2;
				}
				else {
					game->localplayeranimationhint->leanright = FALSE;
				}
				if (!game->localplayeranimationhint->leanleft && !game->localplayeranimationhint->leanright) {
					game->localstance = 0;
				}
				game->controls->movedx += game->touchMoveDx;
				game->controls->movedy += game->touchMoveDy;
			}
		}
		if (Controls_GetFreemove(game->controls) != 0 || Game_SwimmingEyes(game)) {
			if (game->guiTyping == TypingState_NONE && game->keyboardState[Game_GetKey(game, 51)]) {
				game->controls->moveup = TRUE;
			}
			if (game->guiTyping == TypingState_NONE && game->keyboardState[Game_GetKey(game, 3)]) {
				game->controls->movedown = TRUE;
			}
		}
	}
}

static void ModClearInactivePlayersDrawInfo_Construct(ModClearInactivePlayersDrawInfo *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModClearInactivePlayersDrawInfo;
	ClientMod_Construct(&self->base, vtbl);
}

ModClearInactivePlayersDrawInfo *ModClearInactivePlayersDrawInfo_New(void)
{
	ModClearInactivePlayersDrawInfo *self = (ModClearInactivePlayersDrawInfo *) malloc(sizeof(ModClearInactivePlayersDrawInfo));
	if (self != NULL)
		ModClearInactivePlayersDrawInfo_Construct(self, NULL);
	return self;
}

void ModClearInactivePlayersDrawInfo_Delete(ModClearInactivePlayersDrawInfo *self)
{
	free(self);
}

void ModClearInactivePlayersDrawInfo_OnNewFrameFixed(ModClearInactivePlayersDrawInfo const *self, Game const *game, NewFrameEventArgs const *args)
{
	float one = 1;
	int now = game->platform->vtbl->timeMillisecondsFromStart(game->platform);
	{
		int i;
		for (i = 0; i < 64; i++) {
			int kKey;
			Entity *p;
			if (game->entities[i] == NULL) {
				continue;
			}
			if (game->entities[i]->playerDrawInfo == NULL) {
				continue;
			}
			if (game->entities[i]->networkPosition == NULL) {
				continue;
			}
			kKey = i;
			p = game->entities[i];
			if (one * (now - p->networkPosition->lastUpdateMilliseconds) / 1000 > 2) {
				p->playerDrawInfo = NULL;
				p->networkPosition->positionLoaded = FALSE;
			}
		}
	}
}

static void ModCompass_Construct(ModCompass *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModCompass;
	ClientMod_Construct(&self->base, vtbl);
	self->one = 1;
	self->compassid = -1;
	self->needleid = -1;
	self->compassangle = 0;
	self->compassvertex = 1;
}

ModCompass *ModCompass_New(void)
{
	ModCompass *self = (ModCompass *) malloc(sizeof(ModCompass));
	if (self != NULL)
		ModCompass_Construct(self, NULL);
	return self;
}

void ModCompass_Delete(ModCompass *self)
{
	free(self);
}

static cibool ModCompass_CompassInActiveMaterials(ModCompass const *self, Game const *game)
{
	{
		int i;
		for (i = 0; i < 10; i++) {
			if (Game_MaterialSlots_(game, i) == GameData_BlockIdCompass(game->d_Data)) {
				return TRUE;
			}
		}
	}
	return FALSE;
}

void ModCompass_DrawCompass(ModCompass *self, Game *game)
{
	float size;
	float posX;
	float posY;
	float playerorientation;
	if (!ModCompass_CompassInActiveMaterials(self, game))
		return;
	if (self->compassid == -1) {
		self->compassid = Game_GetTexture(game, "compass.png");
		self->needleid = Game_GetTexture(game, "compassneedle.png");
	}
	size = 175;
	posX = Game_Width(game) - 100;
	posY = 100;
	playerorientation = -(game->player->position->roty / (2 * Game_GetPi()) * 360);
	self->compassvertex += (playerorientation - self->compassangle) / 50;
	self->compassvertex *= self->one * 9 / 10;
	self->compassangle += self->compassvertex;
	Game_Draw2dTexture(game, self->compassid, posX - size / 2, posY - size / 2, size, size, NULL, 0, Game_ColorFromArgb(255, 255, 255, 255), FALSE);
	Game_GLPushMatrix(game);
	Game_GLTranslate(game, posX, posY, 0);
	Game_GLRotate(game, self->compassangle, 0, 0, 90);
	Game_GLTranslate(game, -size / 2, -size / 2, 0);
	Game_Draw2dTexture(game, self->needleid, 0, 0, size, size, NULL, 0, Game_ColorFromArgb(255, 255, 255, 255), FALSE);
	Game_GLPopMatrix(game);
}

void ModCompass_OnNewFrameDraw2d(ModCompass *self, Game *game, float dt)
{
	if (game->guistate == GuiState_MAP_LOADING) {
		return;
	}
	ModCompass_DrawCompass(self, game);
}

static void ModDebugChunk_Construct(ModDebugChunk *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModDebugChunk;
	ClientMod_Construct(&self->base, vtbl);
	self->draw = FALSE;
	self->lines = DrawWireframeCube_New();
}

ModDebugChunk *ModDebugChunk_New(void)
{
	ModDebugChunk *self = (ModDebugChunk *) malloc(sizeof(ModDebugChunk));
	if (self != NULL)
		ModDebugChunk_Construct(self, NULL);
	return self;
}

void ModDebugChunk_Delete(ModDebugChunk *self)
{
	free(self);
}

cibool ModDebugChunk_OnClientCommand(ModDebugChunk *self, Game const *game, ClientCommandArgs const *args)
{
	if (strcmp(args->command, "chunk") == 0) {
		self->draw = !self->draw;
		return TRUE;
	}
	return FALSE;
}

void ModDebugChunk_OnNewFrameDraw3d(ModDebugChunk const *self, Game const *game, float deltaTime)
{
	if (self->draw) {
		DrawWireframeCube_DrawWireframeCube_(self->lines, game, game->platform->vtbl->floatToInt(game->platform, game->player->position->x / 16) * 16 + 8, game->platform->vtbl->floatToInt(game->platform, game->player->position->y / 16) * 16 + 8, game->platform->vtbl->floatToInt(game->platform, game->player->position->z / 16) * 16 + 8, 16, 16, 16);
	}
}

static void ModDialog_Construct(ModDialog *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModDialog;
	ClientMod_Construct(&self->base, vtbl);
	self->packetHandler = &ClientPacketHandlerDialog_New()->base;
}

ModDialog *ModDialog_New(void)
{
	ModDialog *self = (ModDialog *) malloc(sizeof(ModDialog));
	if (self != NULL)
		ModDialog_Construct(self, NULL);
	return self;
}

void ModDialog_Delete(ModDialog *self)
{
	free(self);
}

static void ModDialog_DrawDialogs(ModDialog const *self, Game const *game)
{
	{
		int i;
		for (i = 0; i < game->dialogsCount; i++) {
			VisibleDialog const *d;
			int x;
			int y;
			if (game->dialogs[i] == NULL) {
				continue;
			}
			d = game->dialogs[i];
			x = Game_Width(game) / 2 - d->value->width / 2;
			y = Game_Height(game) / 2 - d->value->height_ / 2;
			d->screen->screenx = x;
			d->screen->screeny = y;
			GameScreen_DrawWidgets(d->screen);
		}
	}
}

void ModDialog_OnKeyDown(ModDialog const *self, Game *game, KeyEventArgs *args)
{
	{
		int i;
		for (i = 0; i < game->dialogsCount; i++) {
			if (game->dialogs[i] == NULL) {
				continue;
			}
			game->dialogs[i]->screen->base.vtbl->onKeyDown(&game->dialogs[i]->screen->base, game, args);
		}
	}
	if (game->guistate == GuiState_NORMAL) {
		if (KeyEventArgs_GetKeyCode(args) == Game_GetKey(game, 50)) {
			{
				int i;
				for (i = 0; i < game->dialogsCount; i++) {
					VisibleDialog const *d;
					if (game->dialogs[i] == NULL) {
						continue;
					}
					d = game->dialogs[i];
					if (d->value->isModal != 0) {
						game->dialogs[i] = NULL;
						return;
					}
				}
			}
			Game_ShowEscapeMenu(game);
			KeyEventArgs_SetHandled(args, TRUE);
			return;
		}
	}
	if (game->guistate == GuiState_MODAL_DIALOG) {
		if (KeyEventArgs_GetKeyCode(args) == Game_GetKey(game, 50)) {
			{
				int i;
				for (i = 0; i < game->dialogsCount; i++) {
					if (game->dialogs[i] == NULL) {
						continue;
					}
					if (game->dialogs[i]->value->isModal != 0) {
						game->dialogs[i] = NULL;
					}
				}
			}
			Game_SendPacketClient(game, ClientPackets_DialogClick("Esc", (const char **) malloc(0 * sizeof(const char *)), 0));
			Game_GuiStateBackToGame(game);
			KeyEventArgs_SetHandled(args, TRUE);
		}
		if (KeyEventArgs_GetKeyCode(args) == Game_GetKey(game, 52)) {
			Game_SendPacketClient(game, ClientPackets_DialogClick("Tab", (const char **) malloc(0 * sizeof(const char *)), 0));
			KeyEventArgs_SetHandled(args, TRUE);
		}
		return;
	}
}

void ModDialog_OnKeyPress(ModDialog const *self, Game const *game, KeyPressEventArgs const *args)
{
	if (game->guistate != GuiState_MODAL_DIALOG && game->guistate != GuiState_NORMAL) {
		return;
	}
	if (game->isTyping) {
		return;
	}
	{
		int i;
		for (i = 0; i < game->dialogsCount; i++) {
			if (game->dialogs[i] == NULL) {
				continue;
			}
			game->dialogs[i]->screen->base.vtbl->onKeyPress(&game->dialogs[i]->screen->base, game, args);
		}
	}
	{
		int k;
		for (k = 0; k < game->dialogsCount; k++) {
			VisibleDialog const *d;
			if (game->dialogs[k] == NULL) {
				continue;
			}
			d = game->dialogs[k];
			{
				int i;
				for (i = 0; i < d->value->widgetsCount; i++) {
					Packet_Widget const *w = d->value->widgets[i];
					const char *valid;
					if (w == NULL) {
						continue;
					}
					valid = "abcdefghijklmnopqrstuvwxyz1234567890\t ";
					if (game->platform->vtbl->stringContains(game->platform, valid, Game_CharToString(game, w->clickKey))) {
						if (KeyPressEventArgs_GetKeyChar(args) == w->clickKey) {
							Game_SendPacketClient(game, ClientPackets_DialogClick(w->id, (const char **) malloc(0 * sizeof(const char *)), 0));
							return;
						}
					}
				}
			}
		}
	}
}

void ModDialog_OnKeyUp(ModDialog const *self, Game const *game, KeyEventArgs const *args)
{
	{
		int i;
		for (i = 0; i < game->dialogsCount; i++) {
			if (game->dialogs[i] == NULL) {
				continue;
			}
			(&game->dialogs[i]->screen->base)->vtbl->onKeyUp(&game->dialogs[i]->screen->base, game, args);
		}
	}
}

void ModDialog_OnMouseDown(ModDialog const *self, Game const *game, MouseEventArgs const *args)
{
	{
		int i;
		for (i = 0; i < game->dialogsCount; i++) {
			if (game->dialogs[i] == NULL) {
				continue;
			}
			game->dialogs[i]->screen->base.vtbl->onMouseDown(&game->dialogs[i]->screen->base, game, args);
		}
	}
}

void ModDialog_OnMouseUp(ModDialog const *self, Game const *game, MouseEventArgs const *args)
{
	{
		int i;
		for (i = 0; i < game->dialogsCount; i++) {
			if (game->dialogs[i] == NULL) {
				continue;
			}
			game->dialogs[i]->screen->base.vtbl->onMouseUp(&game->dialogs[i]->screen->base, game, args);
		}
	}
}

void ModDialog_OnNewFrameDraw2d(ModDialog const *self, Game const *game, float deltaTime)
{
	game->packetHandlers[52] = self->packetHandler;
	ModDialog_DrawDialogs(self, game);
}

static void ModDraw2dMisc_Construct(ModDraw2dMisc *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModDraw2dMisc;
	ClientMod_Construct(&self->base, vtbl);
}

ModDraw2dMisc *ModDraw2dMisc_New(void)
{
	ModDraw2dMisc *self = (ModDraw2dMisc *) malloc(sizeof(ModDraw2dMisc));
	if (self != NULL)
		ModDraw2dMisc_Construct(self, NULL);
	return self;
}

void ModDraw2dMisc_Delete(ModDraw2dMisc *self)
{
	free(self);
}

static void ModDraw2dMisc_DrawAim(ModDraw2dMisc const *self, Game *game)
{
	int aimwidth;
	int aimheight;
	if (game->cameratype == CameraType_OVERHEAD) {
		return;
	}
	aimwidth = 32;
	aimheight = 32;
	game->platform->vtbl->bindTexture2d(game->platform, 0);
	if (Game_CurrentAimRadius(game) > 1) {
		float fov_ = Game_currentfov(game);
		Game_Circle3i(game, Game_Width(game) / 2, Game_Height(game) / 2, Game_CurrentAimRadius(game) * game->fov / fov_);
	}
	Game_Draw2dBitmapFile(game, "target.png", Game_Width(game) / 2 - aimwidth / 2, Game_Height(game) / 2 - aimheight / 2, aimwidth, aimheight);
}

static void ModDraw2dMisc_DrawAmmo(ModDraw2dMisc const *self, Game *game)
{
	Packet_Item const *item = game->d_Inventory->rightHand[game->activeMaterial];
	if (item != NULL && item->itemClass == 0) {
		if (game->blocktypes[item->blockId]->isPistol) {
			int loaded = game->loadedAmmo[item->blockId];
			int total = game->totalAmmo[item->blockId];
			const char *s = game->platform->vtbl->stringFormat2(game->platform, "{0}/{1}", game->platform->vtbl->intToString(game->platform, loaded), game->platform->vtbl->intToString(game->platform, total - loaded));
			FontCi *font = FontCi_New();
			font->family = "Arial";
			font->size = 18;
			Game_Draw2dText(game, s, font, Game_Width(game) - Game_TextSizeWidth(game, s, 18) - 50, Game_Height(game) - Game_TextSizeHeight(game, s, 18) - 50, loaded == 0 ? IntRef_Create(Game_ColorFromArgb(255, 255, 0, 0)) : IntRef_Create(Game_ColorFromArgb(255, 255, 255, 255)), FALSE);
			if (loaded == 0) {
				const char *pressR;
				font->size = 14;
				pressR = "Press R to reload";
				Game_Draw2dText(game, pressR, font, Game_Width(game) - Game_TextSizeWidth(game, pressR, 14) - 50, Game_Height(game) - Game_TextSizeHeight(game, s, 14) - 80, IntRef_Create(Game_ColorFromArgb(255, 255, 0, 0)), FALSE);
			}
		}
	}
}

void ModDraw2dMisc_DrawBlockInfo(ModDraw2dMisc const *self, Game *game)
{
	int x;
	int y;
	int z;
	int blocktype;
	if (!game->drawblockinfo) {
		return;
	}
	x = game->selectedBlockPositionX;
	y = game->selectedBlockPositionZ;
	z = game->selectedBlockPositionY;
	if (!Map_IsValidPos(game->map, x, y, z)) {
		return;
	}
	blocktype = Map_GetBlock(game->map, x, y, z);
	if (!Game_IsValid(game, blocktype)) {
		return;
	}
	game->currentAttackedBlock = Vector3IntRef_Create(x, y, z);
	ModDraw2dMisc_DrawEnemyHealthBlock(self, game);
}

static void ModDraw2dMisc_DrawDisconnected(ModDraw2dMisc const *self, Game *game)
{
	float one = 1;
	float lagSeconds = one * (game->platform->vtbl->timeMillisecondsFromStart(game->platform) - game->lastReceivedMilliseconds) / 1000;
	if (lagSeconds >= 10 && lagSeconds < 86400 && game->invalidVersionDrawMessage == NULL && !(game->issingleplayer && !game->platform->vtbl->singlePlayerServerLoaded(game->platform))) {
		FontCi *font;
		Game_Draw2dBitmapFile(game, "disconnected.png", Game_Width(game) - 100, 50, 50, 50);
		font = FontCi_New();
		font->family = "Arial";
		font->size = 12;
		Game_Draw2dText(game, game->platform->vtbl->intToString(game->platform, game->platform->vtbl->floatToInt(game->platform, lagSeconds)), font, Game_Width(game) - 100, 110, NULL, FALSE);
		Game_Draw2dText(game, "Press F6 to reconnect", font, Game_Width(game) / 2 - 100, 50, NULL, FALSE);
	}
}

static void ModDraw2dMisc_DrawEnemyHealthBlock(ModDraw2dMisc const *self, Game *game)
{
	if (game->currentAttackedBlock != NULL) {
		int x = game->currentAttackedBlock->x;
		int y = game->currentAttackedBlock->y;
		int z = game->currentAttackedBlock->z;
		int blocktype = Map_GetBlock(game->map, x, y, z);
		float health = Game_GetCurrentBlockHealth(game, x, y, z);
		float progress = health / GameData_Strength(game->d_Data)[blocktype];
		if (Game_IsUsableBlock(game, blocktype)) {
			ModDraw2dMisc_DrawEnemyHealthUseInfo(self, game, Language_Get(game->language, StringTools_StringAppend(game->platform, "Block_", game->blocktypes[blocktype]->name)), progress, TRUE);
		}
		ModDraw2dMisc_DrawEnemyHealthCommon(self, game, Language_Get(game->language, StringTools_StringAppend(game->platform, "Block_", game->blocktypes[blocktype]->name)), progress);
	}
	if (game->currentlyAttackedEntity != -1) {
		Entity const *e = game->entities[game->currentlyAttackedEntity];
		float health;
		const char *name;
		if (e == NULL) {
			return;
		}
		if (e->playerStats != NULL) {
			health = game->one * e->playerStats->currentHealth / e->playerStats->maxHealth;
		}
		else {
			health = 1;
		}
		name = "Unknown";
		if (e->drawName != NULL) {
			name = e->drawName->name;
		}
		if (e->usable) {
			ModDraw2dMisc_DrawEnemyHealthUseInfo(self, game, Language_Get(game->language, name), health, TRUE);
		}
		ModDraw2dMisc_DrawEnemyHealthCommon(self, game, Language_Get(game->language, name), health);
	}
}

static void ModDraw2dMisc_DrawEnemyHealthCommon(ModDraw2dMisc const *self, Game *game, const char *name, float progress)
{
	ModDraw2dMisc_DrawEnemyHealthUseInfo(self, game, name, 1, FALSE);
}

static void ModDraw2dMisc_DrawEnemyHealthUseInfo(ModDraw2dMisc const *self, Game *game, const char *name, float progress, cibool useInfo)
{
	int y = useInfo ? 55 : 35;
	FontCi *font;
	IntRef const *w;
	IntRef const *h;
	Game_Draw2dTexture(game, Game_WhiteTexture(game), Game_xcenter(game, 300), 40, 300, y, NULL, 0, Game_ColorFromArgb(255, 0, 0, 0), FALSE);
	Game_Draw2dTexture(game, Game_WhiteTexture(game), Game_xcenter(game, 300), 40, 300 * progress, y, NULL, 0, Game_ColorFromArgb(255, 255, 0, 0), FALSE);
	font = FontCi_New();
	font->family = "Arial";
	font->size = 14;
	w = IntRef_New();
	h = IntRef_New();
	game->platform->vtbl->textSize(game->platform, name, 14, w, h);
	Game_Draw2dText(game, name, font, Game_xcenter(game, w->value), 40, NULL, FALSE);
	if (useInfo) {
		FontCi *font2;
		name = game->platform->vtbl->stringFormat(game->platform, Language_PressToUse(game->language), "E");
		game->platform->vtbl->textSize(game->platform, name, 10, w, h);
		font2 = FontCi_New();
		font2->family = "Arial";
		font2->size = 10;
		Game_Draw2dText(game, name, font2, Game_xcenter(game, w->value), 70, NULL, FALSE);
	}
}

static void ModDraw2dMisc_DrawLocalPosition(ModDraw2dMisc const *self, Game *game)
{
	float one = 1;
	if (game->eNABLE_DRAWPOSITION) {
		float heading = one * Game_HeadingByte(game, game->player->position->rotx, game->player->position->roty, game->player->position->rotz);
		float pitch = one * Game_PitchByte(game, game->player->position->rotx, game->player->position->roty, game->player->position->rotz);
		const char *postext = game->platform->vtbl->stringFormat(game->platform, "X: {0}", game->platform->vtbl->intToString(game->platform, Game_MathFloor(game, game->player->position->x)));
		FontCi *font;
		postext = StringTools_StringAppend(game->platform, postext, ",\tY: ");
		postext = StringTools_StringAppend(game->platform, postext, game->platform->vtbl->intToString(game->platform, Game_MathFloor(game, game->player->position->z)));
		postext = StringTools_StringAppend(game->platform, postext, ",\tZ: ");
		postext = StringTools_StringAppend(game->platform, postext, game->platform->vtbl->intToString(game->platform, Game_MathFloor(game, game->player->position->y)));
		postext = StringTools_StringAppend(game->platform, postext, "\nHeading: ");
		postext = StringTools_StringAppend(game->platform, postext, game->platform->vtbl->intToString(game->platform, Game_MathFloor(game, heading)));
		postext = StringTools_StringAppend(game->platform, postext, "\nPitch: ");
		postext = StringTools_StringAppend(game->platform, postext, game->platform->vtbl->intToString(game->platform, Game_MathFloor(game, pitch)));
		font = FontCi_New();
		font->family = "Arial";
		font->size = 11;
		Game_Draw2dText(game, postext, font, 100, 460, NULL, FALSE);
	}
}

static void ModDraw2dMisc_DrawMouseCursor(ModDraw2dMisc const *self, Game *game)
{
	if (!Game_GetFreeMouse(game)) {
		return;
	}
	if (!game->platform->vtbl->mouseCursorIsVisible(game->platform)) {
		Game_Draw2dBitmapFile(game, "mousecursor.png", game->mouseCurrentX, game->mouseCurrentY, 32, 32);
	}
}

void ModDraw2dMisc_OnNewFrameDraw2d(ModDraw2dMisc const *self, Game *game, float deltaTime)
{
	if (game->guistate == GuiState_NORMAL) {
		ModDraw2dMisc_DrawAim(self, game);
	}
	if (game->guistate != GuiState_MAP_LOADING) {
		ModDraw2dMisc_DrawEnemyHealthBlock(self, game);
		ModDraw2dMisc_DrawAmmo(self, game);
		ModDraw2dMisc_DrawLocalPosition(self, game);
		ModDraw2dMisc_DrawBlockInfo(self, game);
	}
	ModDraw2dMisc_DrawMouseCursor(self, game);
	ModDraw2dMisc_DrawDisconnected(self, game);
}

static void ModDrawArea_Construct(ModDrawArea *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModDrawArea;
	ClientMod_Construct(&self->base, vtbl);
}

ModDrawArea *ModDrawArea_New(void)
{
	ModDrawArea *self = (ModDrawArea *) malloc(sizeof(ModDrawArea));
	if (self != NULL)
		ModDrawArea_Construct(self, NULL);
	return self;
}

void ModDrawArea_Delete(ModDrawArea *self)
{
	free(self);
}

void ModDrawArea_OnHitEntity(ModDrawArea const *self, Game const *game, OnUseEntityArgs const *e)
{
	Entity const *entity = game->entities[e->entityId];
	if (entity == NULL) {
		return;
	}
	if (entity->drawArea == NULL) {
		return;
	}
	entity->drawArea->visible = !entity->drawArea->visible;
}

void ModDrawArea_OnNewFrameDraw3d(ModDrawArea const *self, Game const *game, float deltaTime)
{
	if (game->eNABLE_DRAW2D) {
		{
			int i;
			for (i = 0; i < game->entitiesCount; i++) {
				Entity const *e = game->entities[i];
				int x;
				int y;
				int z;
				float scalex;
				float scaley;
				float scalez;
				if (e == NULL) {
					continue;
				}
				if (e->drawArea == NULL) {
					continue;
				}
				if (!e->drawArea->visible) {
					continue;
				}
				x = e->drawArea->x + e->drawArea->sizex / 2;
				y = e->drawArea->y + e->drawArea->sizey / 2;
				z = e->drawArea->z + e->drawArea->sizez / 2;
				scalex = e->drawArea->sizex;
				scaley = e->drawArea->sizey;
				scalez = e->drawArea->sizez;
				DrawWireframeCube_DrawWireframeCube_(self->lines, game, x, y, z, scalex, scaley, scalez);
			}
		}
	}
}

void ModDrawArea_OnNewFrameFixed(ModDrawArea *self, Game const *game, NewFrameEventArgs const *args)
{
	self->lines = DrawWireframeCube_New();
}

static void ModDrawHand2d_Construct(ModDrawHand2d *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModDrawHand2d;
	ClientMod_Construct(&self->base, vtbl);
}

ModDrawHand2d *ModDrawHand2d_New(void)
{
	ModDrawHand2d *self = (ModDrawHand2d *) malloc(sizeof(ModDrawHand2d));
	if (self != NULL)
		ModDrawHand2d_Construct(self, NULL);
	return self;
}

void ModDrawHand2d_Delete(ModDrawHand2d *self)
{
	free(self);
}

const char *ModDrawHand2d_HandImage2d(Game const *game)
{
	Packet_Item const *item = game->d_Inventory->rightHand[game->activeMaterial];
	const char *img = NULL;
	if (item != NULL) {
		img = game->blocktypes[item->blockId]->handimage;
		if (game->ironSights) {
			img = game->blocktypes[item->blockId]->ironSightsImage;
		}
	}
	return img;
}

void ModDrawHand2d_OnNewFrameDraw3d(ModDrawHand2d *self, Game *game, float deltaTime)
{
	if (ModDrawHand2d_ShouldDrawHand(game)) {
		const char *img = ModDrawHand2d_HandImage2d(game);
		if (img != NULL) {
			Game_OrthoMode(game, Game_Width(game), Game_Height(game));
			if (strcmp(self->lasthandimage, img) != 0) {
				unsigned char const *file;
				BitmapCi const *bmp;
				self->lasthandimage = img;
				file = Game_GetFile(game, img);
				bmp = game->platform->vtbl->bitmapCreateFromPng(game->platform, file, game->platform->vtbl->byteArrayLength(game->platform, file));
				if (bmp != NULL) {
					game->handTexture = game->platform->vtbl->loadTextureFromBitmap(game->platform, bmp);
					game->platform->vtbl->bitmapDelete(game->platform, bmp);
				}
			}
			Game_Draw2dTexture(game, game->handTexture, Game_Width(game) / 2, Game_Height(game) - 512, 512, 512, NULL, 0, Game_ColorFromArgb(255, 255, 255, 255), FALSE);
			Game_PerspectiveMode(game);
		}
	}
}

cibool ModDrawHand2d_ShouldDrawHand(Game const *game)
{
	return !game->eNABLE_TPP_VIEW && game->eNABLE_DRAW2D;
}

static void ModDrawHand3d_Construct(ModDrawHand3d *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModDrawHand3d;
	ClientMod_Construct(&self->base, vtbl);
	self->one = 1;
	self->attackt = 0;
	self->buildt = 0;
	self->range = self->one * 7 / 100;
	self->speed = 5;
	self->animperiod = Game_GetPi() / (self->speed / 2);
	self->zzzposz = 0;
	self->t_ = 0;
	self->zzzx = -27;
	self->zzzy = -self->one * 137 / 10;
	self->zzzposx = -self->one * 2 / 10;
	self->zzzposy = -self->one * 4 / 10;
	self->attack = -1;
	self->build = FALSE;
	self->slowdownTimerSpecial = 32000;
	self->d_BlockRendererTorch = BlockRendererTorch_New();
}

ModDrawHand3d *ModDrawHand3d_New(void)
{
	ModDrawHand3d *self = (ModDrawHand3d *) malloc(sizeof(ModDrawHand3d));
	if (self != NULL)
		ModDrawHand3d_Construct(self, NULL);
	return self;
}

void ModDrawHand3d_Delete(ModDrawHand3d *self)
{
	free(self);
}

void ModDrawHand3d_AddVertex(ModDrawHand3d const *self, ModelData *model, float x, float y, float z, float u, float v, int color)
{
	model->xyz[ModelData_GetXyzCount(model) + 0] = x;
	model->xyz[ModelData_GetXyzCount(model) + 1] = y;
	model->xyz[ModelData_GetXyzCount(model) + 2] = z;
	model->uv[ModelData_GetUvCount(model) + 0] = u;
	model->uv[ModelData_GetUvCount(model) + 1] = v;
	model->rgba[ModelData_GetRgbaCount(model) + 0] = Game_IntToByte(Game_ColorR(color));
	model->rgba[ModelData_GetRgbaCount(model) + 1] = Game_IntToByte(Game_ColorG(color));
	model->rgba[ModelData_GetRgbaCount(model) + 2] = Game_IntToByte(Game_ColorB(color));
	model->rgba[ModelData_GetRgbaCount(model) + 3] = Game_IntToByte(Game_ColorA(color));
	model->verticesCount++;
}

static void ModDrawHand3d_DrawCube(ModDrawHand3d const *self, ModelData *m, int x, int y, int z, int c)
{
	{
		int sidetexture = ModDrawHand3d_GetWeaponTextureId(self, 0);
		RectFRef const *texrec = TextureAtlas_TextureCoords2d(sidetexture, ModDrawHand3d_texturesPacked(self));
		int lastelement = ModelData_GetVerticesCount(m);
		ModDrawHand3d_AddVertex(self, m, x + 0, z + 1, y + 0, RectFRef_Left(texrec), RectFRef_Top(texrec), c);
		ModDrawHand3d_AddVertex(self, m, x + 0, z + 1, y + 1, RectFRef_Left(texrec), RectFRef_Bottom(texrec), c);
		ModDrawHand3d_AddVertex(self, m, x + 1, z + 1, y + 0, RectFRef_Right(texrec), RectFRef_Top(texrec), c);
		ModDrawHand3d_AddVertex(self, m, x + 1, z + 1, y + 1, RectFRef_Right(texrec), RectFRef_Bottom(texrec), c);
		m->indices[m->indicesCount++] = lastelement + 0;
		m->indices[m->indicesCount++] = lastelement + 1;
		m->indices[m->indicesCount++] = lastelement + 2;
		m->indices[m->indicesCount++] = lastelement + 1;
		m->indices[m->indicesCount++] = lastelement + 3;
		m->indices[m->indicesCount++] = lastelement + 2;
	}
	{
		int sidetexture = ModDrawHand3d_GetWeaponTextureId(self, 1);
		RectFRef const *texrec = TextureAtlas_TextureCoords2d(sidetexture, ModDrawHand3d_texturesPacked(self));
		int lastelement = ModelData_GetVerticesCount(m);
		ModDrawHand3d_AddVertex(self, m, x + 0, z, y + 0, RectFRef_Left(texrec), RectFRef_Top(texrec), c);
		ModDrawHand3d_AddVertex(self, m, x + 0, z, y + 1, RectFRef_Left(texrec), RectFRef_Bottom(texrec), c);
		ModDrawHand3d_AddVertex(self, m, x + 1, z, y + 0, RectFRef_Right(texrec), RectFRef_Top(texrec), c);
		ModDrawHand3d_AddVertex(self, m, x + 1, z, y + 1, RectFRef_Right(texrec), RectFRef_Bottom(texrec), c);
		m->indices[m->indicesCount++] = lastelement + 1;
		m->indices[m->indicesCount++] = lastelement + 0;
		m->indices[m->indicesCount++] = lastelement + 2;
		m->indices[m->indicesCount++] = lastelement + 3;
		m->indices[m->indicesCount++] = lastelement + 1;
		m->indices[m->indicesCount++] = lastelement + 2;
	}
	{
		int sidetexture = ModDrawHand3d_GetWeaponTextureId(self, 2);
		RectFRef const *texrec = TextureAtlas_TextureCoords2d(sidetexture, ModDrawHand3d_texturesPacked(self));
		int lastelement = ModelData_GetVerticesCount(m);
		ModDrawHand3d_AddVertex(self, m, x + 0, z + 0, y + 0, RectFRef_Left(texrec), RectFRef_Bottom(texrec), c);
		ModDrawHand3d_AddVertex(self, m, x + 0, z + 0, y + 1, RectFRef_Right(texrec), RectFRef_Bottom(texrec), c);
		ModDrawHand3d_AddVertex(self, m, x + 0, z + 1, y + 0, RectFRef_Left(texrec), RectFRef_Top(texrec), c);
		ModDrawHand3d_AddVertex(self, m, x + 0, z + 1, y + 1, RectFRef_Right(texrec), RectFRef_Top(texrec), c);
		m->indices[m->indicesCount++] = lastelement + 0;
		m->indices[m->indicesCount++] = lastelement + 1;
		m->indices[m->indicesCount++] = lastelement + 2;
		m->indices[m->indicesCount++] = lastelement + 1;
		m->indices[m->indicesCount++] = lastelement + 3;
		m->indices[m->indicesCount++] = lastelement + 2;
	}
	{
		int sidetexture = ModDrawHand3d_GetWeaponTextureId(self, 3);
		RectFRef const *texrec = TextureAtlas_TextureCoords2d(sidetexture, ModDrawHand3d_texturesPacked(self));
		int lastelement = ModelData_GetVerticesCount(m);
		ModDrawHand3d_AddVertex(self, m, x + 1, z + 0, y + 0, RectFRef_Left(texrec), RectFRef_Bottom(texrec), c);
		ModDrawHand3d_AddVertex(self, m, x + 1, z + 0, y + 1, RectFRef_Right(texrec), RectFRef_Bottom(texrec), c);
		ModDrawHand3d_AddVertex(self, m, x + 1, z + 1, y + 0, RectFRef_Left(texrec), RectFRef_Top(texrec), c);
		ModDrawHand3d_AddVertex(self, m, x + 1, z + 1, y + 1, RectFRef_Right(texrec), RectFRef_Top(texrec), c);
		m->indices[m->indicesCount++] = lastelement + 1;
		m->indices[m->indicesCount++] = lastelement + 0;
		m->indices[m->indicesCount++] = lastelement + 2;
		m->indices[m->indicesCount++] = lastelement + 3;
		m->indices[m->indicesCount++] = lastelement + 1;
		m->indices[m->indicesCount++] = lastelement + 2;
	}
	{
		int sidetexture = ModDrawHand3d_GetWeaponTextureId(self, 4);
		RectFRef const *texrec = TextureAtlas_TextureCoords2d(sidetexture, ModDrawHand3d_texturesPacked(self));
		int lastelement = ModelData_GetVerticesCount(m);
		ModDrawHand3d_AddVertex(self, m, x + 0, z + 0, y + 0, RectFRef_Left(texrec), RectFRef_Bottom(texrec), c);
		ModDrawHand3d_AddVertex(self, m, x + 0, z + 1, y + 0, RectFRef_Left(texrec), RectFRef_Top(texrec), c);
		ModDrawHand3d_AddVertex(self, m, x + 1, z + 0, y + 0, RectFRef_Right(texrec), RectFRef_Bottom(texrec), c);
		ModDrawHand3d_AddVertex(self, m, x + 1, z + 1, y + 0, RectFRef_Right(texrec), RectFRef_Top(texrec), c);
		m->indices[m->indicesCount++] = lastelement + 0;
		m->indices[m->indicesCount++] = lastelement + 1;
		m->indices[m->indicesCount++] = lastelement + 2;
		m->indices[m->indicesCount++] = lastelement + 1;
		m->indices[m->indicesCount++] = lastelement + 3;
		m->indices[m->indicesCount++] = lastelement + 2;
	}
	{
		int sidetexture = ModDrawHand3d_GetWeaponTextureId(self, 5);
		RectFRef const *texrec = TextureAtlas_TextureCoords2d(sidetexture, ModDrawHand3d_texturesPacked(self));
		int lastelement = ModelData_GetVerticesCount(m);
		ModDrawHand3d_AddVertex(self, m, x + 0, z + 0, y + 1, RectFRef_Left(texrec), RectFRef_Bottom(texrec), c);
		ModDrawHand3d_AddVertex(self, m, x + 0, z + 1, y + 1, RectFRef_Left(texrec), RectFRef_Top(texrec), c);
		ModDrawHand3d_AddVertex(self, m, x + 1, z + 0, y + 1, RectFRef_Right(texrec), RectFRef_Bottom(texrec), c);
		ModDrawHand3d_AddVertex(self, m, x + 1, z + 1, y + 1, RectFRef_Right(texrec), RectFRef_Top(texrec), c);
		m->indices[m->indicesCount++] = lastelement + 1;
		m->indices[m->indicesCount++] = lastelement + 0;
		m->indices[m->indicesCount++] = lastelement + 2;
		m->indices[m->indicesCount++] = lastelement + 3;
		m->indices[m->indicesCount++] = lastelement + 1;
		m->indices[m->indicesCount++] = lastelement + 2;
	}
}

void ModDrawHand3d_DrawWeapon(ModDrawHand3d *self, float dt)
{
	int light;
	Packet_Item const *item;
	int curmaterial;
	float curlight;
	cibool move;
	if (ModDrawHand3d_IsTorch(self)) {
		light = 255;
	}
	else {
		light = self->game->platform->vtbl->floatToInt(self->game->platform, ModDrawHand3d_Light(self) * 256);
		if (light > 255) {
			light = 255;
		}
		if (light < 0) {
			light = 0;
		}
	}
	self->game->platform->vtbl->bindTexture2d(self->game->platform, ModDrawHand3d_terrainTexture(self));
	item = self->game->d_Inventory->rightHand[self->game->activeMaterial];
	if (item == NULL) {
		curmaterial = 0;
	}
	else {
		curmaterial = item->blockId == 151 ? 128 : item->blockId;
	}
	curlight = ModDrawHand3d_Light(self);
	if (curmaterial != self->oldMaterial || curlight != self->oldLight || self->modelData == NULL || self->game->handRedraw) {
		int x;
		int y;
		int z;
		self->game->handRedraw = FALSE;
		self->modelData = ModelData_New();
		self->modelData->indices = (int *) malloc(128 * sizeof(int ));
		self->modelData->xyz = (float *) malloc(128 * sizeof(float ));
		self->modelData->uv = (float *) malloc(128 * sizeof(float ));
		self->modelData->rgba = (unsigned char *) malloc(128 * sizeof(unsigned char ));
		x = 0;
		y = 0;
		z = 0;
		if (ModDrawHand3d_IsEmptyHand(self) || ModDrawHand3d_IsCompass(self)) {
			self->d_BlockRendererTorch->topTexture = ModDrawHand3d_GetWeaponTextureId(self, 0);
			self->d_BlockRendererTorch->sideTexture = ModDrawHand3d_GetWeaponTextureId(self, 2);
			BlockRendererTorch_AddTorch(self->d_BlockRendererTorch, self->game->d_Data, self->game, self->modelData, x, y, z, TorchType_NORMAL);
		}
		else if (ModDrawHand3d_IsTorch(self)) {
			self->d_BlockRendererTorch->topTexture = ModDrawHand3d_GetWeaponTextureId(self, 0);
			self->d_BlockRendererTorch->sideTexture = ModDrawHand3d_GetWeaponTextureId(self, 2);
			BlockRendererTorch_AddTorch(self->d_BlockRendererTorch, self->game->d_Data, self->game, self->modelData, x, y, z, TorchType_NORMAL);
		}
		else {
			ModDrawHand3d_DrawCube(self, self->modelData, x, y, z, Game_ColorFromArgb(255, light, light, light));
		}
	}
	self->oldMaterial = curmaterial;
	self->oldLight = curlight;
	self->game->platform->vtbl->glClearDepthBuffer(self->game->platform);
	Game_GLMatrixModeModelView(self->game);
	Game_GLPushMatrix(self->game);
	Game_GLLoadIdentity(self->game);
	Game_GLTranslate(self->game, self->one * 3 / 10 + self->zzzposz - self->attackt * 5, -(self->one * 15 / 10) + self->zzzposx - self->buildt * 10, -(self->one * 15 / 10) + self->zzzposy);
	Game_GLRotate(self->game, 30 + self->zzzx - self->attackt * 300, 1, 0, 0);
	Game_GLRotate(self->game, 60 + self->zzzy, 0, 1, 0);
	Game_GLScale(self->game, self->one * 8 / 10, self->one * 8 / 10, self->one * 8 / 10);
	move = !(self->oldplayerposX == self->game->player->position->x && self->oldplayerposY == self->game->player->position->y && self->oldplayerposZ == self->game->player->position->z);
	self->oldplayerposX = self->game->player->position->x;
	self->oldplayerposY = self->game->player->position->y;
	self->oldplayerposZ = self->game->player->position->z;
	if (move) {
		self->t_ += dt;
		self->slowdownTimer = self->slowdownTimerSpecial;
	}
	else {
		if (self->slowdownTimer == self->slowdownTimerSpecial) {
			self->slowdownTimer = self->animperiod / 2 - self->t_ % (self->animperiod / 2);
		}
		self->slowdownTimer -= dt;
		if (self->slowdownTimer < 0) {
			self->t_ = 0;
		}
		else {
			self->t_ += dt;
		}
	}
	self->zzzposx = ModDrawHand3d_rot(self, self->t_);
	self->zzzposz = ModDrawHand3d_rot2(self, self->t_);
	if (self->attack != -1) {
		self->attack += dt * 7;
		if (self->attack > Game_GetPi() / 2) {
			self->attack = -1;
			if (self->build) {
				self->buildt = 0;
			}
			else {
				self->attackt = 0;
			}
		}
		else {
			if (self->build) {
				self->buildt = ModDrawHand3d_rot(self, self->attack / 5);
				self->attackt = 0;
			}
			else {
				self->attackt = ModDrawHand3d_rot(self, self->attack / 5);
				self->buildt = 0;
			}
		}
	}
	self->game->platform->vtbl->glEnableTexture2d(self->game->platform);
	self->game->platform->vtbl->bindTexture2d(self->game->platform, ModDrawHand3d_terrainTexture(self));
	Game_DrawModelData(self->game, self->modelData);
	Game_GLPopMatrix(self->game);
}

int ModDrawHand3d_GetWeaponTextureId(ModDrawHand3d const *self, int side)
{
	Packet_Item const *item = self->game->d_Inventory->rightHand[self->game->activeMaterial];
	if (item == NULL || ModDrawHand3d_IsCompass(self) || (item != NULL && item->blockId == 0)) {
		if (side == 0) {
			return self->game->textureId[GameData_BlockIdEmptyHand(self->game->d_Data)][0];
		}
		return self->game->textureId[GameData_BlockIdEmptyHand(self->game->d_Data)][2];
	}
	if (item->itemClass == 0) {
		return self->game->textureId[item->blockId][side];
	}
	else {
		return 0;
	}
}

cibool ModDrawHand3d_IsCompass(ModDrawHand3d const *self)
{
	Packet_Item const *item = self->game->d_Inventory->rightHand[self->game->activeMaterial];
	return item != NULL && item->itemClass == 0 && item->blockId == GameData_BlockIdCompass(self->game->d_Data);
}

cibool ModDrawHand3d_IsEmptyHand(ModDrawHand3d const *self)
{
	Packet_Item const *item = self->game->d_Inventory->rightHand[self->game->activeMaterial];
	return item == NULL || item->blockId == 0;
}

cibool ModDrawHand3d_IsTorch(ModDrawHand3d const *self)
{
	Packet_Item const *item = self->game->d_Inventory->rightHand[self->game->activeMaterial];
	return item != NULL && item->itemClass == 0 && self->game->blocktypes[item->blockId]->drawType == 4;
}

float ModDrawHand3d_Light(ModDrawHand3d const *self)
{
	float posx = self->game->player->position->x;
	float posy = self->game->player->position->y;
	float posz = self->game->player->position->z;
	int light = Game_GetLight(self->game, self->game->platform->vtbl->floatToInt(self->game->platform, posx), self->game->platform->vtbl->floatToInt(self->game->platform, posz), self->game->platform->vtbl->floatToInt(self->game->platform, posy));
	return self->one * light / 15;
}

void ModDrawHand3d_OnNewFrameDraw3d(ModDrawHand3d *self, Game *game_, float deltaTime)
{
	if (ModDrawHand2d_ShouldDrawHand(game_)) {
		const char *img = ModDrawHand2d_HandImage2d(game_);
		if (img == NULL) {
			self->game = game_;
			if (self->game->handSetAttackBuild) {
				ModDrawHand3d_SetAttack(self, TRUE, TRUE);
				self->game->handSetAttackBuild = FALSE;
			}
			if (self->game->handSetAttackDestroy) {
				ModDrawHand3d_SetAttack(self, TRUE, FALSE);
				self->game->handSetAttackDestroy = FALSE;
			}
			ModDrawHand3d_DrawWeapon(self, deltaTime);
		}
	}
}

void ModDrawHand3d_SetAttack(ModDrawHand3d *self, cibool isattack, cibool build)
{
	self->build = build;
	if (isattack) {
		if (self->attack == -1) {
			self->attack = 0;
		}
	}
	else {
		self->attack = -1;
	}
}

static float ModDrawHand3d_rot(ModDrawHand3d const *self, float t)
{
	return self->game->platform->vtbl->mathSin(self->game->platform, t * 2 * self->speed) * self->range;
}

static float ModDrawHand3d_rot2(ModDrawHand3d const *self, float t)
{
	return self->game->platform->vtbl->mathSin(self->game->platform, (t + Game_GetPi()) * self->speed) * self->range;
}

int ModDrawHand3d_terrainTexture(ModDrawHand3d const *self)
{
	return self->game->terrainTexture;
}

int ModDrawHand3d_texturesPacked(ModDrawHand3d const *self)
{
	return Game_texturesPacked(self->game);
}

static void ModDrawLinesAroundSelectedBlock_Construct(ModDrawLinesAroundSelectedBlock *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModDrawLinesAroundSelectedBlock;
	ClientMod_Construct(&self->base, vtbl);
	self->one = 1;
	self->lines = DrawWireframeCube_New();
}

ModDrawLinesAroundSelectedBlock *ModDrawLinesAroundSelectedBlock_New(void)
{
	ModDrawLinesAroundSelectedBlock *self = (ModDrawLinesAroundSelectedBlock *) malloc(sizeof(ModDrawLinesAroundSelectedBlock));
	if (self != NULL)
		ModDrawLinesAroundSelectedBlock_Construct(self, NULL);
	return self;
}

void ModDrawLinesAroundSelectedBlock_Delete(ModDrawLinesAroundSelectedBlock *self)
{
	free(self);
}

void ModDrawLinesAroundSelectedBlock_OnNewFrameDraw3d(ModDrawLinesAroundSelectedBlock const *self, Game const *game, float deltaTime)
{
	if (game->eNABLE_DRAW2D) {
		float size = self->one * 102 / 100;
		if (game->selectedEntityId != -1) {
			Entity const *e = game->entities[game->selectedEntityId];
			if (e != NULL) {
				DrawWireframeCube_DrawWireframeCube_(self->lines, game, e->position->x, e->position->y + e->drawModel->modelHeight / 2, e->position->z, size, size * e->drawModel->modelHeight, size);
			}
		}
		else {
			if (game->selectedBlockPositionX != -1) {
				int x = game->selectedBlockPositionX;
				int y = game->selectedBlockPositionY;
				int z = game->selectedBlockPositionZ;
				float pickcubeheight = Game_getblockheight(game, game->platform->vtbl->floatToInt(game->platform, x), game->platform->vtbl->floatToInt(game->platform, z), game->platform->vtbl->floatToInt(game->platform, y));
				float posx = x + self->one / 2;
				float posy = y + pickcubeheight * self->one / 2;
				float posz = z + self->one / 2;
				float scalex = size;
				float scaley = size * pickcubeheight;
				float scalez = size;
				DrawWireframeCube_DrawWireframeCube_(self->lines, game, posx, posy, posz, scalex, scaley, scalez);
			}
		}
	}
}

static void ModDrawMain_Construct(ModDrawMain *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModDrawMain;
	ClientMod_Construct(&self->base, vtbl);
}

ModDrawMain *ModDrawMain_New(void)
{
	ModDrawMain *self = (ModDrawMain *) malloc(sizeof(ModDrawMain));
	if (self != NULL)
		ModDrawMain_Construct(self, NULL);
	return self;
}

void ModDrawMain_Delete(ModDrawMain *self)
{
	free(self);
}

void ModDrawMain_OnReadOnlyMainThread(ModDrawMain const *self, Game *game, float dt)
{
	Game_MainThreadOnRenderFrame(game, dt);
}

static void ModDrawMinecarts_Construct(ModDrawMinecarts *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModDrawMinecarts;
	ClientMod_Construct(&self->base, vtbl);
	self->minecarttexture = -1;
}

ModDrawMinecarts *ModDrawMinecarts_New(void)
{
	ModDrawMinecarts *self = (ModDrawMinecarts *) malloc(sizeof(ModDrawMinecarts));
	if (self != NULL)
		ModDrawMinecarts_Construct(self, NULL);
	return self;
}

void ModDrawMinecarts_Delete(ModDrawMinecarts *self)
{
	free(self);
}

void ModDrawMinecarts_Draw(ModDrawMinecarts *self, Game const *game, float positionX, float positionY, float positionZ, VehicleDirection12 dir, VehicleDirection12 lastdir, float progress)
{
	float one = 1;
	float pX;
	float pY;
	float pZ;
	float currot;
	float lastrot;
	float rot;
	RectangleFloat const **cc;
	if (self->minecarttexture == -1) {
		self->minecarttexture = Game_GetTexture(game, "minecart.png");
	}
	Game_GLPushMatrix(game);
	pX = positionX;
	pY = positionY;
	pZ = positionZ;
	pY += -(one * 7 / 10);
	Game_GLTranslate(game, pX, pY, pZ);
	currot = ModDrawMinecarts_vehiclerotation(self, dir);
	lastrot = ModDrawMinecarts_vehiclerotation(self, lastdir);
	rot = AngleInterpolation_InterpolateAngle360(game->platform, lastrot, currot, progress);
	Game_GLRotate(game, -rot - 90, 0, 1, 0);
	cc = CuboidRenderer_CuboidNet(8, 8, 8, 0, 0);
	CuboidRenderer_CuboidNetNormalize(cc, 32, 16);
	game->platform->vtbl->bindTexture2d(game->platform, self->minecarttexture);
	CuboidRenderer_DrawCuboid(game, -(one * 5 / 10), -(one * 3 / 10), -(one * 5 / 10), 1, 1, 1, cc, 1);
	Game_GLPopMatrix(game);
}

void ModDrawMinecarts_OnNewFrameDraw3d(ModDrawMinecarts *self, Game const *game, float deltaTime)
{
	{
		int i;
		for (i = 0; i < game->entitiesCount; i++) {
			Minecart const *m;
			if (game->entities[i] == NULL) {
				continue;
			}
			if (game->entities[i]->minecart == NULL) {
				continue;
			}
			m = game->entities[i]->minecart;
			if (!m->enabled) {
				continue;
			}
			ModDrawMinecarts_Draw(self, game, m->positionX, m->positionY, m->positionZ, m->direction, m->lastdirection, m->progress);
		}
	}
}

static float ModDrawMinecarts_vehiclerotation(ModDrawMinecarts const *self, VehicleDirection12 dir)
{
	switch (dir) {
	case VehicleDirection12_VERTICAL_UP:
		return 0;
	case VehicleDirection12_DOWN_RIGHT_RIGHT:
	case VehicleDirection12_UP_LEFT_UP:
		return 45;
	case VehicleDirection12_HORIZONTAL_RIGHT:
		return 90;
	case VehicleDirection12_UP_RIGHT_RIGHT:
	case VehicleDirection12_DOWN_LEFT_DOWN:
		return 135;
	case VehicleDirection12_VERTICAL_DOWN:
		return 180;
	case VehicleDirection12_UP_LEFT_LEFT:
	case VehicleDirection12_DOWN_RIGHT_DOWN:
		return 225;
	case VehicleDirection12_HORIZONTAL_LEFT:
		return 270;
	case VehicleDirection12_UP_RIGHT_UP:
	case VehicleDirection12_DOWN_LEFT_LEFT:
		return 315;
	default:
		return 0;
	}
}

static void ModDrawParticleEffectBlockBreak_Construct(ModDrawParticleEffectBlockBreak *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModDrawParticleEffectBlockBreak;
	ClientMod_Construct(&self->base, vtbl);
}

ModDrawParticleEffectBlockBreak *ModDrawParticleEffectBlockBreak_New(void)
{
	ModDrawParticleEffectBlockBreak *self = (ModDrawParticleEffectBlockBreak *) malloc(sizeof(ModDrawParticleEffectBlockBreak));
	if (self != NULL)
		ModDrawParticleEffectBlockBreak_Construct(self, NULL);
	return self;
}

void ModDrawParticleEffectBlockBreak_Delete(ModDrawParticleEffectBlockBreak *self)
{
	free(self);
}

void ModDrawParticleEffectBlockBreak_OnNewFrameDraw3d(ModDrawParticleEffectBlockBreak const *self, Game const *game, float deltaTime)
{
}

void ModDrawParticleEffectBlockBreak_StartParticleEffect(ModDrawParticleEffectBlockBreak const *self, float x, float y, float z)
{
}

static void ModDrawPlayerNames_Construct(ModDrawPlayerNames *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModDrawPlayerNames;
	ClientMod_Construct(&self->base, vtbl);
}

ModDrawPlayerNames *ModDrawPlayerNames_New(void)
{
	ModDrawPlayerNames *self = (ModDrawPlayerNames *) malloc(sizeof(ModDrawPlayerNames));
	if (self != NULL)
		ModDrawPlayerNames_Construct(self, NULL);
	return self;
}

void ModDrawPlayerNames_Delete(ModDrawPlayerNames *self)
{
	free(self);
}

void ModDrawPlayerNames_OnNewFrameDraw3d(ModDrawPlayerNames const *self, Game *game, float deltaTime)
{
	{
		int i;
		for (i = 0; i < game->entitiesCount; i++) {
			Entity const *e = game->entities[i];
			int kKey;
			DrawName const *p;
			float posX;
			float posY;
			float posZ;
			if (e == NULL) {
				continue;
			}
			if (e->drawName == NULL) {
				continue;
			}
			if (i == game->localPlayerId) {
				continue;
			}
			if (e->networkPosition != NULL && !e->networkPosition->positionLoaded) {
				continue;
			}
			kKey = i;
			p = game->entities[i]->drawName;
			if (p->onlyWhenSelected) {
				continue;
			}
			posX = p->textX + e->position->x;
			posY = p->textY + e->position->y + e->drawModel->modelHeight + game->one * 7 / 10;
			posZ = p->textZ + e->position->z;
			if (Game_Dist(game, game->player->position->x, game->player->position->y, game->player->position->z, posX, posY, posZ) < 20 || game->keyboardState[5] || game->keyboardState[6]) {
				const char *name = p->name;
				{
					float shadow = game->one * Game_GetLight(game, game->platform->vtbl->floatToInt(game->platform, posX), game->platform->vtbl->floatToInt(game->platform, posZ), game->platform->vtbl->floatToInt(game->platform, posY)) / 15;
					float scale;
					FontCi *font;
					Game_GLPushMatrix(game);
					Game_GLTranslate(game, posX, posY, posZ);
					ModDrawSprites_Billboard(game);
					scale = game->one * 2 / 100;
					Game_GLScale(game, scale, scale, scale);
					if (p->drawHealth) {
						Game_Draw2dTexture(game, Game_WhiteTexture(game), -26, -11, 52, 12, NULL, 0, Game_ColorFromArgb(255, 0, 0, 0), FALSE);
						Game_Draw2dTexture(game, Game_WhiteTexture(game), -25, -10, 50 * game->one * p->health, 10, NULL, 0, Game_ColorFromArgb(255, 255, 0, 0), FALSE);
					}
					font = FontCi_New();
					font->family = "Arial";
					font->size = 14;
					Game_Draw2dText(game, name, font, -Game_TextSizeWidth(game, name, 14) / 2, 0, IntRef_Create(Game_ColorFromArgb(255, 255, 255, 255)), TRUE);
					Game_GLPopMatrix(game);
				}
			}
		}
	}
}

static void ModDrawPlayers_Construct(ModDrawPlayers *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModDrawPlayers;
	ClientMod_Construct(&self->base, vtbl);
	self->one = 1;
}

ModDrawPlayers *ModDrawPlayers_New(void)
{
	ModDrawPlayers *self = (ModDrawPlayers *) malloc(sizeof(ModDrawPlayers));
	if (self != NULL)
		ModDrawPlayers_Construct(self, NULL);
	return self;
}

void ModDrawPlayers_Delete(ModDrawPlayers *self)
{
	free(self);
}

static void ModDrawPlayers_DrawPlayers(ModDrawPlayers const *self, Game *game, float dt)
{
	game->totaltimeMilliseconds = game->platform->vtbl->timeMillisecondsFromStart(game->platform);
	{
		int i;
		for (i = 0; i < game->entitiesCount; i++) {
			Entity *p_;
			int cx;
			int cy;
			int cz;
			float shadow;
			float FeetPosX;
			float FeetPosY;
			float FeetPosZ;
			AnimationHint const *animHint;
			float playerspeed_;
			if (game->entities[i] == NULL) {
				continue;
			}
			if (game->entities[i]->drawModel == NULL) {
				continue;
			}
			p_ = game->entities[i];
			if (i == game->localPlayerId && !game->eNABLE_TPP_VIEW) {
				continue;
			}
			if (p_->networkPosition != NULL && !p_->networkPosition->positionLoaded) {
				continue;
			}
			if (!FrustumCulling_SphereInFrustum(game->d_FrustumCulling, p_->position->x, p_->position->y, p_->position->z, 3)) {
				continue;
			}
			if (p_->drawModel->currentTexture == -1) {
				continue;
			}
			cx = game->platform->vtbl->floatToInt(game->platform, p_->position->x) / 16;
			cy = game->platform->vtbl->floatToInt(game->platform, p_->position->z) / 16;
			cz = game->platform->vtbl->floatToInt(game->platform, p_->position->y) / 16;
			if (Map_IsValidChunkPos(game->map, cx, cy, cz)) {
				if (!Map_IsChunkRendered(game->map, cx, cy, cz)) {
					continue;
				}
			}
			shadow = self->one * Game_GetLight(game, game->platform->vtbl->floatToInt(game->platform, p_->position->x), game->platform->vtbl->floatToInt(game->platform, p_->position->z), game->platform->vtbl->floatToInt(game->platform, p_->position->y)) / 15;
			if (p_->playerDrawInfo == NULL) {
				p_->playerDrawInfo = PlayerDrawInfo_New();
			}
			p_->playerDrawInfo->anim->light = shadow;
			FeetPosX = p_->position->x;
			FeetPosY = p_->position->y;
			FeetPosZ = p_->position->z;
			animHint = game->entities[i]->playerDrawInfo->animationHint_;
			if (i == game->localPlayerId) {
				Vector3Ref const *playerspeed;
				float playerspeedf;
				if (game->player->playerDrawInfo == NULL) {
					game->player->playerDrawInfo = PlayerDrawInfo_New();
				}
				playerspeed = Vector3Ref_Create(game->playervelocity->x / 60, game->playervelocity->y / 60, game->playervelocity->z / 60);
				playerspeedf = Vector3Ref_Length(playerspeed) * self->one * 15 / 10;
				game->player->playerDrawInfo->moves = playerspeedf != 0;
				playerspeed_ = playerspeedf;
			}
			else {
				playerspeed_ = Game_Length(game, p_->playerDrawInfo->velocityX, p_->playerDrawInfo->velocityY, p_->playerDrawInfo->velocityZ) / dt * self->one * 4 / 100;
			}
			{
				if (p_->drawModel->renderer == NULL) {
					unsigned char const *data;
					int dataLength;
					p_->drawModel->renderer = AnimatedModelRenderer_New();
					data = Game_GetFile(game, p_->drawModel->model_);
					dataLength = Game_GetFileLength(game, p_->drawModel->model_);
					if (data != NULL) {
						const char *dataString = game->platform->vtbl->stringFromUtf8ByteArray(game->platform, data, dataLength);
						AnimatedModel const *model = AnimatedModelSerializer_Deserialize(game->platform, dataString);
						AnimatedModelRenderer_Start(p_->drawModel->renderer, game, model);
					}
				}
				Game_GLPushMatrix(game);
				Game_GLTranslate(game, FeetPosX, FeetPosY, FeetPosZ);
				Game_GLRotate(game, PlayerInterpolate_RadToDeg(-p_->position->roty + Game_GetPi()), 0, 1, 0);
				game->platform->vtbl->bindTexture2d(game->platform, game->entities[i]->drawModel->currentTexture);
				AnimatedModelRenderer_Render(p_->drawModel->renderer, dt, PlayerInterpolate_RadToDeg(p_->position->rotx + Game_GetPi()), TRUE, p_->playerDrawInfo->moves, shadow);
				Game_GLPopMatrix(game);
			}
		}
	}
}

void ModDrawPlayers_OnNewFrameDraw3d(ModDrawPlayers const *self, Game *game, float deltaTime)
{
	ModDrawPlayers_DrawPlayers(self, game, deltaTime);
}

static void ModDrawSprites_Construct(ModDrawSprites *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModDrawSprites;
	ClientMod_Construct(&self->base, vtbl);
}

ModDrawSprites *ModDrawSprites_New(void)
{
	ModDrawSprites *self = (ModDrawSprites *) malloc(sizeof(ModDrawSprites));
	if (self != NULL)
		ModDrawSprites_Construct(self, NULL);
	return self;
}

void ModDrawSprites_Delete(ModDrawSprites *self)
{
	free(self);
}

void ModDrawSprites_Billboard(Game const *game)
{
	float *m = StackMatrix4_Peek(game->mvMatrix);
	float d = game->platform->vtbl->mathSqrt(game->platform, m[0] * m[0] + m[1] * m[1] + m[2] * m[2]);
	m[0] = d;
	m[1] = 0;
	m[2] = 0;
	m[3] = 0;
	m[4] = 0;
	m[5] = d;
	m[6] = 0;
	m[7] = 0;
	m[8] = 0;
	m[9] = 0;
	m[10] = d;
	m[11] = 0;
	m[12] = m[12];
	m[13] = m[13];
	m[14] = m[14];
	m[15] = 1;
	Mat4_RotateX(m, m, Game_GetPi());
	Game_GLLoadMatrix(game, m);
}

void ModDrawSprites_OnNewFrameDraw3d(ModDrawSprites const *self, Game *game, float deltaTime)
{
	float one = 1;
	{
		int i;
		for (i = 0; i < game->entitiesCount; i++) {
			Entity const *entity = game->entities[i];
			Sprite const *b;
			IntRef const *n;
			if (entity == NULL) {
				continue;
			}
			if (entity->sprite == NULL) {
				continue;
			}
			b = entity->sprite;
			Game_GLMatrixModeModelView(game);
			Game_GLPushMatrix(game);
			Game_GLTranslate(game, b->positionX, b->positionY, b->positionZ);
			ModDrawSprites_Billboard(game);
			Game_GLScale(game, one * 2 / 100, one * 2 / 100, one * 2 / 100);
			Game_GLTranslate(game, 0 - b->size / 2, 0 - b->size / 2, 0);
			n = NULL;
			if (b->animationcount > 0) {
				float progress = one - entity->expires->timeLeft / entity->expires->totalTime;
				n = IntRef_Create(game->platform->vtbl->floatToInt(game->platform, progress * (b->animationcount * b->animationcount - 1)));
			}
			Game_Draw2dTexture(game, Game_GetTexture(game, b->image), 0, 0, b->size, b->size, n, b->animationcount, Game_ColorFromArgb(255, 255, 255, 255), TRUE);
			Game_GLPopMatrix(game);
		}
	}
}

static void ModDrawTerrain_Construct(ModDrawTerrain *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModDrawTerrain;
	ClientMod_Construct(&self->base, vtbl);
	self->currentChunk = (int *) malloc(5832 * sizeof(int ));
	self->currentChunkShadows = (unsigned char *) malloc(5832 * sizeof(unsigned char ));
	self->tempnearestpos = (int *) malloc(3 * sizeof(int ));
	self->ids = (int *) malloc(1024 * sizeof(int ));
	self->idsCount = 0;
	self->redraw = (TerrainRendererRedraw const **) malloc(128 * sizeof(TerrainRendererRedraw const *));
	self->redrawCount = 0;
	self->calculateShadowslightRadius = (int *) malloc(1024 * sizeof(int ));
	self->calculateShadowsisTransparentForLight = (cibool *) malloc(1024 * sizeof(cibool ));
	self->lightBase = LightBase_New();
	self->lightBetweenChunks = LightBetweenChunks_New();
	self->lastPerformanceInfoupdateMilliseconds = 0;
	self->lastchunkupdates = 0;
	self->started = FALSE;
}

ModDrawTerrain *ModDrawTerrain_New(void)
{
	ModDrawTerrain *self = (ModDrawTerrain *) malloc(sizeof(ModDrawTerrain));
	if (self != NULL)
		ModDrawTerrain_Construct(self, NULL);
	return self;
}

void ModDrawTerrain_Delete(ModDrawTerrain *self)
{
	free(self);
}

Vector3IntRef const *const *ModDrawTerrain_BlocksAround7(Vector3IntRef const *pos)
{
	Vector3IntRef const **arr = (Vector3IntRef const **) malloc(7 * sizeof(Vector3IntRef const *));
	arr[0] = pos;
	arr[1] = Vector3IntRef_Create(pos->x + 1, pos->y + 0, pos->z + 0);
	arr[2] = Vector3IntRef_Create(pos->x - 1, pos->y + 0, pos->z + 0);
	arr[3] = Vector3IntRef_Create(pos->x + 0, pos->y + 1, pos->z + 0);
	arr[4] = Vector3IntRef_Create(pos->x + 0, pos->y - 1, pos->z + 0);
	arr[5] = Vector3IntRef_Create(pos->x + 0, pos->y + 0, pos->z + 1);
	arr[6] = Vector3IntRef_Create(pos->x + 0, pos->y + 0, pos->z - 1);
	return arr;
}

static void ModDrawTerrain_CalculateShadows(ModDrawTerrain const *self, int cx, int cy, int cz)
{
	Chunk const *chunk;
	{
		int i;
		for (i = 0; i < 1024; i++) {
			if (self->game->blocktypes[i] == NULL) {
				continue;
			}
			self->calculateShadowslightRadius[i] = self->game->blocktypes[i]->lightRadius;
			self->calculateShadowsisTransparentForLight[i] = ModDrawTerrain_IsTransparentForLight(self, i);
		}
	}
	{
		int xx;
		for (xx = 0; xx < 3; xx++) {
			{
				int yy;
				for (yy = 0; yy < 3; yy++) {
					{
						int zz;
						for (zz = 0; zz < 3; zz++) {
							int cx1 = cx + xx - 1;
							int cy1 = cy + yy - 1;
							int cz1 = cz + zz - 1;
							Chunk *c;
							if (!Map_IsValidChunkPos(self->game->map, cx1, cy1, cz1)) {
								continue;
							}
							c = Map_GetChunk(self->game->map, cx1 * self->chunksize, cy1 * self->chunksize, cz1 * self->chunksize);
							if (c->baseLightDirty) {
								LightBase_CalculateChunkBaseLight(self->lightBase, self->game, cx1, cy1, cz1, self->calculateShadowslightRadius, self->calculateShadowsisTransparentForLight);
								c->baseLightDirty = FALSE;
							}
						}
					}
				}
			}
		}
	}
	chunk = Map_GetChunk(self->game->map, cx * self->chunksize, cy * self->chunksize, cz * self->chunksize);
	if (chunk->rendered->light == NULL) {
		chunk->rendered->light = (unsigned char *) malloc(5832 * sizeof(unsigned char ));
		{
			int i;
			for (i = 0; i < 5832; i++) {
				chunk->rendered->light[i] = 15;
			}
		}
	}
	LightBetweenChunks_CalculateLightBetweenChunks(self->lightBetweenChunks, self->game, cx, cy, cz, self->calculateShadowslightRadius, self->calculateShadowsisTransparentForLight);
	{
		int i;
		for (i = 0; i < 5832; i++) {
			self->currentChunkShadows[i] = chunk->rendered->light[i];
		}
	}
}

int ModDrawTerrain_ChunkUpdates(ModDrawTerrain const *self)
{
	return self->chunkupdates;
}

static void ModDrawTerrain_Clear(ModDrawTerrain const *self)
{
	MeshBatcher_Clear(self->game->d_Batcher);
}

void ModDrawTerrain_Dispose(ModDrawTerrain const *self, Game const *game_)
{
	ModDrawTerrain_Clear(self);
}

static void ModDrawTerrain_DoRedraw(ModDrawTerrain *self, TerrainRendererRedraw const *r)
{
	Chunk const *c;
	int *idsarr;
	self->idsCount = 0;
	c = r->c;
	if (c->rendered->ids != NULL) {
		{
			int i;
			for (i = 0; i < c->rendered->idsCount; i++) {
				int loadedSubmesh = c->rendered->ids[i];
				MeshBatcher_Remove(self->game->d_Batcher, loadedSubmesh);
			}
		}
	}
	{
		int i;
		for (i = 0; i < r->dataCount; i++) {
			VerticesIndicesToLoad const *submesh = r->data[i];
			if (ModelData_GetIndicesCount(submesh->modelData) != 0) {
				float centerVecX = submesh->positionX + self->chunksize / 2;
				float centerVecY = submesh->positionZ + self->chunksize / 2;
				float centerVecZ = submesh->positionY + self->chunksize / 2;
				float radius = self->sqrt3half * self->chunksize;
				self->ids[self->idsCount++] = MeshBatcher_Add(self->game->d_Batcher, submesh->modelData, submesh->transparent, submesh->texture, centerVecX, centerVecY, centerVecZ, radius);
			}
		}
	}
	idsarr = (int *) malloc(self->idsCount * sizeof(int ));
	{
		int i;
		for (i = 0; i < self->idsCount; i++) {
			idsarr[i] = self->ids[i];
		}
	}
	c->rendered->ids = idsarr;
	c->rendered->idsCount = self->idsCount;
}

void ModDrawTerrain_DrawTerrain(ModDrawTerrain const *self)
{
	MeshBatcher_Draw(self->game->d_Batcher, self->game->player->position->x, self->game->player->position->y, self->game->player->position->z);
}

static void ModDrawTerrain_GetExtendedChunk(ModDrawTerrain const *self, int x, int y, int z)
{
	Map_GetMapPortion(self->game->map, self->currentChunk, x * self->chunksize - 1, y * self->chunksize - 1, z * self->chunksize - 1, self->chunksize + 2, self->chunksize + 2, self->chunksize + 2);
}

static cibool ModDrawTerrain_IsSolidChunk(ModDrawTerrain const *self, int const *currentChunk, int length)
{
	int block = currentChunk[0];
	{
		int i;
		for (i = 0; i < length; i++) {
			if (currentChunk[i] != currentChunk[0]) {
				return FALSE;
			}
		}
	}
	return TRUE;
}

cibool ModDrawTerrain_IsTransparentForLight(ModDrawTerrain const *self, int block)
{
	Packet_BlockType const *b = self->game->blocktypes[block];
	return b->drawType != 1 && b->drawType != 8;
}

void ModDrawTerrain_MainThreadCommit(ModDrawTerrain *self)
{
	{
		int i;
		for (i = 0; i < self->redrawCount; i++) {
			ModDrawTerrain_DoRedraw(self, self->redraw[i]);
			self->redraw[i] = NULL;
		}
	}
	self->redrawCount = 0;
}

static ModelData const *ModDrawTerrain_ModelDataClone(ModDrawTerrain const *self, ModelData const *source)
{
	ModelData *dest = ModelData_New();
	dest->xyz = (float *) malloc(ModelData_GetXyzCount(source) * sizeof(float ));
	{
		int i;
		for (i = 0; i < ModelData_GetXyzCount(source); i++) {
			dest->xyz[i] = source->xyz[i];
		}
	}
	dest->uv = (float *) malloc(ModelData_GetUvCount(source) * sizeof(float ));
	{
		int i;
		for (i = 0; i < ModelData_GetUvCount(source); i++) {
			dest->uv[i] = source->uv[i];
		}
	}
	dest->rgba = (unsigned char *) malloc(ModelData_GetRgbaCount(source) * sizeof(unsigned char ));
	{
		int i;
		for (i = 0; i < ModelData_GetRgbaCount(source); i++) {
			dest->rgba[i] = source->rgba[i];
		}
	}
	dest->indices = (int *) malloc(ModelData_GetIndicesCount(source) * sizeof(int ));
	{
		int i;
		for (i = 0; i < ModelData_GetIndicesCount(source); i++) {
			dest->indices[i] = source->indices[i];
		}
	}
	ModelData_SetVerticesCount(dest, ModelData_GetVerticesCount(source));
	ModelData_SetIndicesCount(dest, ModelData_GetIndicesCount(source));
	return dest;
}

static void ModDrawTerrain_NearestDirty(ModDrawTerrain const *self, int *nearestpos)
{
	int nearestdist = 2147483647;
	int px;
	int py;
	int pz;
	int chunksxy;
	int chunksz;
	int startx;
	int endx;
	int starty;
	int endy;
	int startz;
	int endz;
	int mapsizexchunks_;
	int mapsizeychunks_;
	nearestpos[0] = -1;
	nearestpos[1] = -1;
	nearestpos[2] = -1;
	px = self->game->platform->vtbl->floatToInt(self->game->platform, self->game->player->position->x) / self->chunksize;
	py = self->game->platform->vtbl->floatToInt(self->game->platform, self->game->player->position->z) / self->chunksize;
	pz = self->game->platform->vtbl->floatToInt(self->game->platform, self->game->player->position->y) / self->chunksize;
	chunksxy = ModDrawTerrain_mapAreaSize(self) / self->chunksize / 2;
	chunksz = ModDrawTerrain_mapAreaSizeZ(self) / self->chunksize / 2;
	startx = px - chunksxy;
	endx = px + chunksxy;
	starty = py - chunksxy;
	endy = py + chunksxy;
	startz = pz - chunksz;
	endz = pz + chunksz;
	if (startx < 0) {
		startx = 0;
	}
	if (starty < 0) {
		starty = 0;
	}
	if (startz < 0) {
		startz = 0;
	}
	if (endx >= ModDrawTerrain_mapsizexchunks(self)) {
		endx = ModDrawTerrain_mapsizexchunks(self) - 1;
	}
	if (endy >= ModDrawTerrain_mapsizeychunks(self)) {
		endy = ModDrawTerrain_mapsizeychunks(self) - 1;
	}
	if (endz >= ModDrawTerrain_mapsizezchunks(self)) {
		endz = ModDrawTerrain_mapsizezchunks(self) - 1;
	}
	mapsizexchunks_ = ModDrawTerrain_mapsizexchunks(self);
	mapsizeychunks_ = ModDrawTerrain_mapsizeychunks(self);
	{
		int x;
		for (x = startx; x <= endx; x++) {
			{
				int y;
				for (y = starty; y <= endy; y++) {
					{
						int z;
						for (z = startz; z <= endz; z++) {
							Chunk const *c = self->game->map->chunks[(z * mapsizeychunks_ + y) * mapsizexchunks_ + x];
							if (c == NULL || c->rendered == NULL) {
								continue;
							}
							if (c->rendered->dirty) {
								int dx = px - x;
								int dy = py - y;
								int dz = pz - z;
								int dist = dx * dx + dy * dy + dz * dz;
								if (dist < nearestdist) {
									nearestdist = dist;
									nearestpos[0] = x;
									nearestpos[1] = y;
									nearestpos[2] = z;
								}
							}
						}
					}
				}
			}
		}
	}
}

void ModDrawTerrain_OnNewFrameDraw3d(ModDrawTerrain *self, Game *game_, float deltaTime)
{
	self->game = game_;
	if (!self->started) {
		self->started = TRUE;
	}
	if (self->game->shouldRedrawAllBlocks) {
		self->game->shouldRedrawAllBlocks = FALSE;
		ModDrawTerrain_RedrawAllBlocks(self);
	}
	ModDrawTerrain_DrawTerrain(self);
	ModDrawTerrain_UpdatePerformanceInfo(self, deltaTime);
}

void ModDrawTerrain_OnReadOnlyBackgroundThread(ModDrawTerrain *self, Game *game_, float dt)
{
	self->game = game_;
	ModDrawTerrain_UpdateTerrain(self);
	Game_QueueActionCommit(game_, &TerrainRendererCommit_Create(self)->base);
}

void ModDrawTerrain_RedrawAllBlocks(ModDrawTerrain *self)
{
	int chunksLength;
	if (!self->terrainRendererStarted) {
		ModDrawTerrain_StartTerrain(self);
	}
	chunksLength = self->game->map->mapSizeX / self->chunksize * self->game->map->mapSizeY / self->chunksize * self->game->map->mapSizeZ / self->chunksize;
	{
		int i;
		for (i = 0; i < chunksLength; i++) {
			Chunk *c = self->game->map->chunks[i];
			if (c == NULL) {
				continue;
			}
			if (c->rendered == NULL) {
				c->rendered = RenderedChunk_New();
			}
			c->rendered->dirty = TRUE;
			c->baseLightDirty = TRUE;
		}
	}
}

static void ModDrawTerrain_RedrawChunk(ModDrawTerrain *self, int x, int y, int z)
{
	Chunk *c = self->game->map->chunks[MapUtilCi_Index3d(x, y, z, ModDrawTerrain_mapsizexchunks(self), ModDrawTerrain_mapsizeychunks(self))];
	TerrainRendererRedraw *r;
	VerticesIndicesToLoad const *const *a;
	IntRef *retCount;
	if (c == NULL) {
		return;
	}
	if (c->rendered == NULL) {
		c->rendered = RenderedChunk_New();
	}
	c->rendered->dirty = FALSE;
	self->chunkupdates++;
	ModDrawTerrain_GetExtendedChunk(self, x, y, z);
	r = TerrainRendererRedraw_New();
	r->c = c;
	a = NULL;
	retCount = IntRef_New();
	if (!ModDrawTerrain_IsSolidChunk(self, self->currentChunk, (self->chunksize + 2) * (self->chunksize + 2) * (self->chunksize + 2))) {
		ModDrawTerrain_CalculateShadows(self, x, y, z);
		a = TerrainChunkTesselatorCi_MakeChunk(self->game->d_TerrainChunkTesselator, x, y, z, self->currentChunk, self->currentChunkShadows, self->game->mLightLevels, retCount);
	}
	r->data = (VerticesIndicesToLoad const **) malloc(retCount->value * sizeof(VerticesIndicesToLoad const *));
	{
		int i;
		for (i = 0; i < retCount->value; i++) {
			r->data[i] = ModDrawTerrain_VerticesIndicesToLoadClone(self, a[i]);
		}
	}
	r->dataCount = retCount->value;
	self->redraw[self->redrawCount++] = r;
}

void ModDrawTerrain_StartTerrain(ModDrawTerrain *self)
{
	self->sqrt3half = self->game->platform->vtbl->mathSqrt(self->game->platform, 3) / 2;
	TerrainChunkTesselatorCi_Start(self->game->d_TerrainChunkTesselator);
	self->terrainRendererStarted = TRUE;
	self->chunksize = 16;
}

int ModDrawTerrain_TrianglesCount(ModDrawTerrain const *self)
{
	return MeshBatcher_TotalTriangleCount(self->game->d_Batcher);
}

static void ModDrawTerrain_UpdatePerformanceInfo(ModDrawTerrain *self, float dt)
{
	float elapsed = 1f * (self->game->platform->vtbl->timeMillisecondsFromStart(self->game->platform) - self->lastPerformanceInfoupdateMilliseconds) / 1000;
	int triangles = ModDrawTerrain_TrianglesCount(self);
	if (elapsed >= 1) {
		int chunkupdates_;
		self->lastPerformanceInfoupdateMilliseconds = self->game->platform->vtbl->timeMillisecondsFromStart(self->game->platform);
		chunkupdates_ = ModDrawTerrain_ChunkUpdates(self);
		DictionaryStringString_Set(self->game->performanceinfo, "chunk updates", self->game->platform->vtbl->stringFormat(self->game->platform, Language_ChunkUpdates(self->game->language), self->game->platform->vtbl->intToString(self->game->platform, chunkupdates_ - self->lastchunkupdates)));
		self->lastchunkupdates = ModDrawTerrain_ChunkUpdates(self);
		DictionaryStringString_Set(self->game->performanceinfo, "triangles", self->game->platform->vtbl->stringFormat(self->game->platform, Language_Triangles(self->game->language), self->game->platform->vtbl->intToString(self->game->platform, triangles)));
	}
}

void ModDrawTerrain_UpdateTerrain(ModDrawTerrain *self)
{
	int updated;
	if (!self->terrainRendererStarted) {
		return;
	}
	if (!(self->game->lastplacedblockX == -1 && self->game->lastplacedblockY == -1 && self->game->lastplacedblockZ == -1)) {
		HashSetVector3IntRef const *ChunksToRedraw = HashSetVector3IntRef_New();
		Vector3IntRef const *const *around = ModDrawTerrain_BlocksAround7(Vector3IntRef_Create(self->game->lastplacedblockX, self->game->lastplacedblockY, self->game->lastplacedblockZ));
		{
			int i;
			for (i = 0; i < 7; i++) {
				Vector3IntRef const *a = around[i];
				HashSetVector3IntRef_Set(ChunksToRedraw, Vector3IntRef_Create(a->x / self->chunksize, a->y / self->chunksize, a->z / self->chunksize));
			}
		}
		{
			int i;
			for (i = 0; i < ChunksToRedraw->max; i++) {
				int const *c;
				int xx;
				int yy;
				int zz;
				if (ChunksToRedraw->values[i] == NULL) {
					break;
				}
				c = (int *) malloc(3 * sizeof(int ));
				xx = ChunksToRedraw->values[i]->x;
				yy = ChunksToRedraw->values[i]->y;
				zz = ChunksToRedraw->values[i]->z;
				if (xx >= 0 && yy >= 0 && zz >= 0 && xx < self->game->map->mapSizeX / self->chunksize && yy < self->game->map->mapSizeY / self->chunksize && zz < self->game->map->mapSizeZ / self->chunksize) {
					Chunk const *chunk = self->game->map->chunks[(zz * ModDrawTerrain_mapsizeychunks(self) + yy) * ModDrawTerrain_mapsizexchunks(self) + xx];
					if (chunk == NULL || chunk->rendered == NULL) {
						continue;
					}
					if (chunk->rendered->dirty) {
						ModDrawTerrain_RedrawChunk(self, xx, yy, zz);
					}
				}
			}
		}
		self->game->lastplacedblockX = -1;
		self->game->lastplacedblockY = -1;
		self->game->lastplacedblockZ = -1;
	}
	updated = 0;
	for (;;) {
		ModDrawTerrain_NearestDirty(self, self->tempnearestpos);
		if (self->tempnearestpos[0] == -1 && self->tempnearestpos[1] == -1 && self->tempnearestpos[2] == -1) {
			break;
		}
		ModDrawTerrain_RedrawChunk(self, self->tempnearestpos[0], self->tempnearestpos[1], self->tempnearestpos[2]);
		{
			break;
		}
	}
}

static VerticesIndicesToLoad const *ModDrawTerrain_VerticesIndicesToLoadClone(ModDrawTerrain const *self, VerticesIndicesToLoad const *source)
{
	VerticesIndicesToLoad *dest = VerticesIndicesToLoad_New();
	dest->modelData = ModDrawTerrain_ModelDataClone(self, source->modelData);
	dest->positionX = source->positionX;
	dest->positionY = source->positionY;
	dest->positionZ = source->positionZ;
	dest->texture = source->texture;
	dest->transparent = source->transparent;
	return dest;
}

static int ModDrawTerrain_mapAreaSize(ModDrawTerrain const *self)
{
	return self->game->platform->vtbl->floatToInt(self->game->platform, self->game->d_Config3d->viewdistance) * 2;
}

static int ModDrawTerrain_mapAreaSizeZ(ModDrawTerrain const *self)
{
	return ModDrawTerrain_mapAreaSize(self);
}

static int ModDrawTerrain_mapsizexchunks(ModDrawTerrain const *self)
{
	return Map_mapsizexchunks(self->game->map);
}

static int ModDrawTerrain_mapsizeychunks(ModDrawTerrain const *self)
{
	return Map_mapsizeychunks(self->game->map);
}

static int ModDrawTerrain_mapsizezchunks(ModDrawTerrain const *self)
{
	return Map_mapsizezchunks(self->game->map);
}

int ModDrawTerrain_maxlight(ModDrawTerrain const *self)
{
	return 15;
}

static void ModDrawTestModel_Construct(ModDrawTestModel *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModDrawTestModel;
	ClientMod_Construct(&self->base, vtbl);
}

ModDrawTestModel *ModDrawTestModel_New(void)
{
	ModDrawTestModel *self = (ModDrawTestModel *) malloc(sizeof(ModDrawTestModel));
	if (self != NULL)
		ModDrawTestModel_Construct(self, NULL);
	return self;
}

void ModDrawTestModel_Delete(ModDrawTestModel *self)
{
	free(self);
}

static void ModDrawTestModel_DrawTestModel(ModDrawTestModel *self, Game const *game, float deltaTime)
{
	if (!game->eNABLE_DRAW_TEST_CHARACTER) {
		return;
	}
	if (self->testmodel == NULL) {
		unsigned char const *data;
		int dataLength;
		const char *dataString;
		AnimatedModel const *model;
		self->testmodel = AnimatedModelRenderer_New();
		data = Game_GetFile(game, "player.txt");
		dataLength = Game_GetFileLength(game, "player.txt");
		dataString = game->platform->vtbl->stringFromUtf8ByteArray(game->platform, data, dataLength);
		model = AnimatedModelSerializer_Deserialize(game->platform, dataString);
		AnimatedModelRenderer_Start(self->testmodel, game, model);
	}
	Game_GLPushMatrix(game);
	Game_GLTranslate(game, game->map->mapSizeX / 2, Game_blockheight(game, game->map->mapSizeX / 2, game->map->mapSizeY / 2 - 2, 128), game->map->mapSizeY / 2 - 2);
	game->platform->vtbl->bindTexture2d(game->platform, Game_GetTexture(game, "mineplayer.png"));
	AnimatedModelRenderer_Render(self->testmodel, deltaTime, 0, TRUE, TRUE, 1);
	Game_GLPopMatrix(game);
}

cibool ModDrawTestModel_OnClientCommand(ModDrawTestModel const *self, Game *game, ClientCommandArgs const *args)
{
	if (strcmp(args->command, "testmodel") == 0) {
		game->eNABLE_DRAW_TEST_CHARACTER = Game_BoolCommandArgument(game, args->arguments);
		return TRUE;
	}
	return FALSE;
}

void ModDrawTestModel_OnNewFrameDraw3d(ModDrawTestModel *self, Game const *game, float deltaTime)
{
	if (game->guistate == GuiState_MAP_LOADING) {
		return;
	}
	ModDrawTestModel_DrawTestModel(self, game, deltaTime);
}

static void ModDrawText_Construct(ModDrawText *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModDrawText;
	ClientMod_Construct(&self->base, vtbl);
}

ModDrawText *ModDrawText_New(void)
{
	ModDrawText *self = (ModDrawText *) malloc(sizeof(ModDrawText));
	if (self != NULL)
		ModDrawText_Construct(self, NULL);
	return self;
}

void ModDrawText_Delete(ModDrawText *self)
{
	free(self);
}

void ModDrawText_OnNewFrameDraw3d(ModDrawText const *self, Game *game, float deltaTime)
{
	{
		int i;
		for (i = 0; i < game->entitiesCount; i++) {
			Entity const *e = game->entities[i];
			int kKey;
			EntityDrawText const *p;
			float posX;
			float posY;
			float posZ;
			if (e == NULL) {
				continue;
			}
			if (e->drawText == NULL) {
				continue;
			}
			if (e->networkPosition != NULL && !e->networkPosition->positionLoaded) {
				continue;
			}
			kKey = i;
			p = game->entities[i]->drawText;
			posX = -game->platform->vtbl->mathSin(game->platform, e->position->roty) * p->dx + e->position->x;
			posY = p->dy + e->position->y;
			posZ = game->platform->vtbl->mathCos(game->platform, e->position->roty) * p->dz + e->position->z;
			if (Game_Dist(game, game->player->position->x, game->player->position->y, game->player->position->z, posX, posY, posZ) < 20 || game->keyboardState[5] || game->keyboardState[6]) {
				const char *text = p->text;
				{
					float shadow = game->one * Game_GetLight(game, game->platform->vtbl->floatToInt(game->platform, posX), game->platform->vtbl->floatToInt(game->platform, posZ), game->platform->vtbl->floatToInt(game->platform, posY)) / 15;
					float scale;
					FontCi *font;
					Game_GLPushMatrix(game);
					Game_GLTranslate(game, posX, posY, posZ);
					Game_GLRotate(game, 180, 1, 0, 0);
					Game_GLRotate(game, e->position->roty * 360 / (2 * Game_GetPi()), 0, 1, 0);
					scale = game->one * 5 / 1000;
					Game_GLScale(game, scale, scale, scale);
					font = FontCi_New();
					font->family = "Arial";
					font->size = 14;
					Game_Draw2dText(game, text, font, -Game_TextSizeWidth(game, text, 14) / 2, 0, IntRef_Create(Game_ColorFromArgb(255, 255, 255, 255)), TRUE);
					Game_GLPopMatrix(game);
				}
			}
		}
	}
}

static void ModExpire_Construct(ModExpire *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModExpire;
	ClientMod_Construct(&self->base, vtbl);
}

ModExpire *ModExpire_New(void)
{
	ModExpire *self = (ModExpire *) malloc(sizeof(ModExpire));
	if (self != NULL)
		ModExpire_Construct(self, NULL);
	return self;
}

void ModExpire_Delete(ModExpire *self)
{
	free(self);
}

static void ModExpire_GrenadeExplosion(ModExpire const *self, Game *game, int grenadeEntityId)
{
	float LocalPlayerPositionX = game->player->position->x;
	float LocalPlayerPositionY = game->player->position->y;
	float LocalPlayerPositionZ = game->player->position->z;
	Entity const *grenadeEntity = game->entities[grenadeEntityId];
	Sprite const *grenadeSprite = grenadeEntity->sprite;
	Grenade_ const *grenade = grenadeEntity->grenade;
	float dist;
	float dmg;
	Game_AudioPlayAt(game, "grenadeexplosion.ogg", grenadeSprite->positionX, grenadeSprite->positionY, grenadeSprite->positionZ);
	{
		Entity *entity = Entity_New();
		Sprite *spritenew = Sprite_New();
		spritenew->image = "ani5.png";
		spritenew->positionX = grenadeSprite->positionX;
		spritenew->positionY = grenadeSprite->positionY + 1;
		spritenew->positionZ = grenadeSprite->positionZ;
		spritenew->size = 200;
		spritenew->animationcount = 4;
		entity->sprite = spritenew;
		entity->expires = Expires_Create(1);
		Game_EntityAddLocal(game, entity);
	}
	{
		Packet_ServerExplosion *explosion = Packet_ServerExplosion_New();
		Entity *entity;
		explosion->xFloat = Game_SerializeFloat(game, grenadeSprite->positionX);
		explosion->yFloat = Game_SerializeFloat(game, grenadeSprite->positionZ);
		explosion->zFloat = Game_SerializeFloat(game, grenadeSprite->positionY);
		explosion->rangeFloat = game->blocktypes[grenade->block]->explosionRangeFloat;
		explosion->isRelativeToPlayerPosition = 0;
		explosion->timeFloat = game->blocktypes[grenade->block]->explosionTimeFloat;
		entity = Entity_New();
		entity->push = explosion;
		entity->expires = Expires_New();
		entity->expires->timeLeft = Game_DeserializeFloat(game, game->blocktypes[grenade->block]->explosionTimeFloat);
		Game_EntityAddLocal(game, entity);
	}
	dist = Game_Dist(game, LocalPlayerPositionX, LocalPlayerPositionY, LocalPlayerPositionZ, grenadeSprite->positionX, grenadeSprite->positionY, grenadeSprite->positionZ);
	dmg = (1 - dist / Game_DeserializeFloat(game, game->blocktypes[grenade->block]->explosionRangeFloat)) * Game_DeserializeFloat(game, game->blocktypes[grenade->block]->damageBodyFloat);
	if (dmg > 0) {
		Game_ApplyDamageToPlayer(game, game->platform->vtbl->floatToInt(game->platform, dmg), 3, grenade->sourcePlayer);
	}
}

void ModExpire_OnNewFrameFixed(ModExpire const *self, Game *game, NewFrameEventArgs const *args)
{
	{
		int i;
		for (i = 0; i < game->entitiesCount; i++) {
			Entity const *entity = game->entities[i];
			if (entity == NULL) {
				continue;
			}
			if (entity->expires == NULL) {
				continue;
			}
			entity->expires->timeLeft -= NewFrameEventArgs_GetDt(args);
			if (entity->expires->timeLeft <= 0) {
				if (entity->grenade != NULL) {
					ModExpire_GrenadeExplosion(self, game, i);
				}
				game->entities[i] = NULL;
			}
		}
	}
}

static void ModFallDamageToPlayer_Construct(ModFallDamageToPlayer *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModFallDamageToPlayer;
	ClientMod_Construct(&self->base, vtbl);
	self->one = 1;
	self->fallSoundPlaying = FALSE;
}

ModFallDamageToPlayer *ModFallDamageToPlayer_New(void)
{
	ModFallDamageToPlayer *self = (ModFallDamageToPlayer *) malloc(sizeof(ModFallDamageToPlayer));
	if (self != NULL)
		ModFallDamageToPlayer_Construct(self, NULL);
	return self;
}

void ModFallDamageToPlayer_Delete(ModFallDamageToPlayer *self)
{
	free(self);
}

void ModFallDamageToPlayer_OnNewFrameFixed(ModFallDamageToPlayer *self, Game const *game, NewFrameEventArgs const *args)
{
	if (game->guistate == GuiState_MAP_LOADING) {
		return;
	}
	if (Controls_GetFreemove(game->controls) != 0) {
		if (self->fallSoundPlaying) {
			ModFallDamageToPlayer_SetFallSoundActive(self, game, FALSE);
		}
		return;
	}
	if (Game_FollowId(game) == NULL) {
		ModFallDamageToPlayer_UpdateFallDamageToPlayer(self, game, NewFrameEventArgs_GetDt(args));
	}
}

static void ModFallDamageToPlayer_SetFallSoundActive(ModFallDamageToPlayer *self, Game const *game, cibool active)
{
	Game_AudioPlayLoop(game, "fallloop.wav", active, TRUE);
	self->fallSoundPlaying = active;
}

static void ModFallDamageToPlayer_UpdateFallDamageToPlayer(ModFallDamageToPlayer *self, Game const *game, float dt)
{
	float movedz = game->movedz;
	float fallspeed = movedz / -game->basemovespeed;
	int posX = Game_GetPlayerEyesBlockX(game);
	int posY = Game_GetPlayerEyesBlockY(game);
	int posZ = Game_GetPlayerEyesBlockZ(game);
	if (Game_blockheight(game, posX, posY, posZ) < posZ - 8 || fallspeed > 3) {
		ModFallDamageToPlayer_SetFallSoundActive(self, game, fallspeed > 2);
	}
	else {
		ModFallDamageToPlayer_SetFallSoundActive(self, game, FALSE);
	}
	if (Map_IsValidPos(game->map, posX, posY, posZ - 3)) {
		int blockBelow = Map_GetBlock(game->map, posX, posY, posZ - 3);
		if (blockBelow != 0 && !Game_IsWater(game, blockBelow)) {
			float severity = 0;
			if (fallspeed < 4) {
				return;
			}
			else if (fallspeed < self->one * 45 / 10) {
				severity = self->one * 3 / 10;
			}
			else if (fallspeed < 5) {
				severity = self->one * 5 / 10;
			}
			else if (fallspeed < self->one * 55 / 10) {
				severity = self->one * 6 / 10;
			}
			else if (fallspeed < 6) {
				severity = self->one * 8 / 10;
			}
			else {
				severity = 1;
			}
			if (self->one * (game->platform->vtbl->timeMillisecondsFromStart(game->platform) - self->lastfalldamagetimeMilliseconds) / 1000 < 1) {
				return;
			}
			self->lastfalldamagetimeMilliseconds = game->platform->vtbl->timeMillisecondsFromStart(game->platform);
			Game_ApplyDamageToPlayer(game, game->platform->vtbl->floatToInt(game->platform, severity * game->playerStats->maxHealth), 0, 0);
		}
	}
}

static void ModFpsHistoryGraph_Construct(ModFpsHistoryGraph *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModFpsHistoryGraph;
	ClientMod_Construct(&self->base, vtbl);
	self->one = 1;
	self->drawfpstext = FALSE;
	self->drawfpsgraph = FALSE;
	self->dtHistory = (float *) malloc(300 * sizeof(float ));
	{
		int i;
		for (i = 0; i < 300; i++) {
			self->dtHistory[i] = 0;
		}
	}
	self->todraw = (Draw2dData const **) malloc(300 * sizeof(Draw2dData const *));
	{
		int i;
		for (i = 0; i < 300; i++) {
			self->todraw[i] = Draw2dData_New();
		}
	}
}

ModFpsHistoryGraph *ModFpsHistoryGraph_New(void)
{
	ModFpsHistoryGraph *self = (ModFpsHistoryGraph *) malloc(sizeof(ModFpsHistoryGraph));
	if (self != NULL)
		ModFpsHistoryGraph_Construct(self, NULL);
	return self;
}

void ModFpsHistoryGraph_Delete(ModFpsHistoryGraph *self)
{
	free(self);
}

static void ModFpsHistoryGraph_Draw(ModFpsHistoryGraph const *self)
{
	if (self->drawfpsgraph || self->drawfpstext) {
		self->m->vtbl->orthoMode(self->m);
		if (self->drawfpsgraph) {
			ModFpsHistoryGraph_DrawGraph(self);
		}
		if (self->drawfpstext) {
			self->m->vtbl->draw2dText(self->m, self->fpstext, 20, 20, 11);
		}
		self->m->vtbl->perspectiveMode(self->m);
	}
}

static void ModFpsHistoryGraph_DrawGraph(ModFpsHistoryGraph const *self)
{
	float maxtime = 0;
	int historyheight;
	int posx;
	int posy;
	int *colors;
	int linecolor;
	{
		int i;
		for (i = 0; i < 300; i++) {
			float v = self->dtHistory[i];
			if (v > maxtime) {
				maxtime = v;
			}
		}
	}
	historyheight = 80;
	posx = 25;
	posy = self->m->vtbl->getWindowHeight(self->m) - historyheight - 20;
	colors = (int *) malloc(2 * sizeof(int ));
	colors[0] = Game_ColorFromArgb(255, 0, 0, 0);
	colors[1] = Game_ColorFromArgb(255, 255, 0, 0);
	linecolor = Game_ColorFromArgb(255, 255, 255, 255);
	{
		int i;
		for (i = 0; i < 300; i++) {
			float time = self->dtHistory[i];
			int c;
			time = time * 60 * historyheight;
			c = InterpolationCi_InterpolateColor(self->m->vtbl->getPlatform(self->m), self->one * i / 300, colors, 2);
			self->todraw[i]->x1 = posx + i;
			self->todraw[i]->y1 = posy - time;
			self->todraw[i]->width = 1;
			self->todraw[i]->height = time;
			self->todraw[i]->inAtlasId = NULL;
			self->todraw[i]->color = c;
		}
	}
	self->m->vtbl->draw2dTextures(self->m, self->todraw, 300, self->m->vtbl->whiteTexture(self->m));
	self->m->vtbl->draw2dTexture(self->m, self->m->vtbl->whiteTexture(self->m), posx, posy - historyheight, 300, 1, NULL, linecolor);
	self->m->vtbl->draw2dTexture(self->m, self->m->vtbl->whiteTexture(self->m), posx, posy - historyheight * self->one * 60 / 75, 300, 1, NULL, linecolor);
	self->m->vtbl->draw2dTexture(self->m, self->m->vtbl->whiteTexture(self->m), posx, posy - historyheight * self->one * 60 / 30, 300, 1, NULL, linecolor);
	self->m->vtbl->draw2dTexture(self->m, self->m->vtbl->whiteTexture(self->m), posx, posy - historyheight * self->one * 60 / 150, 300, 1, NULL, linecolor);
	self->m->vtbl->draw2dText(self->m, "60", posx, posy - historyheight * self->one * 60 / 60, 6);
	self->m->vtbl->draw2dText(self->m, "75", posx, posy - historyheight * self->one * 60 / 75, 6);
	self->m->vtbl->draw2dText(self->m, "30", posx, posy - historyheight * self->one * 60 / 30, 6);
	self->m->vtbl->draw2dText(self->m, "150", posx, posy - historyheight * self->one * 60 / 150, 6);
}

cibool ModFpsHistoryGraph_OnClientCommand(ModFpsHistoryGraph *self, Game const *game, ClientCommandArgs const *args)
{
	if (strcmp(args->command, "fps") == 0) {
		IntRef const *argumentsLength = IntRef_New();
		const char *const *arguments = self->m->vtbl->getPlatform(self->m)->vtbl->stringSplit(self->m->vtbl->getPlatform(self->m), args->arguments, " ", argumentsLength);
		if (strcmp(self->m->vtbl->getPlatform(self->m)->vtbl->stringTrim(self->m->vtbl->getPlatform(self->m), args->arguments), "") == 0) {
			self->drawfpstext = TRUE;
		}
		else if (strcmp(arguments[0], "1") == 0) {
			self->drawfpstext = TRUE;
			self->drawfpsgraph = FALSE;
		}
		else if (strcmp(arguments[0], "2") == 0) {
			self->drawfpstext = TRUE;
			self->drawfpsgraph = TRUE;
		}
		else {
			self->drawfpstext = FALSE;
			self->drawfpsgraph = FALSE;
		}
		return TRUE;
	}
	return FALSE;
}

void ModFpsHistoryGraph_OnKeyDown(ModFpsHistoryGraph *self, Game const *game, KeyEventArgs const *args)
{
	if (KeyEventArgs_GetKeyCode(args) == 16) {
		if (!self->drawfpsgraph) {
			self->drawfpstext = TRUE;
			self->drawfpsgraph = TRUE;
		}
		else {
			self->drawfpstext = FALSE;
			self->drawfpsgraph = FALSE;
		}
	}
}

void ModFpsHistoryGraph_OnNewFrame(ModFpsHistoryGraph *self, Game const *game, NewFrameEventArgs const *args)
{
	float dt = NewFrameEventArgs_GetDt(args);
	ModFpsHistoryGraph_UpdateGraph(self, dt);
	ModFpsHistoryGraph_UpdateTitleFps(self, dt);
	ModFpsHistoryGraph_Draw(self);
}

void ModFpsHistoryGraph_Start(ModFpsHistoryGraph *self, ClientModManager const *modmanager)
{
	self->m = modmanager;
}

static void ModFpsHistoryGraph_UpdateGraph(ModFpsHistoryGraph const *self, float dt)
{
	{
		int i;
		for (i = 0; i < 299; i++) {
			self->dtHistory[i] = self->dtHistory[i + 1];
		}
	}
	self->dtHistory[299] = dt;
}

static void ModFpsHistoryGraph_UpdateTitleFps(ModFpsHistoryGraph *self, float dt)
{
	GamePlatform const *p = self->m->vtbl->getPlatform(self->m);
	float elapsed;
	self->fpscount++;
	self->longestframedt = MathCi_MaxFloat(self->longestframedt, dt);
	elapsed = self->one * (p->vtbl->timeMillisecondsFromStart(p) - self->lasttitleupdateMilliseconds) / 1000;
	if (elapsed >= 1) {
		const char *fpstext1 = "";
		const char *s;
		const char **l;
		int lCount;
		int perline;
		self->lasttitleupdateMilliseconds = p->vtbl->timeMillisecondsFromStart(p);
		fpstext1 = StringTools_StringAppend(p, fpstext1, p->vtbl->stringFormat(p, "FPS: {0}", p->vtbl->intToString(p, p->vtbl->floatToInt(p, self->one * self->fpscount / elapsed))));
		fpstext1 = StringTools_StringAppend(p, fpstext1, p->vtbl->stringFormat(p, " (min: {0})", p->vtbl->intToString(p, p->vtbl->floatToInt(p, self->one / self->longestframedt))));
		self->longestframedt = 0;
		self->fpscount = 0;
		DictionaryStringString_Set(self->m->vtbl->getPerformanceInfo(self->m), "fps", fpstext1);
		s = "";
		l = (const char **) malloc(64 * sizeof(const char *));
		lCount = 0;
		{
			int i;
			for (i = 0; i < self->m->vtbl->getPerformanceInfo(self->m)->count; i++) {
				if (self->m->vtbl->getPerformanceInfo(self->m)->items[i] == NULL) {
					continue;
				}
				l[lCount++] = self->m->vtbl->getPerformanceInfo(self->m)->items[i]->value;
			}
		}
		perline = 2;
		{
			int i;
			for (i = 0; i < lCount; i++) {
				s = StringTools_StringAppend(p, s, l[i]);
				if (i % perline == 0 && i != lCount - 1) {
					s = StringTools_StringAppend(p, s, ", ");
				}
				if (i % perline != 0) {
					s = StringTools_StringAppend(p, s, "\n");
				}
			}
		}
		self->fpstext = s;
	}
}

static void ModGrenade_Construct(ModGrenade *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModGrenade;
	ClientMod_Construct(&self->base, vtbl);
	self->one = 1;
	self->projectilegravity = 20;
	self->bouncespeedmultiply = self->one * 5 / 10;
	self->walldistance = self->one * 3 / 10;
}

ModGrenade *ModGrenade_New(void)
{
	ModGrenade *self = (ModGrenade *) malloc(sizeof(ModGrenade));
	if (self != NULL)
		ModGrenade_Construct(self, NULL);
	return self;
}

void ModGrenade_Delete(ModGrenade *self)
{
	free(self);
}

static Vector3Ref const *ModGrenade_GrenadeBounce(ModGrenade const *self, Game const *game, Vector3Ref *oldposition, Vector3Ref *newposition, Vector3Ref *velocity, float dt)
{
	cibool ismoving = Vector3Ref_Length(velocity) > 100 * dt;
	float modelheight = self->walldistance;
	Vector3IntRef const *oldpositioni;
	float playerpositionX;
	float playerpositionY;
	float playerpositionZ;
	oldposition->y += self->walldistance;
	newposition->y += self->walldistance;
	oldpositioni = Vector3IntRef_Create(Game_MathFloor(game, oldposition->x), Game_MathFloor(game, oldposition->z), Game_MathFloor(game, oldposition->y));
	playerpositionX = newposition->x;
	playerpositionY = newposition->y;
	playerpositionZ = newposition->z;
	{
		float qnewpositionX = newposition->x;
		float qnewpositionY = newposition->y;
		float qnewpositionZ = newposition->z + self->walldistance;
		cibool newempty = Game_IsTileEmptyForPhysics(game, Game_MathFloor(game, qnewpositionX), Game_MathFloor(game, qnewpositionZ), Game_MathFloor(game, qnewpositionY)) && Game_IsTileEmptyForPhysics(game, Game_MathFloor(game, qnewpositionX), Game_MathFloor(game, qnewpositionZ), Game_MathFloor(game, qnewpositionY) + 1);
		if (newposition->z - oldposition->z > 0) {
			if (!newempty) {
				velocity->z = -velocity->z;
				velocity->x *= self->bouncespeedmultiply;
				velocity->y *= self->bouncespeedmultiply;
				velocity->z *= self->bouncespeedmultiply;
				if (ismoving) {
					Game_AudioPlayAt(game, "grenadebounce.ogg", newposition->x, newposition->y, newposition->z);
				}
			}
		}
	}
	{
		float qnewpositionX = newposition->x + self->walldistance;
		float qnewpositionY = newposition->y;
		float qnewpositionZ = newposition->z;
		cibool newempty = Game_IsTileEmptyForPhysics(game, Game_MathFloor(game, qnewpositionX), Game_MathFloor(game, qnewpositionZ), Game_MathFloor(game, qnewpositionY)) && Game_IsTileEmptyForPhysics(game, Game_MathFloor(game, qnewpositionX), Game_MathFloor(game, qnewpositionZ), Game_MathFloor(game, qnewpositionY) + 1);
		if (newposition->x - oldposition->x > 0) {
			if (!newempty) {
				velocity->x = -velocity->x;
				velocity->x *= self->bouncespeedmultiply;
				velocity->y *= self->bouncespeedmultiply;
				velocity->z *= self->bouncespeedmultiply;
				if (ismoving) {
					Game_AudioPlayAt(game, "grenadebounce.ogg", newposition->x, newposition->y, newposition->z);
				}
			}
		}
	}
	{
		float qnewpositionX = newposition->x;
		float qnewpositionY = newposition->y - self->walldistance;
		float qnewpositionZ = newposition->z;
		int x = Game_MathFloor(game, qnewpositionX);
		int y = Game_MathFloor(game, qnewpositionZ);
		int z = Game_MathFloor(game, qnewpositionY);
		float a_ = self->walldistance;
		cibool newfull = !Game_IsTileEmptyForPhysics(game, x, y, z) || (qnewpositionX - Game_MathFloor(game, qnewpositionX) <= a_ && !Game_IsTileEmptyForPhysics(game, x - 1, y, z) && Game_IsTileEmptyForPhysics(game, x - 1, y, z + 1)) || (qnewpositionX - Game_MathFloor(game, qnewpositionX) >= 1 - a_ && !Game_IsTileEmptyForPhysics(game, x + 1, y, z) && Game_IsTileEmptyForPhysics(game, x + 1, y, z + 1)) || (qnewpositionZ - Game_MathFloor(game, qnewpositionZ) <= a_ && !Game_IsTileEmptyForPhysics(game, x, y - 1, z) && Game_IsTileEmptyForPhysics(game, x, y - 1, z + 1)) || (qnewpositionZ - Game_MathFloor(game, qnewpositionZ) >= 1 - a_ && !Game_IsTileEmptyForPhysics(game, x, y + 1, z) && Game_IsTileEmptyForPhysics(game, x, y + 1, z + 1));
		if (newposition->y - oldposition->y < 0) {
			if (newfull) {
				velocity->y = -velocity->y;
				velocity->x *= self->bouncespeedmultiply;
				velocity->y *= self->bouncespeedmultiply;
				velocity->z *= self->bouncespeedmultiply;
				if (ismoving) {
					Game_AudioPlayAt(game, "grenadebounce.ogg", newposition->x, newposition->y, newposition->z);
				}
			}
		}
	}
	{
		float qnewpositionX = newposition->x;
		float qnewpositionY = newposition->y;
		float qnewpositionZ = newposition->z - self->walldistance;
		cibool newempty = Game_IsTileEmptyForPhysics(game, Game_MathFloor(game, qnewpositionX), Game_MathFloor(game, qnewpositionZ), Game_MathFloor(game, qnewpositionY)) && Game_IsTileEmptyForPhysics(game, Game_MathFloor(game, qnewpositionX), Game_MathFloor(game, qnewpositionZ), Game_MathFloor(game, qnewpositionY) + 1);
		if (newposition->z - oldposition->z < 0) {
			if (!newempty) {
				velocity->z = -velocity->z;
				velocity->x *= self->bouncespeedmultiply;
				velocity->y *= self->bouncespeedmultiply;
				velocity->z *= self->bouncespeedmultiply;
				if (ismoving) {
					Game_AudioPlayAt(game, "grenadebounce.ogg", newposition->x, newposition->y, newposition->z);
				}
			}
		}
	}
	{
		float qnewpositionX = newposition->x - self->walldistance;
		float qnewpositionY = newposition->y;
		float qnewpositionZ = newposition->z;
		cibool newempty = Game_IsTileEmptyForPhysics(game, Game_MathFloor(game, qnewpositionX), Game_MathFloor(game, qnewpositionZ), Game_MathFloor(game, qnewpositionY)) && Game_IsTileEmptyForPhysics(game, Game_MathFloor(game, qnewpositionX), Game_MathFloor(game, qnewpositionZ), Game_MathFloor(game, qnewpositionY) + 1);
		if (newposition->x - oldposition->x < 0) {
			if (!newempty) {
				velocity->x = -velocity->x;
				velocity->x *= self->bouncespeedmultiply;
				velocity->y *= self->bouncespeedmultiply;
				velocity->z *= self->bouncespeedmultiply;
				if (ismoving) {
					Game_AudioPlayAt(game, "grenadebounce.ogg", newposition->x, newposition->y, newposition->z);
				}
			}
		}
	}
	{
		float qnewpositionX = newposition->x;
		float qnewpositionY = newposition->y + modelheight;
		float qnewpositionZ = newposition->z;
		cibool newempty = Game_IsTileEmptyForPhysics(game, Game_MathFloor(game, qnewpositionX), Game_MathFloor(game, qnewpositionZ), Game_MathFloor(game, qnewpositionY));
		if (newposition->y - oldposition->y > 0) {
			if (!newempty) {
				velocity->y = -velocity->y;
				velocity->x *= self->bouncespeedmultiply;
				velocity->y *= self->bouncespeedmultiply;
				velocity->z *= self->bouncespeedmultiply;
				if (ismoving) {
					Game_AudioPlayAt(game, "grenadebounce.ogg", newposition->x, newposition->y, newposition->z);
				}
			}
		}
	}
	playerpositionY -= self->walldistance;
	return Vector3Ref_Create(playerpositionX, playerpositionY, playerpositionZ);
}

void ModGrenade_OnNewFrameFixed(ModGrenade const *self, Game const *game, NewFrameEventArgs const *args)
{
	{
		int i;
		for (i = 0; i < game->entitiesCount; i++) {
			Entity const *entity = game->entities[i];
			if (entity == NULL) {
				continue;
			}
			if (entity->grenade == NULL) {
				continue;
			}
			ModGrenade_UpdateGrenade(self, game, i, NewFrameEventArgs_GetDt(args));
		}
	}
}

static void ModGrenade_UpdateGrenade(ModGrenade const *self, Game const *game, int grenadeEntityId, float dt)
{
	float LocalPlayerPositionX = game->player->position->x;
	float LocalPlayerPositionY = game->player->position->y;
	float LocalPlayerPositionZ = game->player->position->z;
	Entity const *grenadeEntity = game->entities[grenadeEntityId];
	Sprite *grenadeSprite = grenadeEntity->sprite;
	Grenade_ *grenade = grenadeEntity->grenade;
	float oldposX = grenadeEntity->sprite->positionX;
	float oldposY = grenadeSprite->positionY;
	float oldposZ = grenadeSprite->positionZ;
	float newposX = grenadeSprite->positionX + grenade->velocityX * dt;
	float newposY = grenadeSprite->positionY + grenade->velocityY * dt;
	float newposZ = grenadeSprite->positionZ + grenade->velocityZ * dt;
	Vector3Ref *velocity;
	Vector3Ref const *bouncePosition;
	grenade->velocityY += -self->projectilegravity * dt;
	velocity = Vector3Ref_Create(grenade->velocityX, grenade->velocityY, grenade->velocityZ);
	bouncePosition = ModGrenade_GrenadeBounce(self, game, Vector3Ref_Create(oldposX, oldposY, oldposZ), Vector3Ref_Create(newposX, newposY, newposZ), velocity, dt);
	grenade->velocityX = velocity->x;
	grenade->velocityY = velocity->y;
	grenade->velocityZ = velocity->z;
	grenadeSprite->positionX = bouncePosition->x;
	grenadeSprite->positionY = bouncePosition->y;
	grenadeSprite->positionZ = bouncePosition->z;
}

static void ModGuiChat_Construct(ModGuiChat *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModGuiChat;
	ClientMod_Construct(&self->base, vtbl);
	self->one = 1;
	self->chatFontSize = 11;
	self->chatScreenExpireTimeSeconds = 20;
	self->chatLinesMaxToDraw = 10;
	self->font = FontCi_New();
	self->font->family = "Arial";
	self->font->size = self->chatFontSize;
	self->chatlines2 = (Chatline const **) malloc(1024 * sizeof(Chatline const *));
}

ModGuiChat *ModGuiChat_New(void)
{
	ModGuiChat *self = (ModGuiChat *) malloc(sizeof(ModGuiChat));
	if (self != NULL)
		ModGuiChat_Construct(self, NULL);
	return self;
}

void ModGuiChat_Delete(ModGuiChat *self)
{
	free(self);
}

const char *ModGuiChat_DoAutocomplete(ModGuiChat const *self, const char *text)
{
	if (!self->game->platform->vtbl->stringEmpty(self->game->platform, text)) {
		{
			int i;
			for (i = 0; i < self->game->entitiesCount; i++) {
				Entity const *entity = self->game->entities[i];
				DrawName const *p;
				if (entity == NULL) {
					continue;
				}
				if (entity->drawName == NULL) {
					continue;
				}
				if (!entity->drawName->clientAutoComplete) {
					continue;
				}
				p = entity->drawName;
				if (self->game->platform->vtbl->stringStartsWithIgnoreCase(self->game->platform, StringTools_StringSubstringToEnd(self->game->platform, p->name, 2), text)) {
					return StringTools_StringSubstringToEnd(self->game->platform, p->name, 2);
				}
			}
		}
	}
	return "";
}

void ModGuiChat_DrawChatLines(ModGuiChat *self, cibool all)
{
	int timeNow;
	int scroll;
	int first;
	int count;
	float dx;
	self->chatlines2Count = 0;
	timeNow = self->game->platform->vtbl->timeMillisecondsFromStart(self->game->platform);
	if (!all) {
		scroll = 0;
	}
	else {
		scroll = self->chatPageScroll;
	}
	first = self->game->chatLinesCount - self->chatLinesMaxToDraw * (scroll + 1);
	if (first < 0) {
		first = 0;
	}
	count = self->game->chatLinesCount;
	if (count > self->chatLinesMaxToDraw) {
		count = self->chatLinesMaxToDraw;
	}
	{
		int i;
		for (i = first; i < first + count; i++) {
			Chatline const *c = self->game->chatLines[i];
			if (all || self->one * (timeNow - c->timeMilliseconds) / 1000 < self->chatScreenExpireTimeSeconds) {
				self->chatlines2[self->chatlines2Count++] = c;
			}
		}
	}
	self->font->size = self->chatFontSize * Game_Scale(self->game);
	dx = 20;
	{
		int i;
		for (i = 0; i < self->chatlines2Count; i++) {
			if (self->chatlines2[i]->clickable) {
				self->font->style = 3;
			}
			else {
				self->font->style = 1;
			}
			Game_Draw2dText(self->game, self->chatlines2[i]->text, self->font, dx * Game_Scale(self->game), (90 + i * 25) * Game_Scale(self->game), NULL, FALSE);
		}
	}
	if (self->chatPageScroll != 0) {
		Game_Draw2dText(self->game, self->game->platform->vtbl->stringFormat(self->game->platform, "&7Page: {0}", self->game->platform->vtbl->intToString(self->game->platform, self->chatPageScroll)), self->font, dx * Game_Scale(self->game), 65 * Game_Scale(self->game), NULL, FALSE);
	}
}

void ModGuiChat_DrawTypingBuffer(ModGuiChat const *self)
{
	const char *s;
	self->font->size = self->chatFontSize * Game_Scale(self->game);
	s = self->game->guiTypingBuffer;
	if (self->game->isTeamchat) {
		s = self->game->platform->vtbl->stringFormat(self->game->platform, "To team: {0}", s);
	}
	if (self->game->platform->vtbl->isSmallScreen(self->game->platform)) {
		Game_Draw2dText(self->game, self->game->platform->vtbl->stringFormat(self->game->platform, "{0}_", s), self->font, 50 * Game_Scale(self->game), self->game->platform->vtbl->getCanvasHeight(self->game->platform) / 2 - 100 * Game_Scale(self->game), NULL, TRUE);
	}
	else {
		Game_Draw2dText(self->game, self->game->platform->vtbl->stringFormat(self->game->platform, "{0}_", s), self->font, 50 * Game_Scale(self->game), self->game->platform->vtbl->getCanvasHeight(self->game->platform) - 100 * Game_Scale(self->game), NULL, TRUE);
	}
}

void ModGuiChat_OnKeyDown(ModGuiChat *self, Game const *game_, KeyEventArgs *args)
{
	int eKey;
	if (self->game->guistate != GuiState_NORMAL) {
		return;
	}
	eKey = KeyEventArgs_GetKeyCode(args);
	if (eKey == Game_GetKey(self->game, 116) && self->game->isShiftPressed && self->game->guiTyping == TypingState_NONE) {
		self->game->guiTyping = TypingState_TYPING;
		self->game->isTyping = TRUE;
		self->game->guiTypingBuffer = "";
		self->game->isTeamchat = FALSE;
		KeyEventArgs_SetHandled(args, TRUE);
		return;
	}
	if (eKey == Game_GetKey(self->game, 56) && self->game->guiTyping == TypingState_TYPING) {
		self->chatPageScroll++;
		KeyEventArgs_SetHandled(args, TRUE);
	}
	if (eKey == Game_GetKey(self->game, 57) && self->game->guiTyping == TypingState_TYPING) {
		self->chatPageScroll--;
		KeyEventArgs_SetHandled(args, TRUE);
	}
	self->chatPageScroll = MathCi_ClampInt(self->chatPageScroll, 0, self->game->chatLinesCount / self->chatLinesMaxToDraw);
	if (eKey == Game_GetKey(self->game, 49) || eKey == Game_GetKey(self->game, 82)) {
		if (self->game->guiTyping == TypingState_TYPING) {
			self->game->typinglog[self->game->typinglogCount++] = self->game->guiTypingBuffer;
			self->game->typinglogpos = self->game->typinglogCount;
			Game_ClientCommand(self->game, self->game->guiTypingBuffer);
			self->game->guiTypingBuffer = "";
			self->game->isTyping = FALSE;
			self->game->guiTyping = TypingState_NONE;
			self->game->platform->vtbl->showKeyboard(self->game->platform, FALSE);
		}
		else if (self->game->guiTyping == TypingState_NONE) {
			Game_StartTyping(self->game);
		}
		else if (self->game->guiTyping == TypingState_READY) {
			self->game->platform->vtbl->consoleWriteLine(self->game->platform, "Keyboard_KeyDown ready");
		}
		KeyEventArgs_SetHandled(args, TRUE);
		return;
	}
	if (self->game->guiTyping == TypingState_TYPING) {
		int key = eKey;
		if (key == Game_GetKey(self->game, 53)) {
			if (StringTools_StringLength(self->game->platform, self->game->guiTypingBuffer) > 0) {
				self->game->guiTypingBuffer = StringTools_StringSubstring(self->game->platform, self->game->guiTypingBuffer, 0, StringTools_StringLength(self->game->platform, self->game->guiTypingBuffer) - 1);
			}
			KeyEventArgs_SetHandled(args, TRUE);
			return;
		}
		if (self->game->keyboardStateRaw[Game_GetKey(self->game, 3)] || self->game->keyboardStateRaw[Game_GetKey(self->game, 4)]) {
			if (key == Game_GetKey(self->game, 104)) {
				if (self->game->platform->vtbl->clipboardContainsText(self->game->platform)) {
					self->game->guiTypingBuffer = StringTools_StringAppend(self->game->platform, self->game->guiTypingBuffer, self->game->platform->vtbl->clipboardGetText(self->game->platform));
				}
				KeyEventArgs_SetHandled(args, TRUE);
				return;
			}
		}
		if (key == Game_GetKey(self->game, 45)) {
			self->game->typinglogpos--;
			if (self->game->typinglogpos < 0) {
				self->game->typinglogpos = 0;
			}
			if (self->game->typinglogpos >= 0 && self->game->typinglogpos < self->game->typinglogCount) {
				self->game->guiTypingBuffer = self->game->typinglog[self->game->typinglogpos];
			}
			KeyEventArgs_SetHandled(args, TRUE);
		}
		if (key == Game_GetKey(self->game, 46)) {
			self->game->typinglogpos++;
			if (self->game->typinglogpos > self->game->typinglogCount) {
				self->game->typinglogpos = self->game->typinglogCount;
			}
			if (self->game->typinglogpos >= 0 && self->game->typinglogpos < self->game->typinglogCount) {
				self->game->guiTypingBuffer = self->game->typinglog[self->game->typinglogpos];
			}
			if (self->game->typinglogpos == self->game->typinglogCount) {
				self->game->guiTypingBuffer = "";
			}
			KeyEventArgs_SetHandled(args, TRUE);
		}
		if (eKey == Game_GetKey(self->game, 52) && strcmp(self->game->platform->vtbl->stringTrim(self->game->platform, self->game->guiTypingBuffer), "") != 0) {
			IntRef const *partsLength = IntRef_New();
			const char **parts = self->game->platform->vtbl->stringSplit(self->game->platform, self->game->guiTypingBuffer, " ", partsLength);
			const char *completed = ModGuiChat_DoAutocomplete(self, parts[partsLength->value - 1]);
			if (strcmp(completed, "") == 0) {
				KeyEventArgs_SetHandled(args, TRUE);
				return;
			}
			else if (partsLength->value == 1) {
				self->game->guiTypingBuffer = StringTools_StringAppend(self->game->platform, completed, ": ");
			}
			else {
				parts[partsLength->value - 1] = completed;
				self->game->guiTypingBuffer = StringTools_StringAppend(self->game->platform, self->game->platform->vtbl->stringJoin(self->game->platform, parts, " "), " ");
			}
			KeyEventArgs_SetHandled(args, TRUE);
			return;
		}
		KeyEventArgs_SetHandled(args, TRUE);
		return;
	}
}

void ModGuiChat_OnKeyPress(ModGuiChat const *self, Game const *game_, KeyPressEventArgs const *args)
{
	int eKeyChar;
	int chart;
	int charT;
	int chary;
	int charY;
	if (self->game->guistate != GuiState_NORMAL) {
		return;
	}
	eKeyChar = KeyPressEventArgs_GetKeyChar(args);
	chart = 116;
	charT = 84;
	chary = 121;
	charY = 89;
	if ((eKeyChar == chart || eKeyChar == charT) && self->game->guiTyping == TypingState_NONE) {
		self->game->guiTyping = TypingState_TYPING;
		self->game->guiTypingBuffer = "";
		self->game->isTeamchat = FALSE;
		return;
	}
	if ((eKeyChar == chary || eKeyChar == charY) && self->game->guiTyping == TypingState_NONE) {
		self->game->guiTyping = TypingState_TYPING;
		self->game->guiTypingBuffer = "";
		self->game->isTeamchat = TRUE;
		return;
	}
	if (self->game->guiTyping == TypingState_TYPING) {
		int c = eKeyChar;
		if (self->game->platform->vtbl->isValidTypingChar(self->game->platform, c)) {
			self->game->guiTypingBuffer = StringTools_StringAppend(self->game->platform, self->game->guiTypingBuffer, Game_CharToString(self->game, c));
		}
	}
}

void ModGuiChat_OnMouseDown(ModGuiChat const *self, Game const *game_, MouseEventArgs const *args)
{
	{
		int i;
		for (i = 0; i < self->chatlines2Count; i++) {
			float dx = 20;
			float chatlineStartX;
			float chatlineStartY;
			float chatlineSizeX;
			float chatlineSizeY;
			if (!self->game->platform->vtbl->isMousePointerLocked(self->game->platform)) {
				dx += 100;
			}
			chatlineStartX = dx * Game_Scale(self->game);
			chatlineStartY = (90 + i * 25) * Game_Scale(self->game);
			chatlineSizeX = 500 * Game_Scale(self->game);
			chatlineSizeY = 20 * Game_Scale(self->game);
			if (MouseEventArgs_GetX(args) > chatlineStartX && MouseEventArgs_GetX(args) < chatlineStartX + chatlineSizeX) {
				if (MouseEventArgs_GetY(args) > chatlineStartY && MouseEventArgs_GetY(args) < chatlineStartY + chatlineSizeY) {
					if (self->chatlines2[i]->clickable) {
						self->game->platform->vtbl->openLinkInBrowser(self->game->platform, self->chatlines2[i]->linkTarget);
					}
				}
			}
		}
	}
}

void ModGuiChat_OnNewFrameDraw2d(ModGuiChat *self, Game *game_, float deltaTime)
{
	self->game = game_;
	if (self->game->guistate == GuiState_MAP_LOADING) {
		return;
	}
	ModGuiChat_DrawChatLines(self, self->game->guiTyping == TypingState_TYPING);
	if (self->game->guiTyping == TypingState_TYPING) {
		ModGuiChat_DrawTypingBuffer(self);
	}
}

static void ModGuiCrafting_Construct(ModGuiCrafting *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModGuiCrafting;
	ClientMod_Construct(&self->base, vtbl);
	self->handler = PacketHandlerCraftingRecipes_New();
	self->handler->mod = self;
}

ModGuiCrafting *ModGuiCrafting_New(void)
{
	ModGuiCrafting *self = (ModGuiCrafting *) malloc(sizeof(ModGuiCrafting));
	if (self != NULL)
		ModGuiCrafting_Construct(self, NULL);
	return self;
}

void ModGuiCrafting_Delete(ModGuiCrafting *self)
{
	free(self);
}

static void ModGuiCrafting_CraftingMouse(ModGuiCrafting *self, Game *game)
{
	int menustartx;
	int menustarty;
	if (self->currentRecipes == NULL) {
		return;
	}
	menustartx = Game_xcenter(game, 600);
	menustarty = Game_ycenter(game, self->currentRecipesCount * 80);
	if (game->mouseCurrentY >= menustarty && game->mouseCurrentY < menustarty + self->currentRecipesCount * 80) {
		self->craftingselectedrecipe = (game->mouseCurrentY - menustarty) / 80;
	}
	else {
	}
	if (game->mouseleftclick) {
		if (self->currentRecipesCount != 0) {
			ModGuiCrafting_CraftingRecipeSelected(self, game, self->craftingTableposx, self->craftingTableposy, self->craftingTableposz, IntRef_Create(self->currentRecipes[self->craftingselectedrecipe]));
		}
		game->mouseleftclick = FALSE;
		Game_GuiStateBackToGame(game);
	}
}

static void ModGuiCrafting_CraftingRecipeSelected(ModGuiCrafting const *self, Game const *game, int x, int y, int z, IntRef const *recipe)
{
	if (recipe == NULL) {
		return;
	}
	Game_SendPacketClient(game, ClientPackets_Craft(x, y, z, recipe->value));
}

static void ModGuiCrafting_CraftingRecipesStart(ModGuiCrafting *self, Game *game, Packet_CraftingRecipe const *const *recipes, int recipesCount, int const *blocks, int blocksCount, int posx, int posy, int posz)
{
	self->craftingrecipes2 = recipes;
	self->craftingrecipes2Count = recipesCount;
	self->craftingblocks = blocks;
	self->craftingblocksCount = blocksCount;
	self->craftingTableposx = posx;
	self->craftingTableposy = posy;
	self->craftingTableposz = posz;
	game->guistate = GuiState_CRAFTING_RECIPES;
	game->menustate = MenuState_New();
	Game_SetFreeMouse(game, TRUE);
}

static void ModGuiCrafting_DrawCraftingRecipes(ModGuiCrafting *self, Game *game)
{
	int menustartx;
	int menustarty;
	self->currentRecipes = (int *) malloc(1024 * sizeof(int ));
	self->currentRecipesCount = 0;
	{
		int i;
		for (i = 0; i < self->craftingrecipes2Count; i++) {
			Packet_CraftingRecipe const *r = self->craftingrecipes2[i];
			cibool next;
			if (r == NULL) {
				continue;
			}
			next = FALSE;
			{
				int k;
				for (k = 0; k < r->ingredientsCount; k++) {
					Packet_Ingredient const *ingredient = r->ingredients[k];
					if (ingredient == NULL) {
						continue;
					}
					if (ModGuiCrafting_craftingblocksFindAllCount(self, self->craftingblocks, self->craftingblocksCount, ingredient->type) < ingredient->amount) {
						next = TRUE;
						break;
					}
				}
			}
			if (!next) {
				self->currentRecipes[self->currentRecipesCount++] = i;
			}
		}
	}
	menustartx = Game_xcenter(game, 600);
	menustarty = Game_ycenter(game, self->currentRecipesCount * 80);
	if (self->currentRecipesCount == 0) {
		Game_Draw2dText1(game, Language_NoMaterialsForCrafting(game->language), Game_xcenter(game, 200), Game_ycenter(game, 20), 12, NULL, FALSE);
		return;
	}
	{
		int i;
		for (i = 0; i < self->currentRecipesCount; i++) {
			Packet_CraftingRecipe const *r = self->craftingrecipes2[self->currentRecipes[i]];
			{
				int ii;
				for (ii = 0; ii < r->ingredientsCount; ii++) {
					int xx = menustartx + 20 + ii * 130;
					int yy = menustarty + i * 80;
					Game_Draw2dTexture(game, ITerrainTextures_terrainTexture(game->d_TerrainTextures), xx, yy, 32, 32, IntRef_Create(game->textureIdForInventory[r->ingredients[ii]->type]), Game_texturesPacked(game), Game_ColorFromArgb(255, 255, 255, 255), FALSE);
					Game_Draw2dText1(game, game->platform->vtbl->stringFormat2(game->platform, "{0} {1}", game->platform->vtbl->intToString(game->platform, r->ingredients[ii]->amount), game->blocktypes[r->ingredients[ii]->type]->name), xx + 50, yy, 12, IntRef_Create(i == self->craftingselectedrecipe ? Game_ColorFromArgb(255, 255, 0, 0) : Game_ColorFromArgb(255, 255, 255, 255)), FALSE);
				}
			}
			{
				int xx = menustartx + 20 + 400;
				int yy = menustarty + i * 80;
				Game_Draw2dTexture(game, ITerrainTextures_terrainTexture(game->d_TerrainTextures), xx, yy, 32, 32, IntRef_Create(game->textureIdForInventory[r->output->type]), Game_texturesPacked(game), Game_ColorFromArgb(255, 255, 255, 255), FALSE);
				Game_Draw2dText1(game, game->platform->vtbl->stringFormat2(game->platform, "{0} {1}", game->platform->vtbl->intToString(game->platform, r->output->amount), game->blocktypes[r->output->type]->name), xx + 50, yy, 12, IntRef_Create(i == self->craftingselectedrecipe ? Game_ColorFromArgb(255, 255, 0, 0) : Game_ColorFromArgb(255, 255, 255, 255)), FALSE);
			}
		}
	}
}

void ModGuiCrafting_OnKeyDown(ModGuiCrafting *self, Game *game, KeyEventArgs *args)
{
	int eKey = KeyEventArgs_GetKeyCode(args);
	if (eKey == Game_GetKey(game, 87) && game->guiTyping == TypingState_NONE) {
		if (!(game->selectedBlockPositionX == -1 && game->selectedBlockPositionY == -1 && game->selectedBlockPositionZ == -1)) {
			int posx = game->selectedBlockPositionX;
			int posy = game->selectedBlockPositionZ;
			int posz = game->selectedBlockPositionY;
			if (Map_GetBlock(game->map, posx, posy, posz) == GameData_BlockIdCraftingTable(game->d_Data)) {
				IntRef *tableCount = IntRef_New();
				Vector3IntRef const *const *table = CraftingTableTool_GetTable(self->d_CraftingTableTool, posx, posy, posz, tableCount);
				IntRef *onTableCount = IntRef_New();
				int const *onTable = CraftingTableTool_GetOnTable(self->d_CraftingTableTool, table, tableCount->value, onTableCount);
				ModGuiCrafting_CraftingRecipesStart(self, game, self->d_CraftingRecipes, self->d_CraftingRecipesCount, onTable, onTableCount->value, posx, posy, posz);
				KeyEventArgs_SetHandled(args, TRUE);
			}
		}
	}
}

void ModGuiCrafting_OnNewFrameDraw2d(ModGuiCrafting *self, Game *game, float deltaTime)
{
	if (self->d_CraftingTableTool == NULL) {
		self->d_CraftingTableTool = CraftingTableTool_New();
		self->d_CraftingTableTool->d_Map = &MapStorage2_Create(game)->base;
		self->d_CraftingTableTool->d_Data = game->d_Data;
	}
	game->packetHandlers[30] = &self->handler->base;
	if (game->guistate != GuiState_CRAFTING_RECIPES) {
		return;
	}
	ModGuiCrafting_DrawCraftingRecipes(self, game);
}

void ModGuiCrafting_OnNewFrameFixed(ModGuiCrafting *self, Game *game, NewFrameEventArgs const *args)
{
	if (game->guistate != GuiState_CRAFTING_RECIPES) {
		return;
	}
	ModGuiCrafting_CraftingMouse(self, game);
}

static int ModGuiCrafting_craftingblocksFindAllCount(ModGuiCrafting const *self, int const *craftingblocks_, int craftingblocksCount_, int p)
{
	int count = 0;
	{
		int i;
		for (i = 0; i < craftingblocksCount_; i++) {
			if (craftingblocks_[i] == p) {
				count++;
			}
		}
	}
	return count;
}

static void ModGuiEscapeMenu_Construct(ModGuiEscapeMenu *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModGuiEscapeMenu;
	ClientMod_Construct(&self->base, vtbl);
	self->one = 1;
	self->fonts = (const char **) malloc(4 * sizeof(const char *));
	self->fonts[0] = "Nice";
	self->fonts[1] = "Simple";
	self->fonts[2] = "BlackBackground";
	self->fonts[3] = "Default";
	self->fontsLength = 4;
	self->fontValues = (int *) malloc(4 * sizeof(int ));
	self->fontValues[0] = 0;
	self->fontValues[1] = 1;
	self->fontValues[2] = 2;
	self->fontValues[3] = 3;
	self->widgets = (Button const **) malloc(1024 * sizeof(Button const *));
	self->keyselectid = -1;
}

ModGuiEscapeMenu *ModGuiEscapeMenu_New(void)
{
	ModGuiEscapeMenu *self = (ModGuiEscapeMenu *) malloc(sizeof(ModGuiEscapeMenu));
	if (self != NULL)
		ModGuiEscapeMenu_Construct(self, NULL);
	return self;
}

void ModGuiEscapeMenu_Delete(ModGuiEscapeMenu *self)
{
	free(self);
}

static void ModGuiEscapeMenu_AddWidget(ModGuiEscapeMenu *self, Button *b)
{
	self->widgets[self->widgetsCount++] = b;
}

static void ModGuiEscapeMenu_EscapeMenuMouse1(ModGuiEscapeMenu *self)
{
	{
		int i;
		for (i = 0; i < self->widgetsCount; i++) {
			Button *w = self->widgets[i];
			w->selected = ModGuiEscapeMenu_RectContains(self, w->x, w->y, w->width, w->height, self->game->mouseCurrentX, self->game->mouseCurrentY);
			if (w->selected && self->game->mouseleftclick) {
				ModGuiEscapeMenu_HandleButtonClick(self, w);
				break;
			}
		}
	}
}

static const char *ModGuiEscapeMenu_FontString(ModGuiEscapeMenu const *self)
{
	return self->fonts[self->game->options->font];
}

static void ModGuiEscapeMenu_GraphicsHandleClick(ModGuiEscapeMenu *self, Button const *b)
{
	OptionsCi *options = self->game->options;
	if (b == self->graphicsOptionSmoothShadows) {
		options->smoothshadows = !options->smoothshadows;
		self->game->d_TerrainChunkTesselator->enableSmoothLight = options->smoothshadows;
		if (options->smoothshadows) {
			options->blockShadowSave = self->one * 7 / 10;
			self->game->d_TerrainChunkTesselator->blockShadow = options->blockShadowSave;
		}
		else {
			options->blockShadowSave = self->one * 6 / 10;
			self->game->d_TerrainChunkTesselator->blockShadow = options->blockShadowSave;
		}
		Game_RedrawAllBlocks(self->game);
	}
	if (b == self->graphicsOptionDarkenSides) {
		options->enableBlockShadow = !options->enableBlockShadow;
		self->game->d_TerrainChunkTesselator->option_DarkenBlockSides = options->enableBlockShadow;
		Game_RedrawAllBlocks(self->game);
	}
	if (b == self->graphicsViewDistanceOption) {
		Game_ToggleFog(self->game);
	}
	if (b == self->graphicsOptionFramerate) {
		Game_ToggleVsync(self->game);
	}
	if (b == self->graphicsOptionResolution) {
		ModGuiEscapeMenu_ToggleResolution(self);
	}
	if (b == self->graphicsOptionFullscreen) {
		options->fullscreen = !options->fullscreen;
	}
	if (b == self->graphicsUseServerTexturesOption) {
		options->useServerTextures = !options->useServerTextures;
	}
	if (b == self->graphicsFontOption) {
		ModGuiEscapeMenu_ToggleFont(self);
	}
	if (b == self->graphicsReturnToOptionsMenu) {
		ModGuiEscapeMenu_UseFullscreen(self);
		ModGuiEscapeMenu_UseResolution(self);
		ModGuiEscapeMenu_SetEscapeMenuState(self, EscapeMenuState_OPTIONS);
	}
}

static void ModGuiEscapeMenu_GraphicsSet(ModGuiEscapeMenu *self)
{
	OptionsCi const *options = self->game->options;
	Language const *language = self->game->language;
	self->graphicsOptionSmoothShadows = Button_New();
	self->graphicsOptionSmoothShadows->text = self->game->platform->vtbl->stringFormat(self->game->platform, Language_OptionSmoothShadows(language), options->smoothshadows ? Language_On(language) : Language_Off(language));
	self->graphicsOptionDarkenSides = Button_New();
	self->graphicsOptionDarkenSides->text = self->game->platform->vtbl->stringFormat(self->game->platform, Language_Get(language, "OptionDarkenSides"), options->enableBlockShadow ? Language_On(language) : Language_Off(language));
	self->graphicsViewDistanceOption = Button_New();
	self->graphicsViewDistanceOption->text = self->game->platform->vtbl->stringFormat(self->game->platform, Language_ViewDistanceOption(language), self->game->platform->vtbl->intToString(self->game->platform, self->game->platform->vtbl->floatToInt(self->game->platform, self->game->d_Config3d->viewdistance)));
	self->graphicsOptionFramerate = Button_New();
	self->graphicsOptionFramerate->text = self->game->platform->vtbl->stringFormat(self->game->platform, Language_OptionFramerate(language), ModGuiEscapeMenu_VsyncString(self));
	self->graphicsOptionResolution = Button_New();
	self->graphicsOptionResolution->text = self->game->platform->vtbl->stringFormat(self->game->platform, Language_OptionResolution(language), ModGuiEscapeMenu_ResolutionString(self));
	self->graphicsOptionFullscreen = Button_New();
	self->graphicsOptionFullscreen->text = self->game->platform->vtbl->stringFormat(self->game->platform, Language_OptionFullscreen(language), options->fullscreen ? Language_On(language) : Language_Off(language));
	self->graphicsUseServerTexturesOption = Button_New();
	self->graphicsUseServerTexturesOption->text = self->game->platform->vtbl->stringFormat(self->game->platform, Language_UseServerTexturesOption(language), options->useServerTextures ? Language_On(language) : Language_Off(language));
	self->graphicsFontOption = Button_New();
	self->graphicsFontOption->text = self->game->platform->vtbl->stringFormat(self->game->platform, Language_FontOption(language), ModGuiEscapeMenu_FontString(self));
	self->graphicsReturnToOptionsMenu = Button_New();
	self->graphicsReturnToOptionsMenu->text = Language_ReturnToOptionsMenu(language);
	ModGuiEscapeMenu_WidgetsClear(self);
	ModGuiEscapeMenu_AddWidget(self, self->graphicsOptionSmoothShadows);
	ModGuiEscapeMenu_AddWidget(self, self->graphicsOptionDarkenSides);
	ModGuiEscapeMenu_AddWidget(self, self->graphicsViewDistanceOption);
	ModGuiEscapeMenu_AddWidget(self, self->graphicsOptionFramerate);
	ModGuiEscapeMenu_AddWidget(self, self->graphicsOptionResolution);
	ModGuiEscapeMenu_AddWidget(self, self->graphicsOptionFullscreen);
	ModGuiEscapeMenu_AddWidget(self, self->graphicsUseServerTexturesOption);
	ModGuiEscapeMenu_AddWidget(self, self->graphicsFontOption);
	ModGuiEscapeMenu_AddWidget(self, self->graphicsReturnToOptionsMenu);
}

static void ModGuiEscapeMenu_HandleButtonClick(ModGuiEscapeMenu *self, Button const *w)
{
	ModGuiEscapeMenu_MainHandleClick(self, w);
	ModGuiEscapeMenu_OptionsHandleClick(self, w);
	ModGuiEscapeMenu_GraphicsHandleClick(self, w);
	ModGuiEscapeMenu_OtherHandleClick(self, w);
	ModGuiEscapeMenu_KeysHandleClick(self, w);
}

static KeyHelp const *ModGuiEscapeMenu_KeyHelpCreate(ModGuiEscapeMenu const *self, const char *text, int defaultKey)
{
	KeyHelp *h = KeyHelp_New();
	h->text = text;
	h->defaultKey = defaultKey;
	return h;
}

static const char *ModGuiEscapeMenu_KeyName(ModGuiEscapeMenu const *self, int key)
{
	return self->game->platform->vtbl->keyName(self->game->platform, key);
}

static void ModGuiEscapeMenu_KeysHandleClick(ModGuiEscapeMenu *self, Button const *b)
{
	if (self->keyButtons != NULL) {
		{
			int i;
			for (i = 0; i < 1024; i++) {
				if (self->keyButtons[i] == b) {
					self->keyselectid = i;
				}
			}
		}
	}
	if (b == self->keysDefaultKeys) {
		self->game->options->keys = (int *) malloc(256 * sizeof(int ));
	}
	if (b == self->keysReturnToOptionsMenu) {
		ModGuiEscapeMenu_SetEscapeMenuState(self, EscapeMenuState_OPTIONS);
	}
}

static void ModGuiEscapeMenu_KeysSet(ModGuiEscapeMenu *self)
{
	Language const *language = self->game->language;
	KeyHelp const *const *helps;
	self->keyButtons = (Button const **) malloc(1024 * sizeof(Button const *));
	{
		int i;
		for (i = 0; i < 1024; i++) {
			self->keyButtons[i] = NULL;
		}
	}
	helps = ModGuiEscapeMenu_keyhelps(self);
	{
		int i;
		for (i = 0; i < 1024; i++) {
			int defaultkey;
			int key;
			if (helps[i] == NULL) {
				break;
			}
			defaultkey = helps[i]->defaultKey;
			key = defaultkey;
			if (self->game->options->keys[defaultkey] != 0) {
				key = self->game->options->keys[defaultkey];
			}
			self->keyButtons[i] = Button_New();
			self->keyButtons[i]->text = self->game->platform->vtbl->stringFormat2(self->game->platform, Language_KeyChange(language), helps[i]->text, ModGuiEscapeMenu_KeyName(self, key));
			ModGuiEscapeMenu_AddWidget(self, self->keyButtons[i]);
		}
	}
	self->keysDefaultKeys = Button_New();
	self->keysDefaultKeys->text = Language_DefaultKeys(language);
	self->keysReturnToOptionsMenu = Button_New();
	self->keysReturnToOptionsMenu->text = Language_ReturnToOptionsMenu(language);
	ModGuiEscapeMenu_AddWidget(self, self->keysDefaultKeys);
	ModGuiEscapeMenu_AddWidget(self, self->keysReturnToOptionsMenu);
}

void ModGuiEscapeMenu_LoadOptions(ModGuiEscapeMenu *self)
{
	OptionsCi *o = ModGuiEscapeMenu_LoadOptions_(self);
	OptionsCi const *options;
	if (o == NULL) {
		return;
	}
	self->game->options = o;
	options = o;
	self->game->font = self->fontValues[options->font];
	Game_UpdateTextRendererFont(self->game);
	self->game->d_Config3d->viewdistance = options->drawDistance;
	self->game->audioEnabled = options->enableSound;
	self->game->autoJumpEnabled = options->enableAutoJump;
	if (strcmp(options->clientLanguage, "") != 0) {
		self->game->language->overrideLanguage = options->clientLanguage;
	}
	self->game->d_TerrainChunkTesselator->enableSmoothLight = options->smoothshadows;
	self->game->d_TerrainChunkTesselator->blockShadow = options->blockShadowSave;
	self->game->d_TerrainChunkTesselator->option_DarkenBlockSides = options->enableBlockShadow;
	self->game->eNABLE_LAG = options->framerate;
	ModGuiEscapeMenu_UseFullscreen(self);
	Game_UseVsync(self->game);
	ModGuiEscapeMenu_UseResolution(self);
}

static OptionsCi *ModGuiEscapeMenu_LoadOptions_(ModGuiEscapeMenu const *self)
{
	OptionsCi *options = OptionsCi_New();
	Preferences const *preferences = self->game->platform->vtbl->getPreferences(self->game->platform);
	options->shadows = Preferences_GetBool(preferences, "Shadows", TRUE);
	options->font = Preferences_GetInt(preferences, "Font", 0);
	options->drawDistance = Preferences_GetInt(preferences, "DrawDistance", self->game->platform->vtbl->isFastSystem(self->game->platform) ? 128 : 32);
	options->useServerTextures = Preferences_GetBool(preferences, "UseServerTextures", TRUE);
	options->enableSound = Preferences_GetBool(preferences, "EnableSound", TRUE);
	options->enableAutoJump = Preferences_GetBool(preferences, "EnableAutoJump", FALSE);
	options->clientLanguage = Preferences_GetString(preferences, "ClientLanguage", "");
	options->framerate = Preferences_GetInt(preferences, "Framerate", 0);
	options->resolution = Preferences_GetInt(preferences, "Resolution", 0);
	options->fullscreen = Preferences_GetBool(preferences, "Fullscreen", FALSE);
	options->smoothshadows = Preferences_GetBool(preferences, "Smoothshadows", TRUE);
	options->blockShadowSave = self->one * Preferences_GetInt(preferences, "BlockShadowSave", 70) / 100;
	options->enableBlockShadow = Preferences_GetBool(preferences, "EnableBlockShadow", TRUE);
	{
		int i;
		for (i = 0; i < 256; i++) {
			const char *preferencesKey = StringTools_StringAppend(self->game->platform, "Key", self->game->platform->vtbl->intToString(self->game->platform, i));
			int value = Preferences_GetInt(preferences, preferencesKey, 0);
			if (value != 0) {
				options->keys[i] = value;
			}
		}
	}
	return options;
}

static void ModGuiEscapeMenu_MainHandleClick(ModGuiEscapeMenu *self, Button const *b)
{
	if (b == self->buttonMainReturnToGame) {
		Game_GuiStateBackToGame(self->game);
	}
	if (b == self->buttonMainOptions) {
		ModGuiEscapeMenu_SetEscapeMenuState(self, EscapeMenuState_OPTIONS);
	}
	if (b == self->buttonMainExit) {
		Game_SendLeave(self->game, 0);
		Game_ExitToMainMenu_(self->game);
	}
}

static void ModGuiEscapeMenu_MainSet(ModGuiEscapeMenu *self)
{
	Language const *language = self->game->language;
	self->buttonMainReturnToGame = Button_New();
	self->buttonMainReturnToGame->text = Language_ReturnToGame(language);
	self->buttonMainOptions = Button_New();
	self->buttonMainOptions->text = Language_Options(language);
	self->buttonMainExit = Button_New();
	self->buttonMainExit->text = Language_Exit(language);
	ModGuiEscapeMenu_WidgetsClear(self);
	ModGuiEscapeMenu_AddWidget(self, self->buttonMainReturnToGame);
	ModGuiEscapeMenu_AddWidget(self, self->buttonMainOptions);
	ModGuiEscapeMenu_AddWidget(self, self->buttonMainExit);
}

static void ModGuiEscapeMenu_MakeSimpleOptions(ModGuiEscapeMenu const *self, int fontsize, int textheight)
{
	int starty = Game_ycenter(self->game, self->widgetsCount * textheight);
	{
		int i;
		for (i = 0; i < self->widgetsCount; i++) {
			const char *s = self->widgets[i]->text;
			float sizeWidth = Game_TextSizeWidth(self->game, s, fontsize);
			float sizeHeight = Game_TextSizeHeight(self->game, s, fontsize);
			int Width = self->game->platform->vtbl->floatToInt(self->game->platform, sizeWidth) + 10;
			int Height = self->game->platform->vtbl->floatToInt(self->game->platform, sizeHeight);
			int X = Game_xcenter(self->game, sizeWidth);
			int Y = starty + textheight * i;
			self->widgets[i]->x = X;
			self->widgets[i]->y = Y;
			self->widgets[i]->width = Width;
			self->widgets[i]->height = Height;
			self->widgets[i]->fontsize = fontsize;
			if (i == self->keyselectid) {
				self->widgets[i]->fontcolor = Game_ColorFromArgb(255, 0, 255, 0);
				self->widgets[i]->fontcolorselected = Game_ColorFromArgb(255, 0, 255, 0);
			}
		}
	}
}

void ModGuiEscapeMenu_OnKeyDown(ModGuiEscapeMenu *self, Game const *game_, KeyEventArgs *args)
{
	int eKey = KeyEventArgs_GetKeyCode(args);
	if (eKey == Game_GetKey(self->game, 50)) {
		if (self->escapemenustate == EscapeMenuState_GRAPHICS || self->escapemenustate == EscapeMenuState_KEYS || self->escapemenustate == EscapeMenuState_OTHER) {
			ModGuiEscapeMenu_SetEscapeMenuState(self, EscapeMenuState_OPTIONS);
		}
		else if (self->escapemenustate == EscapeMenuState_OPTIONS) {
			ModGuiEscapeMenu_SaveOptions(self);
			ModGuiEscapeMenu_SetEscapeMenuState(self, EscapeMenuState_MAIN);
		}
		else {
			ModGuiEscapeMenu_SetEscapeMenuState(self, EscapeMenuState_MAIN);
			Game_GuiStateBackToGame(self->game);
		}
		KeyEventArgs_SetHandled(args, TRUE);
	}
	if (self->escapemenustate == EscapeMenuState_KEYS) {
		if (self->keyselectid != -1) {
			self->game->options->keys[ModGuiEscapeMenu_keyhelps(self)[self->keyselectid]->defaultKey] = eKey;
			self->keyselectid = -1;
			KeyEventArgs_SetHandled(args, TRUE);
		}
	}
	if (eKey == Game_GetKey(self->game, 20)) {
		if (self->game->platform->vtbl->getWindowState(self->game->platform) == WindowState_FULLSCREEN) {
			self->game->platform->vtbl->setWindowState(self->game->platform, WindowState_NORMAL);
			ModGuiEscapeMenu_RestoreResolution(self);
			ModGuiEscapeMenu_SaveOptions(self);
		}
		else {
			self->game->platform->vtbl->setWindowState(self->game->platform, WindowState_FULLSCREEN);
			ModGuiEscapeMenu_UseResolution(self);
			ModGuiEscapeMenu_SaveOptions(self);
		}
		KeyEventArgs_SetHandled(args, TRUE);
	}
}

void ModGuiEscapeMenu_OnNewFrameDraw2d(ModGuiEscapeMenu *self, Game *game_, float deltaTime)
{
	self->game = game_;
	if (!self->loaded) {
		self->loaded = TRUE;
		ModGuiEscapeMenu_LoadOptions(self);
	}
	if (self->game->escapeMenuRestart) {
		self->game->escapeMenuRestart = FALSE;
		ModGuiEscapeMenu_SetEscapeMenuState(self, EscapeMenuState_MAIN);
	}
	if (self->game->guistate != GuiState_ESCAPE_MENU) {
		return;
	}
	ModGuiEscapeMenu_SetEscapeMenuState(self, self->escapemenustate);
	ModGuiEscapeMenu_EscapeMenuMouse1(self);
	{
		int i;
		for (i = 0; i < self->widgetsCount; i++) {
			Button const *w = self->widgets[i];
			Game_Draw2dText1(self->game, w->text, w->x, w->y, w->fontsize, IntRef_Create(w->selected ? w->fontcolorselected : w->fontcolor), FALSE);
		}
	}
}

static void ModGuiEscapeMenu_OptionsHandleClick(ModGuiEscapeMenu *self, Button const *b)
{
	if (b == self->optionsGraphics) {
		ModGuiEscapeMenu_SetEscapeMenuState(self, EscapeMenuState_GRAPHICS);
	}
	if (b == self->optionsKeys) {
		ModGuiEscapeMenu_SetEscapeMenuState(self, EscapeMenuState_KEYS);
	}
	if (b == self->optionsOther) {
		ModGuiEscapeMenu_SetEscapeMenuState(self, EscapeMenuState_OTHER);
	}
	if (b == self->optionsReturnToMainMenu) {
		ModGuiEscapeMenu_SaveOptions(self);
		ModGuiEscapeMenu_SetEscapeMenuState(self, EscapeMenuState_MAIN);
	}
}

static void ModGuiEscapeMenu_OptionsSet(ModGuiEscapeMenu *self)
{
	Language const *language = self->game->language;
	self->optionsGraphics = Button_New();
	self->optionsGraphics->text = Language_Graphics(language);
	self->optionsKeys = Button_New();
	self->optionsKeys->text = Language_Keys(language);
	self->optionsOther = Button_New();
	self->optionsOther->text = Language_Other(language);
	self->optionsReturnToMainMenu = Button_New();
	self->optionsReturnToMainMenu->text = Language_ReturnToMainMenu(language);
	ModGuiEscapeMenu_WidgetsClear(self);
	ModGuiEscapeMenu_AddWidget(self, self->optionsGraphics);
	ModGuiEscapeMenu_AddWidget(self, self->optionsKeys);
	ModGuiEscapeMenu_AddWidget(self, self->optionsOther);
	ModGuiEscapeMenu_AddWidget(self, self->optionsReturnToMainMenu);
}

static void ModGuiEscapeMenu_OtherHandleClick(ModGuiEscapeMenu *self, Button const *b)
{
	if (b == self->otherSoundOption) {
		self->game->audioEnabled = !self->game->audioEnabled;
	}
	if (b == self->otherAutoJumpOption) {
		self->game->autoJumpEnabled = !self->game->autoJumpEnabled;
	}
	if (b == self->otherLanguageSetting) {
		Language_NextLanguage(self->game->language);
	}
	if (b == self->otherReturnToOptionsMenu) {
		ModGuiEscapeMenu_SetEscapeMenuState(self, EscapeMenuState_OPTIONS);
	}
}

static void ModGuiEscapeMenu_OtherSet(ModGuiEscapeMenu *self)
{
	Language const *language = self->game->language;
	self->otherSoundOption = Button_New();
	self->otherSoundOption->text = self->game->platform->vtbl->stringFormat(self->game->platform, Language_SoundOption(language), self->game->audioEnabled ? Language_On(language) : Language_Off(language));
	self->otherAutoJumpOption = Button_New();
	self->otherAutoJumpOption->text = self->game->platform->vtbl->stringFormat(self->game->platform, Language_AutoJumpOption(language), self->game->autoJumpEnabled ? Language_On(language) : Language_Off(language));
	self->otherLanguageSetting = Button_New();
	self->otherLanguageSetting->text = self->game->platform->vtbl->stringFormat(self->game->platform, Language_ClientLanguageOption(language), Language_GetUsedLanguage(language));
	self->otherReturnToOptionsMenu = Button_New();
	self->otherReturnToOptionsMenu->text = Language_ReturnToOptionsMenu(language);
	ModGuiEscapeMenu_WidgetsClear(self);
	ModGuiEscapeMenu_AddWidget(self, self->otherSoundOption);
	ModGuiEscapeMenu_AddWidget(self, self->otherAutoJumpOption);
	ModGuiEscapeMenu_AddWidget(self, self->otherLanguageSetting);
	ModGuiEscapeMenu_AddWidget(self, self->otherReturnToOptionsMenu);
}

static cibool ModGuiEscapeMenu_RectContains(ModGuiEscapeMenu const *self, int x, int y, int w, int h, int px, int py)
{
	return px >= x && py >= y && px < x + w && py < y + h;
}

static const char *ModGuiEscapeMenu_ResolutionString(ModGuiEscapeMenu const *self)
{
	IntRef const *resolutionsCount = IntRef_New();
	DisplayResolutionCi const *res = self->game->platform->vtbl->getDisplayResolutions(self->game->platform, resolutionsCount)[self->game->options->resolution];
	return self->game->platform->vtbl->stringFormat4(self->game->platform, "{0}x{1}, {2}, {3} Hz", self->game->platform->vtbl->intToString(self->game->platform, res->width), self->game->platform->vtbl->intToString(self->game->platform, res->height), self->game->platform->vtbl->intToString(self->game->platform, res->bitsPerPixel), self->game->platform->vtbl->intToString(self->game->platform, self->game->platform->vtbl->floatToInt(self->game->platform, res->refreshRate)));
}

void ModGuiEscapeMenu_RestoreResolution(ModGuiEscapeMenu *self)
{
	if (self->changedResolution) {
		self->game->platform->vtbl->changeResolution(self->game->platform, self->originalResolutionWidth, self->originalResolutionHeight, 32, -1);
		self->changedResolution = FALSE;
	}
}

void ModGuiEscapeMenu_SaveOptions(ModGuiEscapeMenu const *self)
{
	OptionsCi *options = self->game->options;
	options->font = self->game->font;
	options->shadows = TRUE;
	options->drawDistance = self->game->platform->vtbl->floatToInt(self->game->platform, self->game->d_Config3d->viewdistance);
	options->enableSound = self->game->audioEnabled;
	options->enableAutoJump = self->game->autoJumpEnabled;
	if (self->game->language->overrideLanguage != NULL) {
		options->clientLanguage = self->game->language->overrideLanguage;
	}
	options->framerate = self->game->eNABLE_LAG;
	options->fullscreen = self->game->platform->vtbl->getWindowState(self->game->platform) == WindowState_FULLSCREEN;
	options->smoothshadows = self->game->d_TerrainChunkTesselator->enableSmoothLight;
	options->enableBlockShadow = self->game->d_TerrainChunkTesselator->option_DarkenBlockSides;
	ModGuiEscapeMenu_SaveOptions_(self, options);
}

static void ModGuiEscapeMenu_SaveOptions_(ModGuiEscapeMenu const *self, OptionsCi const *options)
{
	Preferences const *preferences = self->game->platform->vtbl->getPreferences(self->game->platform);
	Preferences_SetBool(preferences, "Shadows", options->shadows);
	Preferences_SetInt(preferences, "Font", options->font);
	Preferences_SetInt(preferences, "DrawDistance", options->drawDistance);
	Preferences_SetBool(preferences, "UseServerTextures", options->useServerTextures);
	Preferences_SetBool(preferences, "EnableSound", options->enableSound);
	Preferences_SetBool(preferences, "EnableAutoJump", options->enableAutoJump);
	if (strcmp(options->clientLanguage, "") != 0) {
		Preferences_SetString(preferences, "ClientLanguage", options->clientLanguage);
	}
	Preferences_SetInt(preferences, "Framerate", options->framerate);
	Preferences_SetInt(preferences, "Resolution", options->resolution);
	Preferences_SetBool(preferences, "Fullscreen", options->fullscreen);
	Preferences_SetBool(preferences, "Smoothshadows", options->smoothshadows);
	Preferences_SetInt(preferences, "BlockShadowSave", self->game->platform->vtbl->floatToInt(self->game->platform, options->blockShadowSave * 100));
	Preferences_SetBool(preferences, "EnableBlockShadow", options->enableBlockShadow);
	{
		int i;
		for (i = 0; i < 256; i++) {
			int value = options->keys[i];
			const char *preferencesKey = StringTools_StringAppend(self->game->platform, "Key", self->game->platform->vtbl->intToString(self->game->platform, i));
			if (value != 0) {
				Preferences_SetInt(preferences, preferencesKey, value);
			}
			else {
				Preferences_Remove(preferences, preferencesKey);
			}
		}
	}
	self->game->platform->vtbl->setPreferences(self->game->platform, preferences);
}

static void ModGuiEscapeMenu_SetEscapeMenuState(ModGuiEscapeMenu *self, EscapeMenuState state)
{
	Language const *language = self->game->language;
	self->escapemenustate = state;
	ModGuiEscapeMenu_WidgetsClear(self);
	if (state == EscapeMenuState_MAIN) {
		ModGuiEscapeMenu_MainSet(self);
		ModGuiEscapeMenu_MakeSimpleOptions(self, 20, 50);
	}
	else if (state == EscapeMenuState_OPTIONS) {
		ModGuiEscapeMenu_OptionsSet(self);
		ModGuiEscapeMenu_MakeSimpleOptions(self, 20, 50);
	}
	else if (state == EscapeMenuState_GRAPHICS) {
		ModGuiEscapeMenu_GraphicsSet(self);
		ModGuiEscapeMenu_MakeSimpleOptions(self, 20, 50);
	}
	else if (state == EscapeMenuState_OTHER) {
		ModGuiEscapeMenu_OtherSet(self);
		ModGuiEscapeMenu_MakeSimpleOptions(self, 20, 50);
	}
	else if (state == EscapeMenuState_KEYS) {
		int fontsize;
		int textheight;
		ModGuiEscapeMenu_KeysSet(self);
		fontsize = 12;
		textheight = 20;
		ModGuiEscapeMenu_MakeSimpleOptions(self, fontsize, textheight);
	}
}

static void ModGuiEscapeMenu_ToggleFont(ModGuiEscapeMenu const *self)
{
	OptionsCi *options = self->game->options;
	options->font++;
	if (options->font >= self->fontsLength) {
		options->font = 0;
	}
	self->game->font = self->fontValues[options->font];
	Game_UpdateTextRendererFont(self->game);
	{
		int i;
		for (i = 0; i < self->game->cachedTextTexturesMax; i++) {
			self->game->cachedTextTextures[i] = NULL;
		}
	}
}

static void ModGuiEscapeMenu_ToggleResolution(ModGuiEscapeMenu const *self)
{
	OptionsCi *options = self->game->options;
	IntRef const *resolutionsCount;
	options->resolution++;
	resolutionsCount = IntRef_New();
	self->game->platform->vtbl->getDisplayResolutions(self->game->platform, resolutionsCount);
	if (options->resolution >= resolutionsCount->value) {
		options->resolution = 0;
	}
}

static void ModGuiEscapeMenu_UseFullscreen(ModGuiEscapeMenu *self)
{
	if (self->game->options->fullscreen) {
		if (!self->changedResolution) {
			self->originalResolutionWidth = self->game->platform->vtbl->getDisplayResolutionDefault(self->game->platform)->width;
			self->originalResolutionHeight = self->game->platform->vtbl->getDisplayResolutionDefault(self->game->platform)->height;
			self->changedResolution = TRUE;
		}
		self->game->platform->vtbl->setWindowState(self->game->platform, WindowState_FULLSCREEN);
		ModGuiEscapeMenu_UseResolution(self);
	}
	else {
		self->game->platform->vtbl->setWindowState(self->game->platform, WindowState_NORMAL);
		ModGuiEscapeMenu_RestoreResolution(self);
	}
}

void ModGuiEscapeMenu_UseResolution(ModGuiEscapeMenu const *self)
{
	OptionsCi *options = self->game->options;
	IntRef const *resolutionsCount = IntRef_New();
	DisplayResolutionCi const *const *resolutions = self->game->platform->vtbl->getDisplayResolutions(self->game->platform, resolutionsCount);
	DisplayResolutionCi const *res;
	if (resolutions == NULL) {
		return;
	}
	if (options->resolution >= resolutionsCount->value) {
		options->resolution = 0;
	}
	res = resolutions[options->resolution];
	if (self->game->platform->vtbl->getWindowState(self->game->platform) == WindowState_FULLSCREEN) {
		self->game->platform->vtbl->changeResolution(self->game->platform, res->width, res->height, res->bitsPerPixel, res->refreshRate);
		self->game->platform->vtbl->setWindowState(self->game->platform, WindowState_NORMAL);
		self->game->platform->vtbl->setWindowState(self->game->platform, WindowState_FULLSCREEN);
	}
	else {
	}
}

static const char *ModGuiEscapeMenu_VsyncString(ModGuiEscapeMenu const *self)
{
	if (self->game->eNABLE_LAG == 0) {
		return "Vsync";
	}
	else if (self->game->eNABLE_LAG == 1) {
		return "Unlimited";
	}
	else if (self->game->eNABLE_LAG == 2) {
		return "Lag";
	}
	else
		return NULL;
}

static void ModGuiEscapeMenu_WidgetsClear(ModGuiEscapeMenu *self)
{
	self->widgetsCount = 0;
}

static KeyHelp const *const *ModGuiEscapeMenu_keyhelps(ModGuiEscapeMenu const *self)
{
	int n = 1024;
	KeyHelp const **helps = (KeyHelp const **) malloc(n * sizeof(KeyHelp const *));
	Language const *language;
	int count;
	{
		int i;
		for (i = 0; i < n; i++) {
			helps[i] = NULL;
		}
	}
	language = self->game->language;
	count = 0;
	helps[count++] = ModGuiEscapeMenu_KeyHelpCreate(self, Language_KeyMoveFoward(language), 105);
	helps[count++] = ModGuiEscapeMenu_KeyHelpCreate(self, Language_KeyMoveBack(language), 101);
	helps[count++] = ModGuiEscapeMenu_KeyHelpCreate(self, Language_KeyMoveLeft(language), 83);
	helps[count++] = ModGuiEscapeMenu_KeyHelpCreate(self, Language_KeyMoveRight(language), 86);
	helps[count++] = ModGuiEscapeMenu_KeyHelpCreate(self, Language_KeyJump(language), 51);
	helps[count++] = ModGuiEscapeMenu_KeyHelpCreate(self, Language_KeyShowMaterialSelector(language), 84);
	helps[count++] = ModGuiEscapeMenu_KeyHelpCreate(self, Language_KeySetSpawnPosition(language), 98);
	helps[count++] = ModGuiEscapeMenu_KeyHelpCreate(self, Language_KeyRespawn(language), 97);
	helps[count++] = ModGuiEscapeMenu_KeyHelpCreate(self, Language_KeyReloadWeapon(language), 100);
	helps[count++] = ModGuiEscapeMenu_KeyHelpCreate(self, Language_KeyToggleFogDistance(language), 88);
	helps[count++] = ModGuiEscapeMenu_KeyHelpCreate(self, self->game->platform->vtbl->stringFormat(self->game->platform, Language_KeyMoveSpeed(language), "1"), 10);
	helps[count++] = ModGuiEscapeMenu_KeyHelpCreate(self, self->game->platform->vtbl->stringFormat(self->game->platform, Language_KeyMoveSpeed(language), "10"), 11);
	helps[count++] = ModGuiEscapeMenu_KeyHelpCreate(self, Language_KeyFreeMove(language), 12);
	helps[count++] = ModGuiEscapeMenu_KeyHelpCreate(self, Language_KeyThirdPersonCamera(language), 14);
	helps[count++] = ModGuiEscapeMenu_KeyHelpCreate(self, Language_KeyTextEditor(language), 18);
	helps[count++] = ModGuiEscapeMenu_KeyHelpCreate(self, Language_KeyFullscreen(language), 20);
	helps[count++] = ModGuiEscapeMenu_KeyHelpCreate(self, Language_KeyScreenshot(language), 21);
	helps[count++] = ModGuiEscapeMenu_KeyHelpCreate(self, Language_KeyPlayersList(language), 52);
	helps[count++] = ModGuiEscapeMenu_KeyHelpCreate(self, Language_KeyChat(language), 102);
	helps[count++] = ModGuiEscapeMenu_KeyHelpCreate(self, Language_KeyTeamChat(language), 107);
	helps[count++] = ModGuiEscapeMenu_KeyHelpCreate(self, Language_KeyCraft(language), 85);
	helps[count++] = ModGuiEscapeMenu_KeyHelpCreate(self, Language_KeyBlockInfo(language), 91);
	helps[count++] = ModGuiEscapeMenu_KeyHelpCreate(self, Language_KeyUse(language), 87);
	helps[count++] = ModGuiEscapeMenu_KeyHelpCreate(self, Language_KeyReverseMinecart(language), 99);
	return helps;
}

static void ModGuiInventory_Construct(ModGuiInventory *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModGuiInventory;
	ClientMod_Construct(&self->base, vtbl);
	self->wearPlaceStart = (PointRef const **) malloc(5 * sizeof(PointRef const *));
	{
		self->wearPlaceStart[0] = PointRef_Create(34, 100);
		self->wearPlaceStart[1] = PointRef_Create(74, 100);
		self->wearPlaceStart[2] = PointRef_Create(194, 100);
		self->wearPlaceStart[3] = PointRef_Create(114, 100);
		self->wearPlaceStart[4] = PointRef_Create(154, 100);
	}
	self->wearPlaceCells = (PointRef const **) malloc(5 * sizeof(PointRef const *));
	{
		self->wearPlaceCells[0] = PointRef_Create(1, 1);
		self->wearPlaceCells[1] = PointRef_Create(1, 1);
		self->wearPlaceCells[2] = PointRef_Create(1, 1);
		self->wearPlaceCells[3] = PointRef_Create(1, 1);
		self->wearPlaceCells[4] = PointRef_Create(1, 1);
	}
	self->cellCountInPageX = 12;
	self->cellCountInPageY = 7;
	self->cellCountTotalX = 12;
	self->cellCountTotalY = 42;
	self->cellDrawSize = 40;
}

ModGuiInventory *ModGuiInventory_New(void)
{
	ModGuiInventory *self = (ModGuiInventory *) malloc(sizeof(ModGuiInventory));
	if (self != NULL)
		ModGuiInventory_Construct(self, NULL);
	return self;
}

void ModGuiInventory_Delete(ModGuiInventory *self)
{
	free(self);
}

int ModGuiInventory_ActiveMaterialCellSize(ModGuiInventory const *self)
{
	return self->game->platform->vtbl->floatToInt(self->game->platform, 48 * Game_Scale(self->game));
}

int ModGuiInventory_CellsStartX(ModGuiInventory const *self)
{
	return 33 + ModGuiInventory_InventoryStartX(self);
}

int ModGuiInventory_CellsStartY(ModGuiInventory const *self)
{
	return 180 + ModGuiInventory_InventoryStartY(self);
}

static void ModGuiInventory_DrawItem(ModGuiInventory const *self, int screenposX, int screenposY, Packet_Item const *item, int drawsizeX, int drawsizeY)
{
	int sizex;
	int sizey;
	if (item == NULL) {
		return;
	}
	sizex = GameDataItemsClient_ItemSizeX(self->dataItems, item);
	sizey = GameDataItemsClient_ItemSizeY(self->dataItems, item);
	if (drawsizeX == 0 || drawsizeX == -1) {
		drawsizeX = self->cellDrawSize * sizex;
		drawsizeY = self->cellDrawSize * sizey;
	}
	if (item->itemClass == 0) {
		if (item->blockId == 0) {
			return;
		}
		Game_Draw2dTexture(self->game, self->game->terrainTexture, screenposX, screenposY, drawsizeX, drawsizeY, IntRef_Create(GameDataItemsClient_TextureIdForInventory(self->dataItems)[item->blockId]), Game_texturesPacked(self->game), Game_ColorFromArgb(255, 255, 255, 255), FALSE);
		if (item->blockCount > 1) {
			FontCi *font = FontCi_New();
			font->size = 8;
			font->family = "Arial";
			Game_Draw2dText(self->game, self->game->platform->vtbl->intToString(self->game->platform, item->blockCount), font, screenposX, screenposY, NULL, FALSE);
		}
	}
	else {
		Game_Draw2dBitmapFile(self->game, GameDataItemsClient_ItemGraphics(self->dataItems, item), screenposX, screenposY, drawsizeX, drawsizeY);
	}
}

void ModGuiInventory_DrawItemInfo(ModGuiInventory const *self, int screenposX, int screenposY, Packet_Item const *item)
{
	int sizex = GameDataItemsClient_ItemSizeX(self->dataItems, item);
	int sizey = GameDataItemsClient_ItemSizeY(self->dataItems, item);
	IntRef *tw = IntRef_New();
	IntRef *th = IntRef_New();
	float one = 1;
	int w;
	int h;
	FontCi *font;
	Packet_Item *item2;
	self->game->platform->vtbl->textSize(self->game->platform, GameDataItemsClient_ItemInfo(self->dataItems, item), 11 + one / 2, tw, th);
	tw->value += 6;
	th->value += 4;
	w = self->game->platform->vtbl->floatToInt(self->game->platform, tw->value + self->cellDrawSize * sizex);
	h = self->game->platform->vtbl->floatToInt(self->game->platform, th->value < self->cellDrawSize * sizey ? self->cellDrawSize * sizey + 4 : th->value);
	if (screenposX < w + 20) {
		screenposX = w + 20;
	}
	if (screenposY < h + 20) {
		screenposY = h + 20;
	}
	if (screenposX > Game_Width(self->game) - (w + 20)) {
		screenposX = Game_Width(self->game) - (w + 20);
	}
	if (screenposY > Game_Height(self->game) - (h + 20)) {
		screenposY = Game_Height(self->game) - (h + 20);
	}
	Game_Draw2dTexture(self->game, Game_WhiteTexture(self->game), screenposX - w, screenposY - h, w, h, NULL, 0, Game_ColorFromArgb(255, 0, 0, 0), FALSE);
	Game_Draw2dTexture(self->game, Game_WhiteTexture(self->game), screenposX - w + 2, screenposY - h + 2, w - 4, h - 4, NULL, 0, Game_ColorFromArgb(255, 105, 105, 105), FALSE);
	font = FontCi_New();
	font->family = "Arial";
	font->size = 10;
	Game_Draw2dText(self->game, GameDataItemsClient_ItemInfo(self->dataItems, item), font, screenposX - tw->value + 4, screenposY - h + 2, NULL, FALSE);
	item2 = Packet_Item_New();
	item2->blockId = item->blockId;
	ModGuiInventory_DrawItem(self, screenposX - w + 2, screenposY - h + 2, item2, 0, 0);
}

void ModGuiInventory_DrawMaterialSelector(ModGuiInventory const *self)
{
	int materialSelectorStartX_;
	int materialSelectorStartY_;
	Game_Draw2dBitmapFile(self->game, "materials.png", ModGuiInventory_MaterialSelectorBackgroundStartX(self), ModGuiInventory_MaterialSelectorBackgroundStartY(self), self->game->platform->vtbl->floatToInt(self->game->platform, 1024 * Game_Scale(self->game)), self->game->platform->vtbl->floatToInt(self->game->platform, 128 * Game_Scale(self->game)));
	materialSelectorStartX_ = ModGuiInventory_MaterialSelectorStartX(self);
	materialSelectorStartY_ = ModGuiInventory_MaterialSelectorStartY(self);
	{
		int i;
		for (i = 0; i < 10; i++) {
			Packet_Item const *item = self->game->d_Inventory->rightHand[i];
			if (item != NULL) {
				ModGuiInventory_DrawItem(self, materialSelectorStartX_ + i * ModGuiInventory_ActiveMaterialCellSize(self), materialSelectorStartY_, item, ModGuiInventory_ActiveMaterialCellSize(self), ModGuiInventory_ActiveMaterialCellSize(self));
			}
		}
	}
	Game_Draw2dBitmapFile(self->game, "activematerial.png", ModGuiInventory_MaterialSelectorStartX(self) + ModGuiInventory_ActiveMaterialCellSize(self) * self->game->activeMaterial, ModGuiInventory_MaterialSelectorStartY(self), ModGuiInventory_ActiveMaterialCellSize(self) * 64 / 48, ModGuiInventory_ActiveMaterialCellSize(self) * 64 / 48);
}

static Packet_Item const *ModGuiInventory_GetItem(ModGuiInventory const *self, Packet_Inventory const *inventory, int x, int y)
{
	{
		int i;
		for (i = 0; i < inventory->itemsCount; i++) {
			if (inventory->items[i]->x == x && inventory->items[i]->y == y) {
				return inventory->items[i]->value_;
			}
		}
	}
	return NULL;
}

int ModGuiInventory_InventoryStartX(ModGuiInventory const *self)
{
	return Game_Width(self->game) / 2 - 280;
}

int ModGuiInventory_InventoryStartY(ModGuiInventory const *self)
{
	return Game_Height(self->game) / 2 - 300;
}

cibool ModGuiInventory_IsMouseOverCells(ModGuiInventory const *self)
{
	return ModGuiInventory_SelectedCellOrScrollbar(self, self->game->mouseCurrentX, self->game->mouseCurrentY);
}

static int ModGuiInventory_MaterialSelectorBackgroundStartX(ModGuiInventory const *self)
{
	return self->game->platform->vtbl->floatToInt(self->game->platform, Game_Width(self->game) / 2 - 256 * Game_Scale(self->game));
}

static int ModGuiInventory_MaterialSelectorBackgroundStartY(ModGuiInventory const *self)
{
	return self->game->platform->vtbl->floatToInt(self->game->platform, Game_Height(self->game) - 90 * Game_Scale(self->game));
}

static int ModGuiInventory_MaterialSelectorStartX(ModGuiInventory const *self)
{
	return self->game->platform->vtbl->floatToInt(self->game->platform, ModGuiInventory_MaterialSelectorBackgroundStartX(self) + 17 * Game_Scale(self->game));
}

static int ModGuiInventory_MaterialSelectorStartY(ModGuiInventory const *self)
{
	return self->game->platform->vtbl->floatToInt(self->game->platform, ModGuiInventory_MaterialSelectorBackgroundStartY(self) + 17 * Game_Scale(self->game));
}

void ModGuiInventory_OnKeyPress(ModGuiInventory const *self, Game const *game_, KeyPressEventArgs const *args)
{
	int keyChar;
	if (self->game->guistate != GuiState_INVENTORY) {
		return;
	}
	keyChar = KeyPressEventArgs_GetKeyChar(args);
	if (keyChar == 49) {
		self->game->activeMaterial = 0;
	}
	if (keyChar == 50) {
		self->game->activeMaterial = 1;
	}
	if (keyChar == 51) {
		self->game->activeMaterial = 2;
	}
	if (keyChar == 52) {
		self->game->activeMaterial = 3;
	}
	if (keyChar == 53) {
		self->game->activeMaterial = 4;
	}
	if (keyChar == 54) {
		self->game->activeMaterial = 5;
	}
	if (keyChar == 55) {
		self->game->activeMaterial = 6;
	}
	if (keyChar == 56) {
		self->game->activeMaterial = 7;
	}
	if (keyChar == 57) {
		self->game->activeMaterial = 8;
	}
	if (keyChar == 48) {
		self->game->activeMaterial = 9;
	}
}

void ModGuiInventory_OnMouseDown(ModGuiInventory *self, Game const *game_, MouseEventArgs *args)
{
	PointRef const *scaledMouse;
	PointRef const *cellInPage;
	if (self->game->guistate != GuiState_INVENTORY) {
		return;
	}
	scaledMouse = PointRef_Create(MouseEventArgs_GetX(args), MouseEventArgs_GetY(args));
	if (ModGuiInventory_SelectedMaterialSelectorSlot(self, scaledMouse) != NULL) {
		self->game->activeMaterial = ModGuiInventory_SelectedMaterialSelectorSlot(self, scaledMouse)->value;
		{
			Packet_InventoryPosition *p = Packet_InventoryPosition_New();
			p->type = 2;
			p->materialId = self->game->activeMaterial;
			self->controller->vtbl->inventoryClick(self->controller, p);
		}
		MouseEventArgs_SetHandled(args, TRUE);
		return;
	}
	if (self->game->guistate != GuiState_INVENTORY) {
		return;
	}
	cellInPage = ModGuiInventory_SelectedCell(self, scaledMouse);
	if (cellInPage != NULL) {
		if (MouseEventArgs_GetButton(args) == 0) {
			Packet_InventoryPosition *p = Packet_InventoryPosition_New();
			p->type = 0;
			p->areaX = cellInPage->x;
			p->areaY = cellInPage->y + self->scrollLine;
			self->controller->vtbl->inventoryClick(self->controller, p);
			MouseEventArgs_SetHandled(args, TRUE);
			return;
		}
		else {
			{
				Packet_InventoryPosition *p = Packet_InventoryPosition_New();
				p->type = 0;
				p->areaX = cellInPage->x;
				p->areaY = cellInPage->y + self->scrollLine;
				self->controller->vtbl->inventoryClick(self->controller, p);
			}
			{
				Packet_InventoryPosition *p = Packet_InventoryPosition_New();
				p->type = 3;
				p->wearPlace = 0;
				p->activeMaterial = self->game->activeMaterial;
				self->controller->vtbl->inventoryClick(self->controller, p);
			}
			{
				Packet_InventoryPosition *p = Packet_InventoryPosition_New();
				p->type = 0;
				p->areaX = cellInPage->x;
				p->areaY = cellInPage->y + self->scrollLine;
				self->controller->vtbl->inventoryClick(self->controller, p);
			}
		}
		if (self->game->guistate == GuiState_INVENTORY) {
			MouseEventArgs_SetHandled(args, TRUE);
			return;
		}
	}
	if (ModGuiInventory_SelectedWearPlace(self, scaledMouse) != NULL) {
		Packet_InventoryPosition *p = Packet_InventoryPosition_New();
		p->type = 3;
		p->wearPlace = ModGuiInventory_SelectedWearPlace(self, scaledMouse)->value;
		p->activeMaterial = self->game->activeMaterial;
		self->controller->vtbl->inventoryClick(self->controller, p);
		MouseEventArgs_SetHandled(args, TRUE);
		return;
	}
	if (scaledMouse->x >= ModGuiInventory_ScrollUpButtonX(self) && scaledMouse->x < ModGuiInventory_ScrollUpButtonX(self) + ModGuiInventory_ScrollButtonSize(self) && scaledMouse->y >= ModGuiInventory_ScrollUpButtonY(self) && scaledMouse->y < ModGuiInventory_ScrollUpButtonY(self) + ModGuiInventory_ScrollButtonSize(self)) {
		ModGuiInventory_ScrollUp(self);
		self->scrollingUpTimeMilliseconds = self->game->platform->vtbl->timeMillisecondsFromStart(self->game->platform);
		MouseEventArgs_SetHandled(args, TRUE);
		return;
	}
	if (scaledMouse->x >= ModGuiInventory_ScrollDownButtonX(self) && scaledMouse->x < ModGuiInventory_ScrollDownButtonX(self) + ModGuiInventory_ScrollButtonSize(self) && scaledMouse->y >= ModGuiInventory_ScrollDownButtonY(self) && scaledMouse->y < ModGuiInventory_ScrollDownButtonY(self) + ModGuiInventory_ScrollButtonSize(self)) {
		ModGuiInventory_ScrollDown(self);
		self->scrollingDownTimeMilliseconds = self->game->platform->vtbl->timeMillisecondsFromStart(self->game->platform);
		MouseEventArgs_SetHandled(args, TRUE);
		return;
	}
	Game_GuiStateBackToGame(self->game);
	return;
}

void ModGuiInventory_OnMouseUp(ModGuiInventory *self, Game const *game_, MouseEventArgs const *args)
{
	if (self->game->guistate != GuiState_INVENTORY) {
		return;
	}
	self->scrollingUpTimeMilliseconds = 0;
	self->scrollingDownTimeMilliseconds = 0;
}

void ModGuiInventory_OnMouseWheelChanged(ModGuiInventory *self, Game *game_, MouseWheelEventArgs const *args)
{
	float delta = MouseWheelEventArgs_GetDeltaPrecise(args);
	if ((game_->guistate == GuiState_NORMAL || (game_->guistate == GuiState_INVENTORY && !ModGuiInventory_IsMouseOverCells(self))) && !game_->keyboardState[Game_GetKey(game_, 1)]) {
		game_->activeMaterial -= game_->platform->vtbl->floatToInt(game_->platform, delta);
		game_->activeMaterial = game_->activeMaterial % 10;
		while (game_->activeMaterial < 0) {
			game_->activeMaterial += 10;
		}
	}
	if (ModGuiInventory_IsMouseOverCells(self) && self->game->guistate == GuiState_INVENTORY) {
		if (delta > 0) {
			ModGuiInventory_ScrollUp(self);
		}
		if (delta < 0) {
			ModGuiInventory_ScrollDown(self);
		}
	}
}

void ModGuiInventory_OnNewFrameDraw2d(ModGuiInventory *self, Game *game_, float deltaTime)
{
	PointRef const *scaledMouse;
	self->game = game_;
	if (self->dataItems == NULL) {
		self->dataItems = GameDataItemsClient_New();
		self->dataItems->game = game_;
		self->controller = &ClientInventoryController_Create(game_)->base;
		self->inventoryUtil = self->game->d_InventoryUtil;
	}
	if (self->game->guistate == GuiState_MAP_LOADING) {
		return;
	}
	ModGuiInventory_DrawMaterialSelector(self);
	if (self->game->guistate != GuiState_INVENTORY) {
		return;
	}
	if (self->scrollingUpTimeMilliseconds != 0 && self->game->platform->vtbl->timeMillisecondsFromStart(self->game->platform) - self->scrollingUpTimeMilliseconds > 250) {
		self->scrollingUpTimeMilliseconds = self->game->platform->vtbl->timeMillisecondsFromStart(self->game->platform);
		ModGuiInventory_ScrollUp(self);
	}
	if (self->scrollingDownTimeMilliseconds != 0 && self->game->platform->vtbl->timeMillisecondsFromStart(self->game->platform) - self->scrollingDownTimeMilliseconds > 250) {
		self->scrollingDownTimeMilliseconds = self->game->platform->vtbl->timeMillisecondsFromStart(self->game->platform);
		ModGuiInventory_ScrollDown(self);
	}
	scaledMouse = PointRef_Create(self->game->mouseCurrentX, self->game->mouseCurrentY);
	Game_Draw2dBitmapFile(self->game, "inventory.png", ModGuiInventory_InventoryStartX(self), ModGuiInventory_InventoryStartY(self), 1024, 1024);
	{
		int i;
		for (i = 0; i < self->game->d_Inventory->itemsCount; i++) {
			Packet_PositionItem const *k = self->game->d_Inventory->items[i];
			int screeny;
			if (k == NULL) {
				continue;
			}
			screeny = k->y - self->scrollLine;
			if (screeny >= 0 && screeny < self->cellCountInPageY) {
				ModGuiInventory_DrawItem(self, ModGuiInventory_CellsStartX(self) + k->x * self->cellDrawSize, ModGuiInventory_CellsStartY(self) + screeny * self->cellDrawSize, k->value_, 0, 0);
			}
		}
	}
	if (self->game->d_Inventory->dragDropItem != NULL) {
		PointRef const *selectedInPage = ModGuiInventory_SelectedCell(self, scaledMouse);
		IntRef const *selectedWear;
		if (selectedInPage != NULL) {
			int x = selectedInPage->x * self->cellDrawSize + ModGuiInventory_CellsStartX(self);
			int y = selectedInPage->y * self->cellDrawSize + ModGuiInventory_CellsStartY(self);
			int sizex = GameDataItemsClient_ItemSizeX(self->dataItems, self->game->d_Inventory->dragDropItem);
			int sizey = GameDataItemsClient_ItemSizeY(self->dataItems, self->game->d_Inventory->dragDropItem);
			if (selectedInPage->x + sizex <= self->cellCountInPageX && selectedInPage->y + sizey <= self->cellCountInPageY) {
				int c;
				IntRef *itemsAtAreaCount = IntRef_New();
				PointRef const *const *itemsAtArea = InventoryUtilClient_ItemsAtArea(self->inventoryUtil, selectedInPage->x, selectedInPage->y + self->scrollLine, sizex, sizey, itemsAtAreaCount);
				if (itemsAtArea == NULL || itemsAtAreaCount->value > 1) {
					c = Game_ColorFromArgb(100, 255, 0, 0);
				}
				else {
					c = Game_ColorFromArgb(100, 0, 255, 0);
				}
				Game_Draw2dTexture(self->game, Game_WhiteTexture(self->game), x, y, self->cellDrawSize * sizex, self->cellDrawSize * sizey, NULL, 0, c, FALSE);
			}
		}
		selectedWear = ModGuiInventory_SelectedWearPlace(self, scaledMouse);
		if (selectedWear != NULL) {
			PointRef const *p = PointRef_Create(self->wearPlaceStart[selectedWear->value]->x + ModGuiInventory_InventoryStartX(self), self->wearPlaceStart[selectedWear->value]->y + ModGuiInventory_InventoryStartY(self));
			PointRef const *size = self->wearPlaceCells[selectedWear->value];
			int c;
			Packet_Item const *itemsAtArea = InventoryUtilClient_ItemAtWearPlace(self->inventoryUtil, selectedWear->value, self->game->activeMaterial);
			if (!GameDataItemsClient_CanWear(self->dataItems, selectedWear->value, self->game->d_Inventory->dragDropItem)) {
				c = Game_ColorFromArgb(100, 255, 0, 0);
			}
			else {
				c = Game_ColorFromArgb(100, 0, 255, 0);
			}
			Game_Draw2dTexture(self->game, Game_WhiteTexture(self->game), p->x, p->y, self->cellDrawSize * size->x, self->cellDrawSize * size->y, NULL, 0, c, FALSE);
		}
	}
	ModGuiInventory_DrawMaterialSelector(self);
	ModGuiInventory_DrawItem(self, self->wearPlaceStart[0]->x + ModGuiInventory_InventoryStartX(self), self->wearPlaceStart[0]->y + ModGuiInventory_InventoryStartY(self), self->game->d_Inventory->rightHand[self->game->activeMaterial], 0, 0);
	ModGuiInventory_DrawItem(self, self->wearPlaceStart[1]->x + ModGuiInventory_InventoryStartX(self), self->wearPlaceStart[1]->y + ModGuiInventory_InventoryStartY(self), self->game->d_Inventory->mainArmor, 0, 0);
	ModGuiInventory_DrawItem(self, self->wearPlaceStart[2]->x + ModGuiInventory_InventoryStartX(self), self->wearPlaceStart[2]->y + ModGuiInventory_InventoryStartY(self), self->game->d_Inventory->boots, 0, 0);
	ModGuiInventory_DrawItem(self, self->wearPlaceStart[3]->x + ModGuiInventory_InventoryStartX(self), self->wearPlaceStart[3]->y + ModGuiInventory_InventoryStartY(self), self->game->d_Inventory->helmet, 0, 0);
	ModGuiInventory_DrawItem(self, self->wearPlaceStart[4]->x + ModGuiInventory_InventoryStartX(self), self->wearPlaceStart[4]->y + ModGuiInventory_InventoryStartY(self), self->game->d_Inventory->gauntlet, 0, 0);
	if (ModGuiInventory_SelectedCell(self, scaledMouse) != NULL) {
		PointRef *selected = ModGuiInventory_SelectedCell(self, scaledMouse);
		PointRef const *itemAtCell;
		selected->y += self->scrollLine;
		itemAtCell = InventoryUtilClient_ItemAtCell(self->inventoryUtil, selected);
		if (itemAtCell != NULL) {
			Packet_Item const *item = ModGuiInventory_GetItem(self, self->game->d_Inventory, itemAtCell->x, itemAtCell->y);
			if (item != NULL) {
				int x = selected->x * self->cellDrawSize + ModGuiInventory_CellsStartX(self);
				int y = selected->y * self->cellDrawSize + ModGuiInventory_CellsStartY(self);
				ModGuiInventory_DrawItemInfo(self, scaledMouse->x, scaledMouse->y, item);
			}
		}
	}
	if (ModGuiInventory_SelectedWearPlace(self, scaledMouse) != NULL) {
		int selected = ModGuiInventory_SelectedWearPlace(self, scaledMouse)->value;
		Packet_Item const *itemAtWearPlace = InventoryUtilClient_ItemAtWearPlace(self->inventoryUtil, selected, self->game->activeMaterial);
		if (itemAtWearPlace != NULL) {
			ModGuiInventory_DrawItemInfo(self, scaledMouse->x, scaledMouse->y, itemAtWearPlace);
		}
	}
	if (ModGuiInventory_SelectedMaterialSelectorSlot(self, scaledMouse) != NULL) {
		int selected = ModGuiInventory_SelectedMaterialSelectorSlot(self, scaledMouse)->value;
		Packet_Item const *item = self->game->d_Inventory->rightHand[selected];
		if (item != NULL) {
			ModGuiInventory_DrawItemInfo(self, scaledMouse->x, scaledMouse->y, item);
		}
	}
	if (self->game->d_Inventory->dragDropItem != NULL) {
		ModGuiInventory_DrawItem(self, scaledMouse->x, scaledMouse->y, self->game->d_Inventory->dragDropItem, 0, 0);
	}
}

void ModGuiInventory_OnTouchStart(ModGuiInventory *self, Game const *game_, TouchEventArgs *e)
{
	MouseEventArgs *args = MouseEventArgs_New();
	MouseEventArgs_SetX(args, TouchEventArgs_GetX(e));
	MouseEventArgs_SetY(args, TouchEventArgs_GetY(e));
	self->base.vtbl->onMouseDown(&self->base, game_, args);
	TouchEventArgs_SetHandled(e, MouseEventArgs_GetHandled(args));
}

static int ModGuiInventory_ScrollButtonSize(ModGuiInventory const *self)
{
	return self->cellDrawSize;
}

void ModGuiInventory_ScrollDown(ModGuiInventory *self)
{
	int max;
	self->scrollLine++;
	max = self->cellCountTotalY - self->cellCountInPageY;
	if (self->scrollLine >= max) {
		self->scrollLine = max;
	}
}

static int ModGuiInventory_ScrollDownButtonX(ModGuiInventory const *self)
{
	return ModGuiInventory_CellsStartX(self) + self->cellCountInPageX * self->cellDrawSize;
}

static int ModGuiInventory_ScrollDownButtonY(ModGuiInventory const *self)
{
	return ModGuiInventory_CellsStartY(self) + (self->cellCountInPageY - 1) * self->cellDrawSize;
}

void ModGuiInventory_ScrollUp(ModGuiInventory *self)
{
	self->scrollLine--;
	if (self->scrollLine < 0) {
		self->scrollLine = 0;
	}
}

static int ModGuiInventory_ScrollUpButtonX(ModGuiInventory const *self)
{
	return ModGuiInventory_CellsStartX(self) + self->cellCountInPageX * self->cellDrawSize;
}

static int ModGuiInventory_ScrollUpButtonY(ModGuiInventory const *self)
{
	return ModGuiInventory_CellsStartY(self);
}

static PointRef *ModGuiInventory_SelectedCell(ModGuiInventory const *self, PointRef const *scaledMouse)
{
	PointRef const *cell;
	if (scaledMouse->x < ModGuiInventory_CellsStartX(self) || scaledMouse->y < ModGuiInventory_CellsStartY(self) || scaledMouse->x > ModGuiInventory_CellsStartX(self) + self->cellCountInPageX * self->cellDrawSize || scaledMouse->y > ModGuiInventory_CellsStartY(self) + self->cellCountInPageY * self->cellDrawSize) {
		return NULL;
	}
	cell = PointRef_Create((scaledMouse->x - ModGuiInventory_CellsStartX(self)) / self->cellDrawSize, (scaledMouse->y - ModGuiInventory_CellsStartY(self)) / self->cellDrawSize);
	return cell;
}

static cibool ModGuiInventory_SelectedCellOrScrollbar(ModGuiInventory const *self, int scaledMouseX, int scaledMouseY)
{
	if (scaledMouseX < ModGuiInventory_CellsStartX(self) || scaledMouseY < ModGuiInventory_CellsStartY(self) || scaledMouseX > ModGuiInventory_CellsStartX(self) + (self->cellCountInPageX + 1) * self->cellDrawSize || scaledMouseY > ModGuiInventory_CellsStartY(self) + self->cellCountInPageY * self->cellDrawSize) {
		return FALSE;
	}
	return TRUE;
}

static IntRef const *ModGuiInventory_SelectedMaterialSelectorSlot(ModGuiInventory const *self, PointRef const *scaledMouse)
{
	if (scaledMouse->x >= ModGuiInventory_MaterialSelectorStartX(self) && scaledMouse->y >= ModGuiInventory_MaterialSelectorStartY(self) && scaledMouse->x < ModGuiInventory_MaterialSelectorStartX(self) + 10 * ModGuiInventory_ActiveMaterialCellSize(self) && scaledMouse->y < ModGuiInventory_MaterialSelectorStartY(self) + 10 * ModGuiInventory_ActiveMaterialCellSize(self)) {
		return IntRef_Create((scaledMouse->x - ModGuiInventory_MaterialSelectorStartX(self)) / ModGuiInventory_ActiveMaterialCellSize(self));
	}
	return NULL;
}

static IntRef const *ModGuiInventory_SelectedWearPlace(ModGuiInventory const *self, PointRef const *scaledMouse)
{
	{
		int i;
		for (i = 0; i < 5; i++) {
			PointRef *p = self->wearPlaceStart[i];
			PointRef const *cells;
			p->x += ModGuiInventory_InventoryStartX(self);
			p->y += ModGuiInventory_InventoryStartY(self);
			cells = self->wearPlaceCells[i];
			if (scaledMouse->x >= p->x && scaledMouse->y >= p->y && scaledMouse->x < p->x + cells->x * self->cellDrawSize && scaledMouse->y < p->y + cells->y * self->cellDrawSize) {
				return IntRef_Create(i);
			}
		}
	}
	return NULL;
}

static void ModGuiMapLoading_Construct(ModGuiMapLoading *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModGuiMapLoading;
	ClientMod_Construct(&self->base, vtbl);
}

ModGuiMapLoading *ModGuiMapLoading_New(void)
{
	ModGuiMapLoading *self = (ModGuiMapLoading *) malloc(sizeof(ModGuiMapLoading));
	if (self != NULL)
		ModGuiMapLoading_Construct(self, NULL);
	return self;
}

void ModGuiMapLoading_Delete(ModGuiMapLoading *self)
{
	free(self);
}

static void ModGuiMapLoading_DrawBackground(ModGuiMapLoading *self, Game *game)
{
	int countX;
	int countY;
	self->backgroundW = 512;
	self->backgroundH = 512;
	countX = game->platform->vtbl->floatToInt(game->platform, self->width / self->backgroundW) + 1;
	countY = game->platform->vtbl->floatToInt(game->platform, self->height / self->backgroundH) + 1;
	{
		int x;
		for (x = 0; x < countX; x++) {
			{
				int y;
				for (y = 0; y < countY; y++) {
					Game_Draw2dTexture(game, Game_GetTexture(game, "background.png"), x * self->backgroundW, y * self->backgroundH, self->backgroundW, self->backgroundH, NULL, 0, Game_ColorFromArgb(255, 255, 255, 255), FALSE);
				}
			}
		}
	}
}

void ModGuiMapLoading_OnNewFrameDraw2d(ModGuiMapLoading *self, Game *game, float deltaTime)
{
	GamePlatform const *platform;
	float one;
	const char *connecting;
	IntRef const *serverNameWidth;
	IntRef const *serverNameHeight;
	IntRef const *connectingWidth;
	IntRef const *connectingHeight;
	const char *progress;
	const char *progress1;
	if (game->guistate != GuiState_MAP_LOADING) {
		return;
	}
	platform = game->platform;
	one = 1;
	self->width = platform->vtbl->getCanvasWidth(platform);
	self->height = platform->vtbl->getCanvasHeight(platform);
	ModGuiMapLoading_DrawBackground(self, game);
	connecting = Language_Connecting(game->language);
	if (game->issingleplayer && !platform->vtbl->singlePlayerServerLoaded(platform)) {
		connecting = "Starting game...";
	}
	if (game->maploadingprogress->progressStatus != NULL) {
		connecting = game->maploadingprogress->progressStatus;
	}
	if (game->invalidVersionDrawMessage != NULL) {
		const char *connect;
		Game_Draw2dText(game, game->invalidVersionDrawMessage, game->fontMapLoading, Game_xcenter(game, Game_TextSizeWidth(game, game->invalidVersionDrawMessage, 14)), self->height / 2 - 50, NULL, FALSE);
		connect = "Click to connect";
		Game_Draw2dText(game, connect, game->fontMapLoading, Game_xcenter(game, Game_TextSizeWidth(game, connect, 14)), self->height / 2 + 50, NULL, FALSE);
		return;
	}
	serverNameWidth = IntRef_New();
	serverNameHeight = IntRef_New();
	platform->vtbl->textSize(platform, game->serverInfo->serverName, 14, serverNameWidth, serverNameHeight);
	Game_Draw2dText(game, game->serverInfo->serverName, game->fontMapLoading, Game_xcenter(game, serverNameWidth->value), self->height / 2 - 150, NULL, FALSE);
	if (game->serverInfo->serverMotd != NULL) {
		IntRef const *serverMotdWidth = IntRef_New();
		IntRef const *serverMotdHeight = IntRef_New();
		platform->vtbl->textSize(platform, game->serverInfo->serverMotd, 14, serverMotdWidth, serverMotdHeight);
		Game_Draw2dText(game, game->serverInfo->serverMotd, game->fontMapLoading, Game_xcenter(game, serverMotdWidth->value), self->height / 2 - 100, NULL, FALSE);
	}
	connectingWidth = IntRef_New();
	connectingHeight = IntRef_New();
	platform->vtbl->textSize(platform, connecting, 14, connectingWidth, connectingHeight);
	Game_Draw2dText(game, connecting, game->fontMapLoading, Game_xcenter(game, connectingWidth->value), self->height / 2 - 50, NULL, FALSE);
	progress = platform->vtbl->stringFormat(platform, Language_ConnectingProgressPercent(game->language), platform->vtbl->intToString(platform, game->maploadingprogress->progressPercent));
	progress1 = platform->vtbl->stringFormat(platform, Language_ConnectingProgressKilobytes(game->language), platform->vtbl->intToString(platform, game->maploadingprogress->progressBytes / 1024));
	if (game->maploadingprogress->progressPercent > 0) {
		IntRef const *progressWidth = IntRef_New();
		IntRef const *progressHeight = IntRef_New();
		IntRef const *progress1Width;
		IntRef const *progress1Height;
		float progressratio;
		int sizex;
		int sizey;
		int red;
		int yellow;
		int green;
		int *colors;
		int c;
		platform->vtbl->textSize(platform, progress, 14, progressWidth, progressHeight);
		Game_Draw2dText(game, progress, game->fontMapLoading, Game_xcenter(game, progressWidth->value), self->height / 2 - 20, NULL, FALSE);
		progress1Width = IntRef_New();
		progress1Height = IntRef_New();
		platform->vtbl->textSize(platform, progress1, 14, progress1Width, progress1Height);
		Game_Draw2dText(game, progress1, game->fontMapLoading, Game_xcenter(game, progress1Width->value), self->height / 2 + 10, NULL, FALSE);
		progressratio = one * game->maploadingprogress->progressPercent / 100;
		sizex = 400;
		sizey = 40;
		Game_Draw2dTexture(game, Game_WhiteTexture(game), Game_xcenter(game, sizex), self->height / 2 + 70, sizex, sizey, NULL, 0, Game_ColorFromArgb(255, 0, 0, 0), FALSE);
		red = Game_ColorFromArgb(255, 255, 0, 0);
		yellow = Game_ColorFromArgb(255, 255, 255, 0);
		green = Game_ColorFromArgb(255, 0, 255, 0);
		colors = (int *) malloc(3 * sizeof(int ));
		colors[0] = red;
		colors[1] = yellow;
		colors[2] = green;
		c = InterpolationCi_InterpolateColor(platform, progressratio, colors, 3);
		Game_Draw2dTexture(game, Game_WhiteTexture(game), Game_xcenter(game, sizex), self->height / 2 + 70, progressratio * sizex, sizey, NULL, 0, c, FALSE);
	}
}

static void ModGuiPlayerStats_Construct(ModGuiPlayerStats *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModGuiPlayerStats;
	ClientMod_Construct(&self->base, vtbl);
}

ModGuiPlayerStats *ModGuiPlayerStats_New(void)
{
	ModGuiPlayerStats *self = (ModGuiPlayerStats *) malloc(sizeof(ModGuiPlayerStats));
	if (self != NULL)
		ModGuiPlayerStats_Construct(self, NULL);
	return self;
}

void ModGuiPlayerStats_Delete(ModGuiPlayerStats *self)
{
	free(self);
}

void ModGuiPlayerStats_DrawPlayerHealth(ModGuiPlayerStats const *self, Game *game)
{
	if (game->playerStats != NULL) {
		float progress = game->one * game->playerStats->currentHealth / game->playerStats->maxHealth;
		Game_Draw2dTexture(game, Game_GetTexture(game, "ui_bar_background.png"), self->healthPosX, self->healthPosY, 220, 32, NULL, 0, Game_ColorFromArgb(255, 255, 255, 255), FALSE);
		Game_Draw2dTexturePart(game, Game_GetTexture(game, "ui_bar_inner.png"), progress, 1, self->healthPosX, self->healthPosY, progress * 220, 32, Game_ColorFromArgb(255, 255, 0, 0), FALSE);
	}
}

void ModGuiPlayerStats_DrawPlayerOxygen(ModGuiPlayerStats const *self, Game *game)
{
	if (game->playerStats != NULL) {
		if (game->playerStats->currentOxygen < game->playerStats->maxOxygen) {
			float progress = game->one * game->playerStats->currentOxygen / game->playerStats->maxOxygen;
			Game_Draw2dTexture(game, Game_GetTexture(game, "ui_bar_background.png"), self->oxygenPosX, self->oxygenPosY, 220, 32, NULL, 0, Game_ColorFromArgb(255, 255, 255, 255), FALSE);
			Game_Draw2dTexturePart(game, Game_GetTexture(game, "ui_bar_inner.png"), progress, 1, self->oxygenPosX, self->oxygenPosY, progress * 220, 32, Game_ColorFromArgb(255, 0, 0, 255), FALSE);
		}
	}
}

void ModGuiPlayerStats_OnNewFrameDraw2d(ModGuiPlayerStats *self, Game *game, float deltaTime)
{
	self->healthPosX = Game_Width(game) / 2 - 220 - 20;
	self->healthPosY = Game_Height(game) - 122;
	self->oxygenPosX = Game_Width(game) / 2 + 20;
	self->oxygenPosY = Game_Height(game) - 122;
	if (game->guistate != GuiState_MAP_LOADING) {
		ModGuiPlayerStats_DrawPlayerHealth(self, game);
		ModGuiPlayerStats_DrawPlayerOxygen(self, game);
	}
}

static void ModGuiTextEditor_Construct(ModGuiTextEditor *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = (const ClientModVtbl *) &CiVtbl_ModGuiTextEditor;
	GameScreen_Construct(&self->base, vtbl);
	self->buffer = (int const **) malloc(128 * sizeof(int const *));
	{
		int i;
		for (i = 0; i < 128; i++) {
			self->buffer[i] = (int *) malloc(80 * sizeof(int ));
		}
	}
	self->startX = 100;
	self->startY = 100;
	self->charSize = 12;
	self->font = FontCi_New();
	self->font->family = "Courier New";
	self->font->size = 12;
}

ModGuiTextEditor *ModGuiTextEditor_New(void)
{
	ModGuiTextEditor *self = (ModGuiTextEditor *) malloc(sizeof(ModGuiTextEditor));
	if (self != NULL)
		ModGuiTextEditor_Construct(self, NULL);
	return self;
}

void ModGuiTextEditor_Delete(ModGuiTextEditor *self)
{
	free(self);
}

static int ModGuiTextEditor_LineLength(ModGuiTextEditor const *self, int const *line)
{
	{
		int i;
		for (i = 0; i < 80; i++) {
			if (line[i] == 0) {
				return i;
			}
		}
	}
	return 80;
}

static const char *ModGuiTextEditor_LineToString(ModGuiTextEditor const *self, int const *line)
{
	if (line == NULL) {
		return "";
	}
	return self->base.game->platform->vtbl->charArrayToString(self->base.game->platform, line, ModGuiTextEditor_LineLength(self, line));
}

void ModGuiTextEditor_OnKeyDown(ModGuiTextEditor *self, Game const *game_, KeyEventArgs *e)
{
	if (KeyEventArgs_GetKeyCode(e) == Game_GetKey(self->base.game, 18)) {
		self->visible = !self->visible;
	}
	if (!self->visible) {
		return;
	}
	if (KeyEventArgs_GetKeyCode(e) == 50) {
		self->visible = FALSE;
	}
	if (KeyEventArgs_GetKeyCode(e) == 47) {
		self->cursorColumn--;
	}
	if (KeyEventArgs_GetKeyCode(e) == 48) {
		self->cursorColumn++;
	}
	if (KeyEventArgs_GetKeyCode(e) == 45) {
		self->cursorLine--;
	}
	if (KeyEventArgs_GetKeyCode(e) == 46) {
		self->cursorLine++;
	}
	if (KeyEventArgs_GetKeyCode(e) == 53) {
		self->cursorColumn--;
		KeyEventArgs_SetKeyCode(e, 55);
	}
	if (self->cursorColumn < 0) {
		self->cursorColumn = 0;
	}
	if (self->cursorLine < 0) {
		self->cursorLine = 0;
	}
	if (self->cursorColumn >= 80) {
		self->cursorColumn = 80;
	}
	if (self->cursorLine > 128) {
		self->cursorLine = 128;
	}
	if (self->cursorColumn > ModGuiTextEditor_LineLength(self, self->buffer[self->cursorLine])) {
		self->cursorColumn = ModGuiTextEditor_LineLength(self, self->buffer[self->cursorLine]);
	}
	if (KeyEventArgs_GetKeyCode(e) == 55) {
		{
			int i;
			for (i = self->cursorColumn; i < 79; i++) {
				self->buffer[self->cursorLine][i] = self->buffer[self->cursorLine][i + 1];
			}
		}
	}
	KeyEventArgs_SetHandled(e, TRUE);
}

void ModGuiTextEditor_OnKeyPress(ModGuiTextEditor *self, Game const *game_, KeyPressEventArgs *e)
{
	if (!self->visible) {
		return;
	}
	if (KeyPressEventArgs_GetKeyChar(e) == 8) {
		return;
	}
	{
		int i;
		for (i = 79; i > self->cursorColumn; i--) {
			self->buffer[self->cursorLine][i] = self->buffer[self->cursorLine][i - 1];
		}
	}
	self->buffer[self->cursorLine][self->cursorColumn] = KeyPressEventArgs_GetKeyChar(e);
	self->cursorColumn++;
	KeyPressEventArgs_SetHandled(e, TRUE);
}

void ModGuiTextEditor_OnNewFrameDraw2d(ModGuiTextEditor const *self, Game *game, float deltaTime)
{
	float dt = deltaTime;
	int *spaces;
	const char *spacesString;
	if (!self->visible) {
		return;
	}
	Game_Draw2dTexture(game, Game_WhiteTexture(game), self->startX, self->startY, 80 * self->charSize, 128 * self->charSize, NULL, 0, Game_ColorFromArgb(255, 100, 100, 100), FALSE);
	{
		int i;
		for (i = 0; i < 128; i++) {
			Game_Draw2dText(game, ModGuiTextEditor_LineToString(self, self->buffer[i]), self->font, self->startX, self->startY + self->charSize * i, NULL, FALSE);
		}
	}
	spaces = (int *) malloc(80 * sizeof(int ));
	{
		int i;
		for (i = 0; i < 80; i++) {
			spaces[i] = 32;
		}
	}
	spaces[self->cursorColumn] = 95;
	spacesString = game->platform->vtbl->charArrayToString(game->platform, spaces, self->cursorColumn + 1);
	Game_Draw2dText(game, spacesString, self->font, self->startX, self->startY + self->cursorLine * self->charSize, NULL, FALSE);
}

static void ModGuiTouchButtons_Construct(ModGuiTouchButtons *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = (const ClientModVtbl *) &CiVtbl_ModGuiTouchButtons;
	GameScreen_Construct(&self->base, vtbl);
	self->touchButtonsEnabled = FALSE;
	self->buttonMenu = MenuWidget_New();
	self->buttonMenu->image = "TouchMenu.png";
	self->buttonInventory = MenuWidget_New();
	self->buttonInventory->image = "TouchInventory.png";
	self->buttonTalk = MenuWidget_New();
	self->buttonTalk->image = "TouchTalk.png";
	self->buttonCamera = MenuWidget_New();
	self->buttonCamera->image = "TouchCamera.png";
	self->base.widgets[0] = self->buttonMenu;
	self->base.widgets[1] = self->buttonInventory;
	self->base.widgets[2] = self->buttonTalk;
	self->base.widgets[3] = self->buttonCamera;
	self->touchIdMove = -1;
	self->touchIdRotate = -1;
}

ModGuiTouchButtons *ModGuiTouchButtons_New(void)
{
	ModGuiTouchButtons *self = (ModGuiTouchButtons *) malloc(sizeof(ModGuiTouchButtons));
	if (self != NULL)
		ModGuiTouchButtons_Construct(self, NULL);
	return self;
}

void ModGuiTouchButtons_Delete(ModGuiTouchButtons *self)
{
	free(self);
}

void ModGuiTouchButtons_OnButton(ModGuiTouchButtons const *self, MenuWidget const *w)
{
	if (w == self->buttonMenu) {
		Game_ShowEscapeMenu(self->base.game);
	}
	if (w == self->buttonInventory) {
		Game_ShowInventory(self->base.game);
	}
	if (w == self->buttonTalk) {
		if (self->base.game->guiTyping == TypingState_NONE) {
			Game_StartTyping(self->base.game);
			self->base.game->platform->vtbl->showKeyboard(self->base.game->platform, TRUE);
		}
		else {
			Game_StopTyping(self->base.game);
			self->base.game->platform->vtbl->showKeyboard(self->base.game->platform, FALSE);
		}
	}
	if (w == self->buttonCamera) {
		Game_CameraChange(self->base.game);
	}
}

void ModGuiTouchButtons_OnNewFrameDraw2d(ModGuiTouchButtons *self, Game *game_, float deltaTime)
{
	float dt;
	int buttonSize;
	if (!self->touchButtonsEnabled) {
		return;
	}
	self->base.game = game_;
	dt = deltaTime;
	buttonSize = 80;
	if (self->base.game->guistate != GuiState_NORMAL) {
		return;
	}
	self->buttonMenu->x = 16 * ModGuiTouchButtons_Scale(self);
	self->buttonMenu->y = 16 * ModGuiTouchButtons_Scale(self);
	self->buttonMenu->sizex = buttonSize * ModGuiTouchButtons_Scale(self);
	self->buttonMenu->sizey = buttonSize * ModGuiTouchButtons_Scale(self);
	self->buttonInventory->x = 16 * ModGuiTouchButtons_Scale(self);
	self->buttonInventory->y = 112 * ModGuiTouchButtons_Scale(self);
	self->buttonInventory->sizex = buttonSize * ModGuiTouchButtons_Scale(self);
	self->buttonInventory->sizey = buttonSize * ModGuiTouchButtons_Scale(self);
	self->buttonTalk->x = 16 * ModGuiTouchButtons_Scale(self);
	self->buttonTalk->y = 208 * ModGuiTouchButtons_Scale(self);
	self->buttonTalk->sizex = buttonSize * ModGuiTouchButtons_Scale(self);
	self->buttonTalk->sizey = buttonSize * ModGuiTouchButtons_Scale(self);
	self->buttonCamera->x = 16 * ModGuiTouchButtons_Scale(self);
	self->buttonCamera->y = 304 * ModGuiTouchButtons_Scale(self);
	self->buttonCamera->sizex = buttonSize * ModGuiTouchButtons_Scale(self);
	self->buttonCamera->sizey = buttonSize * ModGuiTouchButtons_Scale(self);
	if (!self->base.game->platform->vtbl->isMousePointerLocked(self->base.game->platform)) {
		if (self->base.game->cameratype == CameraType_FPP || self->base.game->cameratype == CameraType_TPP) {
			Game_Draw2dText1(self->base.game, "Move", Game_Width(self->base.game) * 5 / 100, Game_Height(self->base.game) * 85 / 100, self->base.game->platform->vtbl->floatToInt(self->base.game->platform, ModGuiTouchButtons_Scale(self) * 50), NULL, FALSE);
			Game_Draw2dText1(self->base.game, "Look", Game_Width(self->base.game) * 80 / 100, Game_Height(self->base.game) * 85 / 100, self->base.game->platform->vtbl->floatToInt(self->base.game->platform, ModGuiTouchButtons_Scale(self) * 50), NULL, FALSE);
		}
		GameScreen_DrawWidgets(&self->base);
	}
}

void ModGuiTouchButtons_OnTouchEnd(ModGuiTouchButtons *self, Game const *game_, TouchEventArgs const *e)
{
	GameScreen_ScreenOnTouchEnd(&self->base, e);
	if (TouchEventArgs_GetHandled(e)) {
		return;
	}
	if (TouchEventArgs_GetId(e) == self->touchIdMove) {
		self->touchIdMove = -1;
		self->base.game->touchMoveDx = 0;
		self->base.game->touchMoveDy = 0;
	}
	if (TouchEventArgs_GetId(e) == self->touchIdRotate) {
		self->touchIdRotate = -1;
		self->base.game->touchOrientationDx = 0;
		self->base.game->touchOrientationDy = 0;
	}
}

void ModGuiTouchButtons_OnTouchMove(ModGuiTouchButtons *self, Game *game, TouchEventArgs const *e)
{
	float one = 1;
	if (TouchEventArgs_GetId(e) == self->touchIdMove) {
		float range = Game_Width(game) * one / 20;
		float length;
		game->touchMoveDx = TouchEventArgs_GetX(e) - self->touchMoveStartX;
		game->touchMoveDy = -(TouchEventArgs_GetY(e) - 1 - self->touchMoveStartY);
		length = Game_Length(game, game->touchMoveDx, game->touchMoveDy, 0);
		if (TouchEventArgs_GetY(e) < Game_Height(game) * 50 / 100) {
			game->touchMoveDx = 0;
			game->touchMoveDy = 1;
		}
		else {
			if (length > 0) {
				game->touchMoveDx /= length;
				game->touchMoveDy /= length;
			}
		}
	}
	if (TouchEventArgs_GetId(e) == self->touchIdRotate) {
		game->touchOrientationDx += (TouchEventArgs_GetX(e) - self->touchRotateStartX) / (Game_Width(game) * one / 40);
		game->touchOrientationDy += (TouchEventArgs_GetY(e) - self->touchRotateStartY) / (Game_Width(game) * one / 40);
		self->touchRotateStartX = TouchEventArgs_GetX(e);
		self->touchRotateStartY = TouchEventArgs_GetY(e);
	}
}

void ModGuiTouchButtons_OnTouchStart(ModGuiTouchButtons *self, Game const *game_, TouchEventArgs *e)
{
	self->touchButtonsEnabled = TRUE;
	GameScreen_ScreenOnTouchStart(&self->base, e);
	if (TouchEventArgs_GetHandled(e)) {
		return;
	}
	if (TouchEventArgs_GetX(e) <= Game_Width(self->base.game) / 2) {
		if (self->touchIdMove == -1) {
			self->touchIdMove = TouchEventArgs_GetId(e);
			self->touchMoveStartX = TouchEventArgs_GetX(e);
			self->touchMoveStartY = TouchEventArgs_GetY(e);
			self->base.game->touchMoveDx = 0;
			if (TouchEventArgs_GetY(e) < Game_Height(self->base.game) * 50 / 100) {
				self->base.game->touchMoveDy = 1;
			}
			else {
				self->base.game->touchMoveDy = 0;
			}
		}
	}
	if ((self->touchIdMove != -1 && TouchEventArgs_GetId(e) != self->touchIdMove) || TouchEventArgs_GetX(e) > Game_Width(self->base.game) / 2) {
		if (self->touchIdRotate == -1) {
			self->touchIdRotate = TouchEventArgs_GetId(e);
			self->touchRotateStartX = TouchEventArgs_GetX(e);
			self->touchRotateStartY = TouchEventArgs_GetY(e);
		}
	}
}

static float ModGuiTouchButtons_Scale(ModGuiTouchButtons const *self)
{
	return Game_Scale(self->base.game);
}

static void ModInterpolatePositions_Construct(ModInterpolatePositions *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModInterpolatePositions;
	ClientMod_Construct(&self->base, vtbl);
}

ModInterpolatePositions *ModInterpolatePositions_New(void)
{
	ModInterpolatePositions *self = (ModInterpolatePositions *) malloc(sizeof(ModInterpolatePositions));
	if (self != NULL)
		ModInterpolatePositions_Construct(self, NULL);
	return self;
}

void ModInterpolatePositions_Delete(ModInterpolatePositions *self)
{
	free(self);
}

static void ModInterpolatePositions_InterpolatePositions(ModInterpolatePositions const *self, Game const *game, float dt)
{
	{
		int i;
		for (i = 0; i < game->entitiesCount; i++) {
			Entity *e = game->entities[i];
			Entity const *p;
			PlayerDrawInfo *info;
			float networkposX;
			float networkposY;
			float networkposZ;
			PlayerInterpolationState *curstate;
			float curposX;
			float curposY;
			float curposZ;
			if (e == NULL) {
				continue;
			}
			if (e->networkPosition == NULL) {
				continue;
			}
			if (i == game->localPlayerId) {
				continue;
			}
			if (!e->networkPosition->positionLoaded) {
				continue;
			}
			if (e->playerDrawInfo == NULL) {
				e->playerDrawInfo = PlayerDrawInfo_New();
			}
			if (e->playerDrawInfo->interpolation == NULL) {
				NetworkInterpolation *n = NetworkInterpolation_New();
				PlayerInterpolate *playerInterpolate = PlayerInterpolate_New();
				playerInterpolate->platform = game->platform;
				n->req = &playerInterpolate->base;
				n->dELAYMILLISECONDS = 500;
				n->eXTRAPOLATE = FALSE;
				n->eXTRAPOLATION_TIMEMILLISECONDS = 300;
				e->playerDrawInfo->interpolation = n;
			}
			e->playerDrawInfo->interpolation->dELAYMILLISECONDS = MathCi_MaxInt(100, Ping__RoundtripTimeTotalMilliseconds(game->serverInfo->serverPing));
			p = e;
			info = p->playerDrawInfo;
			networkposX = p->networkPosition->x;
			networkposY = p->networkPosition->y;
			networkposZ = p->networkPosition->z;
			if (!Game_Vec3Equal(game, networkposX, networkposY, networkposZ, info->lastnetworkposX, info->lastnetworkposY, info->lastnetworkposZ) || p->networkPosition->rotx != info->lastnetworkrotx || p->networkPosition->roty != info->lastnetworkroty || p->networkPosition->rotz != info->lastnetworkrotz) {
				PlayerInterpolationState *state = PlayerInterpolationState_New();
				state->positionX = networkposX;
				state->positionY = networkposY;
				state->positionZ = networkposZ;
				state->rotx = p->networkPosition->rotx;
				state->roty = p->networkPosition->roty;
				state->rotz = p->networkPosition->rotz;
				info->interpolation->base.vtbl->addNetworkPacket(&info->interpolation->base, &state->base, game->totaltimeMilliseconds);
			}
			curstate = game->platform->vtbl->castToPlayerInterpolationState(game->platform, info->interpolation->base.vtbl->interpolatedState(&info->interpolation->base, game->totaltimeMilliseconds));
			if (curstate == NULL) {
				curstate = PlayerInterpolationState_New();
			}
			if (Game_EnablePlayerUpdatePositionContainsKey(game, i) && !Game_EnablePlayerUpdatePosition(game, i)) {
				curstate->positionX = p->networkPosition->x;
				curstate->positionY = p->networkPosition->y;
				curstate->positionZ = p->networkPosition->z;
			}
			curposX = curstate->positionX;
			curposY = curstate->positionY;
			curposZ = curstate->positionZ;
			info->velocityX = curposX - info->lastcurposX;
			info->velocityY = curposY - info->lastcurposY;
			info->velocityZ = curposZ - info->lastcurposZ;
			info->moves = !Game_Vec3Equal(game, curposX, curposY, curposZ, info->lastcurposX, info->lastcurposY, info->lastcurposZ);
			info->lastcurposX = curposX;
			info->lastcurposY = curposY;
			info->lastcurposZ = curposZ;
			info->lastnetworkposX = networkposX;
			info->lastnetworkposY = networkposY;
			info->lastnetworkposZ = networkposZ;
			info->lastnetworkrotx = p->networkPosition->rotx;
			info->lastnetworkroty = p->networkPosition->roty;
			info->lastnetworkrotz = p->networkPosition->rotz;
			p->position->x = curposX;
			p->position->y = curposY;
			p->position->z = curposZ;
			p->position->rotx = curstate->rotx;
			p->position->roty = curstate->roty;
			p->position->rotz = curstate->rotz;
		}
	}
}

void ModInterpolatePositions_OnNewFrame(ModInterpolatePositions const *self, Game const *game, NewFrameEventArgs const *args)
{
	ModInterpolatePositions_InterpolatePositions(self, game, NewFrameEventArgs_GetDt(args));
}

static void ModLoadPlayerTextures_Construct(ModLoadPlayerTextures *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModLoadPlayerTextures;
	ClientMod_Construct(&self->base, vtbl);
}

ModLoadPlayerTextures *ModLoadPlayerTextures_New(void)
{
	ModLoadPlayerTextures *self = (ModLoadPlayerTextures *) malloc(sizeof(ModLoadPlayerTextures));
	if (self != NULL)
		ModLoadPlayerTextures_Construct(self, NULL);
	return self;
}

void ModLoadPlayerTextures_Delete(ModLoadPlayerTextures *self)
{
	free(self);
}

static void ModLoadPlayerTextures_LoadPlayerTextures(ModLoadPlayerTextures *self, Game const *game)
{
	if (!game->issingleplayer) {
		if (self->skinserverResponse->done) {
			self->skinserver = game->platform->vtbl->stringFromUtf8ByteArray(game->platform, self->skinserverResponse->value, self->skinserverResponse->valueLength);
		}
		else if (self->skinserverResponse->error) {
			self->skinserver = NULL;
		}
		else {
			return;
		}
	}
	{
		int i;
		for (i = 0; i < game->entitiesCount; i++) {
			Entity const *e = game->entities[i];
			unsigned char const *file;
			BitmapCi const *bmp;
			if (e == NULL) {
				continue;
			}
			if (e->drawModel == NULL) {
				continue;
			}
			if (e->drawModel->currentTexture != -1) {
				continue;
			}
			if (!game->issingleplayer && e->drawModel->downloadSkin && self->skinserver != NULL && e->drawModel->texture_ == NULL) {
				if (e->drawModel->skinDownloadResponse == NULL) {
					const char *url;
					e->drawModel->skinDownloadResponse = HttpResponseCi_New();
					url = StringTools_StringAppend(game->platform, self->skinserver, StringTools_StringSubstringToEnd(game->platform, e->drawName->name, 2));
					url = StringTools_StringAppend(game->platform, url, ".png");
					game->platform->vtbl->webClientDownloadDataAsync(game->platform, url, e->drawModel->skinDownloadResponse);
					continue;
				}
				if (!e->drawModel->skinDownloadResponse->error) {
					BitmapCi const *bmp_;
					if (!e->drawModel->skinDownloadResponse->done) {
						continue;
					}
					bmp_ = game->platform->vtbl->bitmapCreateFromPng(game->platform, e->drawModel->skinDownloadResponse->value, e->drawModel->skinDownloadResponse->valueLength);
					if (bmp_ != NULL) {
						e->drawModel->currentTexture = Game_GetTextureOrLoad(game, e->drawName->name, bmp_);
						game->platform->vtbl->bitmapDelete(game->platform, bmp_);
						continue;
					}
				}
			}
			if (e->drawModel->texture_ == NULL) {
				e->drawModel->currentTexture = Game_GetTexture(game, "mineplayer.png");
				continue;
			}
			file = Game_GetFile(game, e->drawModel->texture_);
			if (file == NULL) {
				e->drawModel->currentTexture = 0;
				continue;
			}
			bmp = game->platform->vtbl->bitmapCreateFromPng(game->platform, file, game->platform->vtbl->byteArrayLength(game->platform, file));
			if (bmp == NULL) {
				e->drawModel->currentTexture = 0;
				continue;
			}
			e->drawModel->currentTexture = Game_GetTextureOrLoad(game, e->drawModel->texture_, bmp);
			game->platform->vtbl->bitmapDelete(game->platform, bmp);
		}
	}
}

void ModLoadPlayerTextures_OnNewFrame(ModLoadPlayerTextures *self, Game const *game, NewFrameEventArgs const *args)
{
	if (game->guistate == GuiState_MAP_LOADING) {
		return;
	}
	if (!self->started) {
		self->started = TRUE;
		if (!game->issingleplayer) {
			self->skinserverResponse = HttpResponseCi_New();
			game->platform->vtbl->webClientDownloadDataAsync(game->platform, "http://manicdigger.sourceforge.net/skinserver.txt", self->skinserverResponse);
		}
	}
	ModLoadPlayerTextures_LoadPlayerTextures(self, game);
}

static void ModManagerSimple_Construct(ModManagerSimple *self, const ModManagerSimpleVtbl *vtbl)
{
	self->vtbl = vtbl;
}

static void ModManagerSimple1_Construct(ModManagerSimple1 *self, const ModManagerSimpleVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModManagerSimple1;
	ModManagerSimple_Construct(&self->base, vtbl);
}

ModManagerSimple1 *ModManagerSimple1_New(void)
{
	ModManagerSimple1 *self = (ModManagerSimple1 *) malloc(sizeof(ModManagerSimple1));
	if (self != NULL)
		ModManagerSimple1_Construct(self, NULL);
	return self;
}

void ModManagerSimple1_Delete(ModManagerSimple1 *self)
{
	free(self);
}

void ModManagerSimple1_AddToInventory(ModManagerSimple1 const *self, int player, const char *block, int amount)
{
	Packet_Inventory const *inv = self->server->clients[player]->inventory;
	{
		int i;
		for (i = 0; i < 10; i++) {
			if (inv->rightHand[i]->blockId == 0) {
				inv->rightHand[i]->blockId = self->base.vtbl->getBlockTypeId(&self->base, block);
				inv->rightHand[i]->blockCount = amount;
				break;
			}
		}
	}
	self->server->clients[player]->inventoryDirty = TRUE;
}

BlockTypeSimple const *ModManagerSimple1_CreateBlockType(ModManagerSimple1 const *self, const char *name)
{
	BlockTypeSimple const *b = BlockTypeSimple_New();
	BlockTypeSimple_SetName(b, name);
	self->server->blockTypes[self->server->blockTypesCount++] = b->block;
	return b;
}

int ModManagerSimple1_GetBlockTypeId(ModManagerSimple1 const *self, const char *p)
{
	{
		int i;
		for (i = 0; i < self->server->blockTypesCount; i++) {
			if (self->server->blockTypes[i] == NULL) {
				continue;
			}
			if (Game_StringEquals(self->server->blockTypes[i]->name, p)) {
				return i;
			}
		}
	}
	return -1;
}

void ModManagerSimple1_Start(ModManagerSimple1 *self, ServerSimple *serverSimple)
{
	self->server = serverSimple;
}

static void ModNetworkEntity_Construct(ModNetworkEntity *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModNetworkEntity;
	ClientMod_Construct(&self->base, vtbl);
	self->spawn = ClientPacketHandlerEntitySpawn_New();
	self->position = ClientPacketHandlerEntityPosition_New();
	self->despawn = ClientPacketHandlerEntityDespawn_New();
}

ModNetworkEntity *ModNetworkEntity_New(void)
{
	ModNetworkEntity *self = (ModNetworkEntity *) malloc(sizeof(ModNetworkEntity));
	if (self != NULL)
		ModNetworkEntity_Construct(self, NULL);
	return self;
}

void ModNetworkEntity_Delete(ModNetworkEntity *self)
{
	free(self);
}

void ModNetworkEntity_OnNewFrame(ModNetworkEntity const *self, Game const *game, NewFrameEventArgs const *args)
{
	game->packetHandlers[66] = &self->spawn->base;
	game->packetHandlers[67] = &self->position->base;
	game->packetHandlers[68] = &self->despawn->base;
}

static void ModNetworkProcess_Construct(ModNetworkProcess *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModNetworkProcess;
	ClientMod_Construct(&self->base, vtbl);
	self->currentChunk = (unsigned char *) malloc(65536 * sizeof(unsigned char ));
	self->currentChunkCount = 0;
	self->receivedchunk = (int *) malloc(32768 * sizeof(int ));
	self->decompressedchunk = (unsigned char *) malloc(65536 * sizeof(unsigned char ));
}

ModNetworkProcess *ModNetworkProcess_New(void)
{
	ModNetworkProcess *self = (ModNetworkProcess *) malloc(sizeof(ModNetworkProcess));
	if (self != NULL)
		ModNetworkProcess_Construct(self, NULL);
	return self;
}

void ModNetworkProcess_Delete(ModNetworkProcess *self)
{
	free(self);
}

void ModNetworkProcess_NetworkProcess(ModNetworkProcess *self)
{
	NetIncomingMessage const *msg;
	self->game->currentTimeMilliseconds = self->game->platform->vtbl->timeMillisecondsFromStart(self->game->platform);
	if (self->game->main == NULL) {
		return;
	}
	for (;;) {
		if (self->game->invalidVersionPacketIdentification != NULL) {
			break;
		}
		msg = self->game->main->vtbl->readMessage(self->game->main);
		if (msg == NULL) {
			break;
		}
		ModNetworkProcess_TryReadPacket(self, msg->message, msg->messageLength);
	}
}

void ModNetworkProcess_OnReadOnlyBackgroundThread(ModNetworkProcess *self, Game *game_, float dt)
{
	self->game = game_;
	ModNetworkProcess_NetworkProcess(self);
}

static void ModNetworkProcess_ProcessInBackground(ModNetworkProcess *self, Packet_Server const *packet)
{
	switch (packet->id) {
		unsigned char const *arr;
		int arrLength;
	case 57:
		arr = packet->chunkPart->compressedChunkPart;
		arrLength = self->game->platform->vtbl->byteArrayLength(self->game->platform, arr);
		{
			int i;
			for (i = 0; i < arrLength; i++) {
				self->currentChunk[self->currentChunkCount++] = arr[i];
			}
		}
		break;
	case 15:
		{
			Packet_ServerChunk const *p = packet->chunk_;
			if (self->currentChunkCount != 0) {
				self->game->platform->vtbl->gzipDecompress(self->game->platform, self->currentChunk, self->currentChunkCount, self->decompressedchunk);
				{
					int i = 0;
					{
						int zz;
						for (zz = 0; zz < p->sizeZ; zz++) {
							{
								int yy;
								for (yy = 0; yy < p->sizeY; yy++) {
									{
										int xx;
										for (xx = 0; xx < p->sizeX; xx++) {
											int block = (self->decompressedchunk[i + 1] << 8) + self->decompressedchunk[i];
											if (block < 1024) {
												self->receivedchunk[(zz * p->sizeY + yy) * p->sizeX + xx] = block;
											}
											i += 2;
										}
									}
								}
							}
						}
					}
				}
			}
			else {
				int size = p->sizeX * p->sizeY * p->sizeZ;
				{
					int i;
					for (i = 0; i < size; i++) {
						self->receivedchunk[i] = 0;
					}
				}
			}
			{
				Map_SetMapPortion(self->game->map, p->x, p->y, p->z, self->receivedchunk, p->sizeX, p->sizeY, p->sizeZ);
				{
					int xx;
					for (xx = 0; xx < 2; xx++) {
						{
							int yy;
							for (yy = 0; yy < 2; yy++) {
								{
									int zz;
									for (zz = 0; zz < 2; zz++) {
									}
								}
							}
						}
					}
				}
			}
			self->game->receivedMapLength += self->currentChunkCount;
			self->currentChunkCount = 0;
		}
		break;
	case 21:
		{
			Packet_ServerHeightmapChunk const *p = packet->heightmapChunk;
			int const *decompressedchunk1;
			self->game->platform->vtbl->gzipDecompress(self->game->platform, p->compressedHeightmap, self->game->platform->vtbl->byteArrayLength(self->game->platform, p->compressedHeightmap), self->decompressedchunk);
			decompressedchunk1 = Game_ByteArrayToUshortArray(self->decompressedchunk, p->sizeX * p->sizeY * 2);
			{
				int xx;
				for (xx = 0; xx < p->sizeX; xx++) {
					{
						int yy;
						for (yy = 0; yy < p->sizeY; yy++) {
							int height = decompressedchunk1[MapUtilCi_Index2d(xx, yy, p->sizeX)];
							InfiniteMapChunked2d_SetBlock(self->game->d_Heightmap, p->x + xx, p->y + yy, height);
						}
					}
				}
			}
		}
		break;
	}
}

void ModNetworkProcess_TryReadPacket(ModNetworkProcess *self, unsigned char *data, int dataLength)
{
	Packet_Server *packet = Packet_Server_New();
	ProcessPacketTask *task;
	Packet_ServerSerializer_DeserializeBuffer(data, dataLength, packet);
	ModNetworkProcess_ProcessInBackground(self, packet);
	task = ProcessPacketTask_New();
	task->game = self->game;
	task->packet_ = packet;
	Game_QueueActionCommit(self->game, &task->base);
	self->game->lastReceivedMilliseconds = self->game->currentTimeMilliseconds;
}

static void ModPicking_Construct(ModPicking *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModPicking;
	ClientMod_Construct(&self->base, vtbl);
	self->unproject = Unproject_New();
	self->tempViewport = (float *) malloc(4 * sizeof(float ));
	self->tempRay = (float *) malloc(4 * sizeof(float ));
	self->tempRayStartPoint = (float *) malloc(4 * sizeof(float ));
	self->fillarea = DictionaryVector3Float_New();
}

ModPicking *ModPicking_New(void)
{
	ModPicking *self = (ModPicking *) malloc(sizeof(ModPicking));
	if (self != NULL)
		ModPicking_Construct(self, NULL);
	return self;
}

void ModPicking_Delete(ModPicking *self)
{
	free(self);
}

static float ModPicking_BuildDelay(ModPicking const *self, Game const *game)
{
	float default_ = 1f * 95 / 100 * 1 / game->basemovespeed;
	Packet_Item const *item = game->d_Inventory->rightHand[game->activeMaterial];
	float delay;
	if (item == NULL || item->itemClass != 0) {
		return default_;
	}
	delay = Game_DeserializeFloat(game, game->blocktypes[item->blockId]->delayFloat);
	if (delay == 0) {
		return default_;
	}
	return delay;
}

static void ModPicking_ClearFillArea(ModPicking const *self, Game *game)
{
	{
		int i;
		for (i = 0; i < self->fillarea->itemsCount; i++) {
			Vector3Float const *k = self->fillarea->items[i];
			if (k == NULL) {
				continue;
			}
			Game_SetBlock(game, k->x, k->y, k->z, game->platform->vtbl->floatToInt(game->platform, k->value));
			Game_RedrawBlock(game, k->x, k->y, k->z);
		}
	}
	DictionaryVector3Float_Clear(self->fillarea);
}

static float ModPicking_CurrentPickDistance(ModPicking const *self, Game const *game)
{
	float pick_distance = game->pICK_DISTANCE;
	IntRef const *inHand = Game_BlockInHand(game);
	if (inHand != NULL) {
		if (game->blocktypes[inHand->value]->pickDistanceWhenUsedFloat > 0) {
			pick_distance = Game_DeserializeFloat(game, game->blocktypes[inHand->value]->pickDistanceWhenUsedFloat);
		}
	}
	if (game->cameratype == CameraType_TPP) {
		pick_distance = game->tppcameradistance + game->pICK_DISTANCE;
	}
	if (game->cameratype == CameraType_OVERHEAD) {
		if (game->platform->vtbl->isFastSystem(game->platform)) {
			pick_distance = 100;
		}
		else {
			pick_distance = game->overheadcameradistance * 2;
		}
	}
	return pick_distance;
}

static void ModPicking_FillFill(ModPicking const *self, Game *game, Vector3IntRef const *a_, Vector3IntRef const *b_)
{
	int startx = MathCi_MinInt(a_->x, b_->x);
	int endx = MathCi_MaxInt(a_->x, b_->x);
	int starty = MathCi_MinInt(a_->y, b_->y);
	int endy = MathCi_MaxInt(a_->y, b_->y);
	int startz = MathCi_MinInt(a_->z, b_->z);
	int endz = MathCi_MaxInt(a_->z, b_->z);
	{
		int x;
		for (x = startx; x <= endx; x++) {
			{
				int y;
				for (y = starty; y <= endy; y++) {
					{
						int z;
						for (z = startz; z <= endz; z++) {
							if (DictionaryVector3Float_Count(self->fillarea) > game->fillAreaLimit) {
								ModPicking_ClearFillArea(self, game);
								return;
							}
							if (!Game_IsFillBlock(game, Map_GetBlock(game->map, x, y, z))) {
								DictionaryVector3Float_Set(self->fillarea, x, y, z, Map_GetBlock(game->map, x, y, z));
								Game_SetBlock(game, x, y, z, GameData_BlockIdFillArea(game->d_Data));
								Game_RedrawBlock(game, x, y, z);
							}
						}
					}
				}
			}
		}
	}
}

static PointFloatRef const *ModPicking_GetAim(ModPicking const *self, Game const *game)
{
	float half;
	float x;
	float y;
	if (Game_CurrentAimRadius(game) <= 1) {
		return PointFloatRef_Create(0, 0);
	}
	half = 0.5f;
	for (;;) {
		float dist1;
		x = (game->rnd->vtbl->nextFloat(game->rnd) - half) * Game_CurrentAimRadius(game) * 2;
		y = (game->rnd->vtbl->nextFloat(game->rnd) - half) * Game_CurrentAimRadius(game) * 2;
		dist1 = game->platform->vtbl->mathSqrt(game->platform, x * x + y * y);
		if (dist1 <= Game_CurrentAimRadius(game)) {
			break;
		}
	}
	return PointFloatRef_Create(x, y);
}

void ModPicking_GetPickingLine(ModPicking const *self, Game const *game, Line3D *retPick, cibool ispistolshoot)
{
	int mouseX;
	int mouseY;
	PointFloatRef const *aim;
	float raydirX;
	float raydirY;
	float raydirZ;
	float raydirLength;
	float pickDistance1;
	if (game->cameratype == CameraType_FPP || game->cameratype == CameraType_TPP) {
		mouseX = Game_Width(game) / 2;
		mouseY = Game_Height(game) / 2;
	}
	else {
		mouseX = game->mouseCurrentX;
		mouseY = game->mouseCurrentY;
	}
	aim = ModPicking_GetAim(self, game);
	if (ispistolshoot && (aim->x != 0 || aim->y != 0)) {
		mouseX += game->platform->vtbl->floatToInt(game->platform, aim->x);
		mouseY += game->platform->vtbl->floatToInt(game->platform, aim->y);
	}
	self->tempViewport[0] = 0;
	self->tempViewport[1] = 0;
	self->tempViewport[2] = Game_Width(game);
	self->tempViewport[3] = Game_Height(game);
	Unproject_UnProject(self->unproject, mouseX, Game_Height(game) - mouseY, 1, StackMatrix4_Peek(game->mvMatrix), StackMatrix4_Peek(game->pMatrix), self->tempViewport, self->tempRay);
	Unproject_UnProject(self->unproject, mouseX, Game_Height(game) - mouseY, 0, StackMatrix4_Peek(game->mvMatrix), StackMatrix4_Peek(game->pMatrix), self->tempViewport, self->tempRayStartPoint);
	raydirX = self->tempRay[0] - self->tempRayStartPoint[0];
	raydirY = self->tempRay[1] - self->tempRayStartPoint[1];
	raydirZ = self->tempRay[2] - self->tempRayStartPoint[2];
	raydirLength = Game_Length(game, raydirX, raydirY, raydirZ);
	raydirX /= raydirLength;
	raydirY /= raydirLength;
	raydirZ /= raydirLength;
	retPick->start = (float *) malloc(3 * sizeof(float ));
	retPick->start[0] = self->tempRayStartPoint[0];
	retPick->start[1] = self->tempRayStartPoint[1];
	retPick->start[2] = self->tempRayStartPoint[2];
	pickDistance1 = ModPicking_CurrentPickDistance(self, game) * (ispistolshoot ? 100 : 1);
	pickDistance1 += 1;
	retPick->end = (float *) malloc(3 * sizeof(float ));
	retPick->end[0] = self->tempRayStartPoint[0] + raydirX * pickDistance1;
	retPick->end[1] = self->tempRayStartPoint[1] + raydirY * pickDistance1;
	retPick->end[2] = self->tempRayStartPoint[2] + raydirZ * pickDistance1;
}

static void ModPicking_NextBullet(ModPicking *self, Game *game, int bulletsshot)
{
	float one = 1;
	cibool left = game->mouseLeft;
	cibool middle = game->mouseMiddle;
	cibool right = game->mouseRight;
	cibool IsNextShot = bulletsshot != 0;
	Packet_Item const *item;
	cibool ispistol;
	cibool ispistolshoot;
	cibool isgrenade;
	float wait;
	IntRef *pick2count;
	Line3D *pick;
	BlockPosSide *const *pick2;
	cibool pickdistanceok;
	cibool playertileempty;
	cibool playertileemptyclose;
	BlockPosSide *pick0;
	if (!game->leftpressedpicking) {
		if (game->mouseleftclick) {
			game->leftpressedpicking = TRUE;
		}
		else {
			left = FALSE;
		}
	}
	else {
		if (game->mouseleftdeclick) {
			game->leftpressedpicking = FALSE;
			left = FALSE;
		}
	}
	if (!left) {
		game->currentAttackedBlock = NULL;
	}
	item = game->d_Inventory->rightHand[game->activeMaterial];
	ispistol = item != NULL && game->blocktypes[item->blockId]->isPistol;
	ispistolshoot = ispistol && left;
	isgrenade = ispistol && game->blocktypes[item->blockId]->pistolType == 1;
	if (ispistol && isgrenade) {
		ispistolshoot = game->mouseleftdeclick;
	}
	if (game->mouseleftclick) {
		game->grenadecookingstartMilliseconds = game->platform->vtbl->timeMillisecondsFromStart(game->platform);
		if (ispistol && isgrenade) {
			if (game->blocktypes[item->blockId]->sounds->shootCount > 0) {
				Game_AudioPlay(game, game->platform->vtbl->stringFormat(game->platform, "{0}.ogg", game->blocktypes[item->blockId]->sounds->shoot[0]));
			}
		}
	}
	wait = one * (game->platform->vtbl->timeMillisecondsFromStart(game->platform) - game->grenadecookingstartMilliseconds) / 1000;
	if (isgrenade && left) {
		if (wait >= game->grenadetime && isgrenade && game->grenadecookingstartMilliseconds != 0) {
			ispistolshoot = TRUE;
			game->mouseleftdeclick = TRUE;
		}
		else {
			return;
		}
	}
	else {
		game->grenadecookingstartMilliseconds = 0;
	}
	if (ispistol && game->mouserightclick && game->platform->vtbl->timeMillisecondsFromStart(game->platform) - game->lastironsightschangeMilliseconds >= 500) {
		game->ironSights = !game->ironSights;
		game->lastironsightschangeMilliseconds = game->platform->vtbl->timeMillisecondsFromStart(game->platform);
	}
	pick2count = IntRef_New();
	pick = Line3D_New();
	ModPicking_GetPickingLine(self, game, pick, ispistolshoot);
	pick2 = Game_Pick(game, game->s, pick, pick2count);
	if (left) {
		game->handSetAttackDestroy = TRUE;
	}
	else if (right) {
		game->handSetAttackBuild = TRUE;
	}
	if (game->overheadcamera && pick2count->value > 0 && left) {
		if (game->follow == NULL) {
			game->playerdestination = Vector3Ref_Create(pick2[0]->blockPos[0], pick2[0]->blockPos[1] + 1, pick2[0]->blockPos[2]);
		}
	}
	pickdistanceok = pick2count->value > 0;
	if (pickdistanceok) {
		if (Game_Dist(game, pick2[0]->blockPos[0] + one / 2, pick2[0]->blockPos[1] + one / 2, pick2[0]->blockPos[2] + one / 2, pick->start[0], pick->start[1], pick->start[2]) > ModPicking_CurrentPickDistance(self, game)) {
			pickdistanceok = FALSE;
		}
	}
	playertileempty = Game_IsTileEmptyForPhysics(game, game->platform->vtbl->floatToInt(game->platform, game->player->position->x), game->platform->vtbl->floatToInt(game->platform, game->player->position->z), game->platform->vtbl->floatToInt(game->platform, game->player->position->y + one / 2));
	playertileemptyclose = Game_IsTileEmptyForPhysicsClose(game, game->platform->vtbl->floatToInt(game->platform, game->player->position->x), game->platform->vtbl->floatToInt(game->platform, game->player->position->z), game->platform->vtbl->floatToInt(game->platform, game->player->position->y + one / 2));
	pick0 = BlockPosSide_New();
	if (pick2count->value > 0 && ((pickdistanceok && (playertileempty || playertileemptyclose)) || game->overheadcamera)) {
		game->selectedBlockPositionX = game->platform->vtbl->floatToInt(game->platform, BlockPosSide_Current(pick2[0])[0]);
		game->selectedBlockPositionY = game->platform->vtbl->floatToInt(game->platform, BlockPosSide_Current(pick2[0])[1]);
		game->selectedBlockPositionZ = game->platform->vtbl->floatToInt(game->platform, BlockPosSide_Current(pick2[0])[2]);
		pick0 = pick2[0];
	}
	else {
		game->selectedBlockPositionX = -1;
		game->selectedBlockPositionY = -1;
		game->selectedBlockPositionZ = -1;
		pick0->blockPos = (float *) malloc(3 * sizeof(float ));
		pick0->blockPos[0] = -1;
		pick0->blockPos[1] = -1;
		pick0->blockPos[2] = -1;
	}
	ModPicking_PickEntity(self, game, pick, pick2, pick2count);
	if (game->cameratype == CameraType_FPP || game->cameratype == CameraType_TPP) {
		int ntileX = game->platform->vtbl->floatToInt(game->platform, BlockPosSide_Current(pick0)[0]);
		int ntileY = game->platform->vtbl->floatToInt(game->platform, BlockPosSide_Current(pick0)[1]);
		int ntileZ = game->platform->vtbl->floatToInt(game->platform, BlockPosSide_Current(pick0)[2]);
		if (Game_IsUsableBlock(game, Map_GetBlock(game->map, ntileX, ntileZ, ntileY))) {
			game->currentAttackedBlock = Vector3IntRef_Create(ntileX, ntileZ, ntileY);
		}
	}
	if (Game_GetFreeMouse(game)) {
		if (pick2count->value > 0) {
			ModPicking_OnPick_(self, pick0);
		}
		return;
	}
	if (one * (game->platform->vtbl->timeMillisecondsFromStart(game->platform) - self->lastbuildMilliseconds) / 1000 >= ModPicking_BuildDelay(self, game) || IsNextShot) {
		if (left && game->d_Inventory->rightHand[game->activeMaterial] == NULL) {
			Game_SendPacketClient(game, ClientPackets_MonsterHit(game->platform->vtbl->floatToInt(game->platform, 2 + game->rnd->vtbl->nextFloat(game->rnd) * 4)));
		}
		if (left && !self->fastclicking) {
			self->fastclicking = FALSE;
		}
		if ((left || right || middle) && !isgrenade) {
			self->lastbuildMilliseconds = game->platform->vtbl->timeMillisecondsFromStart(game->platform);
		}
		if (isgrenade && game->mouseleftdeclick) {
			self->lastbuildMilliseconds = game->platform->vtbl->timeMillisecondsFromStart(game->platform);
		}
		if (game->reloadstartMilliseconds != 0) {
			ModPicking_PickingEnd(self, left, right, middle, ispistol);
			return;
		}
		if (ispistolshoot) {
			if (!(game->loadedAmmo[item->blockId] > 0) || !(game->totalAmmo[item->blockId] > 0)) {
				Game_AudioPlay(game, "Dry Fire Gun-SoundBible.com-2053652037.ogg");
				ModPicking_PickingEnd(self, left, right, middle, ispistol);
				return;
			}
		}
		if (ispistolshoot) {
			float toX = pick->end[0];
			float toY = pick->end[1];
			float toZ = pick->end[2];
			Packet_ClientShot *shot;
			float projectilespeed;
			Packet_Client *packet;
			if (pick2count->value > 0) {
				toX = pick2[0]->blockPos[0];
				toY = pick2[0]->blockPos[1];
				toZ = pick2[0]->blockPos[2];
			}
			shot = Packet_ClientShot_New();
			shot->fromX = Game_SerializeFloat(game, pick->start[0]);
			shot->fromY = Game_SerializeFloat(game, pick->start[1]);
			shot->fromZ = Game_SerializeFloat(game, pick->start[2]);
			shot->toX = Game_SerializeFloat(game, toX);
			shot->toY = Game_SerializeFloat(game, toY);
			shot->toZ = Game_SerializeFloat(game, toZ);
			shot->hitPlayer = -1;
			{
				int i;
				for (i = 0; i < game->entitiesCount; i++) {
					Entity const *p_;
					float feetposX;
					float feetposY;
					float feetposZ;
					Box3D *bodybox;
					float headsize;
					float h;
					float r;
					Box3D *headbox;
					float const *p;
					float localeyeposX;
					float localeyeposY;
					float localeyeposZ;
					if (game->entities[i] == NULL) {
						continue;
					}
					if (game->entities[i]->drawModel == NULL) {
						continue;
					}
					p_ = game->entities[i];
					if (p_->networkPosition == NULL) {
						continue;
					}
					if (!p_->networkPosition->positionLoaded) {
						continue;
					}
					feetposX = p_->position->x;
					feetposY = p_->position->y;
					feetposZ = p_->position->z;
					bodybox = Box3D_New();
					headsize = (p_->drawModel->modelHeight - p_->drawModel->eyeHeight) * 2;
					h = p_->drawModel->modelHeight - headsize;
					r = one * 35 / 100;
					Box3D_AddPoint(bodybox, feetposX - r, feetposY + 0, feetposZ - r);
					Box3D_AddPoint(bodybox, feetposX - r, feetposY + 0, feetposZ + r);
					Box3D_AddPoint(bodybox, feetposX + r, feetposY + 0, feetposZ - r);
					Box3D_AddPoint(bodybox, feetposX + r, feetposY + 0, feetposZ + r);
					Box3D_AddPoint(bodybox, feetposX - r, feetposY + h, feetposZ - r);
					Box3D_AddPoint(bodybox, feetposX - r, feetposY + h, feetposZ + r);
					Box3D_AddPoint(bodybox, feetposX + r, feetposY + h, feetposZ - r);
					Box3D_AddPoint(bodybox, feetposX + r, feetposY + h, feetposZ + r);
					headbox = Box3D_New();
					Box3D_AddPoint(headbox, feetposX - r, feetposY + h, feetposZ - r);
					Box3D_AddPoint(headbox, feetposX - r, feetposY + h, feetposZ + r);
					Box3D_AddPoint(headbox, feetposX + r, feetposY + h, feetposZ - r);
					Box3D_AddPoint(headbox, feetposX + r, feetposY + h, feetposZ + r);
					Box3D_AddPoint(headbox, feetposX - r, feetposY + h + headsize, feetposZ - r);
					Box3D_AddPoint(headbox, feetposX - r, feetposY + h + headsize, feetposZ + r);
					Box3D_AddPoint(headbox, feetposX + r, feetposY + h + headsize, feetposZ - r);
					Box3D_AddPoint(headbox, feetposX + r, feetposY + h + headsize, feetposZ + r);
					localeyeposX = Game_EyesPosX(game);
					localeyeposY = Game_EyesPosY(game);
					localeyeposZ = Game_EyesPosZ(game);
					p = Intersection_CheckLineBoxExact(pick, headbox);
					if (p != NULL) {
						if (pick2count->value == 0 || Game_Dist(game, pick2[0]->blockPos[0], pick2[0]->blockPos[1], pick2[0]->blockPos[2], localeyeposX, localeyeposY, localeyeposZ) > Game_Dist(game, p[0], p[1], p[2], localeyeposX, localeyeposY, localeyeposZ)) {
							if (!isgrenade) {
								Entity *entity = Entity_New();
								Sprite *sprite = Sprite_New();
								sprite->positionX = p[0];
								sprite->positionY = p[1];
								sprite->positionZ = p[2];
								sprite->image = "blood.png";
								entity->sprite = sprite;
								entity->expires = Expires_Create(one * 2 / 10);
								Game_EntityAddLocal(game, entity);
							}
							shot->hitPlayer = i;
							shot->isHitHead = 1;
						}
					}
					else {
						p = Intersection_CheckLineBoxExact(pick, bodybox);
						if (p != NULL) {
							if (pick2count->value == 0 || Game_Dist(game, pick2[0]->blockPos[0], pick2[0]->blockPos[1], pick2[0]->blockPos[2], localeyeposX, localeyeposY, localeyeposZ) > Game_Dist(game, p[0], p[1], p[2], localeyeposX, localeyeposY, localeyeposZ)) {
								if (!isgrenade) {
									Entity *entity = Entity_New();
									Sprite *sprite = Sprite_New();
									sprite->positionX = p[0];
									sprite->positionY = p[1];
									sprite->positionZ = p[2];
									sprite->image = "blood.png";
									entity->sprite = sprite;
									entity->expires = Expires_Create(one * 2 / 10);
									Game_EntityAddLocal(game, entity);
								}
								shot->hitPlayer = i;
								shot->isHitHead = 0;
							}
						}
					}
				}
			}
			shot->weaponBlock = item->blockId;
			game->loadedAmmo[item->blockId] = game->loadedAmmo[item->blockId] - 1;
			game->totalAmmo[item->blockId] = game->totalAmmo[item->blockId] - 1;
			projectilespeed = Game_DeserializeFloat(game, game->blocktypes[item->blockId]->projectileSpeedFloat);
			if (projectilespeed == 0) {
				{
					Entity *entity = Game_CreateBulletEntity(game, pick->start[0], pick->start[1], pick->start[2], toX, toY, toZ, 150);
					Game_EntityAddLocal(game, entity);
				}
			}
			else {
				float vX = toX - pick->start[0];
				float vY = toY - pick->start[1];
				float vZ = toZ - pick->start[2];
				float vLength = Game_Length(game, vX, vY, vZ);
				vX /= vLength;
				vY /= vLength;
				vZ /= vLength;
				vX *= projectilespeed;
				vY *= projectilespeed;
				vZ *= projectilespeed;
				shot->explodesAfter = Game_SerializeFloat(game, game->grenadetime - wait);
				{
					Entity *grenadeEntity = Entity_New();
					Sprite *sprite = Sprite_New();
					Grenade_ *projectile;
					sprite->image = "ChemicalGreen.png";
					sprite->size = 14;
					sprite->animationcount = 0;
					sprite->positionX = pick->start[0];
					sprite->positionY = pick->start[1];
					sprite->positionZ = pick->start[2];
					grenadeEntity->sprite = sprite;
					projectile = Grenade__New();
					projectile->velocityX = vX;
					projectile->velocityY = vY;
					projectile->velocityZ = vZ;
					projectile->block = item->blockId;
					projectile->sourcePlayer = game->localPlayerId;
					grenadeEntity->expires = Expires_Create(game->grenadetime - wait);
					grenadeEntity->grenade = projectile;
					Game_EntityAddLocal(game, grenadeEntity);
				}
			}
			packet = Packet_Client_New();
			packet->id = 54;
			packet->shot = shot;
			Game_SendPacketClient(game, packet);
			if (game->blocktypes[item->blockId]->sounds->shootEndCount > 0) {
				game->pistolcycle = game->rnd->vtbl->next(game->rnd) % game->blocktypes[item->blockId]->sounds->shootEndCount;
				Game_AudioPlay(game, game->platform->vtbl->stringFormat(game->platform, "{0}.ogg", game->blocktypes[item->blockId]->sounds->shootEnd[game->pistolcycle]));
			}
			bulletsshot++;
			if (bulletsshot < Game_DeserializeFloat(game, game->blocktypes[item->blockId]->bulletsPerShotFloat)) {
				ModPicking_NextBullet(self, game, bulletsshot);
			}
			game->player->position->rotx -= game->rnd->vtbl->nextFloat(game->rnd) * Game_CurrentRecoil(game);
			game->player->position->roty += game->rnd->vtbl->nextFloat(game->rnd) * Game_CurrentRecoil(game) * 2 - Game_CurrentRecoil(game);
			ModPicking_PickingEnd(self, left, right, middle, ispistol);
			return;
		}
		if (ispistol && right) {
			ModPicking_PickingEnd(self, left, right, middle, ispistol);
			return;
		}
		if (pick2count->value > 0) {
			if (middle) {
				int newtileX = game->platform->vtbl->floatToInt(game->platform, BlockPosSide_Current(pick0)[0]);
				int newtileY = game->platform->vtbl->floatToInt(game->platform, BlockPosSide_Current(pick0)[1]);
				int newtileZ = game->platform->vtbl->floatToInt(game->platform, BlockPosSide_Current(pick0)[2]);
				if (Map_IsValidPos(game->map, newtileX, newtileZ, newtileY)) {
					int clonesource = Map_GetBlock(game->map, newtileX, newtileZ, newtileY);
					int clonesource2 = GameData_WhenPlayerPlacesGetsConvertedTo(game->d_Data)[clonesource];
					cibool gotoDone = FALSE;
					const char *const *sound;
					{
						int i;
						for (i = 0; i < 10; i++) {
							if (game->d_Inventory->rightHand[i] != NULL && game->d_Inventory->rightHand[i]->itemClass == 0 && game->d_Inventory->rightHand[i]->blockId == clonesource2) {
								game->activeMaterial = i;
								gotoDone = TRUE;
							}
						}
					}
					if (!gotoDone) {
						IntRef const *freehand = InventoryUtilClient_FreeHand(game->d_InventoryUtil, game->activeMaterial);
						{
							int i;
							for (i = 0; i < game->d_Inventory->itemsCount; i++) {
								Packet_PositionItem const *k = game->d_Inventory->items[i];
								if (k == NULL) {
									continue;
								}
								if (k->value_->itemClass == 0 && k->value_->blockId == clonesource2) {
									if (freehand != NULL) {
										Game_WearItem(game, Game_InventoryPositionMainArea(game, k->x, k->y), Game_InventoryPositionMaterialSelector(game, freehand->value));
										break;
									}
									if (game->d_Inventory->rightHand[game->activeMaterial] != NULL && game->d_Inventory->rightHand[game->activeMaterial]->itemClass == 0) {
										Game_MoveToInventory(game, Game_InventoryPositionMaterialSelector(game, game->activeMaterial));
										Game_WearItem(game, Game_InventoryPositionMainArea(game, k->x, k->y), Game_InventoryPositionMaterialSelector(game, game->activeMaterial));
									}
								}
							}
						}
					}
					sound = GameData_CloneSound(game->d_Data)[clonesource];
					if (sound != NULL) {
						Game_AudioPlay(game, sound[0]);
					}
				}
			}
			if (left || right) {
				BlockPosSide const *tile = pick0;
				int newtileX;
				int newtileY;
				int newtileZ;
				if (right) {
					newtileX = game->platform->vtbl->floatToInt(game->platform, BlockPosSide_Translated(tile)[0]);
					newtileY = game->platform->vtbl->floatToInt(game->platform, BlockPosSide_Translated(tile)[1]);
					newtileZ = game->platform->vtbl->floatToInt(game->platform, BlockPosSide_Translated(tile)[2]);
				}
				else {
					newtileX = game->platform->vtbl->floatToInt(game->platform, BlockPosSide_Current(tile)[0]);
					newtileY = game->platform->vtbl->floatToInt(game->platform, BlockPosSide_Current(tile)[1]);
					newtileZ = game->platform->vtbl->floatToInt(game->platform, BlockPosSide_Current(tile)[2]);
				}
				if (Map_IsValidPos(game->map, newtileX, newtileZ, newtileY)) {
					if (!(pick0->blockPos[0] == -1 && pick0->blockPos[1] == -1 && pick0->blockPos[2] == -1)) {
						int blocktype;
						const char *const *sound;
						if (left) {
							blocktype = Map_GetBlock(game->map, newtileX, newtileZ, newtileY);
						}
						else {
							blocktype = Game_BlockInHand(game) == NULL ? 1 : Game_BlockInHand(game)->value;
						}
						if (left && blocktype == GameData_BlockIdAdminium(game->d_Data)) {
							ModPicking_PickingEnd(self, left, right, middle, ispistol);
							return;
						}
						sound = left ? GameData_BreakSound(game->d_Data)[blocktype] : GameData_BuildSound(game->d_Data)[blocktype];
						if (sound != NULL) {
							Game_AudioPlay(game, sound[0]);
						}
					}
					if (!right) {
						int posx = newtileX;
						int posy = newtileZ;
						int posz = newtileY;
						float health;
						game->currentAttackedBlock = Vector3IntRef_Create(posx, posy, posz);
						if (!DictionaryVector3Float_ContainsKey(game->blockHealth, posx, posy, posz)) {
							DictionaryVector3Float_Set(game->blockHealth, posx, posy, posz, Game_GetCurrentBlockHealth(game, posx, posy, posz));
						}
						DictionaryVector3Float_Set(game->blockHealth, posx, posy, posz, DictionaryVector3Float_Get(game->blockHealth, posx, posy, posz) - Game_WeaponAttackStrength(game));
						health = Game_GetCurrentBlockHealth(game, posx, posy, posz);
						if (health <= 0) {
							if (game->currentAttackedBlock != NULL) {
								DictionaryVector3Float_Remove(game->blockHealth, posx, posy, posz);
							}
							game->currentAttackedBlock = NULL;
							ModPicking_OnPick(self, game, game->platform->vtbl->floatToInt(game->platform, newtileX), game->platform->vtbl->floatToInt(game->platform, newtileZ), game->platform->vtbl->floatToInt(game->platform, newtileY), game->platform->vtbl->floatToInt(game->platform, BlockPosSide_Current(tile)[0]), game->platform->vtbl->floatToInt(game->platform, BlockPosSide_Current(tile)[2]), game->platform->vtbl->floatToInt(game->platform, BlockPosSide_Current(tile)[1]), tile->collisionPos, right);
						}
						ModPicking_PickingEnd(self, left, right, middle, ispistol);
						return;
					}
					if (!right) {
						ModDrawParticleEffectBlockBreak_StartParticleEffect(game->particleEffectBlockBreak, newtileX, newtileY, newtileZ);
					}
					if (!Map_IsValidPos(game->map, newtileX, newtileZ, newtileY)) {
						game->platform->vtbl->throwException(game->platform, "Error in picking - NextBullet()");
					}
					ModPicking_OnPick(self, game, game->platform->vtbl->floatToInt(game->platform, newtileX), game->platform->vtbl->floatToInt(game->platform, newtileZ), game->platform->vtbl->floatToInt(game->platform, newtileY), game->platform->vtbl->floatToInt(game->platform, BlockPosSide_Current(tile)[0]), game->platform->vtbl->floatToInt(game->platform, BlockPosSide_Current(tile)[2]), game->platform->vtbl->floatToInt(game->platform, BlockPosSide_Current(tile)[1]), tile->collisionPos, right);
				}
			}
		}
	}
	ModPicking_PickingEnd(self, left, right, middle, ispistol);
}

void ModPicking_OnMouseDown(ModPicking *self, Game *game, MouseEventArgs const *args)
{
	if (game->guistate == GuiState_NORMAL) {
		ModPicking_UpdatePicking(self, game);
		ModPicking_UpdateEntityHit(self, game);
	}
}

void ModPicking_OnMouseUp(ModPicking *self, Game *game, MouseEventArgs const *args)
{
	if (game->guistate == GuiState_NORMAL) {
		ModPicking_UpdatePicking(self, game);
	}
}

void ModPicking_OnNewFrameReadOnlyMainThread(ModPicking *self, Game *game, float deltaTime)
{
	if (game->guistate == GuiState_NORMAL) {
		ModPicking_UpdatePicking(self, game);
	}
}

static void ModPicking_OnPick(ModPicking *self, Game *game, int blockposX, int blockposY, int blockposZ, int blockposoldX, int blockposoldY, int blockposoldZ, float const *collisionPos, cibool right)
{
	float xfract = collisionPos[0] - Game_MathFloor(game, collisionPos[0]);
	float zfract = collisionPos[2] - Game_MathFloor(game, collisionPos[2]);
	int activematerial = Game_MaterialSlots_(game, game->activeMaterial);
	int railstart = GameData_BlockIdRailstart(game->d_Data);
	int x;
	int y;
	int z;
	int mode;
	if (activematerial == railstart + 3 || activematerial == railstart + 60) {
		RailDirection dirnew;
		int dir;
		if (activematerial == railstart + 3) {
			dirnew = ModPicking_PickHorizontalVertical(self, xfract, zfract);
		}
		else {
			dirnew = ModPicking_PickCorners(self, xfract, zfract);
		}
		dir = GameData_Rail(game->d_Data)[Map_GetBlock(game->map, blockposoldX, blockposoldY, blockposoldZ)];
		if (dir != 0) {
			blockposX = blockposoldX;
			blockposY = blockposoldY;
			blockposZ = blockposoldZ;
		}
		activematerial = railstart + (dir | DirectionUtils_ToRailDirectionFlags(dirnew));
	}
	x = game->platform->vtbl->floatToInt(game->platform, blockposX);
	y = game->platform->vtbl->floatToInt(game->platform, blockposY);
	z = game->platform->vtbl->floatToInt(game->platform, blockposZ);
	mode = right ? 1 : 0;
	{
		Vector3IntRef const *v;
		Vector3IntRef const *oldfillstart;
		Vector3IntRef const *oldfillend;
		if (Game_IsAnyPlayerInPos(game, x, y, z) || activematerial == 151) {
			return;
		}
		v = Vector3IntRef_Create(x, y, z);
		oldfillstart = self->fillstart;
		oldfillend = self->fillend;
		if (mode == 1) {
			if (game->blocktypes[activematerial]->isTool) {
				ModPicking_OnPickUseWithTool(self, game, blockposX, blockposY, blockposZ);
				return;
			}
			if (activematerial == GameData_BlockIdCuboid(game->d_Data)) {
				ModPicking_ClearFillArea(self, game);
				if (self->fillstart != NULL) {
					Vector3IntRef const *f = self->fillstart;
					if (!Game_IsFillBlock(game, Map_GetBlock(game->map, f->x, f->y, f->z))) {
						DictionaryVector3Float_Set(self->fillarea, f->x, f->y, f->z, Map_GetBlock(game->map, f->x, f->y, f->z));
					}
					Game_SetBlock(game, f->x, f->y, f->z, GameData_BlockIdFillStart(game->d_Data));
					ModPicking_FillFill(self, game, v, self->fillstart);
				}
				if (!Game_IsFillBlock(game, Map_GetBlock(game->map, v->x, v->y, v->z))) {
					DictionaryVector3Float_Set(self->fillarea, v->x, v->y, v->z, Map_GetBlock(game->map, v->x, v->y, v->z));
				}
				Game_SetBlock(game, v->x, v->y, v->z, GameData_BlockIdCuboid(game->d_Data));
				self->fillend = v;
				Game_RedrawBlock(game, v->x, v->y, v->z);
				return;
			}
			if (activematerial == GameData_BlockIdFillStart(game->d_Data)) {
				ModPicking_ClearFillArea(self, game);
				if (!Game_IsFillBlock(game, Map_GetBlock(game->map, v->x, v->y, v->z))) {
					DictionaryVector3Float_Set(self->fillarea, v->x, v->y, v->z, Map_GetBlock(game->map, v->x, v->y, v->z));
				}
				Game_SetBlock(game, v->x, v->y, v->z, GameData_BlockIdFillStart(game->d_Data));
				self->fillstart = v;
				self->fillend = NULL;
				Game_RedrawBlock(game, v->x, v->y, v->z);
				return;
			}
			if (DictionaryVector3Float_ContainsKey(self->fillarea, v->x, v->y, v->z)) {
				Game_SendFillArea(game, self->fillstart->x, self->fillstart->y, self->fillstart->z, self->fillend->x, self->fillend->y, self->fillend->z, activematerial);
				ModPicking_ClearFillArea(self, game);
				self->fillstart = NULL;
				self->fillend = NULL;
				return;
			}
		}
		else {
			if (game->blocktypes[activematerial]->isTool) {
				ModPicking_OnPickUseWithTool(self, game, blockposX, blockposY, blockposoldZ);
				return;
			}
			if (self->fillstart != NULL && self->fillstart->x == v->x && self->fillstart->y == v->y && self->fillstart->z == v->z) {
				ModPicking_ClearFillArea(self, game);
				self->fillstart = NULL;
				self->fillend = NULL;
				return;
			}
			if (self->fillend != NULL && self->fillend->x == v->x && self->fillend->y == v->y && self->fillend->z == v->z) {
				ModPicking_ClearFillArea(self, game);
				self->fillend = NULL;
				return;
			}
		}
		Game_SendSetBlockAndUpdateSpeculative(game, activematerial, x, y, z, mode);
	}
}

static void ModPicking_OnPickUseWithTool(ModPicking const *self, Game const *game, int posX, int posY, int posZ)
{
	Game_SendSetBlock(game, posX, posY, posZ, 3, game->d_Inventory->rightHand[game->activeMaterial]->blockId, game->activeMaterial);
}

static void ModPicking_OnPick_(ModPicking const *self, BlockPosSide const *pick0)
{
}

static RailDirection ModPicking_PickCorners(ModPicking const *self, float xfract, float zfract)
{
	float half = 0.5f;
	if (xfract < half && zfract < half) {
		return RailDirection_UP_LEFT;
	}
	if (xfract >= half && zfract < half) {
		return RailDirection_UP_RIGHT;
	}
	if (xfract < half && zfract >= half) {
		return RailDirection_DOWN_LEFT;
	}
	return RailDirection_DOWN_RIGHT;
}

static void ModPicking_PickEntity(ModPicking const *self, Game *game, Line3D const *pick, BlockPosSide const *const *pick2, IntRef const *pick2count)
{
	float one;
	game->selectedEntityId = -1;
	game->currentlyAttackedEntity = -1;
	one = 1;
	{
		int i;
		for (i = 0; i < game->entitiesCount; i++) {
			Entity const *p_;
			float feetposX;
			float feetposY;
			float feetposZ;
			float dist;
			Box3D *bodybox;
			float h;
			float r;
			float const *p;
			float localeyeposX;
			float localeyeposY;
			float localeyeposZ;
			if (game->entities[i] == NULL) {
				continue;
			}
			if (i == game->localPlayerId) {
				continue;
			}
			if (game->entities[i]->drawModel == NULL) {
				continue;
			}
			p_ = game->entities[i];
			if (p_->networkPosition == NULL) {
				continue;
			}
			if (!p_->networkPosition->positionLoaded) {
				continue;
			}
			if (!p_->usable) {
				continue;
			}
			feetposX = p_->position->x;
			feetposY = p_->position->y;
			feetposZ = p_->position->z;
			dist = Game_Dist(game, feetposX, feetposY, feetposZ, game->player->position->x, game->player->position->y, game->player->position->z);
			if (dist > 5) {
				continue;
			}
			bodybox = Box3D_New();
			h = p_->drawModel->modelHeight;
			r = one * 35 / 100;
			Box3D_AddPoint(bodybox, feetposX - r, feetposY + 0, feetposZ - r);
			Box3D_AddPoint(bodybox, feetposX - r, feetposY + 0, feetposZ + r);
			Box3D_AddPoint(bodybox, feetposX + r, feetposY + 0, feetposZ - r);
			Box3D_AddPoint(bodybox, feetposX + r, feetposY + 0, feetposZ + r);
			Box3D_AddPoint(bodybox, feetposX - r, feetposY + h, feetposZ - r);
			Box3D_AddPoint(bodybox, feetposX - r, feetposY + h, feetposZ + r);
			Box3D_AddPoint(bodybox, feetposX + r, feetposY + h, feetposZ - r);
			Box3D_AddPoint(bodybox, feetposX + r, feetposY + h, feetposZ + r);
			localeyeposX = Game_EyesPosX(game);
			localeyeposY = Game_EyesPosY(game);
			localeyeposZ = Game_EyesPosZ(game);
			p = Intersection_CheckLineBoxExact(pick, bodybox);
			if (p != NULL) {
				if (pick2count->value == 0 || Game_Dist(game, pick2[0]->blockPos[0], pick2[0]->blockPos[1], pick2[0]->blockPos[2], localeyeposX, localeyeposY, localeyeposZ) > Game_Dist(game, p[0], p[1], p[2], localeyeposX, localeyeposY, localeyeposZ)) {
					game->selectedEntityId = i;
					if (game->cameratype == CameraType_FPP || game->cameratype == CameraType_TPP) {
						game->currentlyAttackedEntity = i;
					}
				}
			}
		}
	}
}

static RailDirection ModPicking_PickHorizontalVertical(ModPicking const *self, float xfract, float yfract)
{
	float x = xfract;
	float y = yfract;
	if (y >= x && y >= 1 - x) {
		return RailDirection_VERTICAL;
	}
	if (y < x && y < 1 - x) {
		return RailDirection_VERTICAL;
	}
	return RailDirection_HORIZONTAL;
}

static void ModPicking_PickingEnd(ModPicking *self, cibool left, cibool right, cibool middle, cibool ispistol)
{
	self->fastclicking = FALSE;
	if (!(left || right || middle) && !ispistol) {
		self->lastbuildMilliseconds = 0;
		self->fastclicking = TRUE;
	}
}

static void ModPicking_UpdateEntityHit(ModPicking const *self, Game const *game)
{
	if (game->currentlyAttackedEntity != -1 && game->mouseLeft) {
		{
			int i;
			for (i = 0; i < game->clientmodsCount; i++) {
				OnUseEntityArgs *args;
				if (game->clientmods[i] == NULL) {
					continue;
				}
				args = OnUseEntityArgs_New();
				args->entityId = game->currentlyAttackedEntity;
				game->clientmods[i]->vtbl->onHitEntity(game->clientmods[i], game, args);
			}
		}
		Game_SendPacketClient(game, ClientPackets_HitEntity(game->currentlyAttackedEntity));
	}
}

static void ModPicking_UpdatePicking(ModPicking *self, Game *game)
{
	if (Game_FollowId(game) != NULL) {
		game->selectedBlockPositionX = -1;
		game->selectedBlockPositionY = -1;
		game->selectedBlockPositionZ = -1;
		return;
	}
	ModPicking_NextBullet(self, game, 0);
}

static void ModPush_Construct(ModPush *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModPush;
	ClientMod_Construct(&self->base, vtbl);
}

ModPush *ModPush_New(void)
{
	ModPush *self = (ModPush *) malloc(sizeof(ModPush));
	if (self != NULL)
		ModPush_Construct(self, NULL);
	return self;
}

void ModPush_Delete(ModPush *self)
{
	free(self);
}

void ModPush_OnNewFrameFixed(ModPush const *self, Game *game, NewFrameEventArgs const *args)
{
	float LocalPlayerPositionX;
	float LocalPlayerPositionY;
	float LocalPlayerPositionZ;
	game->pushX = 0;
	game->pushY = 0;
	game->pushZ = 0;
	LocalPlayerPositionX = game->player->position->x;
	LocalPlayerPositionY = game->player->position->y;
	LocalPlayerPositionZ = game->player->position->z;
	{
		int i;
		for (i = 0; i < game->entitiesCount; i++) {
			Entity const *entity = game->entities[i];
			float kposX;
			float kposY;
			float kposZ;
			float dist;
			if (entity == NULL) {
				continue;
			}
			if (entity->push == NULL) {
				continue;
			}
			if (entity->networkPosition != NULL && !entity->networkPosition->positionLoaded) {
				continue;
			}
			kposX = Game_DeserializeFloat(game, entity->push->xFloat);
			kposY = Game_DeserializeFloat(game, entity->push->zFloat);
			kposZ = Game_DeserializeFloat(game, entity->push->yFloat);
			if (entity->push->isRelativeToPlayerPosition != 0) {
				kposX += LocalPlayerPositionX;
				kposY += LocalPlayerPositionY;
				kposZ += LocalPlayerPositionZ;
			}
			dist = Game_Dist(game, kposX, kposY, kposZ, LocalPlayerPositionX, LocalPlayerPositionY, LocalPlayerPositionZ);
			if (dist < Game_DeserializeFloat(game, entity->push->rangeFloat)) {
				float diffX = LocalPlayerPositionX - kposX;
				float diffY = LocalPlayerPositionY - kposY;
				float diffZ = LocalPlayerPositionZ - kposZ;
				game->pushX += diffX;
				game->pushY += diffY;
				game->pushZ += diffZ;
			}
		}
	}
}

static void ModRail_Construct(ModRail *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModRail;
	ClientMod_Construct(&self->base, vtbl);
	self->one = 1;
	self->railheight = self->one * 3 / 10;
}

ModRail *ModRail_New(void)
{
	ModRail *self = (ModRail *) malloc(sizeof(ModRail));
	if (self != NULL)
		ModRail_Construct(self, NULL);
	return self;
}

void ModRail_Delete(ModRail *self)
{
	free(self);
}

static VehicleDirection12 ModRail_BestNewDirection(ModRail const *self, int dirVehicleDirection12Flags, cibool turnleft, cibool turnright, BoolRef *retFound)
{
	retFound->value = TRUE;
	if (turnright) {
		if ((dirVehicleDirection12Flags & 2048) != 0) {
			return VehicleDirection12_DOWN_RIGHT_RIGHT;
		}
		if ((dirVehicleDirection12Flags & 64) != 0) {
			return VehicleDirection12_UP_RIGHT_UP;
		}
		if ((dirVehicleDirection12Flags & 32) != 0) {
			return VehicleDirection12_UP_LEFT_LEFT;
		}
		if ((dirVehicleDirection12Flags & 256) != 0) {
			return VehicleDirection12_DOWN_LEFT_DOWN;
		}
	}
	if (turnleft) {
		if ((dirVehicleDirection12Flags & 1024) != 0) {
			return VehicleDirection12_DOWN_RIGHT_DOWN;
		}
		if ((dirVehicleDirection12Flags & 128) != 0) {
			return VehicleDirection12_UP_RIGHT_RIGHT;
		}
		if ((dirVehicleDirection12Flags & 16) != 0) {
			return VehicleDirection12_UP_LEFT_UP;
		}
		if ((dirVehicleDirection12Flags & 512) != 0) {
			return VehicleDirection12_DOWN_LEFT_LEFT;
		}
	}
	if ((dirVehicleDirection12Flags & 8) != 0) {
		return VehicleDirection12_VERTICAL_DOWN;
	}
	if ((dirVehicleDirection12Flags & 4) != 0) {
		return VehicleDirection12_VERTICAL_UP;
	}
	if ((dirVehicleDirection12Flags & 1) != 0) {
		return VehicleDirection12_HORIZONTAL_LEFT;
	}
	if ((dirVehicleDirection12Flags & 2) != 0) {
		return VehicleDirection12_HORIZONTAL_RIGHT;
	}
	if ((dirVehicleDirection12Flags & 256) != 0) {
		return VehicleDirection12_DOWN_LEFT_DOWN;
	}
	if ((dirVehicleDirection12Flags & 512) != 0) {
		return VehicleDirection12_DOWN_LEFT_LEFT;
	}
	if ((dirVehicleDirection12Flags & 1024) != 0) {
		return VehicleDirection12_DOWN_RIGHT_DOWN;
	}
	if ((dirVehicleDirection12Flags & 2048) != 0) {
		return VehicleDirection12_DOWN_RIGHT_RIGHT;
	}
	if ((dirVehicleDirection12Flags & 32) != 0) {
		return VehicleDirection12_UP_LEFT_LEFT;
	}
	if ((dirVehicleDirection12Flags & 16) != 0) {
		return VehicleDirection12_UP_LEFT_UP;
	}
	if ((dirVehicleDirection12Flags & 128) != 0) {
		return VehicleDirection12_UP_RIGHT_RIGHT;
	}
	if ((dirVehicleDirection12Flags & 64) != 0) {
		return VehicleDirection12_UP_RIGHT_UP;
	}
	retFound->value = FALSE;
	return VehicleDirection12_DOWN_LEFT_DOWN;
}

static Vector3Ref const *ModRail_CurrentRailPos(ModRail const *self, Game const *game)
{
	RailSlope slope = RailMapUtil_GetRailSlope(self->d_RailMapUtil, self->currentrailblockX, self->currentrailblockY, self->currentrailblockZ);
	float aX = self->currentrailblockX;
	float aY = self->currentrailblockY;
	float aZ = self->currentrailblockZ;
	float x_correction = 0;
	float y_correction = 0;
	float z_correction = 0;
	float half = self->one / 2;
	switch (self->currentdirection) {
	case VehicleDirection12_HORIZONTAL_RIGHT:
		x_correction += self->currentrailblockprogress;
		y_correction += half;
		if (slope == RailSlope_TWO_RIGHT_RAISED)
			z_correction += self->currentrailblockprogress;
		if (slope == RailSlope_TWO_LEFT_RAISED)
			z_correction += 1 - self->currentrailblockprogress;
		break;
	case VehicleDirection12_HORIZONTAL_LEFT:
		x_correction += 1 - self->currentrailblockprogress;
		y_correction += half;
		if (slope == RailSlope_TWO_RIGHT_RAISED)
			z_correction += 1 - self->currentrailblockprogress;
		if (slope == RailSlope_TWO_LEFT_RAISED)
			z_correction += self->currentrailblockprogress;
		break;
	case VehicleDirection12_VERTICAL_DOWN:
		x_correction += half;
		y_correction += self->currentrailblockprogress;
		if (slope == RailSlope_TWO_DOWN_RAISED)
			z_correction += self->currentrailblockprogress;
		if (slope == RailSlope_TWO_UP_RAISED)
			z_correction += 1 - self->currentrailblockprogress;
		break;
	case VehicleDirection12_VERTICAL_UP:
		x_correction += half;
		y_correction += 1 - self->currentrailblockprogress;
		if (slope == RailSlope_TWO_DOWN_RAISED)
			z_correction += 1 - self->currentrailblockprogress;
		if (slope == RailSlope_TWO_UP_RAISED)
			z_correction += self->currentrailblockprogress;
		break;
	case VehicleDirection12_UP_LEFT_LEFT:
		x_correction += half * (1 - self->currentrailblockprogress);
		y_correction += half * self->currentrailblockprogress;
		break;
	case VehicleDirection12_UP_LEFT_UP:
		x_correction += half * self->currentrailblockprogress;
		y_correction += half - half * self->currentrailblockprogress;
		break;
	case VehicleDirection12_UP_RIGHT_RIGHT:
		x_correction += half + half * self->currentrailblockprogress;
		y_correction += half * self->currentrailblockprogress;
		break;
	case VehicleDirection12_UP_RIGHT_UP:
		x_correction += 1 - half * self->currentrailblockprogress;
		y_correction += half - half * self->currentrailblockprogress;
		break;
	case VehicleDirection12_DOWN_LEFT_LEFT:
		x_correction += half * (1 - self->currentrailblockprogress);
		y_correction += 1 - half * self->currentrailblockprogress;
		break;
	case VehicleDirection12_DOWN_LEFT_DOWN:
		x_correction += half * self->currentrailblockprogress;
		y_correction += half + half * self->currentrailblockprogress;
		break;
	case VehicleDirection12_DOWN_RIGHT_RIGHT:
		x_correction += half + half * self->currentrailblockprogress;
		y_correction += 1 - half * self->currentrailblockprogress;
		break;
	case VehicleDirection12_DOWN_RIGHT_DOWN:
		x_correction += 1 - half * self->currentrailblockprogress;
		y_correction += half + half * self->currentrailblockprogress;
		break;
	}
	return Vector3Ref_Create(aX + x_correction, aZ + self->railheight + 1 + z_correction, aY + y_correction);
}

static void ModRail_ExitVehicle(ModRail *self, Game *game)
{
	Game_SetCharacterEyesHeight(game, self->originalmodelheight);
	self->railriding = FALSE;
	Controls_SetFreemove(game->controls, 0);
	game->enable_move = TRUE;
}

static int ModRail_GetUpDownMove(ModRail const *self, Game const *game, int railblockX, int railblockY, int railblockZ, TileEnterDirection dir)
{
	RailSlope slope;
	if (!Map_IsValidPos(game->map, railblockX, railblockY, railblockZ)) {
		return 0;
	}
	slope = RailMapUtil_GetRailSlope(self->d_RailMapUtil, railblockX, railblockY, railblockZ);
	if (slope == RailSlope_TWO_DOWN_RAISED && dir == TileEnterDirection_UP) {
		return 1;
	}
	if (slope == RailSlope_TWO_UP_RAISED && dir == TileEnterDirection_DOWN) {
		return 1;
	}
	if (slope == RailSlope_TWO_LEFT_RAISED && dir == TileEnterDirection_RIGHT) {
		return 1;
	}
	if (slope == RailSlope_TWO_RIGHT_RAISED && dir == TileEnterDirection_LEFT) {
		return 1;
	}
	if (slope == RailSlope_TWO_DOWN_RAISED && dir == TileEnterDirection_DOWN) {
		return 2;
	}
	if (slope == RailSlope_TWO_UP_RAISED && dir == TileEnterDirection_UP) {
		return 2;
	}
	if (slope == RailSlope_TWO_LEFT_RAISED && dir == TileEnterDirection_LEFT) {
		return 2;
	}
	if (slope == RailSlope_TWO_RIGHT_RAISED && dir == TileEnterDirection_RIGHT) {
		return 2;
	}
	return 0;
}

Vector3IntRef const *ModRail_NextTile(VehicleDirection12 direction, int currentTileX, int currentTileY, int currentTileZ)
{
	return ModRail_NextTile_(DirectionUtils_ResultExit(direction), currentTileX, currentTileY, currentTileZ);
}

Vector3IntRef const *ModRail_NextTile_(TileExitDirection direction, int currentTileX, int currentTileY, int currentTileZ)
{
	switch (direction) {
	case TileExitDirection_LEFT:
		return Vector3IntRef_Create(currentTileX - 1, currentTileY, currentTileZ);
	case TileExitDirection_RIGHT:
		return Vector3IntRef_Create(currentTileX + 1, currentTileY, currentTileZ);
	case TileExitDirection_UP:
		return Vector3IntRef_Create(currentTileX, currentTileY - 1, currentTileZ);
	case TileExitDirection_DOWN:
		return Vector3IntRef_Create(currentTileX, currentTileY + 1, currentTileZ);
	default:
		return NULL;
	}
}

void ModRail_OnNewFrameFixed(ModRail *self, Game *game, NewFrameEventArgs const *args)
{
	if (self->d_RailMapUtil == NULL) {
		self->d_RailMapUtil = RailMapUtil_New();
		self->d_RailMapUtil->game = game;
	}
	ModRail_RailOnNewFrame(self, game, NewFrameEventArgs_GetDt(args));
}

static int ModRail_PossibleRails(ModRail const *self, Game const *game, TileEnterData const *enter)
{
	int possible_railsVehicleDirection12Flags = 0;
	if (Map_IsValidPos(game->map, enter->blockPositionX, enter->blockPositionY, enter->blockPositionZ)) {
		int newpositionrail = GameData_Rail(game->d_Data)[Map_GetBlock(game->map, enter->blockPositionX, enter->blockPositionY, enter->blockPositionZ)];
		VehicleDirection12 *all_possible_rails = (VehicleDirection12 *) malloc(3 * sizeof(VehicleDirection12 ));
		int all_possible_railsCount = 0;
		VehicleDirection12 const *possibleRails3 = DirectionUtils_PossibleNewRails3(enter->enterDirection);
		{
			int i;
			for (i = 0; i < 3; i++) {
				VehicleDirection12 z = possibleRails3[i];
				if ((newpositionrail & DirectionUtils_ToRailDirectionFlags(DirectionUtils_ToRailDirection(z))) != 0) {
					all_possible_rails[all_possible_railsCount++] = z;
				}
			}
		}
		possible_railsVehicleDirection12Flags = DirectionUtils_ToVehicleDirection12Flags_(all_possible_rails, all_possible_railsCount);
	}
	return possible_railsVehicleDirection12Flags;
}

static void ModRail_RailOnNewFrame(ModRail *self, Game *game, float dt)
{
	cibool turnright;
	cibool turnleft;
	if (self->localMinecart == NULL) {
		self->localMinecart = Entity_New();
		self->localMinecart->minecart = Minecart_New();
		Game_EntityAddLocal(game, self->localMinecart);
	}
	self->localMinecart->minecart->enabled = self->railriding;
	if (self->railriding) {
		Minecart *m = self->localMinecart->minecart;
		m->positionX = game->player->position->x;
		m->positionY = game->player->position->y;
		m->positionZ = game->player->position->z;
		m->direction = self->currentdirection;
		m->lastdirection = self->lastdirection;
		m->progress = self->currentrailblockprogress;
	}
	game->localplayeranimationhint->inVehicle = self->railriding;
	game->localplayeranimationhint->drawFixX = 0;
	game->localplayeranimationhint->drawFixY = self->railriding ? -self->one * 7 / 10 : 0;
	game->localplayeranimationhint->drawFixZ = 0;
	turnright = game->keyboardState[Game_GetKey(game, 86)];
	turnleft = game->keyboardState[Game_GetKey(game, 83)];
	ModRail_RailSound(self, game);
	if (self->railriding) {
		Vector3Ref const *railPos;
		Controls_SetFreemove(game->controls, 1);
		game->enable_move = FALSE;
		railPos = ModRail_CurrentRailPos(self, game);
		game->player->position->x = railPos->x;
		game->player->position->y = railPos->y;
		game->player->position->z = railPos->z;
		self->currentrailblockprogress += self->currentvehiclespeed * dt;
		if (self->currentrailblockprogress >= 1) {
			TileEnterData *newenter;
			Vector3IntRef const *nexttile;
			BoolRef *newdirFound;
			VehicleDirection12 newdir;
			self->lastdirection = self->currentdirection;
			self->currentrailblockprogress = 0;
			newenter = TileEnterData_New();
			nexttile = ModRail_NextTile(self->currentdirection, self->currentrailblockX, self->currentrailblockY, self->currentrailblockZ);
			newenter->blockPositionX = nexttile->x;
			newenter->blockPositionY = nexttile->y;
			newenter->blockPositionZ = nexttile->z;
			if (ModRail_GetUpDownMove(self, game, self->currentrailblockX, self->currentrailblockY, self->currentrailblockZ, DirectionUtils_ResultEnter(DirectionUtils_ResultExit(self->currentdirection))) == 1) {
				newenter->blockPositionZ++;
			}
			if (ModRail_GetUpDownMove(self, game, newenter->blockPositionX, newenter->blockPositionY, newenter->blockPositionZ - 1, DirectionUtils_ResultEnter(DirectionUtils_ResultExit(self->currentdirection))) == 2) {
				newenter->blockPositionZ--;
			}
			newenter->enterDirection = DirectionUtils_ResultEnter(DirectionUtils_ResultExit(self->currentdirection));
			newdirFound = BoolRef_New();
			newdir = ModRail_BestNewDirection(self, ModRail_PossibleRails(self, game, newenter), turnleft, turnright, newdirFound);
			if (!newdirFound->value) {
				self->currentdirection = DirectionUtils_Reverse(self->currentdirection);
			}
			else {
				self->currentdirection = newdir;
				self->currentrailblockX = game->platform->vtbl->floatToInt(game->platform, newenter->blockPositionX);
				self->currentrailblockY = game->platform->vtbl->floatToInt(game->platform, newenter->blockPositionY);
				self->currentrailblockZ = game->platform->vtbl->floatToInt(game->platform, newenter->blockPositionZ);
			}
		}
	}
	if (game->keyboardState[Game_GetKey(game, 105)] && game->guiTyping != TypingState_TYPING) {
		self->currentvehiclespeed += 1 * dt;
	}
	if (game->keyboardState[Game_GetKey(game, 101)] && game->guiTyping != TypingState_TYPING) {
		self->currentvehiclespeed -= 5 * dt;
	}
	if (self->currentvehiclespeed < 0) {
		self->currentvehiclespeed = 0;
	}
	if (!self->wasqpressed && game->keyboardState[Game_GetKey(game, 99)] && game->guiTyping != TypingState_TYPING) {
		ModRail_Reverse(self);
	}
	if (!self->wasepressed && game->keyboardState[Game_GetKey(game, 87)] && !self->railriding && Controls_GetFreemove(game->controls) == 0 && game->guiTyping != TypingState_TYPING) {
		self->currentrailblockX = game->platform->vtbl->floatToInt(game->platform, game->player->position->x);
		self->currentrailblockY = game->platform->vtbl->floatToInt(game->platform, game->player->position->z);
		self->currentrailblockZ = game->platform->vtbl->floatToInt(game->platform, game->player->position->y) - 1;
		if (!Map_IsValidPos(game->map, self->currentrailblockX, self->currentrailblockY, self->currentrailblockZ)) {
			ModRail_ExitVehicle(self, game);
		}
		else {
			int railunderplayer = GameData_Rail(game->d_Data)[Map_GetBlock(game->map, self->currentrailblockX, self->currentrailblockY, self->currentrailblockZ)];
			self->railriding = TRUE;
			self->originalmodelheight = Game_GetCharacterEyesHeight(game);
			Game_SetCharacterEyesHeight(game, ModRail_minecartheight(self));
			self->currentvehiclespeed = 0;
			if ((railunderplayer & 1) != 0) {
				self->currentdirection = VehicleDirection12_HORIZONTAL_RIGHT;
			}
			else if ((railunderplayer & 2) != 0) {
				self->currentdirection = VehicleDirection12_VERTICAL_UP;
			}
			else if ((railunderplayer & 4) != 0) {
				self->currentdirection = VehicleDirection12_UP_LEFT_UP;
			}
			else if ((railunderplayer & 8) != 0) {
				self->currentdirection = VehicleDirection12_UP_RIGHT_UP;
			}
			else if ((railunderplayer & 16) != 0) {
				self->currentdirection = VehicleDirection12_DOWN_LEFT_LEFT;
			}
			else if ((railunderplayer & 32) != 0) {
				self->currentdirection = VehicleDirection12_DOWN_RIGHT_RIGHT;
			}
			else {
				ModRail_ExitVehicle(self, game);
			}
			self->lastdirection = self->currentdirection;
		}
	}
	else if (!self->wasepressed && game->keyboardState[Game_GetKey(game, 87)] && self->railriding && game->guiTyping != TypingState_TYPING) {
		ModRail_ExitVehicle(self, game);
		game->player->position->y += self->one * 7 / 10;
	}
	self->wasqpressed = game->keyboardState[Game_GetKey(game, 99)] && game->guiTyping != TypingState_TYPING;
	self->wasepressed = game->keyboardState[Game_GetKey(game, 87)] && game->guiTyping != TypingState_TYPING;
}

static void ModRail_RailSound(ModRail *self, Game const *game)
{
	float railsoundpersecond = self->currentvehiclespeed;
	if (railsoundpersecond > 10) {
		railsoundpersecond = 10;
	}
	Game_AudioPlayLoop(game, "railnoise.wav", self->railriding && railsoundpersecond > self->one * 1 / 10, FALSE);
	if (!self->railriding) {
		return;
	}
	if (game->platform->vtbl->timeMillisecondsFromStart(game->platform) - self->lastrailsoundtimeMilliseconds > 1000 / railsoundpersecond) {
		Game_AudioPlay(game, game->platform->vtbl->stringFormat(game->platform, "rail{0}.wav", game->platform->vtbl->intToString(game->platform, self->lastrailsound + 1)));
		self->lastrailsoundtimeMilliseconds = game->platform->vtbl->timeMillisecondsFromStart(game->platform);
		self->lastrailsound++;
		if (self->lastrailsound >= 4) {
			self->lastrailsound = 0;
		}
	}
}

static void ModRail_Reverse(ModRail *self)
{
	self->currentdirection = DirectionUtils_Reverse(self->currentdirection);
	self->currentrailblockprogress = 1 - self->currentrailblockprogress;
	self->lastdirection = self->currentdirection;
}

static float ModRail_minecartheight(ModRail const *self)
{
	return self->one / 2;
}

static void ModReloadAmmo_Construct(ModReloadAmmo *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModReloadAmmo;
	ClientMod_Construct(&self->base, vtbl);
}

ModReloadAmmo *ModReloadAmmo_New(void)
{
	ModReloadAmmo *self = (ModReloadAmmo *) malloc(sizeof(ModReloadAmmo));
	if (self != NULL)
		ModReloadAmmo_Construct(self, NULL);
	return self;
}

void ModReloadAmmo_Delete(ModReloadAmmo *self)
{
	free(self);
}

void ModReloadAmmo_OnKeyDown(ModReloadAmmo const *self, Game *game, KeyEventArgs const *args)
{
	int eKey;
	if (!(game->guistate == GuiState_NORMAL && game->guiTyping == TypingState_NONE)) {
		return;
	}
	eKey = KeyEventArgs_GetKeyCode(args);
	if (eKey == Game_GetKey(game, 100)) {
		Packet_Item const *item = game->d_Inventory->rightHand[game->activeMaterial];
		if (item != NULL && item->itemClass == 0 && game->blocktypes[item->blockId]->isPistol && game->reloadstartMilliseconds == 0) {
			int sound = game->rnd->vtbl->next(game->rnd) % game->blocktypes[item->blockId]->sounds->reloadCount;
			Game_AudioPlay(game, StringTools_StringAppend(game->platform, game->blocktypes[item->blockId]->sounds->reload[sound], ".ogg"));
			game->reloadstartMilliseconds = game->platform->vtbl->timeMillisecondsFromStart(game->platform);
			game->reloadblock = item->blockId;
			Game_SendPacketClient(game, ClientPackets_Reload());
		}
	}
}

void ModReloadAmmo_OnNewFrameFixed(ModReloadAmmo const *self, Game *game, NewFrameEventArgs const *args)
{
	if (game->reloadstartMilliseconds != 0 && game->one * (game->platform->vtbl->timeMillisecondsFromStart(game->platform) - game->reloadstartMilliseconds) / 1000 > Game_DeserializeFloat(game, game->blocktypes[game->reloadblock]->reloadDelayFloat)) {
		{
			int loaded = game->totalAmmo[game->reloadblock];
			loaded = MathCi_MinInt(game->blocktypes[game->reloadblock]->ammoMagazine, loaded);
			game->loadedAmmo[game->reloadblock] = loaded;
			game->reloadstartMilliseconds = 0;
			game->reloadblock = -1;
		}
	}
}

static void ModScreenshot_Construct(ModScreenshot *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModScreenshot;
	ClientMod_Construct(&self->base, vtbl);
	self->takeScreenshot = FALSE;
	self->screenshotFlashFramesLeft = 0;
}

ModScreenshot *ModScreenshot_New(void)
{
	ModScreenshot *self = (ModScreenshot *) malloc(sizeof(ModScreenshot));
	if (self != NULL)
		ModScreenshot_Construct(self, NULL);
	return self;
}

void ModScreenshot_Delete(ModScreenshot *self)
{
	free(self);
}

static void ModScreenshot_DrawScreenshotFlash(ModScreenshot const *self, Game *game)
{
	const char *screenshottext;
	IntRef const *textWidth;
	IntRef const *textHeight;
	FontCi *font;
	Game_Draw2dTexture(game, Game_WhiteTexture(game), 0, 0, game->platform->vtbl->getCanvasWidth(game->platform), game->platform->vtbl->getCanvasHeight(game->platform), NULL, 0, Game_ColorFromArgb(255, 255, 255, 255), FALSE);
	screenshottext = "&0Screenshot";
	textWidth = IntRef_New();
	textHeight = IntRef_New();
	game->platform->vtbl->textSize(game->platform, screenshottext, 50, textWidth, textHeight);
	font = FontCi_New();
	font->family = "Arial";
	font->size = 50;
	Game_Draw2dText(game, screenshottext, font, Game_xcenter(game, textWidth->value), Game_ycenter(game, textHeight->value), NULL, FALSE);
}

void ModScreenshot_OnKeyDown(ModScreenshot *self, Game const *game, KeyEventArgs *args)
{
	if (KeyEventArgs_GetKeyCode(args) == Game_GetKey(game, 21)) {
		self->takeScreenshot = TRUE;
		KeyEventArgs_SetHandled(args, TRUE);
	}
}

void ModScreenshot_OnNewFrameDraw2d(ModScreenshot *self, Game *game, float deltaTime)
{
	if (self->takeScreenshot) {
		self->takeScreenshot = FALSE;
		game->platform->vtbl->saveScreenshot(game->platform);
		self->screenshotFlashFramesLeft = 5;
	}
	if (self->screenshotFlashFramesLeft > 0) {
		ModScreenshot_DrawScreenshotFlash(self, game);
		self->screenshotFlashFramesLeft--;
	}
}

static void ModSendActiveMaterial_Construct(ModSendActiveMaterial *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModSendActiveMaterial;
	ClientMod_Construct(&self->base, vtbl);
}

ModSendActiveMaterial *ModSendActiveMaterial_New(void)
{
	ModSendActiveMaterial *self = (ModSendActiveMaterial *) malloc(sizeof(ModSendActiveMaterial));
	if (self != NULL)
		ModSendActiveMaterial_Construct(self, NULL);
	return self;
}

void ModSendActiveMaterial_Delete(ModSendActiveMaterial *self)
{
	free(self);
}

void ModSendActiveMaterial_OnNewFrameFixed(ModSendActiveMaterial *self, Game const *game, NewFrameEventArgs const *args)
{
	Packet_Item const *activeitem = game->d_Inventory->rightHand[game->activeMaterial];
	int activeblock = 0;
	if (activeitem != NULL) {
		activeblock = activeitem->blockId;
	}
	if (activeblock != self->previousActiveMaterialBlock) {
		Game_SendPacketClient(game, ClientPackets_ActiveMaterialSlot(game->activeMaterial));
	}
	self->previousActiveMaterialBlock = activeblock;
}

static void ModSendPosition_Construct(ModSendPosition *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModSendPosition;
	ClientMod_Construct(&self->base, vtbl);
}

ModSendPosition *ModSendPosition_New(void)
{
	ModSendPosition *self = (ModSendPosition *) malloc(sizeof(ModSendPosition));
	if (self != NULL)
		ModSendPosition_Construct(self, NULL);
	return self;
}

void ModSendPosition_Delete(ModSendPosition *self)
{
	free(self);
}

void ModSendPosition_OnNewFrame(ModSendPosition const *self, Game *game, NewFrameEventArgs const *args)
{
	if (game->spawned && game->platform->vtbl->timeMillisecondsFromStart(game->platform) - game->lastpositionsentMilliseconds > 100) {
		game->lastpositionsentMilliseconds = game->platform->vtbl->timeMillisecondsFromStart(game->platform);
		Game_SendPacketClient(game, ClientPackets_PositionAndOrientation(game, game->localPlayerId, game->player->position->x, game->player->position->y, game->player->position->z, game->player->position->rotx, game->player->position->roty, game->player->position->rotz, game->localstance));
	}
}

static void ModServerSimple_Construct(ModServerSimple *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModServerSimple;
	ClientMod_Construct(&self->base, vtbl);
}

ModServerSimple *ModServerSimple_New(void)
{
	ModServerSimple *self = (ModServerSimple *) malloc(sizeof(ModServerSimple));
	if (self != NULL)
		ModServerSimple_Construct(self, NULL);
	return self;
}

void ModServerSimple_Delete(ModServerSimple *self)
{
	free(self);
}

void ModServerSimple_OnReadOnlyBackgroundThread(ModServerSimple const *self, Game const *game, float dt)
{
	ServerSimple_Update(self->server);
}

static void ModSimple_Construct(ModSimple *self, const ModSimpleVtbl *vtbl)
{
	self->vtbl = vtbl;
}

void ModSimple_GenerateChunk(ModSimple const *self, int cx, int cy, int cz, int const *chunk)
{
}

int ModSimple_GetHeight(ModSimple const *self)
{
	return -1;
}

void ModSimple_OnPlayerJoin(ModSimple const *self, int playerId)
{
}

static void ModSimpleDefault_Construct(ModSimpleDefault *self, const ModSimpleVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModSimpleDefault;
	ModSimple_Construct(&self->base, vtbl);
}

ModSimpleDefault *ModSimpleDefault_New(void)
{
	ModSimpleDefault *self = (ModSimpleDefault *) malloc(sizeof(ModSimpleDefault));
	if (self != NULL)
		ModSimpleDefault_Construct(self, NULL);
	return self;
}

void ModSimpleDefault_Delete(ModSimpleDefault *self)
{
	free(self);
}

void ModSimpleDefault_OnPlayerJoin(ModSimpleDefault const *self, int playerId)
{
	self->m->vtbl->addToInventory(self->m, playerId, "Dirt", 0);
	self->m->vtbl->addToInventory(self->m, playerId, "Stone", 0);
	self->m->vtbl->addToInventory(self->m, playerId, "Wood", 0);
	self->m->vtbl->addToInventory(self->m, playerId, "Brick", 0);
}

void ModSimpleDefault_Start(ModSimpleDefault *self, ModManagerSimple const *manager)
{
	BlockTypeSimple const *empty;
	BlockTypeSimple const *stone;
	BlockTypeSimple const *dirt;
	BlockTypeSimple const *grass;
	BlockTypeSimple const *wood;
	BlockTypeSimple const *brick;
	BlockTypeSimple const *adminium;
	self->m = manager;
	empty = manager->vtbl->createBlockType(manager, "Empty");
	BlockTypeSimple_SetDrawType(empty, 0);
	BlockTypeSimple_SetWalkableType(empty, 0);
	stone = manager->vtbl->createBlockType(manager, "Stone");
	BlockTypeSimple_SetDrawType(stone, 1);
	BlockTypeSimple_SetWalkableType(stone, 2);
	BlockTypeSimple_SetAllTextures(stone, "Stone");
	dirt = manager->vtbl->createBlockType(manager, "Dirt");
	BlockTypeSimple_SetDrawType(dirt, 1);
	BlockTypeSimple_SetWalkableType(dirt, 2);
	BlockTypeSimple_SetAllTextures(dirt, "Dirt");
	grass = manager->vtbl->createBlockType(manager, "Grass");
	BlockTypeSimple_SetDrawType(grass, 1);
	BlockTypeSimple_SetWalkableType(grass, 2);
	BlockTypeSimple_SetTextureTop(grass, "Grass");
	BlockTypeSimple_SetTextureBack(grass, "GrassSide");
	BlockTypeSimple_SetTextureFront(grass, "GrassSide");
	BlockTypeSimple_SetTextureLeft(grass, "GrassSide");
	BlockTypeSimple_SetTextureRight(grass, "GrassSide");
	BlockTypeSimple_SetTextureBottom(grass, "Dirt");
	wood = manager->vtbl->createBlockType(manager, "Wood");
	BlockTypeSimple_SetDrawType(wood, 1);
	BlockTypeSimple_SetWalkableType(wood, 2);
	BlockTypeSimple_SetAllTextures(wood, "OakWood");
	brick = manager->vtbl->createBlockType(manager, "Brick");
	BlockTypeSimple_SetDrawType(brick, 1);
	BlockTypeSimple_SetWalkableType(brick, 2);
	BlockTypeSimple_SetAllTextures(brick, "Brick");
	manager->vtbl->createBlockType(manager, "Sponge");
	manager->vtbl->createBlockType(manager, "Trampoline");
	adminium = manager->vtbl->createBlockType(manager, "Adminium");
	BlockTypeSimple_SetDrawType(adminium, 1);
	BlockTypeSimple_SetWalkableType(adminium, 2);
	BlockTypeSimple_SetAllTextures(adminium, "Adminium");
	manager->vtbl->createBlockType(manager, "Compass");
	manager->vtbl->createBlockType(manager, "Ladder");
	manager->vtbl->createBlockType(manager, "EmptyHand");
	manager->vtbl->createBlockType(manager, "CraftingTable");
	manager->vtbl->createBlockType(manager, "Lava");
	manager->vtbl->createBlockType(manager, "StationaryLava");
	manager->vtbl->createBlockType(manager, "FillStart");
	manager->vtbl->createBlockType(manager, "Cuboid");
	manager->vtbl->createBlockType(manager, "FillArea");
	manager->vtbl->createBlockType(manager, "Minecart");
	manager->vtbl->createBlockType(manager, "Rail0");
}

static void ModSimpleWorldGenerator_Construct(ModSimpleWorldGenerator *self, const ModSimpleVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModSimpleWorldGenerator;
	ModSimple_Construct(&self->base, vtbl);
}

ModSimpleWorldGenerator *ModSimpleWorldGenerator_New(void)
{
	ModSimpleWorldGenerator *self = (ModSimpleWorldGenerator *) malloc(sizeof(ModSimpleWorldGenerator));
	if (self != NULL)
		ModSimpleWorldGenerator_Construct(self, NULL);
	return self;
}

void ModSimpleWorldGenerator_Delete(ModSimpleWorldGenerator *self)
{
	free(self);
}

void ModSimpleWorldGenerator_GenerateChunk(ModSimpleWorldGenerator const *self, int cx, int cy, int cz, int *chunk)
{
	int grass = self->m->vtbl->getBlockTypeId(self->m, "Grass");
	int dirt = self->m->vtbl->getBlockTypeId(self->m, "Dirt");
	int stone = self->m->vtbl->getBlockTypeId(self->m, "Stone");
	int adminium = self->m->vtbl->getBlockTypeId(self->m, "Adminium");
	{
		int xx;
		for (xx = 0; xx < 32; xx++) {
			{
				int yy;
				for (yy = 0; yy < 32; yy++) {
					{
						int zz;
						for (zz = 0; zz < 32; zz++) {
							int z = cz * 32 + zz;
							int height = 32;
							int block = 0;
							if (z > height) {
								block = 0;
							}
							else if (z == height) {
								block = grass;
							}
							else if (z > height - 5) {
								block = dirt;
							}
							else {
								block = stone;
							}
							if (z == 0) {
								block = adminium;
							}
							chunk[(zz * 32 + yy) * 32 + xx] = block;
						}
					}
				}
			}
		}
	}
}

int ModSimpleWorldGenerator_GetHeight(ModSimpleWorldGenerator const *self)
{
	return 33;
}

void ModSimpleWorldGenerator_Start(ModSimpleWorldGenerator *self, ModManagerSimple const *manager)
{
	self->m = manager;
}

static void ModSkySphereAnimated_Construct(ModSkySphereAnimated *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModSkySphereAnimated;
	ClientMod_Construct(&self->base, vtbl);
	self->stars = &ModSkySphereStatic_New()->base;
}

ModSkySphereAnimated *ModSkySphereAnimated_New(void)
{
	ModSkySphereAnimated *self = (ModSkySphereAnimated *) malloc(sizeof(ModSkySphereAnimated));
	if (self != NULL)
		ModSkySphereAnimated_Construct(self, NULL);
	return self;
}

void ModSkySphereAnimated_Delete(ModSkySphereAnimated *self)
{
	free(self);
}

void ModSkySphereAnimated_Draw(ModSkySphereAnimated *self, Game *game, float fov)
{
	int size = 1000;
	if (game->fancySkysphere) {
		self->skymodel = ModSkySphereAnimated_GetSphereModelData2(self, self->skymodel, game->platform, size, size, 64, 64, self->skyPixels, self->glowPixels, game->sunPositionX, game->sunPositionY, game->sunPositionZ);
	}
	else {
		self->skymodel = ModSkySphereAnimated_GetSphereModelData2(self, self->skymodel, game->platform, size, size, 20, 20, self->skyPixels, self->glowPixels, game->sunPositionX, game->sunPositionY, game->sunPositionZ);
	}
	Game_Set3dProjection(game, size * 2, fov);
	Game_GLMatrixModeModelView(game);
	Game_GLPushMatrix(game);
	Game_GLTranslate(game, game->player->position->x, game->player->position->y, game->player->position->z);
	game->platform->vtbl->bindTexture2d(game->platform, 0);
	Game_DrawModelData(game, self->skymodel);
	Game_GLPopMatrix(game);
	Game_Set3dProjection(game, Game_zfar(game), fov);
}

static void ModSkySphereAnimated_DrawSkySphere(ModSkySphereAnimated *self, Game *game)
{
	if (!self->started) {
		BitmapCi const *skyBmp;
		BitmapCi const *glowBmp;
		self->started = TRUE;
		skyBmp = game->platform->vtbl->bitmapCreateFromPng(game->platform, Game_GetFile(game, "sky.png"), Game_GetFileLength(game, "sky.png"));
		glowBmp = game->platform->vtbl->bitmapCreateFromPng(game->platform, Game_GetFile(game, "glow.png"), Game_GetFileLength(game, "glow.png"));
		self->skyPixels = (int *) malloc(1048576 * sizeof(int ));
		self->glowPixels = (int *) malloc(1048576 * sizeof(int ));
		game->platform->vtbl->bitmapGetPixelsArgb(game->platform, skyBmp, self->skyPixels);
		game->platform->vtbl->bitmapGetPixelsArgb(game->platform, glowBmp, self->glowPixels);
		game->platform->vtbl->bitmapDelete(game->platform, skyBmp);
		game->platform->vtbl->bitmapDelete(game->platform, glowBmp);
	}
	game->platform->vtbl->gLDisableAlphaTest(game->platform);
	game->platform->vtbl->glDisableDepthTest(game->platform);
	ModSkySphereAnimated_Draw(self, game, Game_currentfov(game));
	game->platform->vtbl->gLEnableAlphaTest(game->platform);
	game->platform->vtbl->glEnableDepthTest(game->platform);
}

ModelData *ModSkySphereAnimated_GetSphereModelData2(ModSkySphereAnimated const *self, ModelData *data, GamePlatform const *platform, float radius, float height, int segments, int rings, int const *skyPixels_, int const *glowPixels_, float sunX, float sunY, float sunZ)
{
	int i = 0;
	if (data == NULL) {
		data = ModelData_New();
		data->xyz = (float *) malloc(rings * segments * 3 * sizeof(float ));
		data->uv = (float *) malloc(rings * segments * 2 * sizeof(float ));
		data->rgba = (unsigned char *) malloc(rings * segments * 4 * sizeof(unsigned char ));
		ModelData_SetVerticesCount(data, segments * rings);
		ModelData_SetIndicesCount(data, segments * rings * 6);
		ModelData_setIndices(data, SphereModelData_CalculateElements(radius, height, segments, rings));
	}
	{
		int y;
		for (y = 0; y < rings; y++) {
			float yFloat = y;
			float phiFloat = yFloat / (rings - 1) * Game_GetPi();
			{
				int x;
				for (x = 0; x < segments; x++) {
					float xFloat = x;
					float theta = xFloat / (segments - 1) * 2 * Game_GetPi();
					float vx = radius * Platform_Sin(phiFloat) * Platform_Cos(theta);
					float vy = height * Platform_Cos(phiFloat);
					float vz = radius * Platform_Sin(phiFloat) * Platform_Sin(theta);
					float u = xFloat / (segments - 1);
					float v = yFloat / (rings - 1);
					float vertexLength;
					float vertexXNormalized;
					float vertexYNormalized;
					float vertexZNormalized;
					float sunLength;
					float sunXNormalized;
					float sunYNormalized;
					float sunZNormalized;
					float dx;
					float dy;
					float dz;
					float proximityToSun;
					float one;
					int skyColor;
					float skyColorA;
					float skyColorR;
					float skyColorG;
					float skyColorB;
					int glowColor;
					float glowColorA;
					float glowColorR;
					float glowColorG;
					float glowColorB;
					float colorR;
					float colorG;
					float colorB;
					float colorA;
					data->xyz[i * 3 + 0] = vx;
					data->xyz[i * 3 + 1] = vy;
					data->xyz[i * 3 + 2] = vz;
					data->uv[i * 2 + 0] = u;
					data->uv[i * 2 + 1] = v;
					vertexLength = platform->vtbl->mathSqrt(platform, vx * vx + vy * vy + vz * vz);
					vertexXNormalized = vx / vertexLength;
					vertexYNormalized = vy / vertexLength;
					vertexZNormalized = vz / vertexLength;
					sunLength = platform->vtbl->mathSqrt(platform, sunX * sunX + sunY * sunY + sunZ * sunZ);
					if (sunLength == 0) {
						sunLength = 1;
					}
					sunXNormalized = sunX / sunLength;
					sunYNormalized = sunY / sunLength;
					sunZNormalized = sunZ / sunLength;
					dx = vertexXNormalized - sunXNormalized;
					dy = vertexYNormalized - sunYNormalized;
					dz = vertexZNormalized - sunZNormalized;
					proximityToSun = 1 - platform->vtbl->mathSqrt(platform, dx * dx + dy * dy + dz * dz) / 2;
					one = 1;
					skyColor = ModSkySphereAnimated_Texture2d(platform, skyPixels_, (sunYNormalized + 2) / 4, 1 - (vertexYNormalized + 1) / 2);
					skyColorA = one * Game_ColorA(skyColor) / 255;
					skyColorR = one * Game_ColorR(skyColor) / 255;
					skyColorG = one * Game_ColorG(skyColor) / 255;
					skyColorB = one * Game_ColorB(skyColor) / 255;
					glowColor = ModSkySphereAnimated_Texture2d(platform, glowPixels_, (sunYNormalized + one) / 2, 1 - proximityToSun);
					glowColorA = one * Game_ColorA(glowColor) / 255;
					glowColorR = one * Game_ColorR(glowColor) / 255;
					glowColorG = one * Game_ColorG(glowColor) / 255;
					glowColorB = one * Game_ColorB(glowColor) / 255;
					colorR = skyColorR + glowColorR * glowColorA;
					colorG = skyColorG + glowColorG * glowColorA;
					colorB = skyColorB + glowColorB * glowColorA;
					colorA = skyColorA;
					if (colorR > 1) {
						colorR = 1;
					}
					if (colorG > 1) {
						colorG = 1;
					}
					if (colorB > 1) {
						colorB = 1;
					}
					if (colorA > 1) {
						colorA = 1;
					}
					data->rgba[i * 4 + 0] = Game_IntToByte(platform->vtbl->floatToInt(platform, colorR * 255));
					data->rgba[i * 4 + 1] = Game_IntToByte(platform->vtbl->floatToInt(platform, colorG * 255));
					data->rgba[i * 4 + 2] = Game_IntToByte(platform->vtbl->floatToInt(platform, colorB * 255));
					data->rgba[i * 4 + 3] = Game_IntToByte(platform->vtbl->floatToInt(platform, colorA * 255));
					i++;
				}
			}
		}
	}
	return data;
}

void ModSkySphereAnimated_OnNewFrameDraw3d(ModSkySphereAnimated *self, Game *game, float deltaTime)
{
	game->skySphereNight = TRUE;
	self->stars->vtbl->onNewFrameDraw3d(self->stars, game, deltaTime);
	game->platform->vtbl->glDisableFog(game->platform);
	ModSkySphereAnimated_DrawSkySphere(self, game);
	Game_SetFog(game);
}

static int ModSkySphereAnimated_Texture2d(GamePlatform const *platform, int const *pixelsArgb, float x, float y)
{
	int px = platform->vtbl->floatToInt(platform, x * 511);
	int py = platform->vtbl->floatToInt(platform, y * 511);
	px = ModSkySphereAnimated_positive_modulo(px, 511);
	py = ModSkySphereAnimated_positive_modulo(py, 511);
	return pixelsArgb[MapUtilCi_Index2d(px, py, 512)];
}

static int ModSkySphereAnimated_positive_modulo(int i, int n)
{
	return (i % n + n) % n;
}

static void ModSkySphereStatic_Construct(ModSkySphereStatic *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModSkySphereStatic;
	ClientMod_Construct(&self->base, vtbl);
	self->skyTexture = -1;
	self->skyspheretexture = -1;
	self->skyspherenighttexture = -1;
}

ModSkySphereStatic *ModSkySphereStatic_New(void)
{
	ModSkySphereStatic *self = (ModSkySphereStatic *) malloc(sizeof(ModSkySphereStatic));
	if (self != NULL)
		ModSkySphereStatic_Construct(self, NULL);
	return self;
}

void ModSkySphereStatic_Delete(ModSkySphereStatic *self)
{
	free(self);
}

void ModSkySphereStatic_Draw(ModSkySphereStatic *self, Game *game, float fov)
{
	int size;
	if (self->skyTexture == -1) {
		game->platform->vtbl->throwException(game->platform, "InvalidOperationException");
	}
	size = 1000;
	if (self->skymodel == NULL) {
		self->skymodel = game->platform->vtbl->createModel(game->platform, SphereModelData_GetSphereModelData(size, size, 20, 20));
	}
	Game_Set3dProjection(game, size * 2, fov);
	Game_GLMatrixModeModelView(game);
	Game_GLPushMatrix(game);
	Game_GLTranslate(game, game->player->position->x, game->player->position->y, game->player->position->z);
	game->platform->vtbl->bindTexture2d(game->platform, self->skyTexture);
	Game_DrawModel(game, self->skymodel);
	Game_GLPopMatrix(game);
	Game_Set3dProjection(game, Game_zfar(game), fov);
}

static void ModSkySphereStatic_DrawSkySphere(ModSkySphereStatic *self, Game *game)
{
	int texture;
	if (self->skyspheretexture == -1) {
		BitmapCi const *skysphereBmp = game->platform->vtbl->bitmapCreateFromPng(game->platform, Game_GetFile(game, "skysphere.png"), Game_GetFileLength(game, "skysphere.png"));
		BitmapCi const *skysphereNightBmp = game->platform->vtbl->bitmapCreateFromPng(game->platform, Game_GetFile(game, "skyspherenight.png"), Game_GetFileLength(game, "skyspherenight.png"));
		self->skyspheretexture = game->platform->vtbl->loadTextureFromBitmap(game->platform, skysphereBmp);
		self->skyspherenighttexture = game->platform->vtbl->loadTextureFromBitmap(game->platform, skysphereNightBmp);
		game->platform->vtbl->bitmapDelete(game->platform, skysphereBmp);
		game->platform->vtbl->bitmapDelete(game->platform, skysphereNightBmp);
	}
	texture = game->skySphereNight ? self->skyspherenighttexture : self->skyspheretexture;
	if (game->shadowssimple) {
		texture = self->skyspheretexture;
	}
	self->skyTexture = texture;
	ModSkySphereStatic_Draw(self, game, Game_currentfov(game));
}

void ModSkySphereStatic_OnNewFrameDraw3d(ModSkySphereStatic *self, Game *game, float deltaTime)
{
	game->platform->vtbl->glDisableFog(game->platform);
	ModSkySphereStatic_DrawSkySphere(self, game);
	Game_SetFog(game);
}

static void ModUnloadRendererChunks_Construct(ModUnloadRendererChunks *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModUnloadRendererChunks;
	ClientMod_Construct(&self->base, vtbl);
	self->unloadxyztemp = Vector3IntRef_New();
}

ModUnloadRendererChunks *ModUnloadRendererChunks_New(void)
{
	ModUnloadRendererChunks *self = (ModUnloadRendererChunks *) malloc(sizeof(ModUnloadRendererChunks));
	if (self != NULL)
		ModUnloadRendererChunks_Construct(self, NULL);
	return self;
}

void ModUnloadRendererChunks_Delete(ModUnloadRendererChunks *self)
{
	free(self);
}

void ModUnloadRendererChunks_OnReadOnlyBackgroundThread(ModUnloadRendererChunks *self, Game const *game_, float dt)
{
	int px;
	int py;
	int pz;
	int chunksxy;
	int chunksz;
	int startx;
	int endx;
	int starty;
	int endy;
	int startz;
	int endz;
	int mapsizexchunks_;
	int mapsizeychunks_;
	int mapsizezchunks_;
	int count;
	self->game = game_;
	self->chunksize = 16;
	self->mapsizexchunks = self->game->map->mapSizeX / self->chunksize;
	self->mapsizeychunks = self->game->map->mapSizeY / self->chunksize;
	self->mapsizezchunks = self->game->map->mapSizeZ / self->chunksize;
	px = self->game->platform->vtbl->floatToInt(self->game->platform, self->game->player->position->x) / self->chunksize;
	py = self->game->platform->vtbl->floatToInt(self->game->platform, self->game->player->position->z) / self->chunksize;
	pz = self->game->platform->vtbl->floatToInt(self->game->platform, self->game->player->position->y) / self->chunksize;
	chunksxy = ModUnloadRendererChunks_mapAreaSize(self) / self->chunksize / 2;
	chunksz = ModUnloadRendererChunks_mapAreaSizeZ(self) / self->chunksize / 2;
	startx = px - chunksxy;
	endx = px + chunksxy;
	starty = py - chunksxy;
	endy = py + chunksxy;
	startz = pz - chunksz;
	endz = pz + chunksz;
	if (startx < 0) {
		startx = 0;
	}
	if (starty < 0) {
		starty = 0;
	}
	if (startz < 0) {
		startz = 0;
	}
	if (endx >= self->mapsizexchunks) {
		endx = self->mapsizexchunks - 1;
	}
	if (endy >= self->mapsizeychunks) {
		endy = self->mapsizeychunks - 1;
	}
	if (endz >= self->mapsizezchunks) {
		endz = self->mapsizezchunks - 1;
	}
	mapsizexchunks_ = self->mapsizexchunks;
	mapsizeychunks_ = self->mapsizeychunks;
	mapsizezchunks_ = self->mapsizezchunks;
	if (self->game->platform->vtbl->isFastSystem(self->game->platform)) {
		count = 1000;
	}
	else {
		count = 250;
	}
	{
		int i;
		for (i = 0; i < count; i++) {
			int x;
			int y;
			int z;
			int pos;
			cibool unloaded;
			Chunk const *c;
			self->unloadIterationXy++;
			if (self->unloadIterationXy >= mapsizexchunks_ * mapsizeychunks_ * mapsizezchunks_) {
				self->unloadIterationXy = 0;
			}
			MapUtilCi_PosInt(self->unloadIterationXy, mapsizexchunks_, mapsizeychunks_, self->unloadxyztemp);
			x = self->unloadxyztemp->x;
			y = self->unloadxyztemp->y;
			z = self->unloadxyztemp->z;
			pos = MapUtilCi_Index3d(x, y, z, mapsizexchunks_, mapsizeychunks_);
			unloaded = FALSE;
			c = self->game->map->chunks[pos];
			if (c == NULL || c->rendered == NULL || c->rendered->ids == NULL) {
				continue;
			}
			if (x < startx || y < starty || z < startz || x > endx || y > endy || z > endz) {
				int unloadChunkPos = pos;
				UnloadRendererChunksCommit *commit = UnloadRendererChunksCommit_New();
				commit->game = self->game;
				commit->unloadChunkPos = unloadChunkPos;
				Game_QueueActionCommit(self->game, &commit->base);
			}
			unloaded = TRUE;
			if (unloaded) {
				break;
			}
		}
	}
}

static int ModUnloadRendererChunks_mapAreaSize(ModUnloadRendererChunks const *self)
{
	return self->game->platform->vtbl->floatToInt(self->game->platform, self->game->d_Config3d->viewdistance) * 2;
}

static int ModUnloadRendererChunks_mapAreaSizeZ(ModUnloadRendererChunks const *self)
{
	return ModUnloadRendererChunks_mapAreaSize(self);
}

static void ModUpdateMain_Construct(ModUpdateMain *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModUpdateMain;
	ClientMod_Construct(&self->base, vtbl);
}

ModUpdateMain *ModUpdateMain_New(void)
{
	ModUpdateMain *self = (ModUpdateMain *) malloc(sizeof(ModUpdateMain));
	if (self != NULL)
		ModUpdateMain_Construct(self, NULL);
	return self;
}

void ModUpdateMain_Delete(ModUpdateMain *self)
{
	free(self);
}

void ModUpdateMain_OnReadOnlyMainThread(ModUpdateMain const *self, Game const *game, float dt)
{
	Game_Update(game, dt);
}

static void ModWalkSound_Construct(ModWalkSound *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ModWalkSound;
	ClientMod_Construct(&self->base, vtbl);
	self->one = 1;
	self->walksoundtimer = 0;
	self->lastwalksound = 0;
	self->stepsoundduration = self->one * 4 / 10;
}

ModWalkSound *ModWalkSound_New(void)
{
	ModWalkSound *self = (ModWalkSound *) malloc(sizeof(ModWalkSound));
	if (self != NULL)
		ModWalkSound_Construct(self, NULL);
	return self;
}

void ModWalkSound_Delete(ModWalkSound *self)
{
	free(self);
}

static int ModWalkSound_GetSoundCount(ModWalkSound const *self, const char *const *soundwalk)
{
	int count = 0;
	{
		int i;
		for (i = 0; i < 8; i++) {
			if (soundwalk[i] != NULL) {
				count++;
			}
		}
	}
	return count;
}

void ModWalkSound_OnNewFrameFixed(ModWalkSound *self, Game const *game, NewFrameEventArgs const *args)
{
	if (Game_FollowId(game) == NULL) {
		if (game->soundnow->value) {
			ModWalkSound_UpdateWalkSound(self, game, -1);
		}
		if ((game->isplayeronground && game->controls->movedx != 0) || game->controls->movedy != 0) {
			ModWalkSound_UpdateWalkSound(self, game, NewFrameEventArgs_GetDt(args));
		}
	}
}

static void ModWalkSound_UpdateWalkSound(ModWalkSound *self, Game const *game, float dt)
{
	const char *const *soundwalk;
	if (dt == -1) {
		dt = self->stepsoundduration / 2;
	}
	self->walksoundtimer += dt;
	soundwalk = ModWalkSound_soundwalkcurrent(self, game);
	if (ModWalkSound_GetSoundCount(self, soundwalk) == 0) {
		return;
	}
	if (self->walksoundtimer >= self->stepsoundduration) {
		self->walksoundtimer = 0;
		self->lastwalksound++;
		if (self->lastwalksound >= ModWalkSound_GetSoundCount(self, soundwalk)) {
			self->lastwalksound = 0;
		}
		if (game->rnd->vtbl->next(game->rnd) % 100 < 40) {
			self->lastwalksound = game->rnd->vtbl->next(game->rnd) % ModWalkSound_GetSoundCount(self, soundwalk);
		}
		Game_AudioPlay(game, soundwalk[self->lastwalksound]);
	}
}

static const char *const *ModWalkSound_soundwalkcurrent(ModWalkSound const *self, Game const *game)
{
	int b = Game_BlockUnderPlayer(game);
	if (b != -1) {
		return GameData_WalkSound(game->d_Data)[b];
	}
	return GameData_WalkSound(game->d_Data)[0];
}

ModelData *ModelData_New(void)
{
	ModelData *self = (ModelData *) malloc(sizeof(ModelData));
	return self;
}

void ModelData_Delete(ModelData *self)
{
	free(self);
}

int ModelData_GetIndicesCount(ModelData const *self)
{
	return self->indicesCount;
}

int ModelData_GetRgbaCount(ModelData const *self)
{
	return self->verticesCount * 4;
}

int ModelData_GetUvCount(ModelData const *self)
{
	return self->verticesCount * 2;
}

int ModelData_GetVerticesCount(ModelData const *self)
{
	return self->verticesCount;
}

int ModelData_GetXyzCount(ModelData const *self)
{
	return self->verticesCount * 3;
}

void ModelData_SetIndicesCount(ModelData *self, int value)
{
	self->indicesCount = value;
}

void ModelData_SetVerticesCount(ModelData *self, int value)
{
	self->verticesCount = value;
}

int const *ModelData_getIndices(ModelData const *self)
{
	return self->indices;
}

int ModelData_getMode(ModelData const *self)
{
	return self->mode;
}

unsigned char const *ModelData_getRgba(ModelData const *self)
{
	return self->rgba;
}

float const *ModelData_getUv(ModelData const *self)
{
	return self->uv;
}

float const *ModelData_getXyz(ModelData const *self)
{
	return self->xyz;
}

void ModelData_setIndices(ModelData *self, int *p)
{
	self->indices = p;
}

void ModelData_setMode(ModelData *self, int p)
{
	self->mode = p;
}

void ModelData_setRgba(ModelData *self, unsigned char *p)
{
	self->rgba = p;
}

void ModelData_setUv(ModelData *self, float *p)
{
	self->uv = p;
}

void ModelData_setXyz(ModelData *self, float *p)
{
	self->xyz = p;
}

static void ModelDataTool_AddIndex(ModelData *model, int index)
{
	if (model->indicesCount >= model->indicesMax) {
		int indicesCount = model->indicesCount;
		int *indices = (int *) malloc(indicesCount * 2 * sizeof(int ));
		{
			int i;
			for (i = 0; i < indicesCount; i++) {
				indices[i] = model->indices[i];
			}
		}
		model->indices = indices;
		model->indicesMax = model->indicesMax * 2;
	}
	model->indices[model->indicesCount++] = index;
}

void ModelDataTool_AddVertex(ModelData *model, float x, float y, float z, float u, float v, int color)
{
	if (model->verticesCount >= model->verticesMax) {
		int xyzCount = ModelData_GetXyzCount(model);
		float *xyz = (float *) malloc(xyzCount * 2 * sizeof(float ));
		int uvCount;
		float *uv;
		int rgbaCount;
		unsigned char *rgba;
		{
			int i;
			for (i = 0; i < xyzCount; i++) {
				xyz[i] = model->xyz[i];
			}
		}
		uvCount = ModelData_GetUvCount(model);
		uv = (float *) malloc(uvCount * 2 * sizeof(float ));
		{
			int i;
			for (i = 0; i < uvCount; i++) {
				uv[i] = model->uv[i];
			}
		}
		rgbaCount = ModelData_GetRgbaCount(model);
		rgba = (unsigned char *) malloc(rgbaCount * 2 * sizeof(unsigned char ));
		{
			int i;
			for (i = 0; i < rgbaCount; i++) {
				rgba[i] = model->rgba[i];
			}
		}
		model->xyz = xyz;
		model->uv = uv;
		model->rgba = rgba;
		model->verticesMax = model->verticesMax * 2;
	}
	model->xyz[ModelData_GetXyzCount(model) + 0] = x;
	model->xyz[ModelData_GetXyzCount(model) + 1] = y;
	model->xyz[ModelData_GetXyzCount(model) + 2] = z;
	model->uv[ModelData_GetUvCount(model) + 0] = u;
	model->uv[ModelData_GetUvCount(model) + 1] = v;
	model->rgba[ModelData_GetRgbaCount(model) + 0] = Game_IntToByte(Game_ColorR(color));
	model->rgba[ModelData_GetRgbaCount(model) + 1] = Game_IntToByte(Game_ColorG(color));
	model->rgba[ModelData_GetRgbaCount(model) + 2] = Game_IntToByte(Game_ColorB(color));
	model->rgba[ModelData_GetRgbaCount(model) + 3] = Game_IntToByte(Game_ColorA(color));
	model->verticesCount++;
}

MouseEventArgs *MouseEventArgs_New(void)
{
	MouseEventArgs *self = (MouseEventArgs *) malloc(sizeof(MouseEventArgs));
	return self;
}

void MouseEventArgs_Delete(MouseEventArgs *self)
{
	free(self);
}

int MouseEventArgs_GetButton(MouseEventArgs const *self)
{
	return self->button;
}

cibool MouseEventArgs_GetEmulated(MouseEventArgs const *self)
{
	return self->emulated;
}

cibool MouseEventArgs_GetForceUsage(MouseEventArgs const *self)
{
	return self->forceUsage;
}

cibool MouseEventArgs_GetHandled(MouseEventArgs const *self)
{
	return self->handled;
}

int MouseEventArgs_GetMovementX(MouseEventArgs const *self)
{
	return self->movementX;
}

int MouseEventArgs_GetMovementY(MouseEventArgs const *self)
{
	return self->movementY;
}

int MouseEventArgs_GetX(MouseEventArgs const *self)
{
	return self->x;
}

int MouseEventArgs_GetY(MouseEventArgs const *self)
{
	return self->y;
}

void MouseEventArgs_SetButton(MouseEventArgs *self, int value)
{
	self->button = value;
}

void MouseEventArgs_SetEmulated(MouseEventArgs *self, cibool value)
{
	self->emulated = value;
}

void MouseEventArgs_SetForceUsage(MouseEventArgs *self, cibool value)
{
	self->forceUsage = value;
}

void MouseEventArgs_SetHandled(MouseEventArgs *self, cibool value)
{
	self->handled = value;
}

void MouseEventArgs_SetMovementX(MouseEventArgs *self, int value)
{
	self->movementX = value;
}

void MouseEventArgs_SetMovementY(MouseEventArgs *self, int value)
{
	self->movementY = value;
}

void MouseEventArgs_SetX(MouseEventArgs *self, int value)
{
	self->x = value;
}

void MouseEventArgs_SetY(MouseEventArgs *self, int value)
{
	self->y = value;
}

static void MouseEventHandler_Construct(MouseEventHandler *self, const MouseEventHandlerVtbl *vtbl)
{
	self->vtbl = vtbl;
}

MouseWheelEventArgs *MouseWheelEventArgs_New(void)
{
	MouseWheelEventArgs *self = (MouseWheelEventArgs *) malloc(sizeof(MouseWheelEventArgs));
	return self;
}

void MouseWheelEventArgs_Delete(MouseWheelEventArgs *self)
{
	free(self);
}

int MouseWheelEventArgs_GetDelta(MouseWheelEventArgs const *self)
{
	return self->delta;
}

float MouseWheelEventArgs_GetDeltaPrecise(MouseWheelEventArgs const *self)
{
	return self->deltaPrecise;
}

void MouseWheelEventArgs_SetDelta(MouseWheelEventArgs *self, int value)
{
	self->delta = value;
}

void MouseWheelEventArgs_SetDeltaPrecise(MouseWheelEventArgs *self, float value)
{
	self->deltaPrecise = value;
}

static void NetClient_Construct(NetClient *self, const NetClientVtbl *vtbl)
{
	self->vtbl = vtbl;
}

static void NetConnection_Construct(NetConnection *self, const NetConnectionVtbl *vtbl)
{
	self->vtbl = vtbl;
}

NetIncomingMessage *NetIncomingMessage_New(void)
{
	NetIncomingMessage *self = (NetIncomingMessage *) malloc(sizeof(NetIncomingMessage));
	return self;
}

void NetIncomingMessage_Delete(NetIncomingMessage *self)
{
	free(self);
}

static void NetServer_Construct(NetServer *self, const NetServerVtbl *vtbl)
{
	self->vtbl = vtbl;
}

static void NetworkInterpolation_Construct(NetworkInterpolation *self, const INetworkInterpolationVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_NetworkInterpolation;
	INetworkInterpolation_Construct(&self->base, vtbl);
	self->received = (Packet_ const **) malloc(128 * sizeof(Packet_ const *));
	self->dELAYMILLISECONDS = 200;
	self->eXTRAPOLATION_TIMEMILLISECONDS = 200;
}

NetworkInterpolation *NetworkInterpolation_New(void)
{
	NetworkInterpolation *self = (NetworkInterpolation *) malloc(sizeof(NetworkInterpolation));
	if (self != NULL)
		NetworkInterpolation_Construct(self, NULL);
	return self;
}

void NetworkInterpolation_Delete(NetworkInterpolation *self)
{
	free(self);
}

void NetworkInterpolation_AddNetworkPacket(NetworkInterpolation *self, InterpolatedObject const *c, int timeMilliseconds)
{
	Packet_ *p = Packet__New();
	int max;
	p->content = c;
	p->timestampMilliseconds = timeMilliseconds;
	max = 100;
	if (self->receivedCount >= max) {
		{
			int i;
			for (i = 0; i < max - 1; i++) {
				self->received[i] = self->received[i + 1];
			}
		}
		self->receivedCount = max - 1;
	}
	self->received[self->receivedCount++] = p;
}

InterpolatedObject const *NetworkInterpolation_InterpolatedState(NetworkInterpolation const *self, int timeMilliseconds)
{
	int curtimeMilliseconds = timeMilliseconds;
	int interpolationtimeMilliseconds = curtimeMilliseconds - self->dELAYMILLISECONDS;
	int p1;
	int p2;
	InterpolatedObject const *result;
	if (self->receivedCount == 0) {
		return NULL;
	}
	if (self->receivedCount > 0 && interpolationtimeMilliseconds < self->received[0]->timestampMilliseconds) {
		p1 = 0;
		p2 = 0;
	}
	else if (self->eXTRAPOLATE && self->receivedCount >= 2 && interpolationtimeMilliseconds > self->received[self->receivedCount - 1]->timestampMilliseconds) {
		p1 = self->receivedCount - 2;
		p2 = self->receivedCount - 1;
		interpolationtimeMilliseconds = MathCi_MinInt(interpolationtimeMilliseconds, self->received[self->receivedCount - 1]->timestampMilliseconds + self->eXTRAPOLATION_TIMEMILLISECONDS);
	}
	else {
		p1 = 0;
		{
			int i;
			for (i = 0; i < self->receivedCount; i++) {
				if (self->received[i]->timestampMilliseconds <= interpolationtimeMilliseconds) {
					p1 = i;
				}
			}
		}
		p2 = p1;
		if (self->receivedCount - 1 > p1) {
			p2++;
		}
	}
	if (p1 == p2) {
		result = self->received[p1]->content;
	}
	else {
		float one = 1;
		result = self->req->vtbl->interpolate(self->req, self->received[p1]->content, self->received[p2]->content, one * (interpolationtimeMilliseconds - self->received[p1]->timestampMilliseconds) / (self->received[p2]->timestampMilliseconds - self->received[p1]->timestampMilliseconds));
	}
	return result;
}

NewFrameEventArgs *NewFrameEventArgs_New(void)
{
	NewFrameEventArgs *self = (NewFrameEventArgs *) malloc(sizeof(NewFrameEventArgs));
	return self;
}

void NewFrameEventArgs_Delete(NewFrameEventArgs *self)
{
	free(self);
}

float NewFrameEventArgs_GetDt(NewFrameEventArgs const *self)
{
	return self->dt;
}

void NewFrameEventArgs_SetDt(NewFrameEventArgs *self, float p)
{
	self->dt = p;
}

static void NewFrameHandler_Construct(NewFrameHandler *self, const NewFrameHandlerVtbl *vtbl)
{
	self->vtbl = vtbl;
}

Node *Node_New(void)
{
	Node *self = (Node *) malloc(sizeof(Node));
	return self;
}

void Node_Delete(Node *self)
{
	free(self);
}

static void NotifyMapAction_Construct(NotifyMapAction *self, const Action_Vtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_NotifyMapAction;
	Action__Construct(&self->base, vtbl);
}

static NotifyMapAction *NotifyMapAction_New(void)
{
	NotifyMapAction *self = (NotifyMapAction *) malloc(sizeof(NotifyMapAction));
	if (self != NULL)
		NotifyMapAction_Construct(self, NULL);
	return self;
}

static void NotifyMapAction_LoadAndSendChunk(NotifyMapAction const *self, int x, int y, int z)
{
	ClientSimple const *c = self->server->clients[self->clientId];
	int pos = MapUtilCi_Index2d(x, y, self->server->mapSizeX / 32);
	int const *chunk;
	unsigned char const *chunkBytes;
	IntRef const *compressedLength;
	unsigned char const *chunkCompressed;
	if (c->chunksseen[pos] == NULL) {
		c->chunksseen[pos] = (cibool *) malloc(self->server->mapSizeZ / 32 * sizeof(cibool ));
	}
	c->chunksseen[pos][z] = TRUE;
	chunk = (int *) malloc(32768 * sizeof(int ));
	{
		int i;
		for (i = 0; i < self->server->modsCount; i++) {
			self->server->mods[i]->vtbl->generateChunk(self->server->mods[i], x, y, z, chunk);
		}
	}
	chunkBytes = MiscCi_UshortArrayToByteArray(chunk, 32768);
	compressedLength = IntRef_New();
	chunkCompressed = self->server->platform->vtbl->gzipCompress(self->server->platform, chunkBytes, 65536, compressedLength);
	ServerSimple_QueueMainThreadAction(self->server, &SendPacketAction_Create(self->server, self->clientId, ServerPackets_ChunkPart(chunkCompressed))->base);
	ServerSimple_QueueMainThreadAction(self->server, &SendPacketAction_Create(self->server, self->clientId, ServerPackets_Chunk_(x * 32, y * 32, z * 32, 32))->base);
}

static void NotifyMapAction_NearestDirty(NotifyMapAction const *self, int clientid, int playerx, int playery, int playerz, int *retNearest)
{
	int nearestdist = 2147483647;
	int px;
	int py;
	int pz;
	int chunksxy;
	int chunksz;
	int startx;
	int endx;
	int starty;
	int endy;
	int startz;
	int endz;
	ClientSimple const *client;
	retNearest[0] = -1;
	retNearest[1] = -1;
	retNearest[2] = -1;
	px = playerx / 32;
	py = playery / 32;
	pz = playerz / 32;
	chunksxy = NotifyMapAction_mapAreaSize(self) / 32 / 2;
	chunksz = NotifyMapAction_mapAreaSizeZ(self) / 32 / 2;
	startx = px - chunksxy;
	endx = px + chunksxy;
	starty = py - chunksxy;
	endy = py + chunksxy;
	startz = pz - chunksz;
	endz = pz + chunksz;
	if (startx < 0) {
		startx = 0;
	}
	if (starty < 0) {
		starty = 0;
	}
	if (startz < 0) {
		startz = 0;
	}
	if (endx >= NotifyMapAction_mapsizexchunks(self)) {
		endx = NotifyMapAction_mapsizexchunks(self) - 1;
	}
	if (endy >= NotifyMapAction_mapsizeychunks(self)) {
		endy = NotifyMapAction_mapsizeychunks(self) - 1;
	}
	if (endz >= NotifyMapAction_mapsizezchunks(self)) {
		endz = NotifyMapAction_mapsizezchunks(self) - 1;
	}
	client = self->server->clients[clientid];
	{
		int x;
		for (x = startx; x <= endx; x++) {
			{
				int y;
				for (y = starty; y <= endy; y++) {
					int pos = MapUtilCi_Index2d(x, y, self->server->mapSizeX / 32);
					if (client->chunksseen[pos] == NULL) {
						client->chunksseen[pos] = (cibool *) malloc(self->server->mapSizeZ / 32 * sizeof(cibool ));
					}
					{
						int z;
						for (z = startz; z <= endz; z++) {
							cibool const *column = client->chunksseen[pos];
							if (column[z]) {
								continue;
							}
							{
								int dx = px - x;
								int dy = py - y;
								int dz = pz - z;
								int dist = dx * dx + dy * dy + dz * dz;
								if (dist < nearestdist) {
									nearestdist = dist;
									retNearest[0] = x;
									retNearest[1] = y;
									retNearest[2] = z;
								}
							}
						}
					}
				}
			}
		}
	}
}

void NotifyMapAction_Run(NotifyMapAction const *self)
{
	int *nearest = (int *) malloc(3 * sizeof(int ));
	ClientSimple const *client = self->server->clients[self->clientId];
	int x = self->server->platform->vtbl->floatToInt(self->server->platform, client->glX);
	int y = self->server->platform->vtbl->floatToInt(self->server->platform, client->glZ);
	int z = self->server->platform->vtbl->floatToInt(self->server->platform, client->glY);
	NotifyMapAction_NearestDirty(self, self->clientId, x, y, z, nearest);
	if (nearest[0] != -1) {
		NotifyMapAction_LoadAndSendChunk(self, nearest[0], nearest[1], nearest[2]);
	}
	self->server->clients[self->clientId]->notifyMapAction = NULL;
}

static int NotifyMapAction_mapAreaSize(NotifyMapAction const *self)
{
	return self->server->chunkdrawdistance * 32 * 2;
}

static int NotifyMapAction_mapAreaSizeZ(NotifyMapAction const *self)
{
	return NotifyMapAction_mapAreaSize(self);
}

static int NotifyMapAction_mapsizexchunks(NotifyMapAction const *self)
{
	return self->server->mapSizeX / 32;
}

static int NotifyMapAction_mapsizeychunks(NotifyMapAction const *self)
{
	return self->server->mapSizeY / 32;
}

static int NotifyMapAction_mapsizezchunks(NotifyMapAction const *self)
{
	return self->server->mapSizeZ / 32;
}

static void OnCrashHandler_Construct(OnCrashHandler *self, const OnCrashHandlerVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_OnCrashHandler;
	self->vtbl = vtbl;
}

OnCrashHandler *OnCrashHandler_New(void)
{
	OnCrashHandler *self = (OnCrashHandler *) malloc(sizeof(OnCrashHandler));
	if (self != NULL)
		OnCrashHandler_Construct(self, NULL);
	return self;
}

void OnCrashHandler_Delete(OnCrashHandler *self)
{
	free(self);
}

void OnCrashHandler_OnCrash(OnCrashHandler const *self)
{
}

static void OnCrashHandlerLeave_Construct(OnCrashHandlerLeave *self, const OnCrashHandlerVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_OnCrashHandlerLeave;
	OnCrashHandler_Construct(&self->base, vtbl);
}

OnCrashHandlerLeave *OnCrashHandlerLeave_New(void)
{
	OnCrashHandlerLeave *self = (OnCrashHandlerLeave *) malloc(sizeof(OnCrashHandlerLeave));
	if (self != NULL)
		OnCrashHandlerLeave_Construct(self, NULL);
	return self;
}

void OnCrashHandlerLeave_Delete(OnCrashHandlerLeave *self)
{
	free(self);
}

OnCrashHandlerLeave const *OnCrashHandlerLeave_Create(Game const *game)
{
	OnCrashHandlerLeave *oncrash = OnCrashHandlerLeave_New();
	oncrash->g = game;
	return oncrash;
}

void OnCrashHandlerLeave_OnCrash(OnCrashHandlerLeave const *self)
{
	Game_SendLeave(self->g, 1);
}

OnUseEntityArgs *OnUseEntityArgs_New(void)
{
	OnUseEntityArgs *self = (OnUseEntityArgs *) malloc(sizeof(OnUseEntityArgs));
	return self;
}

void OnUseEntityArgs_Delete(OnUseEntityArgs *self)
{
	free(self);
}

static void OptionsCi_Construct(OptionsCi *self)
{
	float one = 1;
	self->shadows = FALSE;
	self->font = 0;
	self->drawDistance = 32;
	self->useServerTextures = TRUE;
	self->enableSound = TRUE;
	self->enableAutoJump = FALSE;
	self->clientLanguage = "";
	self->framerate = 0;
	self->resolution = 0;
	self->fullscreen = FALSE;
	self->smoothshadows = TRUE;
	self->blockShadowSave = one * 6 / 10;
	self->enableBlockShadow = TRUE;
	self->keys = (int *) malloc(256 * sizeof(int ));
}

OptionsCi *OptionsCi_New(void)
{
	OptionsCi *self = (OptionsCi *) malloc(sizeof(OptionsCi));
	if (self != NULL)
		OptionsCi_Construct(self);
	return self;
}

void OptionsCi_Delete(OptionsCi *self)
{
	free(self);
}

static void PacketHandlerCraftingRecipes_Construct(PacketHandlerCraftingRecipes *self, const ClientPacketHandlerVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_PacketHandlerCraftingRecipes;
	ClientPacketHandler_Construct(&self->base, vtbl);
}

PacketHandlerCraftingRecipes *PacketHandlerCraftingRecipes_New(void)
{
	PacketHandlerCraftingRecipes *self = (PacketHandlerCraftingRecipes *) malloc(sizeof(PacketHandlerCraftingRecipes));
	if (self != NULL)
		PacketHandlerCraftingRecipes_Construct(self, NULL);
	return self;
}

void PacketHandlerCraftingRecipes_Delete(PacketHandlerCraftingRecipes *self)
{
	free(self);
}

void PacketHandlerCraftingRecipes_Handle(PacketHandlerCraftingRecipes const *self, Game const *game, Packet_Server const *packet)
{
	self->mod->d_CraftingRecipes = packet->craftingRecipes->craftingRecipes;
	self->mod->d_CraftingRecipesCount = packet->craftingRecipes->craftingRecipesCount;
}

Packet_ *Packet__New(void)
{
	Packet_ *self = (Packet_ *) malloc(sizeof(Packet_));
	return self;
}

void Packet__Delete(Packet_ *self)
{
	free(self);
}

Packet_BlockType *Packet_BlockType_New(void)
{
	Packet_BlockType *self = (Packet_BlockType *) malloc(sizeof(Packet_BlockType));
	return self;
}

void Packet_BlockType_Delete(Packet_BlockType *self)
{
	free(self);
}

int Packet_BlockType_GetAimRadiusFloat(Packet_BlockType const *self)
{
	return self->aimRadiusFloat;
}

int Packet_BlockType_GetAmmoMagazine(Packet_BlockType const *self)
{
	return self->ammoMagazine;
}

int Packet_BlockType_GetAmmoTotal(Packet_BlockType const *self)
{
	return self->ammoTotal;
}

int Packet_BlockType_GetBulletsPerShotFloat(Packet_BlockType const *self)
{
	return self->bulletsPerShotFloat;
}

int Packet_BlockType_GetDamageBodyFloat(Packet_BlockType const *self)
{
	return self->damageBodyFloat;
}

int Packet_BlockType_GetDamageHeadFloat(Packet_BlockType const *self)
{
	return self->damageHeadFloat;
}

int Packet_BlockType_GetDamageToPlayer(Packet_BlockType const *self)
{
	return self->damageToPlayer;
}

int Packet_BlockType_GetDelayFloat(Packet_BlockType const *self)
{
	return self->delayFloat;
}

int Packet_BlockType_GetDrawType(Packet_BlockType const *self)
{
	return self->drawType;
}

int Packet_BlockType_GetExplosionRangeFloat(Packet_BlockType const *self)
{
	return self->explosionRangeFloat;
}

int Packet_BlockType_GetExplosionTimeFloat(Packet_BlockType const *self)
{
	return self->explosionTimeFloat;
}

const char *Packet_BlockType_GetHandimage(Packet_BlockType const *self)
{
	return self->handimage;
}

int Packet_BlockType_GetIronSightsAimRadiusFloat(Packet_BlockType const *self)
{
	return self->ironSightsAimRadiusFloat;
}

cibool Packet_BlockType_GetIronSightsEnabled(Packet_BlockType const *self)
{
	return self->ironSightsEnabled;
}

int Packet_BlockType_GetIronSightsFovFloat(Packet_BlockType const *self)
{
	return self->ironSightsFovFloat;
}

const char *Packet_BlockType_GetIronSightsImage(Packet_BlockType const *self)
{
	return self->ironSightsImage;
}

int Packet_BlockType_GetIronSightsMoveSpeedFloat(Packet_BlockType const *self)
{
	return self->ironSightsMoveSpeedFloat;
}

cibool Packet_BlockType_GetIsBuildable(Packet_BlockType const *self)
{
	return self->isBuildable;
}

cibool Packet_BlockType_GetIsPistol(Packet_BlockType const *self)
{
	return self->isPistol;
}

cibool Packet_BlockType_GetIsSlipperyWalk(Packet_BlockType const *self)
{
	return self->isSlipperyWalk;
}

cibool Packet_BlockType_GetIsTool(Packet_BlockType const *self)
{
	return self->isTool;
}

cibool Packet_BlockType_GetIsUsable(Packet_BlockType const *self)
{
	return self->isUsable;
}

int Packet_BlockType_GetLightRadius(Packet_BlockType const *self)
{
	return self->lightRadius;
}

const char *Packet_BlockType_GetName(Packet_BlockType const *self)
{
	return self->name;
}

int Packet_BlockType_GetPickDistanceWhenUsedFloat(Packet_BlockType const *self)
{
	return self->pickDistanceWhenUsedFloat;
}

int Packet_BlockType_GetPistolType(Packet_BlockType const *self)
{
	return self->pistolType;
}

cibool Packet_BlockType_GetProjectileBounce(Packet_BlockType const *self)
{
	return self->projectileBounce;
}

int Packet_BlockType_GetProjectileSpeedFloat(Packet_BlockType const *self)
{
	return self->projectileSpeedFloat;
}

int Packet_BlockType_GetRail(Packet_BlockType const *self)
{
	return self->rail;
}

int Packet_BlockType_GetRecoilFloat(Packet_BlockType const *self)
{
	return self->recoilFloat;
}

int Packet_BlockType_GetReloadDelayFloat(Packet_BlockType const *self)
{
	return self->reloadDelayFloat;
}

Packet_SoundSet const *Packet_BlockType_GetSounds(Packet_BlockType const *self)
{
	return self->sounds;
}

int Packet_BlockType_GetStartInventoryAmount(Packet_BlockType const *self)
{
	return self->startInventoryAmount;
}

int Packet_BlockType_GetStrength(Packet_BlockType const *self)
{
	return self->strength;
}

const char *Packet_BlockType_GetTextureIdBack(Packet_BlockType const *self)
{
	return self->textureIdBack;
}

const char *Packet_BlockType_GetTextureIdBottom(Packet_BlockType const *self)
{
	return self->textureIdBottom;
}

const char *Packet_BlockType_GetTextureIdForInventory(Packet_BlockType const *self)
{
	return self->textureIdForInventory;
}

const char *Packet_BlockType_GetTextureIdFront(Packet_BlockType const *self)
{
	return self->textureIdFront;
}

const char *Packet_BlockType_GetTextureIdLeft(Packet_BlockType const *self)
{
	return self->textureIdLeft;
}

const char *Packet_BlockType_GetTextureIdRight(Packet_BlockType const *self)
{
	return self->textureIdRight;
}

const char *Packet_BlockType_GetTextureIdTop(Packet_BlockType const *self)
{
	return self->textureIdTop;
}

int Packet_BlockType_GetWalkSpeedFloat(Packet_BlockType const *self)
{
	return self->walkSpeedFloat;
}

int Packet_BlockType_GetWalkSpeedWhenUsedFloat(Packet_BlockType const *self)
{
	return self->walkSpeedWhenUsedFloat;
}

int Packet_BlockType_GetWalkableType(Packet_BlockType const *self)
{
	return self->walkableType;
}

int Packet_BlockType_GetWhenPlacedGetsConvertedTo(Packet_BlockType const *self)
{
	return self->whenPlacedGetsConvertedTo;
}

void Packet_BlockType_SetAimRadiusFloat(Packet_BlockType *self, int value)
{
	self->aimRadiusFloat = value;
}

void Packet_BlockType_SetAmmoMagazine(Packet_BlockType *self, int value)
{
	self->ammoMagazine = value;
}

void Packet_BlockType_SetAmmoTotal(Packet_BlockType *self, int value)
{
	self->ammoTotal = value;
}

void Packet_BlockType_SetBulletsPerShotFloat(Packet_BlockType *self, int value)
{
	self->bulletsPerShotFloat = value;
}

void Packet_BlockType_SetDamageBodyFloat(Packet_BlockType *self, int value)
{
	self->damageBodyFloat = value;
}

void Packet_BlockType_SetDamageHeadFloat(Packet_BlockType *self, int value)
{
	self->damageHeadFloat = value;
}

void Packet_BlockType_SetDamageToPlayer(Packet_BlockType *self, int value)
{
	self->damageToPlayer = value;
}

void Packet_BlockType_SetDelayFloat(Packet_BlockType *self, int value)
{
	self->delayFloat = value;
}

void Packet_BlockType_SetDrawType(Packet_BlockType *self, int value)
{
	self->drawType = value;
}

void Packet_BlockType_SetExplosionRangeFloat(Packet_BlockType *self, int value)
{
	self->explosionRangeFloat = value;
}

void Packet_BlockType_SetExplosionTimeFloat(Packet_BlockType *self, int value)
{
	self->explosionTimeFloat = value;
}

void Packet_BlockType_SetHandimage(Packet_BlockType *self, const char *value)
{
	self->handimage = value;
}

void Packet_BlockType_SetIronSightsAimRadiusFloat(Packet_BlockType *self, int value)
{
	self->ironSightsAimRadiusFloat = value;
}

void Packet_BlockType_SetIronSightsEnabled(Packet_BlockType *self, cibool value)
{
	self->ironSightsEnabled = value;
}

void Packet_BlockType_SetIronSightsFovFloat(Packet_BlockType *self, int value)
{
	self->ironSightsFovFloat = value;
}

void Packet_BlockType_SetIronSightsImage(Packet_BlockType *self, const char *value)
{
	self->ironSightsImage = value;
}

void Packet_BlockType_SetIronSightsMoveSpeedFloat(Packet_BlockType *self, int value)
{
	self->ironSightsMoveSpeedFloat = value;
}

void Packet_BlockType_SetIsBuildable(Packet_BlockType *self, cibool value)
{
	self->isBuildable = value;
}

void Packet_BlockType_SetIsPistol(Packet_BlockType *self, cibool value)
{
	self->isPistol = value;
}

void Packet_BlockType_SetIsSlipperyWalk(Packet_BlockType *self, cibool value)
{
	self->isSlipperyWalk = value;
}

void Packet_BlockType_SetIsTool(Packet_BlockType *self, cibool value)
{
	self->isTool = value;
}

void Packet_BlockType_SetIsUsable(Packet_BlockType *self, cibool value)
{
	self->isUsable = value;
}

void Packet_BlockType_SetLightRadius(Packet_BlockType *self, int value)
{
	self->lightRadius = value;
}

void Packet_BlockType_SetName(Packet_BlockType *self, const char *value)
{
	self->name = value;
}

void Packet_BlockType_SetPickDistanceWhenUsedFloat(Packet_BlockType *self, int value)
{
	self->pickDistanceWhenUsedFloat = value;
}

void Packet_BlockType_SetPistolType(Packet_BlockType *self, int value)
{
	self->pistolType = value;
}

void Packet_BlockType_SetProjectileBounce(Packet_BlockType *self, cibool value)
{
	self->projectileBounce = value;
}

void Packet_BlockType_SetProjectileSpeedFloat(Packet_BlockType *self, int value)
{
	self->projectileSpeedFloat = value;
}

void Packet_BlockType_SetRail(Packet_BlockType *self, int value)
{
	self->rail = value;
}

void Packet_BlockType_SetRecoilFloat(Packet_BlockType *self, int value)
{
	self->recoilFloat = value;
}

void Packet_BlockType_SetReloadDelayFloat(Packet_BlockType *self, int value)
{
	self->reloadDelayFloat = value;
}

void Packet_BlockType_SetSounds(Packet_BlockType *self, Packet_SoundSet *value)
{
	self->sounds = value;
}

void Packet_BlockType_SetStartInventoryAmount(Packet_BlockType *self, int value)
{
	self->startInventoryAmount = value;
}

void Packet_BlockType_SetStrength(Packet_BlockType *self, int value)
{
	self->strength = value;
}

void Packet_BlockType_SetTextureIdBack(Packet_BlockType *self, const char *value)
{
	self->textureIdBack = value;
}

void Packet_BlockType_SetTextureIdBottom(Packet_BlockType *self, const char *value)
{
	self->textureIdBottom = value;
}

void Packet_BlockType_SetTextureIdForInventory(Packet_BlockType *self, const char *value)
{
	self->textureIdForInventory = value;
}

void Packet_BlockType_SetTextureIdFront(Packet_BlockType *self, const char *value)
{
	self->textureIdFront = value;
}

void Packet_BlockType_SetTextureIdLeft(Packet_BlockType *self, const char *value)
{
	self->textureIdLeft = value;
}

void Packet_BlockType_SetTextureIdRight(Packet_BlockType *self, const char *value)
{
	self->textureIdRight = value;
}

void Packet_BlockType_SetTextureIdTop(Packet_BlockType *self, const char *value)
{
	self->textureIdTop = value;
}

void Packet_BlockType_SetWalkSpeedFloat(Packet_BlockType *self, int value)
{
	self->walkSpeedFloat = value;
}

void Packet_BlockType_SetWalkSpeedWhenUsedFloat(Packet_BlockType *self, int value)
{
	self->walkSpeedWhenUsedFloat = value;
}

void Packet_BlockType_SetWalkableType(Packet_BlockType *self, int value)
{
	self->walkableType = value;
}

void Packet_BlockType_SetWhenPlacedGetsConvertedTo(Packet_BlockType *self, int value)
{
	self->whenPlacedGetsConvertedTo = value;
}

Packet_BlockType const *Packet_BlockTypeSerializer_Deserialize(CitoStream const *stream, Packet_BlockType *instance)
{
	instance->drawType = 0;
	instance->walkableType = 0;
	instance->pistolType = 0;
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance->textureIdTop = ProtocolParser_ReadString(stream);
			continue;
		case 18:
			instance->textureIdBottom = ProtocolParser_ReadString(stream);
			continue;
		case 26:
			instance->textureIdFront = ProtocolParser_ReadString(stream);
			continue;
		case 34:
			instance->textureIdBack = ProtocolParser_ReadString(stream);
			continue;
		case 42:
			instance->textureIdLeft = ProtocolParser_ReadString(stream);
			continue;
		case 50:
			instance->textureIdRight = ProtocolParser_ReadString(stream);
			continue;
		case 58:
			instance->textureIdForInventory = ProtocolParser_ReadString(stream);
			continue;
		case 64:
			instance->drawType = ProtocolParser_ReadUInt64(stream);
			continue;
		case 72:
			instance->walkableType = ProtocolParser_ReadUInt64(stream);
			continue;
		case 80:
			instance->rail = ProtocolParser_ReadUInt64(stream);
			continue;
		case 88:
			instance->walkSpeedFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 96:
			instance->isSlipperyWalk = ProtocolParser_ReadBool(stream);
			continue;
		case 106:
			if (instance->sounds == NULL)
				instance->sounds = Packet_SoundSetSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_SoundSetSerializer_DeserializeLengthDelimited(stream, instance->sounds);
			continue;
		case 112:
			instance->lightRadius = ProtocolParser_ReadUInt64(stream);
			continue;
		case 120:
			instance->startInventoryAmount = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		case 16:
			if (Key_GetWireType(key) != 0)
				break;
			instance->strength = ProtocolParser_ReadUInt64(stream);
			continue;
		case 17:
			if (Key_GetWireType(key) != 2)
				break;
			instance->name = ProtocolParser_ReadString(stream);
			continue;
		case 18:
			if (Key_GetWireType(key) != 0)
				break;
			instance->isBuildable = ProtocolParser_ReadBool(stream);
			continue;
		case 19:
			if (Key_GetWireType(key) != 0)
				break;
			instance->isUsable = ProtocolParser_ReadBool(stream);
			continue;
		case 20:
			if (Key_GetWireType(key) != 0)
				break;
			instance->isTool = ProtocolParser_ReadBool(stream);
			continue;
		case 21:
			if (Key_GetWireType(key) != 2)
				break;
			instance->handimage = ProtocolParser_ReadString(stream);
			continue;
		case 22:
			if (Key_GetWireType(key) != 0)
				break;
			instance->isPistol = ProtocolParser_ReadBool(stream);
			continue;
		case 23:
			if (Key_GetWireType(key) != 0)
				break;
			instance->aimRadiusFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			if (Key_GetWireType(key) != 0)
				break;
			instance->recoilFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 25:
			if (Key_GetWireType(key) != 0)
				break;
			instance->delayFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 26:
			if (Key_GetWireType(key) != 0)
				break;
			instance->bulletsPerShotFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 27:
			if (Key_GetWireType(key) != 0)
				break;
			instance->walkSpeedWhenUsedFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 28:
			if (Key_GetWireType(key) != 0)
				break;
			instance->ironSightsEnabled = ProtocolParser_ReadBool(stream);
			continue;
		case 29:
			if (Key_GetWireType(key) != 0)
				break;
			instance->ironSightsMoveSpeedFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 30:
			if (Key_GetWireType(key) != 2)
				break;
			instance->ironSightsImage = ProtocolParser_ReadString(stream);
			continue;
		case 31:
			if (Key_GetWireType(key) != 0)
				break;
			instance->ironSightsAimRadiusFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			if (Key_GetWireType(key) != 0)
				break;
			instance->ironSightsFovFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 33:
			if (Key_GetWireType(key) != 0)
				break;
			instance->ammoMagazine = ProtocolParser_ReadUInt64(stream);
			continue;
		case 34:
			if (Key_GetWireType(key) != 0)
				break;
			instance->ammoTotal = ProtocolParser_ReadUInt64(stream);
			continue;
		case 35:
			if (Key_GetWireType(key) != 0)
				break;
			instance->reloadDelayFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 36:
			if (Key_GetWireType(key) != 0)
				break;
			instance->explosionRangeFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 37:
			if (Key_GetWireType(key) != 0)
				break;
			instance->explosionTimeFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 38:
			if (Key_GetWireType(key) != 0)
				break;
			instance->projectileSpeedFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 39:
			if (Key_GetWireType(key) != 0)
				break;
			instance->projectileBounce = ProtocolParser_ReadBool(stream);
			continue;
		case 40:
			if (Key_GetWireType(key) != 0)
				break;
			instance->damageBodyFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 41:
			if (Key_GetWireType(key) != 0)
				break;
			instance->damageHeadFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 42:
			if (Key_GetWireType(key) != 0)
				break;
			instance->pistolType = ProtocolParser_ReadUInt64(stream);
			continue;
		case 43:
			if (Key_GetWireType(key) != 0)
				break;
			instance->damageToPlayer = ProtocolParser_ReadUInt64(stream);
			continue;
		case 44:
			if (Key_GetWireType(key) != 0)
				break;
			instance->whenPlacedGetsConvertedTo = ProtocolParser_ReadUInt64(stream);
			continue;
		case 45:
			if (Key_GetWireType(key) != 0)
				break;
			instance->pickDistanceWhenUsedFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_BlockType const *Packet_BlockTypeSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_BlockType *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_BlockTypeSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_BlockType const *Packet_BlockTypeSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_BlockType *instance)
{
	int limit;
	instance->drawType = 0;
	instance->walkableType = 0;
	instance->pistolType = 0;
	limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->textureIdTop = ProtocolParser_ReadString(stream);
			continue;
		case 18:
			instance->textureIdBottom = ProtocolParser_ReadString(stream);
			continue;
		case 26:
			instance->textureIdFront = ProtocolParser_ReadString(stream);
			continue;
		case 34:
			instance->textureIdBack = ProtocolParser_ReadString(stream);
			continue;
		case 42:
			instance->textureIdLeft = ProtocolParser_ReadString(stream);
			continue;
		case 50:
			instance->textureIdRight = ProtocolParser_ReadString(stream);
			continue;
		case 58:
			instance->textureIdForInventory = ProtocolParser_ReadString(stream);
			continue;
		case 64:
			instance->drawType = ProtocolParser_ReadUInt64(stream);
			continue;
		case 72:
			instance->walkableType = ProtocolParser_ReadUInt64(stream);
			continue;
		case 80:
			instance->rail = ProtocolParser_ReadUInt64(stream);
			continue;
		case 88:
			instance->walkSpeedFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 96:
			instance->isSlipperyWalk = ProtocolParser_ReadBool(stream);
			continue;
		case 106:
			if (instance->sounds == NULL)
				instance->sounds = Packet_SoundSetSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_SoundSetSerializer_DeserializeLengthDelimited(stream, instance->sounds);
			continue;
		case 112:
			instance->lightRadius = ProtocolParser_ReadUInt64(stream);
			continue;
		case 120:
			instance->startInventoryAmount = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		case 16:
			if (Key_GetWireType(key) != 0)
				break;
			instance->strength = ProtocolParser_ReadUInt64(stream);
			continue;
		case 17:
			if (Key_GetWireType(key) != 2)
				break;
			instance->name = ProtocolParser_ReadString(stream);
			continue;
		case 18:
			if (Key_GetWireType(key) != 0)
				break;
			instance->isBuildable = ProtocolParser_ReadBool(stream);
			continue;
		case 19:
			if (Key_GetWireType(key) != 0)
				break;
			instance->isUsable = ProtocolParser_ReadBool(stream);
			continue;
		case 20:
			if (Key_GetWireType(key) != 0)
				break;
			instance->isTool = ProtocolParser_ReadBool(stream);
			continue;
		case 21:
			if (Key_GetWireType(key) != 2)
				break;
			instance->handimage = ProtocolParser_ReadString(stream);
			continue;
		case 22:
			if (Key_GetWireType(key) != 0)
				break;
			instance->isPistol = ProtocolParser_ReadBool(stream);
			continue;
		case 23:
			if (Key_GetWireType(key) != 0)
				break;
			instance->aimRadiusFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			if (Key_GetWireType(key) != 0)
				break;
			instance->recoilFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 25:
			if (Key_GetWireType(key) != 0)
				break;
			instance->delayFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 26:
			if (Key_GetWireType(key) != 0)
				break;
			instance->bulletsPerShotFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 27:
			if (Key_GetWireType(key) != 0)
				break;
			instance->walkSpeedWhenUsedFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 28:
			if (Key_GetWireType(key) != 0)
				break;
			instance->ironSightsEnabled = ProtocolParser_ReadBool(stream);
			continue;
		case 29:
			if (Key_GetWireType(key) != 0)
				break;
			instance->ironSightsMoveSpeedFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 30:
			if (Key_GetWireType(key) != 2)
				break;
			instance->ironSightsImage = ProtocolParser_ReadString(stream);
			continue;
		case 31:
			if (Key_GetWireType(key) != 0)
				break;
			instance->ironSightsAimRadiusFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			if (Key_GetWireType(key) != 0)
				break;
			instance->ironSightsFovFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 33:
			if (Key_GetWireType(key) != 0)
				break;
			instance->ammoMagazine = ProtocolParser_ReadUInt64(stream);
			continue;
		case 34:
			if (Key_GetWireType(key) != 0)
				break;
			instance->ammoTotal = ProtocolParser_ReadUInt64(stream);
			continue;
		case 35:
			if (Key_GetWireType(key) != 0)
				break;
			instance->reloadDelayFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 36:
			if (Key_GetWireType(key) != 0)
				break;
			instance->explosionRangeFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 37:
			if (Key_GetWireType(key) != 0)
				break;
			instance->explosionTimeFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 38:
			if (Key_GetWireType(key) != 0)
				break;
			instance->projectileSpeedFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 39:
			if (Key_GetWireType(key) != 0)
				break;
			instance->projectileBounce = ProtocolParser_ReadBool(stream);
			continue;
		case 40:
			if (Key_GetWireType(key) != 0)
				break;
			instance->damageBodyFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 41:
			if (Key_GetWireType(key) != 0)
				break;
			instance->damageHeadFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 42:
			if (Key_GetWireType(key) != 0)
				break;
			instance->pistolType = ProtocolParser_ReadUInt64(stream);
			continue;
		case 43:
			if (Key_GetWireType(key) != 0)
				break;
			instance->damageToPlayer = ProtocolParser_ReadUInt64(stream);
			continue;
		case 44:
			if (Key_GetWireType(key) != 0)
				break;
			instance->whenPlacedGetsConvertedTo = ProtocolParser_ReadUInt64(stream);
			continue;
		case 45:
			if (Key_GetWireType(key) != 0)
				break;
			instance->pickDistanceWhenUsedFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_BlockType const *Packet_BlockTypeSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_BlockType *instance)
{
	int limit;
	instance->drawType = 0;
	instance->walkableType = 0;
	instance->pistolType = 0;
	limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->textureIdTop = ProtocolParser_ReadString(stream);
			continue;
		case 18:
			instance->textureIdBottom = ProtocolParser_ReadString(stream);
			continue;
		case 26:
			instance->textureIdFront = ProtocolParser_ReadString(stream);
			continue;
		case 34:
			instance->textureIdBack = ProtocolParser_ReadString(stream);
			continue;
		case 42:
			instance->textureIdLeft = ProtocolParser_ReadString(stream);
			continue;
		case 50:
			instance->textureIdRight = ProtocolParser_ReadString(stream);
			continue;
		case 58:
			instance->textureIdForInventory = ProtocolParser_ReadString(stream);
			continue;
		case 64:
			instance->drawType = ProtocolParser_ReadUInt64(stream);
			continue;
		case 72:
			instance->walkableType = ProtocolParser_ReadUInt64(stream);
			continue;
		case 80:
			instance->rail = ProtocolParser_ReadUInt64(stream);
			continue;
		case 88:
			instance->walkSpeedFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 96:
			instance->isSlipperyWalk = ProtocolParser_ReadBool(stream);
			continue;
		case 106:
			if (instance->sounds == NULL)
				instance->sounds = Packet_SoundSetSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_SoundSetSerializer_DeserializeLengthDelimited(stream, instance->sounds);
			continue;
		case 112:
			instance->lightRadius = ProtocolParser_ReadUInt64(stream);
			continue;
		case 120:
			instance->startInventoryAmount = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		case 16:
			if (Key_GetWireType(key) != 0)
				break;
			instance->strength = ProtocolParser_ReadUInt64(stream);
			continue;
		case 17:
			if (Key_GetWireType(key) != 2)
				break;
			instance->name = ProtocolParser_ReadString(stream);
			continue;
		case 18:
			if (Key_GetWireType(key) != 0)
				break;
			instance->isBuildable = ProtocolParser_ReadBool(stream);
			continue;
		case 19:
			if (Key_GetWireType(key) != 0)
				break;
			instance->isUsable = ProtocolParser_ReadBool(stream);
			continue;
		case 20:
			if (Key_GetWireType(key) != 0)
				break;
			instance->isTool = ProtocolParser_ReadBool(stream);
			continue;
		case 21:
			if (Key_GetWireType(key) != 2)
				break;
			instance->handimage = ProtocolParser_ReadString(stream);
			continue;
		case 22:
			if (Key_GetWireType(key) != 0)
				break;
			instance->isPistol = ProtocolParser_ReadBool(stream);
			continue;
		case 23:
			if (Key_GetWireType(key) != 0)
				break;
			instance->aimRadiusFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			if (Key_GetWireType(key) != 0)
				break;
			instance->recoilFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 25:
			if (Key_GetWireType(key) != 0)
				break;
			instance->delayFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 26:
			if (Key_GetWireType(key) != 0)
				break;
			instance->bulletsPerShotFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 27:
			if (Key_GetWireType(key) != 0)
				break;
			instance->walkSpeedWhenUsedFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 28:
			if (Key_GetWireType(key) != 0)
				break;
			instance->ironSightsEnabled = ProtocolParser_ReadBool(stream);
			continue;
		case 29:
			if (Key_GetWireType(key) != 0)
				break;
			instance->ironSightsMoveSpeedFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 30:
			if (Key_GetWireType(key) != 2)
				break;
			instance->ironSightsImage = ProtocolParser_ReadString(stream);
			continue;
		case 31:
			if (Key_GetWireType(key) != 0)
				break;
			instance->ironSightsAimRadiusFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			if (Key_GetWireType(key) != 0)
				break;
			instance->ironSightsFovFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 33:
			if (Key_GetWireType(key) != 0)
				break;
			instance->ammoMagazine = ProtocolParser_ReadUInt64(stream);
			continue;
		case 34:
			if (Key_GetWireType(key) != 0)
				break;
			instance->ammoTotal = ProtocolParser_ReadUInt64(stream);
			continue;
		case 35:
			if (Key_GetWireType(key) != 0)
				break;
			instance->reloadDelayFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 36:
			if (Key_GetWireType(key) != 0)
				break;
			instance->explosionRangeFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 37:
			if (Key_GetWireType(key) != 0)
				break;
			instance->explosionTimeFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 38:
			if (Key_GetWireType(key) != 0)
				break;
			instance->projectileSpeedFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 39:
			if (Key_GetWireType(key) != 0)
				break;
			instance->projectileBounce = ProtocolParser_ReadBool(stream);
			continue;
		case 40:
			if (Key_GetWireType(key) != 0)
				break;
			instance->damageBodyFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 41:
			if (Key_GetWireType(key) != 0)
				break;
			instance->damageHeadFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 42:
			if (Key_GetWireType(key) != 0)
				break;
			instance->pistolType = ProtocolParser_ReadUInt64(stream);
			continue;
		case 43:
			if (Key_GetWireType(key) != 0)
				break;
			instance->damageToPlayer = ProtocolParser_ReadUInt64(stream);
			continue;
		case 44:
			if (Key_GetWireType(key) != 0)
				break;
			instance->whenPlacedGetsConvertedTo = ProtocolParser_ReadUInt64(stream);
			continue;
		case 45:
			if (Key_GetWireType(key) != 0)
				break;
			instance->pickDistanceWhenUsedFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_BlockType *Packet_BlockTypeSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_BlockType *instance = Packet_BlockType_New();
	Packet_BlockTypeSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_BlockTypeSerializer_Serialize(CitoStream const *stream, Packet_BlockType const *instance)
{
	if (instance->textureIdTop != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->textureIdTop));
	}
	if (instance->textureIdBottom != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(18));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->textureIdBottom));
	}
	if (instance->textureIdFront != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(26));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->textureIdFront));
	}
	if (instance->textureIdBack != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(34));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->textureIdBack));
	}
	if (instance->textureIdLeft != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(42));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->textureIdLeft));
	}
	if (instance->textureIdRight != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(50));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->textureIdRight));
	}
	if (instance->textureIdForInventory != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(58));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->textureIdForInventory));
	}
	if (instance->drawType != 0) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(64));
		ProtocolParser_WriteUInt64(stream, instance->drawType);
	}
	if (instance->walkableType != 0) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(72));
		ProtocolParser_WriteUInt64(stream, instance->walkableType);
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(80));
	ProtocolParser_WriteUInt64(stream, instance->rail);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(88));
	ProtocolParser_WriteUInt64(stream, instance->walkSpeedFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(96));
	ProtocolParser_WriteBool(stream, instance->isSlipperyWalk);
	if (instance->sounds != NULL) {
		CitoMemoryStream const *ms13;
		int ms13Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(106));
		ms13 = CitoMemoryStream_New();
		Packet_SoundSetSerializer_Serialize(&ms13->base, instance->sounds);
		ms13Length = CitoMemoryStream_Length(ms13);
		ProtocolParser_WriteUInt32_(stream, ms13Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms13), 0, ms13Length);
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(112));
	ProtocolParser_WriteUInt64(stream, instance->lightRadius);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(120));
	ProtocolParser_WriteUInt64(stream, instance->startInventoryAmount);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(128));
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
	ProtocolParser_WriteUInt64(stream, instance->strength);
	if (instance->name != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(138));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->name));
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(144));
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
	ProtocolParser_WriteBool(stream, instance->isBuildable);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(152));
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
	ProtocolParser_WriteBool(stream, instance->isUsable);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(160));
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
	ProtocolParser_WriteBool(stream, instance->isTool);
	if (instance->handimage != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(170));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->handimage));
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(176));
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
	ProtocolParser_WriteBool(stream, instance->isPistol);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(184));
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
	ProtocolParser_WriteUInt64(stream, instance->aimRadiusFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(192));
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
	ProtocolParser_WriteUInt64(stream, instance->recoilFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(200));
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
	ProtocolParser_WriteUInt64(stream, instance->delayFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(208));
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
	ProtocolParser_WriteUInt64(stream, instance->bulletsPerShotFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(216));
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
	ProtocolParser_WriteUInt64(stream, instance->walkSpeedWhenUsedFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(224));
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
	ProtocolParser_WriteBool(stream, instance->ironSightsEnabled);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(232));
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
	ProtocolParser_WriteUInt64(stream, instance->ironSightsMoveSpeedFloat);
	if (instance->ironSightsImage != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(242));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->ironSightsImage));
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(248));
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
	ProtocolParser_WriteUInt64(stream, instance->ironSightsAimRadiusFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(128));
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(2));
	ProtocolParser_WriteUInt64(stream, instance->ironSightsFovFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(136));
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(2));
	ProtocolParser_WriteUInt64(stream, instance->ammoMagazine);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(144));
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(2));
	ProtocolParser_WriteUInt64(stream, instance->ammoTotal);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(152));
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(2));
	ProtocolParser_WriteUInt64(stream, instance->reloadDelayFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(160));
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(2));
	ProtocolParser_WriteUInt64(stream, instance->explosionRangeFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(168));
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(2));
	ProtocolParser_WriteUInt64(stream, instance->explosionTimeFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(176));
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(2));
	ProtocolParser_WriteUInt64(stream, instance->projectileSpeedFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(184));
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(2));
	ProtocolParser_WriteBool(stream, instance->projectileBounce);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(192));
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(2));
	ProtocolParser_WriteUInt64(stream, instance->damageBodyFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(200));
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(2));
	ProtocolParser_WriteUInt64(stream, instance->damageHeadFloat);
	if (instance->pistolType != 0) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(208));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(2));
		ProtocolParser_WriteUInt64(stream, instance->pistolType);
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(216));
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(2));
	ProtocolParser_WriteUInt64(stream, instance->damageToPlayer);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(224));
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(2));
	ProtocolParser_WriteUInt64(stream, instance->whenPlacedGetsConvertedTo);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(232));
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(2));
	ProtocolParser_WriteUInt64(stream, instance->pickDistanceWhenUsedFloat);
}

void Packet_BlockTypeSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_BlockType const *instance)
{
	unsigned char const *data = Packet_BlockTypeSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_BlockTypeSerializer_SerializeToBytes(Packet_BlockType const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_BlockTypeSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_Client *Packet_Client_New(void)
{
	Packet_Client *self = (Packet_Client *) malloc(sizeof(Packet_Client));
	return self;
}

void Packet_Client_Delete(Packet_Client *self)
{
	free(self);
}

Packet_ClientActiveMaterialSlot const *Packet_Client_GetActiveMaterialSlot(Packet_Client const *self)
{
	return self->activeMaterialSlot;
}

Packet_ClientCraft const *Packet_Client_GetCraft(Packet_Client const *self)
{
	return self->craft;
}

Packet_ClientDeath const *Packet_Client_GetDeath(Packet_Client const *self)
{
	return self->death;
}

Packet_ClientDialogClick const *Packet_Client_GetDialogClick_(Packet_Client const *self)
{
	return self->dialogClick_;
}

Packet_ClientEntityInteraction const *Packet_Client_GetEntityInteraction(Packet_Client const *self)
{
	return self->entityInteraction;
}

Packet_ClientFillArea const *Packet_Client_GetFillArea(Packet_Client const *self)
{
	return self->fillArea;
}

Packet_ClientGameResolution const *Packet_Client_GetGameResolution(Packet_Client const *self)
{
	return self->gameResolution;
}

Packet_ClientHealth const *Packet_Client_GetHealth(Packet_Client const *self)
{
	return self->health;
}

int Packet_Client_GetId(Packet_Client const *self)
{
	return self->id;
}

Packet_ClientIdentification const *Packet_Client_GetIdentification(Packet_Client const *self)
{
	return self->identification;
}

Packet_ClientInventoryAction const *Packet_Client_GetInventoryAction(Packet_Client const *self)
{
	return self->inventoryAction;
}

Packet_ClientLeave const *Packet_Client_GetLeave(Packet_Client const *self)
{
	return self->leave;
}

Packet_ClientMessage const *Packet_Client_GetMessage(Packet_Client const *self)
{
	return self->message;
}

Packet_ClientOxygen const *Packet_Client_GetOxygen(Packet_Client const *self)
{
	return self->oxygen;
}

Packet_ClientPingReply const *Packet_Client_GetPingReply(Packet_Client const *self)
{
	return self->pingReply;
}

Packet_ClientPositionAndOrientation const *Packet_Client_GetPositionAndOrientation(Packet_Client const *self)
{
	return self->positionAndOrientation;
}

Packet_ClientServerQuery const *Packet_Client_GetQuery(Packet_Client const *self)
{
	return self->query;
}

Packet_ClientReload const *Packet_Client_GetReload(Packet_Client const *self)
{
	return self->reload;
}

Packet_ClientRequestBlob const *Packet_Client_GetRequestBlob(Packet_Client const *self)
{
	return self->requestBlob;
}

Packet_ClientSetBlock const *Packet_Client_GetSetBlock(Packet_Client const *self)
{
	return self->setBlock;
}

Packet_ClientShot const *Packet_Client_GetShot(Packet_Client const *self)
{
	return self->shot;
}

Packet_ClientSpecialKey const *Packet_Client_GetSpecialKey_(Packet_Client const *self)
{
	return self->specialKey_;
}

void Packet_Client_SetActiveMaterialSlot(Packet_Client *self, Packet_ClientActiveMaterialSlot *value)
{
	self->activeMaterialSlot = value;
}

void Packet_Client_SetCraft(Packet_Client *self, Packet_ClientCraft *value)
{
	self->craft = value;
}

void Packet_Client_SetDeath(Packet_Client *self, Packet_ClientDeath *value)
{
	self->death = value;
}

void Packet_Client_SetDialogClick_(Packet_Client *self, Packet_ClientDialogClick *value)
{
	self->dialogClick_ = value;
}

void Packet_Client_SetEntityInteraction(Packet_Client *self, Packet_ClientEntityInteraction *value)
{
	self->entityInteraction = value;
}

void Packet_Client_SetFillArea(Packet_Client *self, Packet_ClientFillArea *value)
{
	self->fillArea = value;
}

void Packet_Client_SetGameResolution(Packet_Client *self, Packet_ClientGameResolution *value)
{
	self->gameResolution = value;
}

void Packet_Client_SetHealth(Packet_Client *self, Packet_ClientHealth *value)
{
	self->health = value;
}

void Packet_Client_SetId(Packet_Client *self, int value)
{
	self->id = value;
}

void Packet_Client_SetIdentification(Packet_Client *self, Packet_ClientIdentification *value)
{
	self->identification = value;
}

void Packet_Client_SetInventoryAction(Packet_Client *self, Packet_ClientInventoryAction *value)
{
	self->inventoryAction = value;
}

void Packet_Client_SetLeave(Packet_Client *self, Packet_ClientLeave *value)
{
	self->leave = value;
}

void Packet_Client_SetMessage(Packet_Client *self, Packet_ClientMessage *value)
{
	self->message = value;
}

void Packet_Client_SetOxygen(Packet_Client *self, Packet_ClientOxygen *value)
{
	self->oxygen = value;
}

void Packet_Client_SetPingReply(Packet_Client *self, Packet_ClientPingReply const *value)
{
	self->pingReply = value;
}

void Packet_Client_SetPositionAndOrientation(Packet_Client *self, Packet_ClientPositionAndOrientation *value)
{
	self->positionAndOrientation = value;
}

void Packet_Client_SetQuery(Packet_Client *self, Packet_ClientServerQuery const *value)
{
	self->query = value;
}

void Packet_Client_SetReload(Packet_Client *self, Packet_ClientReload const *value)
{
	self->reload = value;
}

void Packet_Client_SetRequestBlob(Packet_Client *self, Packet_ClientRequestBlob *value)
{
	self->requestBlob = value;
}

void Packet_Client_SetSetBlock(Packet_Client *self, Packet_ClientSetBlock *value)
{
	self->setBlock = value;
}

void Packet_Client_SetShot(Packet_Client *self, Packet_ClientShot *value)
{
	self->shot = value;
}

void Packet_Client_SetSpecialKey_(Packet_Client *self, Packet_ClientSpecialKey *value)
{
	self->specialKey_ = value;
}

Packet_ClientActiveMaterialSlot *Packet_ClientActiveMaterialSlot_New(void)
{
	Packet_ClientActiveMaterialSlot *self = (Packet_ClientActiveMaterialSlot *) malloc(sizeof(Packet_ClientActiveMaterialSlot));
	return self;
}

void Packet_ClientActiveMaterialSlot_Delete(Packet_ClientActiveMaterialSlot *self)
{
	free(self);
}

int Packet_ClientActiveMaterialSlot_GetActiveMaterialSlot(Packet_ClientActiveMaterialSlot const *self)
{
	return self->activeMaterialSlot;
}

void Packet_ClientActiveMaterialSlot_SetActiveMaterialSlot(Packet_ClientActiveMaterialSlot *self, int value)
{
	self->activeMaterialSlot = value;
}

Packet_ClientActiveMaterialSlot const *Packet_ClientActiveMaterialSlotSerializer_Deserialize(CitoStream const *stream, Packet_ClientActiveMaterialSlot *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->activeMaterialSlot = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientActiveMaterialSlot const *Packet_ClientActiveMaterialSlotSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ClientActiveMaterialSlot *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ClientActiveMaterialSlotSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ClientActiveMaterialSlot const *Packet_ClientActiveMaterialSlotSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ClientActiveMaterialSlot *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->activeMaterialSlot = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientActiveMaterialSlot const *Packet_ClientActiveMaterialSlotSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ClientActiveMaterialSlot *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->activeMaterialSlot = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientActiveMaterialSlot *Packet_ClientActiveMaterialSlotSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ClientActiveMaterialSlot *instance = Packet_ClientActiveMaterialSlot_New();
	Packet_ClientActiveMaterialSlotSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ClientActiveMaterialSlotSerializer_Serialize(CitoStream const *stream, Packet_ClientActiveMaterialSlot const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->activeMaterialSlot);
}

void Packet_ClientActiveMaterialSlotSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ClientActiveMaterialSlot const *instance)
{
	unsigned char const *data = Packet_ClientActiveMaterialSlotSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ClientActiveMaterialSlotSerializer_SerializeToBytes(Packet_ClientActiveMaterialSlot const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ClientActiveMaterialSlotSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ClientCraft *Packet_ClientCraft_New(void)
{
	Packet_ClientCraft *self = (Packet_ClientCraft *) malloc(sizeof(Packet_ClientCraft));
	return self;
}

void Packet_ClientCraft_Delete(Packet_ClientCraft *self)
{
	free(self);
}

int Packet_ClientCraft_GetRecipeId(Packet_ClientCraft const *self)
{
	return self->recipeId;
}

int Packet_ClientCraft_GetX(Packet_ClientCraft const *self)
{
	return self->x;
}

int Packet_ClientCraft_GetY(Packet_ClientCraft const *self)
{
	return self->y;
}

int Packet_ClientCraft_GetZ(Packet_ClientCraft const *self)
{
	return self->z;
}

void Packet_ClientCraft_SetRecipeId(Packet_ClientCraft *self, int value)
{
	self->recipeId = value;
}

void Packet_ClientCraft_SetX(Packet_ClientCraft *self, int value)
{
	self->x = value;
}

void Packet_ClientCraft_SetY(Packet_ClientCraft *self, int value)
{
	self->y = value;
}

void Packet_ClientCraft_SetZ(Packet_ClientCraft *self, int value)
{
	self->z = value;
}

Packet_ClientCraft const *Packet_ClientCraftSerializer_Deserialize(CitoStream const *stream, Packet_ClientCraft *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->recipeId = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientCraft const *Packet_ClientCraftSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ClientCraft *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ClientCraftSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ClientCraft const *Packet_ClientCraftSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ClientCraft *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->recipeId = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientCraft const *Packet_ClientCraftSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ClientCraft *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->recipeId = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientCraft *Packet_ClientCraftSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ClientCraft *instance = Packet_ClientCraft_New();
	Packet_ClientCraftSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ClientCraftSerializer_Serialize(CitoStream const *stream, Packet_ClientCraft const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->x);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->y);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteUInt64(stream, instance->z);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
	ProtocolParser_WriteUInt64(stream, instance->recipeId);
}

void Packet_ClientCraftSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ClientCraft const *instance)
{
	unsigned char const *data = Packet_ClientCraftSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ClientCraftSerializer_SerializeToBytes(Packet_ClientCraft const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ClientCraftSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ClientDeath *Packet_ClientDeath_New(void)
{
	Packet_ClientDeath *self = (Packet_ClientDeath *) malloc(sizeof(Packet_ClientDeath));
	return self;
}

void Packet_ClientDeath_Delete(Packet_ClientDeath *self)
{
	free(self);
}

int Packet_ClientDeath_GetReason(Packet_ClientDeath const *self)
{
	return self->reason;
}

int Packet_ClientDeath_GetSourcePlayer(Packet_ClientDeath const *self)
{
	return self->sourcePlayer;
}

void Packet_ClientDeath_SetReason(Packet_ClientDeath *self, int value)
{
	self->reason = value;
}

void Packet_ClientDeath_SetSourcePlayer(Packet_ClientDeath *self, int value)
{
	self->sourcePlayer = value;
}

Packet_ClientDeath const *Packet_ClientDeathSerializer_Deserialize(CitoStream const *stream, Packet_ClientDeath *instance)
{
	instance->reason = 0;
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->reason = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->sourcePlayer = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientDeath const *Packet_ClientDeathSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ClientDeath *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ClientDeathSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ClientDeath const *Packet_ClientDeathSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ClientDeath *instance)
{
	int limit;
	instance->reason = 0;
	limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->reason = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->sourcePlayer = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientDeath const *Packet_ClientDeathSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ClientDeath *instance)
{
	int limit;
	instance->reason = 0;
	limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->reason = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->sourcePlayer = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientDeath *Packet_ClientDeathSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ClientDeath *instance = Packet_ClientDeath_New();
	Packet_ClientDeathSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ClientDeathSerializer_Serialize(CitoStream const *stream, Packet_ClientDeath const *instance)
{
	if (instance->reason != 0) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
		ProtocolParser_WriteUInt64(stream, instance->reason);
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->sourcePlayer);
}

void Packet_ClientDeathSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ClientDeath const *instance)
{
	unsigned char const *data = Packet_ClientDeathSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ClientDeathSerializer_SerializeToBytes(Packet_ClientDeath const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ClientDeathSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ClientDialogClick *Packet_ClientDialogClick_New(void)
{
	Packet_ClientDialogClick *self = (Packet_ClientDialogClick *) malloc(sizeof(Packet_ClientDialogClick));
	return self;
}

void Packet_ClientDialogClick_Delete(Packet_ClientDialogClick *self)
{
	free(self);
}

const char *const *Packet_ClientDialogClick_GetTextBoxValue(Packet_ClientDialogClick const *self)
{
	return self->textBoxValue;
}

int Packet_ClientDialogClick_GetTextBoxValueCount(Packet_ClientDialogClick const *self)
{
	return self->textBoxValueCount;
}

int Packet_ClientDialogClick_GetTextBoxValueLength(Packet_ClientDialogClick const *self)
{
	return self->textBoxValueLength;
}

const char *Packet_ClientDialogClick_GetWidgetId(Packet_ClientDialogClick const *self)
{
	return self->widgetId;
}

void Packet_ClientDialogClick_SetTextBoxValue(Packet_ClientDialogClick *self, const char **value, int count, int length)
{
	self->textBoxValue = value;
	self->textBoxValueCount = count;
	self->textBoxValueLength = length;
}

void Packet_ClientDialogClick_SetWidgetId(Packet_ClientDialogClick *self, const char *value)
{
	self->widgetId = value;
}

void Packet_ClientDialogClick_TextBoxValueAdd(Packet_ClientDialogClick *self, const char *value)
{
	if (self->textBoxValueCount >= self->textBoxValueLength) {
		const char **TextBoxValue2 = (const char **) malloc(self->textBoxValueLength * 2 * sizeof(const char *));
		self->textBoxValueLength = self->textBoxValueLength * 2;
		{
			int i;
			for (i = 0; i < self->textBoxValueCount; i++) {
				TextBoxValue2[i] = self->textBoxValue[i];
			}
		}
		self->textBoxValue = TextBoxValue2;
	}
	self->textBoxValue[self->textBoxValueCount] = value;
	self->textBoxValueCount++;
}

Packet_ClientDialogClick const *Packet_ClientDialogClickSerializer_Deserialize(CitoStream const *stream, Packet_ClientDialogClick *instance)
{
	if (instance->textBoxValue == NULL) {
		instance->textBoxValue = (const char **) malloc(1 * sizeof(const char *));
		instance->textBoxValueCount = 0;
		instance->textBoxValueLength = 1;
	}
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance->widgetId = ProtocolParser_ReadString(stream);
			continue;
		case 26:
			Packet_ClientDialogClick_TextBoxValueAdd(instance, ProtocolParser_ReadString(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientDialogClick const *Packet_ClientDialogClickSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ClientDialogClick *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ClientDialogClickSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ClientDialogClick const *Packet_ClientDialogClickSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ClientDialogClick *instance)
{
	int limit;
	if (instance->textBoxValue == NULL) {
		instance->textBoxValue = (const char **) malloc(1 * sizeof(const char *));
		instance->textBoxValueCount = 0;
		instance->textBoxValueLength = 1;
	}
	limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->widgetId = ProtocolParser_ReadString(stream);
			continue;
		case 26:
			Packet_ClientDialogClick_TextBoxValueAdd(instance, ProtocolParser_ReadString(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientDialogClick const *Packet_ClientDialogClickSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ClientDialogClick *instance)
{
	int limit;
	if (instance->textBoxValue == NULL) {
		instance->textBoxValue = (const char **) malloc(1 * sizeof(const char *));
		instance->textBoxValueCount = 0;
		instance->textBoxValueLength = 1;
	}
	limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->widgetId = ProtocolParser_ReadString(stream);
			continue;
		case 26:
			Packet_ClientDialogClick_TextBoxValueAdd(instance, ProtocolParser_ReadString(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientDialogClick *Packet_ClientDialogClickSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ClientDialogClick *instance = Packet_ClientDialogClick_New();
	Packet_ClientDialogClickSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ClientDialogClickSerializer_Serialize(CitoStream const *stream, Packet_ClientDialogClick const *instance)
{
	if (instance->widgetId != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->widgetId));
	}
	if (instance->textBoxValue != NULL) {
		{
			int k;
			for (k = 0; k < instance->textBoxValueCount; k++) {
				const char *i3 = instance->textBoxValue[k];
				stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(26));
				ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(i3));
			}
		}
	}
}

void Packet_ClientDialogClickSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ClientDialogClick const *instance)
{
	unsigned char const *data = Packet_ClientDialogClickSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ClientDialogClickSerializer_SerializeToBytes(Packet_ClientDialogClick const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ClientDialogClickSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ClientEntityInteraction *Packet_ClientEntityInteraction_New(void)
{
	Packet_ClientEntityInteraction *self = (Packet_ClientEntityInteraction *) malloc(sizeof(Packet_ClientEntityInteraction));
	return self;
}

void Packet_ClientEntityInteraction_Delete(Packet_ClientEntityInteraction *self)
{
	free(self);
}

int Packet_ClientEntityInteraction_GetEntityId(Packet_ClientEntityInteraction const *self)
{
	return self->entityId;
}

int Packet_ClientEntityInteraction_GetInteractionType(Packet_ClientEntityInteraction const *self)
{
	return self->interactionType;
}

void Packet_ClientEntityInteraction_SetEntityId(Packet_ClientEntityInteraction *self, int value)
{
	self->entityId = value;
}

void Packet_ClientEntityInteraction_SetInteractionType(Packet_ClientEntityInteraction *self, int value)
{
	self->interactionType = value;
}

Packet_ClientEntityInteraction const *Packet_ClientEntityInteractionSerializer_Deserialize(CitoStream const *stream, Packet_ClientEntityInteraction *instance)
{
	instance->interactionType = 0;
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->entityId = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->interactionType = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientEntityInteraction const *Packet_ClientEntityInteractionSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ClientEntityInteraction *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ClientEntityInteractionSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ClientEntityInteraction const *Packet_ClientEntityInteractionSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ClientEntityInteraction *instance)
{
	int limit;
	instance->interactionType = 0;
	limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->entityId = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->interactionType = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientEntityInteraction const *Packet_ClientEntityInteractionSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ClientEntityInteraction *instance)
{
	int limit;
	instance->interactionType = 0;
	limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->entityId = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->interactionType = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientEntityInteraction *Packet_ClientEntityInteractionSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ClientEntityInteraction *instance = Packet_ClientEntityInteraction_New();
	Packet_ClientEntityInteractionSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ClientEntityInteractionSerializer_Serialize(CitoStream const *stream, Packet_ClientEntityInteraction const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->entityId);
	if (instance->interactionType != 0) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
		ProtocolParser_WriteUInt64(stream, instance->interactionType);
	}
}

void Packet_ClientEntityInteractionSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ClientEntityInteraction const *instance)
{
	unsigned char const *data = Packet_ClientEntityInteractionSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ClientEntityInteractionSerializer_SerializeToBytes(Packet_ClientEntityInteraction const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ClientEntityInteractionSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ClientFillArea *Packet_ClientFillArea_New(void)
{
	Packet_ClientFillArea *self = (Packet_ClientFillArea *) malloc(sizeof(Packet_ClientFillArea));
	return self;
}

void Packet_ClientFillArea_Delete(Packet_ClientFillArea *self)
{
	free(self);
}

int Packet_ClientFillArea_GetBlockType(Packet_ClientFillArea const *self)
{
	return self->blockType;
}

int Packet_ClientFillArea_GetMaterialSlot(Packet_ClientFillArea const *self)
{
	return self->materialSlot;
}

int Packet_ClientFillArea_GetX1(Packet_ClientFillArea const *self)
{
	return self->x1;
}

int Packet_ClientFillArea_GetX2(Packet_ClientFillArea const *self)
{
	return self->x2;
}

int Packet_ClientFillArea_GetY1(Packet_ClientFillArea const *self)
{
	return self->y1;
}

int Packet_ClientFillArea_GetY2(Packet_ClientFillArea const *self)
{
	return self->y2;
}

int Packet_ClientFillArea_GetZ1(Packet_ClientFillArea const *self)
{
	return self->z1;
}

int Packet_ClientFillArea_GetZ2(Packet_ClientFillArea const *self)
{
	return self->z2;
}

void Packet_ClientFillArea_SetBlockType(Packet_ClientFillArea *self, int value)
{
	self->blockType = value;
}

void Packet_ClientFillArea_SetMaterialSlot(Packet_ClientFillArea *self, int value)
{
	self->materialSlot = value;
}

void Packet_ClientFillArea_SetX1(Packet_ClientFillArea *self, int value)
{
	self->x1 = value;
}

void Packet_ClientFillArea_SetX2(Packet_ClientFillArea *self, int value)
{
	self->x2 = value;
}

void Packet_ClientFillArea_SetY1(Packet_ClientFillArea *self, int value)
{
	self->y1 = value;
}

void Packet_ClientFillArea_SetY2(Packet_ClientFillArea *self, int value)
{
	self->y2 = value;
}

void Packet_ClientFillArea_SetZ1(Packet_ClientFillArea *self, int value)
{
	self->z1 = value;
}

void Packet_ClientFillArea_SetZ2(Packet_ClientFillArea *self, int value)
{
	self->z2 = value;
}

Packet_ClientFillArea const *Packet_ClientFillAreaSerializer_Deserialize(CitoStream const *stream, Packet_ClientFillArea *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->x1 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->x2 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->y1 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->y2 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->z1 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->z2 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->blockType = ProtocolParser_ReadUInt64(stream);
			continue;
		case 64:
			instance->materialSlot = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientFillArea const *Packet_ClientFillAreaSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ClientFillArea *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ClientFillAreaSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ClientFillArea const *Packet_ClientFillAreaSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ClientFillArea *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->x1 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->x2 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->y1 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->y2 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->z1 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->z2 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->blockType = ProtocolParser_ReadUInt64(stream);
			continue;
		case 64:
			instance->materialSlot = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientFillArea const *Packet_ClientFillAreaSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ClientFillArea *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->x1 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->x2 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->y1 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->y2 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->z1 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->z2 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->blockType = ProtocolParser_ReadUInt64(stream);
			continue;
		case 64:
			instance->materialSlot = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientFillArea *Packet_ClientFillAreaSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ClientFillArea *instance = Packet_ClientFillArea_New();
	Packet_ClientFillAreaSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ClientFillAreaSerializer_Serialize(CitoStream const *stream, Packet_ClientFillArea const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->x1);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->x2);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteUInt64(stream, instance->y1);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
	ProtocolParser_WriteUInt64(stream, instance->y2);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(40));
	ProtocolParser_WriteUInt64(stream, instance->z1);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(48));
	ProtocolParser_WriteUInt64(stream, instance->z2);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(56));
	ProtocolParser_WriteUInt64(stream, instance->blockType);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(64));
	ProtocolParser_WriteUInt64(stream, instance->materialSlot);
}

void Packet_ClientFillAreaSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ClientFillArea const *instance)
{
	unsigned char const *data = Packet_ClientFillAreaSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ClientFillAreaSerializer_SerializeToBytes(Packet_ClientFillArea const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ClientFillAreaSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ClientGameResolution *Packet_ClientGameResolution_New(void)
{
	Packet_ClientGameResolution *self = (Packet_ClientGameResolution *) malloc(sizeof(Packet_ClientGameResolution));
	return self;
}

void Packet_ClientGameResolution_Delete(Packet_ClientGameResolution *self)
{
	free(self);
}

int Packet_ClientGameResolution_GetHeight(Packet_ClientGameResolution const *self)
{
	return self->height;
}

int Packet_ClientGameResolution_GetWidth(Packet_ClientGameResolution const *self)
{
	return self->width;
}

void Packet_ClientGameResolution_SetHeight(Packet_ClientGameResolution *self, int value)
{
	self->height = value;
}

void Packet_ClientGameResolution_SetWidth(Packet_ClientGameResolution *self, int value)
{
	self->width = value;
}

Packet_ClientGameResolution const *Packet_ClientGameResolutionSerializer_Deserialize(CitoStream const *stream, Packet_ClientGameResolution *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->width = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->height = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientGameResolution const *Packet_ClientGameResolutionSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ClientGameResolution *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ClientGameResolutionSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ClientGameResolution const *Packet_ClientGameResolutionSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ClientGameResolution *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->width = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->height = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientGameResolution const *Packet_ClientGameResolutionSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ClientGameResolution *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->width = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->height = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientGameResolution *Packet_ClientGameResolutionSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ClientGameResolution *instance = Packet_ClientGameResolution_New();
	Packet_ClientGameResolutionSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ClientGameResolutionSerializer_Serialize(CitoStream const *stream, Packet_ClientGameResolution const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->width);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->height);
}

void Packet_ClientGameResolutionSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ClientGameResolution const *instance)
{
	unsigned char const *data = Packet_ClientGameResolutionSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ClientGameResolutionSerializer_SerializeToBytes(Packet_ClientGameResolution const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ClientGameResolutionSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ClientHealth *Packet_ClientHealth_New(void)
{
	Packet_ClientHealth *self = (Packet_ClientHealth *) malloc(sizeof(Packet_ClientHealth));
	return self;
}

void Packet_ClientHealth_Delete(Packet_ClientHealth *self)
{
	free(self);
}

int Packet_ClientHealth_GetCurrentHealth(Packet_ClientHealth const *self)
{
	return self->currentHealth;
}

void Packet_ClientHealth_SetCurrentHealth(Packet_ClientHealth *self, int value)
{
	self->currentHealth = value;
}

Packet_ClientHealth const *Packet_ClientHealthSerializer_Deserialize(CitoStream const *stream, Packet_ClientHealth *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->currentHealth = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientHealth const *Packet_ClientHealthSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ClientHealth *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ClientHealthSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ClientHealth const *Packet_ClientHealthSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ClientHealth *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->currentHealth = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientHealth const *Packet_ClientHealthSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ClientHealth *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->currentHealth = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientHealth *Packet_ClientHealthSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ClientHealth *instance = Packet_ClientHealth_New();
	Packet_ClientHealthSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ClientHealthSerializer_Serialize(CitoStream const *stream, Packet_ClientHealth const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->currentHealth);
}

void Packet_ClientHealthSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ClientHealth const *instance)
{
	unsigned char const *data = Packet_ClientHealthSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ClientHealthSerializer_SerializeToBytes(Packet_ClientHealth const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ClientHealthSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ClientIdentification *Packet_ClientIdentification_New(void)
{
	Packet_ClientIdentification *self = (Packet_ClientIdentification *) malloc(sizeof(Packet_ClientIdentification));
	return self;
}

void Packet_ClientIdentification_Delete(Packet_ClientIdentification *self)
{
	free(self);
}

const char *Packet_ClientIdentification_GetMdProtocolVersion(Packet_ClientIdentification const *self)
{
	return self->mdProtocolVersion;
}

Packet_PositionAndOrientation const *Packet_ClientIdentification_GetRequestPosition(Packet_ClientIdentification const *self)
{
	return self->requestPosition;
}

const char *Packet_ClientIdentification_GetServerPassword(Packet_ClientIdentification const *self)
{
	return self->serverPassword;
}

const char *Packet_ClientIdentification_GetUsername(Packet_ClientIdentification const *self)
{
	return self->username;
}

const char *Packet_ClientIdentification_GetVerificationKey(Packet_ClientIdentification const *self)
{
	return self->verificationKey;
}

void Packet_ClientIdentification_SetMdProtocolVersion(Packet_ClientIdentification *self, const char *value)
{
	self->mdProtocolVersion = value;
}

void Packet_ClientIdentification_SetRequestPosition(Packet_ClientIdentification *self, Packet_PositionAndOrientation *value)
{
	self->requestPosition = value;
}

void Packet_ClientIdentification_SetServerPassword(Packet_ClientIdentification *self, const char *value)
{
	self->serverPassword = value;
}

void Packet_ClientIdentification_SetUsername(Packet_ClientIdentification *self, const char *value)
{
	self->username = value;
}

void Packet_ClientIdentification_SetVerificationKey(Packet_ClientIdentification *self, const char *value)
{
	self->verificationKey = value;
}

Packet_ClientIdentification const *Packet_ClientIdentificationSerializer_Deserialize(CitoStream const *stream, Packet_ClientIdentification *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance->mdProtocolVersion = ProtocolParser_ReadString(stream);
			continue;
		case 18:
			instance->username = ProtocolParser_ReadString(stream);
			continue;
		case 26:
			instance->verificationKey = ProtocolParser_ReadString(stream);
			continue;
		case 34:
			instance->serverPassword = ProtocolParser_ReadString(stream);
			continue;
		case 42:
			if (instance->requestPosition == NULL)
				instance->requestPosition = Packet_PositionAndOrientationSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_PositionAndOrientationSerializer_DeserializeLengthDelimited(stream, instance->requestPosition);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientIdentification const *Packet_ClientIdentificationSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ClientIdentification *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ClientIdentificationSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ClientIdentification const *Packet_ClientIdentificationSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ClientIdentification *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->mdProtocolVersion = ProtocolParser_ReadString(stream);
			continue;
		case 18:
			instance->username = ProtocolParser_ReadString(stream);
			continue;
		case 26:
			instance->verificationKey = ProtocolParser_ReadString(stream);
			continue;
		case 34:
			instance->serverPassword = ProtocolParser_ReadString(stream);
			continue;
		case 42:
			if (instance->requestPosition == NULL)
				instance->requestPosition = Packet_PositionAndOrientationSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_PositionAndOrientationSerializer_DeserializeLengthDelimited(stream, instance->requestPosition);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientIdentification const *Packet_ClientIdentificationSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ClientIdentification *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->mdProtocolVersion = ProtocolParser_ReadString(stream);
			continue;
		case 18:
			instance->username = ProtocolParser_ReadString(stream);
			continue;
		case 26:
			instance->verificationKey = ProtocolParser_ReadString(stream);
			continue;
		case 34:
			instance->serverPassword = ProtocolParser_ReadString(stream);
			continue;
		case 42:
			if (instance->requestPosition == NULL)
				instance->requestPosition = Packet_PositionAndOrientationSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_PositionAndOrientationSerializer_DeserializeLengthDelimited(stream, instance->requestPosition);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientIdentification *Packet_ClientIdentificationSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ClientIdentification *instance = Packet_ClientIdentification_New();
	Packet_ClientIdentificationSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ClientIdentificationSerializer_Serialize(CitoStream const *stream, Packet_ClientIdentification const *instance)
{
	if (instance->mdProtocolVersion != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->mdProtocolVersion));
	}
	if (instance->username != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(18));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->username));
	}
	if (instance->verificationKey != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(26));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->verificationKey));
	}
	if (instance->serverPassword != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(34));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->serverPassword));
	}
	if (instance->requestPosition != NULL) {
		CitoMemoryStream const *ms5;
		int ms5Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(42));
		ms5 = CitoMemoryStream_New();
		Packet_PositionAndOrientationSerializer_Serialize(&ms5->base, instance->requestPosition);
		ms5Length = CitoMemoryStream_Length(ms5);
		ProtocolParser_WriteUInt32_(stream, ms5Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms5), 0, ms5Length);
	}
}

void Packet_ClientIdentificationSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ClientIdentification const *instance)
{
	unsigned char const *data = Packet_ClientIdentificationSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ClientIdentificationSerializer_SerializeToBytes(Packet_ClientIdentification const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ClientIdentificationSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ClientInventoryAction *Packet_ClientInventoryAction_New(void)
{
	Packet_ClientInventoryAction *self = (Packet_ClientInventoryAction *) malloc(sizeof(Packet_ClientInventoryAction));
	return self;
}

void Packet_ClientInventoryAction_Delete(Packet_ClientInventoryAction *self)
{
	free(self);
}

Packet_InventoryPosition const *Packet_ClientInventoryAction_GetA(Packet_ClientInventoryAction const *self)
{
	return self->a;
}

int Packet_ClientInventoryAction_GetAction(Packet_ClientInventoryAction const *self)
{
	return self->action;
}

Packet_InventoryPosition const *Packet_ClientInventoryAction_GetB(Packet_ClientInventoryAction const *self)
{
	return self->b;
}

void Packet_ClientInventoryAction_SetA(Packet_ClientInventoryAction *self, Packet_InventoryPosition *value)
{
	self->a = value;
}

void Packet_ClientInventoryAction_SetAction(Packet_ClientInventoryAction *self, int value)
{
	self->action = value;
}

void Packet_ClientInventoryAction_SetB(Packet_ClientInventoryAction *self, Packet_InventoryPosition *value)
{
	self->b = value;
}

Packet_ClientInventoryAction const *Packet_ClientInventoryActionSerializer_Deserialize(CitoStream const *stream, Packet_ClientInventoryAction *instance)
{
	instance->action = 0;
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->action = ProtocolParser_ReadUInt64(stream);
			continue;
		case 18:
			if (instance->a == NULL)
				instance->a = Packet_InventoryPositionSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_InventoryPositionSerializer_DeserializeLengthDelimited(stream, instance->a);
			continue;
		case 26:
			if (instance->b == NULL)
				instance->b = Packet_InventoryPositionSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_InventoryPositionSerializer_DeserializeLengthDelimited(stream, instance->b);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientInventoryAction const *Packet_ClientInventoryActionSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ClientInventoryAction *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ClientInventoryActionSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ClientInventoryAction const *Packet_ClientInventoryActionSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ClientInventoryAction *instance)
{
	int limit;
	instance->action = 0;
	limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->action = ProtocolParser_ReadUInt64(stream);
			continue;
		case 18:
			if (instance->a == NULL)
				instance->a = Packet_InventoryPositionSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_InventoryPositionSerializer_DeserializeLengthDelimited(stream, instance->a);
			continue;
		case 26:
			if (instance->b == NULL)
				instance->b = Packet_InventoryPositionSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_InventoryPositionSerializer_DeserializeLengthDelimited(stream, instance->b);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientInventoryAction const *Packet_ClientInventoryActionSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ClientInventoryAction *instance)
{
	int limit;
	instance->action = 0;
	limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->action = ProtocolParser_ReadUInt64(stream);
			continue;
		case 18:
			if (instance->a == NULL)
				instance->a = Packet_InventoryPositionSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_InventoryPositionSerializer_DeserializeLengthDelimited(stream, instance->a);
			continue;
		case 26:
			if (instance->b == NULL)
				instance->b = Packet_InventoryPositionSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_InventoryPositionSerializer_DeserializeLengthDelimited(stream, instance->b);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientInventoryAction *Packet_ClientInventoryActionSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ClientInventoryAction *instance = Packet_ClientInventoryAction_New();
	Packet_ClientInventoryActionSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ClientInventoryActionSerializer_Serialize(CitoStream const *stream, Packet_ClientInventoryAction const *instance)
{
	if (instance->action != 0) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
		ProtocolParser_WriteUInt64(stream, instance->action);
	}
	if (instance->a != NULL) {
		CitoMemoryStream const *ms2;
		int ms2Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(18));
		ms2 = CitoMemoryStream_New();
		Packet_InventoryPositionSerializer_Serialize(&ms2->base, instance->a);
		ms2Length = CitoMemoryStream_Length(ms2);
		ProtocolParser_WriteUInt32_(stream, ms2Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms2), 0, ms2Length);
	}
	if (instance->b != NULL) {
		CitoMemoryStream const *ms3;
		int ms3Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(26));
		ms3 = CitoMemoryStream_New();
		Packet_InventoryPositionSerializer_Serialize(&ms3->base, instance->b);
		ms3Length = CitoMemoryStream_Length(ms3);
		ProtocolParser_WriteUInt32_(stream, ms3Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms3), 0, ms3Length);
	}
}

void Packet_ClientInventoryActionSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ClientInventoryAction const *instance)
{
	unsigned char const *data = Packet_ClientInventoryActionSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ClientInventoryActionSerializer_SerializeToBytes(Packet_ClientInventoryAction const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ClientInventoryActionSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ClientLeave *Packet_ClientLeave_New(void)
{
	Packet_ClientLeave *self = (Packet_ClientLeave *) malloc(sizeof(Packet_ClientLeave));
	return self;
}

void Packet_ClientLeave_Delete(Packet_ClientLeave *self)
{
	free(self);
}

int Packet_ClientLeave_GetReason(Packet_ClientLeave const *self)
{
	return self->reason;
}

void Packet_ClientLeave_SetReason(Packet_ClientLeave *self, int value)
{
	self->reason = value;
}

Packet_ClientLeave const *Packet_ClientLeaveSerializer_Deserialize(CitoStream const *stream, Packet_ClientLeave *instance)
{
	instance->reason = 0;
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->reason = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientLeave const *Packet_ClientLeaveSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ClientLeave *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ClientLeaveSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ClientLeave const *Packet_ClientLeaveSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ClientLeave *instance)
{
	int limit;
	instance->reason = 0;
	limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->reason = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientLeave const *Packet_ClientLeaveSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ClientLeave *instance)
{
	int limit;
	instance->reason = 0;
	limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->reason = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientLeave *Packet_ClientLeaveSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ClientLeave *instance = Packet_ClientLeave_New();
	Packet_ClientLeaveSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ClientLeaveSerializer_Serialize(CitoStream const *stream, Packet_ClientLeave const *instance)
{
	if (instance->reason != 0) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
		ProtocolParser_WriteUInt64(stream, instance->reason);
	}
}

void Packet_ClientLeaveSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ClientLeave const *instance)
{
	unsigned char const *data = Packet_ClientLeaveSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ClientLeaveSerializer_SerializeToBytes(Packet_ClientLeave const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ClientLeaveSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ClientMessage *Packet_ClientMessage_New(void)
{
	Packet_ClientMessage *self = (Packet_ClientMessage *) malloc(sizeof(Packet_ClientMessage));
	return self;
}

void Packet_ClientMessage_Delete(Packet_ClientMessage *self)
{
	free(self);
}

int Packet_ClientMessage_GetIsTeamchat(Packet_ClientMessage const *self)
{
	return self->isTeamchat;
}

const char *Packet_ClientMessage_GetMessage(Packet_ClientMessage const *self)
{
	return self->message;
}

void Packet_ClientMessage_SetIsTeamchat(Packet_ClientMessage *self, int value)
{
	self->isTeamchat = value;
}

void Packet_ClientMessage_SetMessage(Packet_ClientMessage *self, const char *value)
{
	self->message = value;
}

Packet_ClientMessage const *Packet_ClientMessageSerializer_Deserialize(CitoStream const *stream, Packet_ClientMessage *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance->message = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->isTeamchat = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientMessage const *Packet_ClientMessageSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ClientMessage *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ClientMessageSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ClientMessage const *Packet_ClientMessageSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ClientMessage *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->message = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->isTeamchat = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientMessage const *Packet_ClientMessageSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ClientMessage *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->message = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->isTeamchat = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientMessage *Packet_ClientMessageSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ClientMessage *instance = Packet_ClientMessage_New();
	Packet_ClientMessageSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ClientMessageSerializer_Serialize(CitoStream const *stream, Packet_ClientMessage const *instance)
{
	if (instance->message != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->message));
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->isTeamchat);
}

void Packet_ClientMessageSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ClientMessage const *instance)
{
	unsigned char const *data = Packet_ClientMessageSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ClientMessageSerializer_SerializeToBytes(Packet_ClientMessage const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ClientMessageSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ClientOxygen *Packet_ClientOxygen_New(void)
{
	Packet_ClientOxygen *self = (Packet_ClientOxygen *) malloc(sizeof(Packet_ClientOxygen));
	return self;
}

void Packet_ClientOxygen_Delete(Packet_ClientOxygen *self)
{
	free(self);
}

int Packet_ClientOxygen_GetCurrentOxygen(Packet_ClientOxygen const *self)
{
	return self->currentOxygen;
}

void Packet_ClientOxygen_SetCurrentOxygen(Packet_ClientOxygen *self, int value)
{
	self->currentOxygen = value;
}

Packet_ClientOxygen const *Packet_ClientOxygenSerializer_Deserialize(CitoStream const *stream, Packet_ClientOxygen *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->currentOxygen = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientOxygen const *Packet_ClientOxygenSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ClientOxygen *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ClientOxygenSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ClientOxygen const *Packet_ClientOxygenSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ClientOxygen *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->currentOxygen = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientOxygen const *Packet_ClientOxygenSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ClientOxygen *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->currentOxygen = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientOxygen *Packet_ClientOxygenSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ClientOxygen *instance = Packet_ClientOxygen_New();
	Packet_ClientOxygenSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ClientOxygenSerializer_Serialize(CitoStream const *stream, Packet_ClientOxygen const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->currentOxygen);
}

void Packet_ClientOxygenSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ClientOxygen const *instance)
{
	unsigned char const *data = Packet_ClientOxygenSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ClientOxygenSerializer_SerializeToBytes(Packet_ClientOxygen const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ClientOxygenSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ClientPingReply const *Packet_ClientPingReplySerializer_Deserialize(CitoStream const *stream, Packet_ClientPingReply const *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientPingReply const *Packet_ClientPingReplySerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ClientPingReply const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ClientPingReplySerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ClientPingReply const *Packet_ClientPingReplySerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ClientPingReply const *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientPingReply const *Packet_ClientPingReplySerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ClientPingReply const *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientPingReply const *Packet_ClientPingReplySerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ClientPingReply const *instance = Packet_ClientPingReply_New();
	Packet_ClientPingReplySerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ClientPingReplySerializer_Serialize(CitoStream const *stream, Packet_ClientPingReply const *instance)
{
}

void Packet_ClientPingReplySerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ClientPingReply const *instance)
{
	unsigned char const *data = Packet_ClientPingReplySerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ClientPingReplySerializer_SerializeToBytes(Packet_ClientPingReply const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ClientPingReplySerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ClientPositionAndOrientation *Packet_ClientPositionAndOrientation_New(void)
{
	Packet_ClientPositionAndOrientation *self = (Packet_ClientPositionAndOrientation *) malloc(sizeof(Packet_ClientPositionAndOrientation));
	return self;
}

void Packet_ClientPositionAndOrientation_Delete(Packet_ClientPositionAndOrientation *self)
{
	free(self);
}

int Packet_ClientPositionAndOrientation_GetHeading(Packet_ClientPositionAndOrientation const *self)
{
	return self->heading;
}

int Packet_ClientPositionAndOrientation_GetPitch(Packet_ClientPositionAndOrientation const *self)
{
	return self->pitch;
}

int Packet_ClientPositionAndOrientation_GetPlayerId(Packet_ClientPositionAndOrientation const *self)
{
	return self->playerId;
}

int Packet_ClientPositionAndOrientation_GetStance(Packet_ClientPositionAndOrientation const *self)
{
	return self->stance;
}

int Packet_ClientPositionAndOrientation_GetX(Packet_ClientPositionAndOrientation const *self)
{
	return self->x;
}

int Packet_ClientPositionAndOrientation_GetY(Packet_ClientPositionAndOrientation const *self)
{
	return self->y;
}

int Packet_ClientPositionAndOrientation_GetZ(Packet_ClientPositionAndOrientation const *self)
{
	return self->z;
}

void Packet_ClientPositionAndOrientation_SetHeading(Packet_ClientPositionAndOrientation *self, int value)
{
	self->heading = value;
}

void Packet_ClientPositionAndOrientation_SetPitch(Packet_ClientPositionAndOrientation *self, int value)
{
	self->pitch = value;
}

void Packet_ClientPositionAndOrientation_SetPlayerId(Packet_ClientPositionAndOrientation *self, int value)
{
	self->playerId = value;
}

void Packet_ClientPositionAndOrientation_SetStance(Packet_ClientPositionAndOrientation *self, int value)
{
	self->stance = value;
}

void Packet_ClientPositionAndOrientation_SetX(Packet_ClientPositionAndOrientation *self, int value)
{
	self->x = value;
}

void Packet_ClientPositionAndOrientation_SetY(Packet_ClientPositionAndOrientation *self, int value)
{
	self->y = value;
}

void Packet_ClientPositionAndOrientation_SetZ(Packet_ClientPositionAndOrientation *self, int value)
{
	self->z = value;
}

Packet_ClientPositionAndOrientation const *Packet_ClientPositionAndOrientationSerializer_Deserialize(CitoStream const *stream, Packet_ClientPositionAndOrientation *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->playerId = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->heading = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->pitch = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->stance = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientPositionAndOrientation const *Packet_ClientPositionAndOrientationSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ClientPositionAndOrientation *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ClientPositionAndOrientationSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ClientPositionAndOrientation const *Packet_ClientPositionAndOrientationSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ClientPositionAndOrientation *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->playerId = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->heading = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->pitch = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->stance = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientPositionAndOrientation const *Packet_ClientPositionAndOrientationSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ClientPositionAndOrientation *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->playerId = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->heading = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->pitch = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->stance = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientPositionAndOrientation *Packet_ClientPositionAndOrientationSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ClientPositionAndOrientation *instance = Packet_ClientPositionAndOrientation_New();
	Packet_ClientPositionAndOrientationSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ClientPositionAndOrientationSerializer_Serialize(CitoStream const *stream, Packet_ClientPositionAndOrientation const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->playerId);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->x);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteUInt64(stream, instance->y);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
	ProtocolParser_WriteUInt64(stream, instance->z);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(40));
	ProtocolParser_WriteUInt64(stream, instance->heading);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(48));
	ProtocolParser_WriteUInt64(stream, instance->pitch);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(56));
	ProtocolParser_WriteUInt64(stream, instance->stance);
}

void Packet_ClientPositionAndOrientationSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ClientPositionAndOrientation const *instance)
{
	unsigned char const *data = Packet_ClientPositionAndOrientationSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ClientPositionAndOrientationSerializer_SerializeToBytes(Packet_ClientPositionAndOrientation const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ClientPositionAndOrientationSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ClientReload const *Packet_ClientReloadSerializer_Deserialize(CitoStream const *stream, Packet_ClientReload const *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientReload const *Packet_ClientReloadSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ClientReload const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ClientReloadSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ClientReload const *Packet_ClientReloadSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ClientReload const *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientReload const *Packet_ClientReloadSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ClientReload const *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientReload const *Packet_ClientReloadSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ClientReload const *instance = Packet_ClientReload_New();
	Packet_ClientReloadSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ClientReloadSerializer_Serialize(CitoStream const *stream, Packet_ClientReload const *instance)
{
}

void Packet_ClientReloadSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ClientReload const *instance)
{
	unsigned char const *data = Packet_ClientReloadSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ClientReloadSerializer_SerializeToBytes(Packet_ClientReload const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ClientReloadSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ClientRequestBlob *Packet_ClientRequestBlob_New(void)
{
	Packet_ClientRequestBlob *self = (Packet_ClientRequestBlob *) malloc(sizeof(Packet_ClientRequestBlob));
	return self;
}

void Packet_ClientRequestBlob_Delete(Packet_ClientRequestBlob *self)
{
	free(self);
}

Packet_StringList const *Packet_ClientRequestBlob_GetRequestedMd5(Packet_ClientRequestBlob const *self)
{
	return self->requestedMd5;
}

void Packet_ClientRequestBlob_SetRequestedMd5(Packet_ClientRequestBlob *self, Packet_StringList *value)
{
	self->requestedMd5 = value;
}

Packet_ClientRequestBlob const *Packet_ClientRequestBlobSerializer_Deserialize(CitoStream const *stream, Packet_ClientRequestBlob *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			if (instance->requestedMd5 == NULL)
				instance->requestedMd5 = Packet_StringListSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_StringListSerializer_DeserializeLengthDelimited(stream, instance->requestedMd5);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientRequestBlob const *Packet_ClientRequestBlobSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ClientRequestBlob *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ClientRequestBlobSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ClientRequestBlob const *Packet_ClientRequestBlobSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ClientRequestBlob *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			if (instance->requestedMd5 == NULL)
				instance->requestedMd5 = Packet_StringListSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_StringListSerializer_DeserializeLengthDelimited(stream, instance->requestedMd5);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientRequestBlob const *Packet_ClientRequestBlobSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ClientRequestBlob *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			if (instance->requestedMd5 == NULL)
				instance->requestedMd5 = Packet_StringListSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_StringListSerializer_DeserializeLengthDelimited(stream, instance->requestedMd5);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientRequestBlob *Packet_ClientRequestBlobSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ClientRequestBlob *instance = Packet_ClientRequestBlob_New();
	Packet_ClientRequestBlobSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ClientRequestBlobSerializer_Serialize(CitoStream const *stream, Packet_ClientRequestBlob const *instance)
{
	if (instance->requestedMd5 != NULL) {
		CitoMemoryStream const *ms1;
		int ms1Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
		ms1 = CitoMemoryStream_New();
		Packet_StringListSerializer_Serialize(&ms1->base, instance->requestedMd5);
		ms1Length = CitoMemoryStream_Length(ms1);
		ProtocolParser_WriteUInt32_(stream, ms1Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms1), 0, ms1Length);
	}
}

void Packet_ClientRequestBlobSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ClientRequestBlob const *instance)
{
	unsigned char const *data = Packet_ClientRequestBlobSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ClientRequestBlobSerializer_SerializeToBytes(Packet_ClientRequestBlob const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ClientRequestBlobSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_Client const *Packet_ClientSerializer_Deserialize(CitoStream const *stream, Packet_Client *instance)
{
	instance->id = 0;
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->id = ProtocolParser_ReadUInt64(stream);
			continue;
		case 18:
			if (instance->identification == NULL)
				instance->identification = Packet_ClientIdentificationSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientIdentificationSerializer_DeserializeLengthDelimited(stream, instance->identification);
			continue;
		case 26:
			if (instance->setBlock == NULL)
				instance->setBlock = Packet_ClientSetBlockSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientSetBlockSerializer_DeserializeLengthDelimited(stream, instance->setBlock);
			continue;
		case 34:
			if (instance->positionAndOrientation == NULL)
				instance->positionAndOrientation = Packet_ClientPositionAndOrientationSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientPositionAndOrientationSerializer_DeserializeLengthDelimited(stream, instance->positionAndOrientation);
			continue;
		case 42:
			if (instance->message == NULL)
				instance->message = Packet_ClientMessageSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientMessageSerializer_DeserializeLengthDelimited(stream, instance->message);
			continue;
		case 50:
			if (instance->craft == NULL)
				instance->craft = Packet_ClientCraftSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientCraftSerializer_DeserializeLengthDelimited(stream, instance->craft);
			continue;
		case 58:
			if (instance->requestBlob == NULL)
				instance->requestBlob = Packet_ClientRequestBlobSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientRequestBlobSerializer_DeserializeLengthDelimited(stream, instance->requestBlob);
			continue;
		case 66:
			if (instance->inventoryAction == NULL)
				instance->inventoryAction = Packet_ClientInventoryActionSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientInventoryActionSerializer_DeserializeLengthDelimited(stream, instance->inventoryAction);
			continue;
		case 74:
			if (instance->health == NULL)
				instance->health = Packet_ClientHealthSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientHealthSerializer_DeserializeLengthDelimited(stream, instance->health);
			continue;
		case 82:
			if (instance->pingReply == NULL)
				instance->pingReply = Packet_ClientPingReplySerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientPingReplySerializer_DeserializeLengthDelimited(stream, instance->pingReply);
			continue;
		case 90:
			if (instance->dialogClick_ == NULL)
				instance->dialogClick_ = Packet_ClientDialogClickSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientDialogClickSerializer_DeserializeLengthDelimited(stream, instance->dialogClick_);
			continue;
		case 98:
			if (instance->shot == NULL)
				instance->shot = Packet_ClientShotSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientShotSerializer_DeserializeLengthDelimited(stream, instance->shot);
			continue;
		case 106:
			if (instance->specialKey_ == NULL)
				instance->specialKey_ = Packet_ClientSpecialKeySerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientSpecialKeySerializer_DeserializeLengthDelimited(stream, instance->specialKey_);
			continue;
		case 114:
			if (instance->activeMaterialSlot == NULL)
				instance->activeMaterialSlot = Packet_ClientActiveMaterialSlotSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientActiveMaterialSlotSerializer_DeserializeLengthDelimited(stream, instance->activeMaterialSlot);
			continue;
		case 122:
			if (instance->leave == NULL)
				instance->leave = Packet_ClientLeaveSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientLeaveSerializer_DeserializeLengthDelimited(stream, instance->leave);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		case 31:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->fillArea == NULL)
				instance->fillArea = Packet_ClientFillAreaSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientFillAreaSerializer_DeserializeLengthDelimited(stream, instance->fillArea);
			continue;
		case 16:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->reload == NULL)
				instance->reload = Packet_ClientReloadSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientReloadSerializer_DeserializeLengthDelimited(stream, instance->reload);
			continue;
		case 17:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->oxygen == NULL)
				instance->oxygen = Packet_ClientOxygenSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientOxygenSerializer_DeserializeLengthDelimited(stream, instance->oxygen);
			continue;
		case 18:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->death == NULL)
				instance->death = Packet_ClientDeathSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientDeathSerializer_DeserializeLengthDelimited(stream, instance->death);
			continue;
		case 19:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->query == NULL)
				instance->query = Packet_ClientServerQuerySerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientServerQuerySerializer_DeserializeLengthDelimited(stream, instance->query);
			continue;
		case 20:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->gameResolution == NULL)
				instance->gameResolution = Packet_ClientGameResolutionSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientGameResolutionSerializer_DeserializeLengthDelimited(stream, instance->gameResolution);
			continue;
		case 21:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->entityInteraction == NULL)
				instance->entityInteraction = Packet_ClientEntityInteractionSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientEntityInteractionSerializer_DeserializeLengthDelimited(stream, instance->entityInteraction);
			continue;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_Client const *Packet_ClientSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_Client *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ClientSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_Client const *Packet_ClientSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_Client *instance)
{
	int limit;
	instance->id = 0;
	limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->id = ProtocolParser_ReadUInt64(stream);
			continue;
		case 18:
			if (instance->identification == NULL)
				instance->identification = Packet_ClientIdentificationSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientIdentificationSerializer_DeserializeLengthDelimited(stream, instance->identification);
			continue;
		case 26:
			if (instance->setBlock == NULL)
				instance->setBlock = Packet_ClientSetBlockSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientSetBlockSerializer_DeserializeLengthDelimited(stream, instance->setBlock);
			continue;
		case 34:
			if (instance->positionAndOrientation == NULL)
				instance->positionAndOrientation = Packet_ClientPositionAndOrientationSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientPositionAndOrientationSerializer_DeserializeLengthDelimited(stream, instance->positionAndOrientation);
			continue;
		case 42:
			if (instance->message == NULL)
				instance->message = Packet_ClientMessageSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientMessageSerializer_DeserializeLengthDelimited(stream, instance->message);
			continue;
		case 50:
			if (instance->craft == NULL)
				instance->craft = Packet_ClientCraftSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientCraftSerializer_DeserializeLengthDelimited(stream, instance->craft);
			continue;
		case 58:
			if (instance->requestBlob == NULL)
				instance->requestBlob = Packet_ClientRequestBlobSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientRequestBlobSerializer_DeserializeLengthDelimited(stream, instance->requestBlob);
			continue;
		case 66:
			if (instance->inventoryAction == NULL)
				instance->inventoryAction = Packet_ClientInventoryActionSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientInventoryActionSerializer_DeserializeLengthDelimited(stream, instance->inventoryAction);
			continue;
		case 74:
			if (instance->health == NULL)
				instance->health = Packet_ClientHealthSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientHealthSerializer_DeserializeLengthDelimited(stream, instance->health);
			continue;
		case 82:
			if (instance->pingReply == NULL)
				instance->pingReply = Packet_ClientPingReplySerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientPingReplySerializer_DeserializeLengthDelimited(stream, instance->pingReply);
			continue;
		case 90:
			if (instance->dialogClick_ == NULL)
				instance->dialogClick_ = Packet_ClientDialogClickSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientDialogClickSerializer_DeserializeLengthDelimited(stream, instance->dialogClick_);
			continue;
		case 98:
			if (instance->shot == NULL)
				instance->shot = Packet_ClientShotSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientShotSerializer_DeserializeLengthDelimited(stream, instance->shot);
			continue;
		case 106:
			if (instance->specialKey_ == NULL)
				instance->specialKey_ = Packet_ClientSpecialKeySerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientSpecialKeySerializer_DeserializeLengthDelimited(stream, instance->specialKey_);
			continue;
		case 114:
			if (instance->activeMaterialSlot == NULL)
				instance->activeMaterialSlot = Packet_ClientActiveMaterialSlotSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientActiveMaterialSlotSerializer_DeserializeLengthDelimited(stream, instance->activeMaterialSlot);
			continue;
		case 122:
			if (instance->leave == NULL)
				instance->leave = Packet_ClientLeaveSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientLeaveSerializer_DeserializeLengthDelimited(stream, instance->leave);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		case 31:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->fillArea == NULL)
				instance->fillArea = Packet_ClientFillAreaSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientFillAreaSerializer_DeserializeLengthDelimited(stream, instance->fillArea);
			continue;
		case 16:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->reload == NULL)
				instance->reload = Packet_ClientReloadSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientReloadSerializer_DeserializeLengthDelimited(stream, instance->reload);
			continue;
		case 17:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->oxygen == NULL)
				instance->oxygen = Packet_ClientOxygenSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientOxygenSerializer_DeserializeLengthDelimited(stream, instance->oxygen);
			continue;
		case 18:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->death == NULL)
				instance->death = Packet_ClientDeathSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientDeathSerializer_DeserializeLengthDelimited(stream, instance->death);
			continue;
		case 19:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->query == NULL)
				instance->query = Packet_ClientServerQuerySerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientServerQuerySerializer_DeserializeLengthDelimited(stream, instance->query);
			continue;
		case 20:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->gameResolution == NULL)
				instance->gameResolution = Packet_ClientGameResolutionSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientGameResolutionSerializer_DeserializeLengthDelimited(stream, instance->gameResolution);
			continue;
		case 21:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->entityInteraction == NULL)
				instance->entityInteraction = Packet_ClientEntityInteractionSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientEntityInteractionSerializer_DeserializeLengthDelimited(stream, instance->entityInteraction);
			continue;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_Client const *Packet_ClientSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_Client *instance)
{
	int limit;
	instance->id = 0;
	limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->id = ProtocolParser_ReadUInt64(stream);
			continue;
		case 18:
			if (instance->identification == NULL)
				instance->identification = Packet_ClientIdentificationSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientIdentificationSerializer_DeserializeLengthDelimited(stream, instance->identification);
			continue;
		case 26:
			if (instance->setBlock == NULL)
				instance->setBlock = Packet_ClientSetBlockSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientSetBlockSerializer_DeserializeLengthDelimited(stream, instance->setBlock);
			continue;
		case 34:
			if (instance->positionAndOrientation == NULL)
				instance->positionAndOrientation = Packet_ClientPositionAndOrientationSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientPositionAndOrientationSerializer_DeserializeLengthDelimited(stream, instance->positionAndOrientation);
			continue;
		case 42:
			if (instance->message == NULL)
				instance->message = Packet_ClientMessageSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientMessageSerializer_DeserializeLengthDelimited(stream, instance->message);
			continue;
		case 50:
			if (instance->craft == NULL)
				instance->craft = Packet_ClientCraftSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientCraftSerializer_DeserializeLengthDelimited(stream, instance->craft);
			continue;
		case 58:
			if (instance->requestBlob == NULL)
				instance->requestBlob = Packet_ClientRequestBlobSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientRequestBlobSerializer_DeserializeLengthDelimited(stream, instance->requestBlob);
			continue;
		case 66:
			if (instance->inventoryAction == NULL)
				instance->inventoryAction = Packet_ClientInventoryActionSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientInventoryActionSerializer_DeserializeLengthDelimited(stream, instance->inventoryAction);
			continue;
		case 74:
			if (instance->health == NULL)
				instance->health = Packet_ClientHealthSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientHealthSerializer_DeserializeLengthDelimited(stream, instance->health);
			continue;
		case 82:
			if (instance->pingReply == NULL)
				instance->pingReply = Packet_ClientPingReplySerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientPingReplySerializer_DeserializeLengthDelimited(stream, instance->pingReply);
			continue;
		case 90:
			if (instance->dialogClick_ == NULL)
				instance->dialogClick_ = Packet_ClientDialogClickSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientDialogClickSerializer_DeserializeLengthDelimited(stream, instance->dialogClick_);
			continue;
		case 98:
			if (instance->shot == NULL)
				instance->shot = Packet_ClientShotSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientShotSerializer_DeserializeLengthDelimited(stream, instance->shot);
			continue;
		case 106:
			if (instance->specialKey_ == NULL)
				instance->specialKey_ = Packet_ClientSpecialKeySerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientSpecialKeySerializer_DeserializeLengthDelimited(stream, instance->specialKey_);
			continue;
		case 114:
			if (instance->activeMaterialSlot == NULL)
				instance->activeMaterialSlot = Packet_ClientActiveMaterialSlotSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientActiveMaterialSlotSerializer_DeserializeLengthDelimited(stream, instance->activeMaterialSlot);
			continue;
		case 122:
			if (instance->leave == NULL)
				instance->leave = Packet_ClientLeaveSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientLeaveSerializer_DeserializeLengthDelimited(stream, instance->leave);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		case 31:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->fillArea == NULL)
				instance->fillArea = Packet_ClientFillAreaSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientFillAreaSerializer_DeserializeLengthDelimited(stream, instance->fillArea);
			continue;
		case 16:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->reload == NULL)
				instance->reload = Packet_ClientReloadSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientReloadSerializer_DeserializeLengthDelimited(stream, instance->reload);
			continue;
		case 17:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->oxygen == NULL)
				instance->oxygen = Packet_ClientOxygenSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientOxygenSerializer_DeserializeLengthDelimited(stream, instance->oxygen);
			continue;
		case 18:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->death == NULL)
				instance->death = Packet_ClientDeathSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientDeathSerializer_DeserializeLengthDelimited(stream, instance->death);
			continue;
		case 19:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->query == NULL)
				instance->query = Packet_ClientServerQuerySerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientServerQuerySerializer_DeserializeLengthDelimited(stream, instance->query);
			continue;
		case 20:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->gameResolution == NULL)
				instance->gameResolution = Packet_ClientGameResolutionSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientGameResolutionSerializer_DeserializeLengthDelimited(stream, instance->gameResolution);
			continue;
		case 21:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->entityInteraction == NULL)
				instance->entityInteraction = Packet_ClientEntityInteractionSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ClientEntityInteractionSerializer_DeserializeLengthDelimited(stream, instance->entityInteraction);
			continue;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_Client const *Packet_ClientSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_Client *instance = Packet_Client_New();
	Packet_ClientSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ClientSerializer_Serialize(CitoStream const *stream, Packet_Client const *instance)
{
	if (instance->id != 0) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
		ProtocolParser_WriteUInt64(stream, instance->id);
	}
	if (instance->identification != NULL) {
		CitoMemoryStream const *ms2;
		int ms2Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(18));
		ms2 = CitoMemoryStream_New();
		Packet_ClientIdentificationSerializer_Serialize(&ms2->base, instance->identification);
		ms2Length = CitoMemoryStream_Length(ms2);
		ProtocolParser_WriteUInt32_(stream, ms2Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms2), 0, ms2Length);
	}
	if (instance->setBlock != NULL) {
		CitoMemoryStream const *ms3;
		int ms3Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(26));
		ms3 = CitoMemoryStream_New();
		Packet_ClientSetBlockSerializer_Serialize(&ms3->base, instance->setBlock);
		ms3Length = CitoMemoryStream_Length(ms3);
		ProtocolParser_WriteUInt32_(stream, ms3Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms3), 0, ms3Length);
	}
	if (instance->fillArea != NULL) {
		CitoMemoryStream const *ms31;
		int ms31Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(250));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
		ms31 = CitoMemoryStream_New();
		Packet_ClientFillAreaSerializer_Serialize(&ms31->base, instance->fillArea);
		ms31Length = CitoMemoryStream_Length(ms31);
		ProtocolParser_WriteUInt32_(stream, ms31Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms31), 0, ms31Length);
	}
	if (instance->positionAndOrientation != NULL) {
		CitoMemoryStream const *ms4;
		int ms4Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(34));
		ms4 = CitoMemoryStream_New();
		Packet_ClientPositionAndOrientationSerializer_Serialize(&ms4->base, instance->positionAndOrientation);
		ms4Length = CitoMemoryStream_Length(ms4);
		ProtocolParser_WriteUInt32_(stream, ms4Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms4), 0, ms4Length);
	}
	if (instance->message != NULL) {
		CitoMemoryStream const *ms5;
		int ms5Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(42));
		ms5 = CitoMemoryStream_New();
		Packet_ClientMessageSerializer_Serialize(&ms5->base, instance->message);
		ms5Length = CitoMemoryStream_Length(ms5);
		ProtocolParser_WriteUInt32_(stream, ms5Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms5), 0, ms5Length);
	}
	if (instance->craft != NULL) {
		CitoMemoryStream const *ms6;
		int ms6Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(50));
		ms6 = CitoMemoryStream_New();
		Packet_ClientCraftSerializer_Serialize(&ms6->base, instance->craft);
		ms6Length = CitoMemoryStream_Length(ms6);
		ProtocolParser_WriteUInt32_(stream, ms6Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms6), 0, ms6Length);
	}
	if (instance->requestBlob != NULL) {
		CitoMemoryStream const *ms7;
		int ms7Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(58));
		ms7 = CitoMemoryStream_New();
		Packet_ClientRequestBlobSerializer_Serialize(&ms7->base, instance->requestBlob);
		ms7Length = CitoMemoryStream_Length(ms7);
		ProtocolParser_WriteUInt32_(stream, ms7Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms7), 0, ms7Length);
	}
	if (instance->inventoryAction != NULL) {
		CitoMemoryStream const *ms8;
		int ms8Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(66));
		ms8 = CitoMemoryStream_New();
		Packet_ClientInventoryActionSerializer_Serialize(&ms8->base, instance->inventoryAction);
		ms8Length = CitoMemoryStream_Length(ms8);
		ProtocolParser_WriteUInt32_(stream, ms8Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms8), 0, ms8Length);
	}
	if (instance->health != NULL) {
		CitoMemoryStream const *ms9;
		int ms9Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(74));
		ms9 = CitoMemoryStream_New();
		Packet_ClientHealthSerializer_Serialize(&ms9->base, instance->health);
		ms9Length = CitoMemoryStream_Length(ms9);
		ProtocolParser_WriteUInt32_(stream, ms9Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms9), 0, ms9Length);
	}
	if (instance->pingReply != NULL) {
		CitoMemoryStream const *ms10;
		int ms10Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(82));
		ms10 = CitoMemoryStream_New();
		Packet_ClientPingReplySerializer_Serialize(&ms10->base, instance->pingReply);
		ms10Length = CitoMemoryStream_Length(ms10);
		ProtocolParser_WriteUInt32_(stream, ms10Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms10), 0, ms10Length);
	}
	if (instance->dialogClick_ != NULL) {
		CitoMemoryStream const *ms11;
		int ms11Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(90));
		ms11 = CitoMemoryStream_New();
		Packet_ClientDialogClickSerializer_Serialize(&ms11->base, instance->dialogClick_);
		ms11Length = CitoMemoryStream_Length(ms11);
		ProtocolParser_WriteUInt32_(stream, ms11Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms11), 0, ms11Length);
	}
	if (instance->shot != NULL) {
		CitoMemoryStream const *ms12;
		int ms12Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(98));
		ms12 = CitoMemoryStream_New();
		Packet_ClientShotSerializer_Serialize(&ms12->base, instance->shot);
		ms12Length = CitoMemoryStream_Length(ms12);
		ProtocolParser_WriteUInt32_(stream, ms12Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms12), 0, ms12Length);
	}
	if (instance->specialKey_ != NULL) {
		CitoMemoryStream const *ms13;
		int ms13Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(106));
		ms13 = CitoMemoryStream_New();
		Packet_ClientSpecialKeySerializer_Serialize(&ms13->base, instance->specialKey_);
		ms13Length = CitoMemoryStream_Length(ms13);
		ProtocolParser_WriteUInt32_(stream, ms13Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms13), 0, ms13Length);
	}
	if (instance->activeMaterialSlot != NULL) {
		CitoMemoryStream const *ms14;
		int ms14Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(114));
		ms14 = CitoMemoryStream_New();
		Packet_ClientActiveMaterialSlotSerializer_Serialize(&ms14->base, instance->activeMaterialSlot);
		ms14Length = CitoMemoryStream_Length(ms14);
		ProtocolParser_WriteUInt32_(stream, ms14Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms14), 0, ms14Length);
	}
	if (instance->leave != NULL) {
		CitoMemoryStream const *ms15;
		int ms15Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(122));
		ms15 = CitoMemoryStream_New();
		Packet_ClientLeaveSerializer_Serialize(&ms15->base, instance->leave);
		ms15Length = CitoMemoryStream_Length(ms15);
		ProtocolParser_WriteUInt32_(stream, ms15Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms15), 0, ms15Length);
	}
	if (instance->reload != NULL) {
		CitoMemoryStream const *ms16;
		int ms16Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(130));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
		ms16 = CitoMemoryStream_New();
		Packet_ClientReloadSerializer_Serialize(&ms16->base, instance->reload);
		ms16Length = CitoMemoryStream_Length(ms16);
		ProtocolParser_WriteUInt32_(stream, ms16Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms16), 0, ms16Length);
	}
	if (instance->oxygen != NULL) {
		CitoMemoryStream const *ms17;
		int ms17Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(138));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
		ms17 = CitoMemoryStream_New();
		Packet_ClientOxygenSerializer_Serialize(&ms17->base, instance->oxygen);
		ms17Length = CitoMemoryStream_Length(ms17);
		ProtocolParser_WriteUInt32_(stream, ms17Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms17), 0, ms17Length);
	}
	if (instance->death != NULL) {
		CitoMemoryStream const *ms18;
		int ms18Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(146));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
		ms18 = CitoMemoryStream_New();
		Packet_ClientDeathSerializer_Serialize(&ms18->base, instance->death);
		ms18Length = CitoMemoryStream_Length(ms18);
		ProtocolParser_WriteUInt32_(stream, ms18Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms18), 0, ms18Length);
	}
	if (instance->query != NULL) {
		CitoMemoryStream const *ms19;
		int ms19Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(154));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
		ms19 = CitoMemoryStream_New();
		Packet_ClientServerQuerySerializer_Serialize(&ms19->base, instance->query);
		ms19Length = CitoMemoryStream_Length(ms19);
		ProtocolParser_WriteUInt32_(stream, ms19Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms19), 0, ms19Length);
	}
	if (instance->gameResolution != NULL) {
		CitoMemoryStream const *ms20;
		int ms20Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(162));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
		ms20 = CitoMemoryStream_New();
		Packet_ClientGameResolutionSerializer_Serialize(&ms20->base, instance->gameResolution);
		ms20Length = CitoMemoryStream_Length(ms20);
		ProtocolParser_WriteUInt32_(stream, ms20Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms20), 0, ms20Length);
	}
	if (instance->entityInteraction != NULL) {
		CitoMemoryStream const *ms21;
		int ms21Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(170));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
		ms21 = CitoMemoryStream_New();
		Packet_ClientEntityInteractionSerializer_Serialize(&ms21->base, instance->entityInteraction);
		ms21Length = CitoMemoryStream_Length(ms21);
		ProtocolParser_WriteUInt32_(stream, ms21Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms21), 0, ms21Length);
	}
}

void Packet_ClientSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_Client const *instance)
{
	unsigned char const *data = Packet_ClientSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ClientSerializer_SerializeToBytes(Packet_Client const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ClientSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ClientServerQuery const *Packet_ClientServerQuerySerializer_Deserialize(CitoStream const *stream, Packet_ClientServerQuery const *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientServerQuery const *Packet_ClientServerQuerySerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ClientServerQuery const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ClientServerQuerySerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ClientServerQuery const *Packet_ClientServerQuerySerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ClientServerQuery const *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientServerQuery const *Packet_ClientServerQuerySerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ClientServerQuery const *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientServerQuery const *Packet_ClientServerQuerySerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ClientServerQuery const *instance = Packet_ClientServerQuery_New();
	Packet_ClientServerQuerySerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ClientServerQuerySerializer_Serialize(CitoStream const *stream, Packet_ClientServerQuery const *instance)
{
}

void Packet_ClientServerQuerySerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ClientServerQuery const *instance)
{
	unsigned char const *data = Packet_ClientServerQuerySerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ClientServerQuerySerializer_SerializeToBytes(Packet_ClientServerQuery const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ClientServerQuerySerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ClientSetBlock *Packet_ClientSetBlock_New(void)
{
	Packet_ClientSetBlock *self = (Packet_ClientSetBlock *) malloc(sizeof(Packet_ClientSetBlock));
	return self;
}

void Packet_ClientSetBlock_Delete(Packet_ClientSetBlock *self)
{
	free(self);
}

int Packet_ClientSetBlock_GetBlockType(Packet_ClientSetBlock const *self)
{
	return self->blockType;
}

int Packet_ClientSetBlock_GetMaterialSlot(Packet_ClientSetBlock const *self)
{
	return self->materialSlot;
}

int Packet_ClientSetBlock_GetMode(Packet_ClientSetBlock const *self)
{
	return self->mode;
}

int Packet_ClientSetBlock_GetX(Packet_ClientSetBlock const *self)
{
	return self->x;
}

int Packet_ClientSetBlock_GetY(Packet_ClientSetBlock const *self)
{
	return self->y;
}

int Packet_ClientSetBlock_GetZ(Packet_ClientSetBlock const *self)
{
	return self->z;
}

void Packet_ClientSetBlock_SetBlockType(Packet_ClientSetBlock *self, int value)
{
	self->blockType = value;
}

void Packet_ClientSetBlock_SetMaterialSlot(Packet_ClientSetBlock *self, int value)
{
	self->materialSlot = value;
}

void Packet_ClientSetBlock_SetMode(Packet_ClientSetBlock *self, int value)
{
	self->mode = value;
}

void Packet_ClientSetBlock_SetX(Packet_ClientSetBlock *self, int value)
{
	self->x = value;
}

void Packet_ClientSetBlock_SetY(Packet_ClientSetBlock *self, int value)
{
	self->y = value;
}

void Packet_ClientSetBlock_SetZ(Packet_ClientSetBlock *self, int value)
{
	self->z = value;
}

Packet_ClientSetBlock const *Packet_ClientSetBlockSerializer_Deserialize(CitoStream const *stream, Packet_ClientSetBlock *instance)
{
	instance->mode = 0;
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->mode = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->blockType = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->materialSlot = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientSetBlock const *Packet_ClientSetBlockSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ClientSetBlock *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ClientSetBlockSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ClientSetBlock const *Packet_ClientSetBlockSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ClientSetBlock *instance)
{
	int limit;
	instance->mode = 0;
	limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->mode = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->blockType = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->materialSlot = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientSetBlock const *Packet_ClientSetBlockSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ClientSetBlock *instance)
{
	int limit;
	instance->mode = 0;
	limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->mode = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->blockType = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->materialSlot = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientSetBlock *Packet_ClientSetBlockSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ClientSetBlock *instance = Packet_ClientSetBlock_New();
	Packet_ClientSetBlockSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ClientSetBlockSerializer_Serialize(CitoStream const *stream, Packet_ClientSetBlock const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->x);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->y);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteUInt64(stream, instance->z);
	if (instance->mode != 0) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
		ProtocolParser_WriteUInt64(stream, instance->mode);
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(40));
	ProtocolParser_WriteUInt64(stream, instance->blockType);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(48));
	ProtocolParser_WriteUInt64(stream, instance->materialSlot);
}

void Packet_ClientSetBlockSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ClientSetBlock const *instance)
{
	unsigned char const *data = Packet_ClientSetBlockSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ClientSetBlockSerializer_SerializeToBytes(Packet_ClientSetBlock const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ClientSetBlockSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ClientShot *Packet_ClientShot_New(void)
{
	Packet_ClientShot *self = (Packet_ClientShot *) malloc(sizeof(Packet_ClientShot));
	return self;
}

void Packet_ClientShot_Delete(Packet_ClientShot *self)
{
	free(self);
}

int Packet_ClientShot_GetExplodesAfter(Packet_ClientShot const *self)
{
	return self->explodesAfter;
}

int Packet_ClientShot_GetFromX(Packet_ClientShot const *self)
{
	return self->fromX;
}

int Packet_ClientShot_GetFromY(Packet_ClientShot const *self)
{
	return self->fromY;
}

int Packet_ClientShot_GetFromZ(Packet_ClientShot const *self)
{
	return self->fromZ;
}

int Packet_ClientShot_GetHitPlayer(Packet_ClientShot const *self)
{
	return self->hitPlayer;
}

int Packet_ClientShot_GetIsHitHead(Packet_ClientShot const *self)
{
	return self->isHitHead;
}

int Packet_ClientShot_GetToX(Packet_ClientShot const *self)
{
	return self->toX;
}

int Packet_ClientShot_GetToY(Packet_ClientShot const *self)
{
	return self->toY;
}

int Packet_ClientShot_GetToZ(Packet_ClientShot const *self)
{
	return self->toZ;
}

int Packet_ClientShot_GetWeaponBlock(Packet_ClientShot const *self)
{
	return self->weaponBlock;
}

void Packet_ClientShot_SetExplodesAfter(Packet_ClientShot *self, int value)
{
	self->explodesAfter = value;
}

void Packet_ClientShot_SetFromX(Packet_ClientShot *self, int value)
{
	self->fromX = value;
}

void Packet_ClientShot_SetFromY(Packet_ClientShot *self, int value)
{
	self->fromY = value;
}

void Packet_ClientShot_SetFromZ(Packet_ClientShot *self, int value)
{
	self->fromZ = value;
}

void Packet_ClientShot_SetHitPlayer(Packet_ClientShot *self, int value)
{
	self->hitPlayer = value;
}

void Packet_ClientShot_SetIsHitHead(Packet_ClientShot *self, int value)
{
	self->isHitHead = value;
}

void Packet_ClientShot_SetToX(Packet_ClientShot *self, int value)
{
	self->toX = value;
}

void Packet_ClientShot_SetToY(Packet_ClientShot *self, int value)
{
	self->toY = value;
}

void Packet_ClientShot_SetToZ(Packet_ClientShot *self, int value)
{
	self->toZ = value;
}

void Packet_ClientShot_SetWeaponBlock(Packet_ClientShot *self, int value)
{
	self->weaponBlock = value;
}

Packet_ClientShot const *Packet_ClientShotSerializer_Deserialize(CitoStream const *stream, Packet_ClientShot *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->fromX = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->fromY = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->fromZ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->toX = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->toY = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->toZ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->weaponBlock = ProtocolParser_ReadUInt64(stream);
			continue;
		case 64:
			instance->hitPlayer = ProtocolParser_ReadUInt64(stream);
			continue;
		case 72:
			instance->isHitHead = ProtocolParser_ReadUInt64(stream);
			continue;
		case 80:
			instance->explodesAfter = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientShot const *Packet_ClientShotSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ClientShot *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ClientShotSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ClientShot const *Packet_ClientShotSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ClientShot *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->fromX = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->fromY = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->fromZ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->toX = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->toY = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->toZ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->weaponBlock = ProtocolParser_ReadUInt64(stream);
			continue;
		case 64:
			instance->hitPlayer = ProtocolParser_ReadUInt64(stream);
			continue;
		case 72:
			instance->isHitHead = ProtocolParser_ReadUInt64(stream);
			continue;
		case 80:
			instance->explodesAfter = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientShot const *Packet_ClientShotSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ClientShot *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->fromX = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->fromY = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->fromZ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->toX = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->toY = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->toZ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->weaponBlock = ProtocolParser_ReadUInt64(stream);
			continue;
		case 64:
			instance->hitPlayer = ProtocolParser_ReadUInt64(stream);
			continue;
		case 72:
			instance->isHitHead = ProtocolParser_ReadUInt64(stream);
			continue;
		case 80:
			instance->explodesAfter = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientShot *Packet_ClientShotSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ClientShot *instance = Packet_ClientShot_New();
	Packet_ClientShotSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ClientShotSerializer_Serialize(CitoStream const *stream, Packet_ClientShot const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->fromX);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->fromY);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteUInt64(stream, instance->fromZ);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
	ProtocolParser_WriteUInt64(stream, instance->toX);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(40));
	ProtocolParser_WriteUInt64(stream, instance->toY);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(48));
	ProtocolParser_WriteUInt64(stream, instance->toZ);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(56));
	ProtocolParser_WriteUInt64(stream, instance->weaponBlock);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(64));
	ProtocolParser_WriteUInt64(stream, instance->hitPlayer);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(72));
	ProtocolParser_WriteUInt64(stream, instance->isHitHead);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(80));
	ProtocolParser_WriteUInt64(stream, instance->explodesAfter);
}

void Packet_ClientShotSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ClientShot const *instance)
{
	unsigned char const *data = Packet_ClientShotSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ClientShotSerializer_SerializeToBytes(Packet_ClientShot const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ClientShotSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ClientSpecialKey *Packet_ClientSpecialKey_New(void)
{
	Packet_ClientSpecialKey *self = (Packet_ClientSpecialKey *) malloc(sizeof(Packet_ClientSpecialKey));
	return self;
}

void Packet_ClientSpecialKey_Delete(Packet_ClientSpecialKey *self)
{
	free(self);
}

int Packet_ClientSpecialKey_GetKey_(Packet_ClientSpecialKey const *self)
{
	return self->key_;
}

void Packet_ClientSpecialKey_SetKey_(Packet_ClientSpecialKey *self, int value)
{
	self->key_ = value;
}

Packet_ClientSpecialKey const *Packet_ClientSpecialKeySerializer_Deserialize(CitoStream const *stream, Packet_ClientSpecialKey *instance)
{
	instance->key_ = 0;
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->key_ = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientSpecialKey const *Packet_ClientSpecialKeySerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ClientSpecialKey *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ClientSpecialKeySerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ClientSpecialKey const *Packet_ClientSpecialKeySerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ClientSpecialKey *instance)
{
	int limit;
	instance->key_ = 0;
	limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->key_ = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientSpecialKey const *Packet_ClientSpecialKeySerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ClientSpecialKey *instance)
{
	int limit;
	instance->key_ = 0;
	limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->key_ = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ClientSpecialKey *Packet_ClientSpecialKeySerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ClientSpecialKey *instance = Packet_ClientSpecialKey_New();
	Packet_ClientSpecialKeySerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ClientSpecialKeySerializer_Serialize(CitoStream const *stream, Packet_ClientSpecialKey const *instance)
{
	if (instance->key_ != 0) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
		ProtocolParser_WriteUInt64(stream, instance->key_);
	}
}

void Packet_ClientSpecialKeySerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ClientSpecialKey const *instance)
{
	unsigned char const *data = Packet_ClientSpecialKeySerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ClientSpecialKeySerializer_SerializeToBytes(Packet_ClientSpecialKey const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ClientSpecialKeySerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_CraftingRecipe *Packet_CraftingRecipe_New(void)
{
	Packet_CraftingRecipe *self = (Packet_CraftingRecipe *) malloc(sizeof(Packet_CraftingRecipe));
	return self;
}

void Packet_CraftingRecipe_Delete(Packet_CraftingRecipe *self)
{
	free(self);
}

Packet_Ingredient const *const *Packet_CraftingRecipe_GetIngredients(Packet_CraftingRecipe const *self)
{
	return self->ingredients;
}

int Packet_CraftingRecipe_GetIngredientsCount(Packet_CraftingRecipe const *self)
{
	return self->ingredientsCount;
}

int Packet_CraftingRecipe_GetIngredientsLength(Packet_CraftingRecipe const *self)
{
	return self->ingredientsLength;
}

Packet_Ingredient const *Packet_CraftingRecipe_GetOutput(Packet_CraftingRecipe const *self)
{
	return self->output;
}

void Packet_CraftingRecipe_IngredientsAdd(Packet_CraftingRecipe *self, Packet_Ingredient const *value)
{
	if (self->ingredientsCount >= self->ingredientsLength) {
		Packet_Ingredient const **Ingredients2 = (Packet_Ingredient const **) malloc(self->ingredientsLength * 2 * sizeof(Packet_Ingredient const *));
		self->ingredientsLength = self->ingredientsLength * 2;
		{
			int i;
			for (i = 0; i < self->ingredientsCount; i++) {
				Ingredients2[i] = self->ingredients[i];
			}
		}
		self->ingredients = Ingredients2;
	}
	self->ingredients[self->ingredientsCount] = value;
	self->ingredientsCount++;
}

void Packet_CraftingRecipe_SetIngredients(Packet_CraftingRecipe *self, Packet_Ingredient const **value, int count, int length)
{
	self->ingredients = value;
	self->ingredientsCount = count;
	self->ingredientsLength = length;
}

void Packet_CraftingRecipe_SetOutput(Packet_CraftingRecipe *self, Packet_Ingredient *value)
{
	self->output = value;
}

Packet_CraftingRecipe const *Packet_CraftingRecipeSerializer_Deserialize(CitoStream const *stream, Packet_CraftingRecipe *instance)
{
	if (instance->ingredients == NULL) {
		instance->ingredients = (Packet_Ingredient const **) malloc(1 * sizeof(Packet_Ingredient const *));
		instance->ingredientsCount = 0;
		instance->ingredientsLength = 1;
	}
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			Packet_CraftingRecipe_IngredientsAdd(instance, Packet_IngredientSerializer_DeserializeLengthDelimitedNew(stream));
			continue;
		case 18:
			if (instance->output == NULL)
				instance->output = Packet_IngredientSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_IngredientSerializer_DeserializeLengthDelimited(stream, instance->output);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_CraftingRecipe const *Packet_CraftingRecipeSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_CraftingRecipe *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_CraftingRecipeSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_CraftingRecipe const *Packet_CraftingRecipeSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_CraftingRecipe *instance)
{
	int limit;
	if (instance->ingredients == NULL) {
		instance->ingredients = (Packet_Ingredient const **) malloc(1 * sizeof(Packet_Ingredient const *));
		instance->ingredientsCount = 0;
		instance->ingredientsLength = 1;
	}
	limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			Packet_CraftingRecipe_IngredientsAdd(instance, Packet_IngredientSerializer_DeserializeLengthDelimitedNew(stream));
			continue;
		case 18:
			if (instance->output == NULL)
				instance->output = Packet_IngredientSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_IngredientSerializer_DeserializeLengthDelimited(stream, instance->output);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_CraftingRecipe const *Packet_CraftingRecipeSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_CraftingRecipe *instance)
{
	int limit;
	if (instance->ingredients == NULL) {
		instance->ingredients = (Packet_Ingredient const **) malloc(1 * sizeof(Packet_Ingredient const *));
		instance->ingredientsCount = 0;
		instance->ingredientsLength = 1;
	}
	limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			Packet_CraftingRecipe_IngredientsAdd(instance, Packet_IngredientSerializer_DeserializeLengthDelimitedNew(stream));
			continue;
		case 18:
			if (instance->output == NULL)
				instance->output = Packet_IngredientSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_IngredientSerializer_DeserializeLengthDelimited(stream, instance->output);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_CraftingRecipe const *Packet_CraftingRecipeSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_CraftingRecipe *instance = Packet_CraftingRecipe_New();
	Packet_CraftingRecipeSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_CraftingRecipeSerializer_Serialize(CitoStream const *stream, Packet_CraftingRecipe const *instance)
{
	if (instance->ingredients != NULL) {
		{
			int k;
			for (k = 0; k < instance->ingredientsCount; k++) {
				Packet_Ingredient const *i1 = instance->ingredients[k];
				CitoMemoryStream const *ms1;
				int ms1Length;
				stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
				ms1 = CitoMemoryStream_New();
				Packet_IngredientSerializer_Serialize(&ms1->base, i1);
				ms1Length = CitoMemoryStream_Length(ms1);
				ProtocolParser_WriteUInt32_(stream, ms1Length);
				stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms1), 0, ms1Length);
			}
		}
	}
	if (instance->output != NULL) {
		CitoMemoryStream const *ms2;
		int ms2Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(18));
		ms2 = CitoMemoryStream_New();
		Packet_IngredientSerializer_Serialize(&ms2->base, instance->output);
		ms2Length = CitoMemoryStream_Length(ms2);
		ProtocolParser_WriteUInt32_(stream, ms2Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms2), 0, ms2Length);
	}
}

void Packet_CraftingRecipeSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_CraftingRecipe const *instance)
{
	unsigned char const *data = Packet_CraftingRecipeSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_CraftingRecipeSerializer_SerializeToBytes(Packet_CraftingRecipe const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_CraftingRecipeSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_Dialog *Packet_Dialog_New(void)
{
	Packet_Dialog *self = (Packet_Dialog *) malloc(sizeof(Packet_Dialog));
	return self;
}

void Packet_Dialog_Delete(Packet_Dialog *self)
{
	free(self);
}

int Packet_Dialog_GetHeight_(Packet_Dialog const *self)
{
	return self->height_;
}

int Packet_Dialog_GetIsModal(Packet_Dialog const *self)
{
	return self->isModal;
}

Packet_Widget const *const *Packet_Dialog_GetWidgets(Packet_Dialog const *self)
{
	return self->widgets;
}

int Packet_Dialog_GetWidgetsCount(Packet_Dialog const *self)
{
	return self->widgetsCount;
}

int Packet_Dialog_GetWidgetsLength(Packet_Dialog const *self)
{
	return self->widgetsLength;
}

int Packet_Dialog_GetWidth(Packet_Dialog const *self)
{
	return self->width;
}

void Packet_Dialog_SetHeight_(Packet_Dialog *self, int value)
{
	self->height_ = value;
}

void Packet_Dialog_SetIsModal(Packet_Dialog *self, int value)
{
	self->isModal = value;
}

void Packet_Dialog_SetWidgets(Packet_Dialog *self, Packet_Widget const **value, int count, int length)
{
	self->widgets = value;
	self->widgetsCount = count;
	self->widgetsLength = length;
}

void Packet_Dialog_SetWidth(Packet_Dialog *self, int value)
{
	self->width = value;
}

void Packet_Dialog_WidgetsAdd(Packet_Dialog *self, Packet_Widget const *value)
{
	if (self->widgetsCount >= self->widgetsLength) {
		Packet_Widget const **Widgets2 = (Packet_Widget const **) malloc(self->widgetsLength * 2 * sizeof(Packet_Widget const *));
		self->widgetsLength = self->widgetsLength * 2;
		{
			int i;
			for (i = 0; i < self->widgetsCount; i++) {
				Widgets2[i] = self->widgets[i];
			}
		}
		self->widgets = Widgets2;
	}
	self->widgets[self->widgetsCount] = value;
	self->widgetsCount++;
}

Packet_DialogFont *Packet_DialogFont_New(void)
{
	Packet_DialogFont *self = (Packet_DialogFont *) malloc(sizeof(Packet_DialogFont));
	return self;
}

void Packet_DialogFont_Delete(Packet_DialogFont *self)
{
	free(self);
}

const char *Packet_DialogFont_GetFamilyName(Packet_DialogFont const *self)
{
	return self->familyName;
}

int Packet_DialogFont_GetFontStyle(Packet_DialogFont const *self)
{
	return self->fontStyle;
}

int Packet_DialogFont_GetSizeFloat(Packet_DialogFont const *self)
{
	return self->sizeFloat;
}

void Packet_DialogFont_SetFamilyName(Packet_DialogFont *self, const char *value)
{
	self->familyName = value;
}

void Packet_DialogFont_SetFontStyle(Packet_DialogFont *self, int value)
{
	self->fontStyle = value;
}

void Packet_DialogFont_SetSizeFloat(Packet_DialogFont *self, int value)
{
	self->sizeFloat = value;
}

Packet_DialogFont const *Packet_DialogFontSerializer_Deserialize(CitoStream const *stream, Packet_DialogFont *instance)
{
	instance->fontStyle = 0;
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance->familyName = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->sizeFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->fontStyle = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_DialogFont const *Packet_DialogFontSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_DialogFont *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_DialogFontSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_DialogFont const *Packet_DialogFontSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_DialogFont *instance)
{
	int limit;
	instance->fontStyle = 0;
	limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->familyName = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->sizeFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->fontStyle = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_DialogFont const *Packet_DialogFontSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_DialogFont *instance)
{
	int limit;
	instance->fontStyle = 0;
	limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->familyName = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->sizeFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->fontStyle = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_DialogFont *Packet_DialogFontSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_DialogFont *instance = Packet_DialogFont_New();
	Packet_DialogFontSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_DialogFontSerializer_Serialize(CitoStream const *stream, Packet_DialogFont const *instance)
{
	if (instance->familyName != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->familyName));
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->sizeFloat);
	if (instance->fontStyle != 0) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
		ProtocolParser_WriteUInt64(stream, instance->fontStyle);
	}
}

void Packet_DialogFontSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_DialogFont const *instance)
{
	unsigned char const *data = Packet_DialogFontSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_DialogFontSerializer_SerializeToBytes(Packet_DialogFont const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_DialogFontSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_Dialog const *Packet_DialogSerializer_Deserialize(CitoStream const *stream, Packet_Dialog *instance)
{
	if (instance->widgets == NULL) {
		instance->widgets = (Packet_Widget const **) malloc(1 * sizeof(Packet_Widget const *));
		instance->widgetsCount = 0;
		instance->widgetsLength = 1;
	}
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			Packet_Dialog_WidgetsAdd(instance, Packet_WidgetSerializer_DeserializeLengthDelimitedNew(stream));
			continue;
		case 16:
			instance->width = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->height_ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->isModal = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_Dialog const *Packet_DialogSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_Dialog *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_DialogSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_Dialog const *Packet_DialogSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_Dialog *instance)
{
	int limit;
	if (instance->widgets == NULL) {
		instance->widgets = (Packet_Widget const **) malloc(1 * sizeof(Packet_Widget const *));
		instance->widgetsCount = 0;
		instance->widgetsLength = 1;
	}
	limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			Packet_Dialog_WidgetsAdd(instance, Packet_WidgetSerializer_DeserializeLengthDelimitedNew(stream));
			continue;
		case 16:
			instance->width = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->height_ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->isModal = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_Dialog const *Packet_DialogSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_Dialog *instance)
{
	int limit;
	if (instance->widgets == NULL) {
		instance->widgets = (Packet_Widget const **) malloc(1 * sizeof(Packet_Widget const *));
		instance->widgetsCount = 0;
		instance->widgetsLength = 1;
	}
	limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			Packet_Dialog_WidgetsAdd(instance, Packet_WidgetSerializer_DeserializeLengthDelimitedNew(stream));
			continue;
		case 16:
			instance->width = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->height_ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->isModal = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_Dialog *Packet_DialogSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_Dialog *instance = Packet_Dialog_New();
	Packet_DialogSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_DialogSerializer_Serialize(CitoStream const *stream, Packet_Dialog const *instance)
{
	if (instance->widgets != NULL) {
		{
			int k;
			for (k = 0; k < instance->widgetsCount; k++) {
				Packet_Widget const *i1 = instance->widgets[k];
				CitoMemoryStream const *ms1;
				int ms1Length;
				stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
				ms1 = CitoMemoryStream_New();
				Packet_WidgetSerializer_Serialize(&ms1->base, i1);
				ms1Length = CitoMemoryStream_Length(ms1);
				ProtocolParser_WriteUInt32_(stream, ms1Length);
				stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms1), 0, ms1Length);
			}
		}
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->width);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteUInt64(stream, instance->height_);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
	ProtocolParser_WriteUInt64(stream, instance->isModal);
}

void Packet_DialogSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_Dialog const *instance)
{
	unsigned char const *data = Packet_DialogSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_DialogSerializer_SerializeToBytes(Packet_Dialog const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_DialogSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_Ingredient *Packet_Ingredient_New(void)
{
	Packet_Ingredient *self = (Packet_Ingredient *) malloc(sizeof(Packet_Ingredient));
	return self;
}

void Packet_Ingredient_Delete(Packet_Ingredient *self)
{
	free(self);
}

int Packet_Ingredient_GetAmount(Packet_Ingredient const *self)
{
	return self->amount;
}

int Packet_Ingredient_GetType(Packet_Ingredient const *self)
{
	return self->type;
}

void Packet_Ingredient_SetAmount(Packet_Ingredient *self, int value)
{
	self->amount = value;
}

void Packet_Ingredient_SetType(Packet_Ingredient *self, int value)
{
	self->type = value;
}

Packet_Ingredient const *Packet_IngredientSerializer_Deserialize(CitoStream const *stream, Packet_Ingredient *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->type = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->amount = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_Ingredient const *Packet_IngredientSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_Ingredient *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_IngredientSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_Ingredient const *Packet_IngredientSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_Ingredient *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->type = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->amount = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_Ingredient const *Packet_IngredientSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_Ingredient *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->type = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->amount = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_Ingredient *Packet_IngredientSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_Ingredient *instance = Packet_Ingredient_New();
	Packet_IngredientSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_IngredientSerializer_Serialize(CitoStream const *stream, Packet_Ingredient const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->type);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->amount);
}

void Packet_IngredientSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_Ingredient const *instance)
{
	unsigned char const *data = Packet_IngredientSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_IngredientSerializer_SerializeToBytes(Packet_Ingredient const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_IngredientSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_IntInt *Packet_IntInt_New(void)
{
	Packet_IntInt *self = (Packet_IntInt *) malloc(sizeof(Packet_IntInt));
	return self;
}

void Packet_IntInt_Delete(Packet_IntInt *self)
{
	free(self);
}

int Packet_IntInt_GetKey_(Packet_IntInt const *self)
{
	return self->key_;
}

int Packet_IntInt_GetValue_(Packet_IntInt const *self)
{
	return self->value_;
}

void Packet_IntInt_SetKey_(Packet_IntInt *self, int value)
{
	self->key_ = value;
}

void Packet_IntInt_SetValue_(Packet_IntInt *self, int value)
{
	self->value_ = value;
}

Packet_IntInt const *Packet_IntIntSerializer_Deserialize(CitoStream const *stream, Packet_IntInt *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->key_ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->value_ = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_IntInt const *Packet_IntIntSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_IntInt *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_IntIntSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_IntInt const *Packet_IntIntSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_IntInt *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->key_ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->value_ = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_IntInt const *Packet_IntIntSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_IntInt *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->key_ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->value_ = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_IntInt const *Packet_IntIntSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_IntInt *instance = Packet_IntInt_New();
	Packet_IntIntSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_IntIntSerializer_Serialize(CitoStream const *stream, Packet_IntInt const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->key_);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->value_);
}

void Packet_IntIntSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_IntInt const *instance)
{
	unsigned char const *data = Packet_IntIntSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_IntIntSerializer_SerializeToBytes(Packet_IntInt const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_IntIntSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_IntString *Packet_IntString_New(void)
{
	Packet_IntString *self = (Packet_IntString *) malloc(sizeof(Packet_IntString));
	return self;
}

void Packet_IntString_Delete(Packet_IntString *self)
{
	free(self);
}

int Packet_IntString_GetKey_(Packet_IntString const *self)
{
	return self->key_;
}

const char *Packet_IntString_GetValue_(Packet_IntString const *self)
{
	return self->value_;
}

void Packet_IntString_SetKey_(Packet_IntString *self, int value)
{
	self->key_ = value;
}

void Packet_IntString_SetValue_(Packet_IntString *self, const char *value)
{
	self->value_ = value;
}

Packet_IntString const *Packet_IntStringSerializer_Deserialize(CitoStream const *stream, Packet_IntString *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->key_ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 18:
			instance->value_ = ProtocolParser_ReadString(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_IntString const *Packet_IntStringSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_IntString *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_IntStringSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_IntString const *Packet_IntStringSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_IntString *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->key_ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 18:
			instance->value_ = ProtocolParser_ReadString(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_IntString const *Packet_IntStringSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_IntString *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->key_ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 18:
			instance->value_ = ProtocolParser_ReadString(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_IntString const *Packet_IntStringSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_IntString *instance = Packet_IntString_New();
	Packet_IntStringSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_IntStringSerializer_Serialize(CitoStream const *stream, Packet_IntString const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->key_);
	if (instance->value_ != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(18));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->value_));
	}
}

void Packet_IntStringSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_IntString const *instance)
{
	unsigned char const *data = Packet_IntStringSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_IntStringSerializer_SerializeToBytes(Packet_IntString const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_IntStringSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_Inventory *Packet_Inventory_New(void)
{
	Packet_Inventory *self = (Packet_Inventory *) malloc(sizeof(Packet_Inventory));
	return self;
}

void Packet_Inventory_Delete(Packet_Inventory *self)
{
	free(self);
}

Packet_Item const *Packet_Inventory_GetBoots(Packet_Inventory const *self)
{
	return self->boots;
}

Packet_Item const *Packet_Inventory_GetDragDropItem(Packet_Inventory const *self)
{
	return self->dragDropItem;
}

Packet_Item const *Packet_Inventory_GetGauntlet(Packet_Inventory const *self)
{
	return self->gauntlet;
}

Packet_Item const *Packet_Inventory_GetHelmet(Packet_Inventory const *self)
{
	return self->helmet;
}

Packet_PositionItem const *const *Packet_Inventory_GetItems(Packet_Inventory const *self)
{
	return self->items;
}

int Packet_Inventory_GetItemsCount(Packet_Inventory const *self)
{
	return self->itemsCount;
}

int Packet_Inventory_GetItemsLength(Packet_Inventory const *self)
{
	return self->itemsLength;
}

Packet_Item const *Packet_Inventory_GetMainArmor(Packet_Inventory const *self)
{
	return self->mainArmor;
}

Packet_Item const *const *Packet_Inventory_GetRightHand(Packet_Inventory const *self)
{
	return self->rightHand;
}

int Packet_Inventory_GetRightHandCount(Packet_Inventory const *self)
{
	return self->rightHandCount;
}

int Packet_Inventory_GetRightHandLength(Packet_Inventory const *self)
{
	return self->rightHandLength;
}

void Packet_Inventory_ItemsAdd(Packet_Inventory *self, Packet_PositionItem const *value)
{
	if (self->itemsCount >= self->itemsLength) {
		Packet_PositionItem const **Items2 = (Packet_PositionItem const **) malloc(self->itemsLength * 2 * sizeof(Packet_PositionItem const *));
		self->itemsLength = self->itemsLength * 2;
		{
			int i;
			for (i = 0; i < self->itemsCount; i++) {
				Items2[i] = self->items[i];
			}
		}
		self->items = Items2;
	}
	self->items[self->itemsCount] = value;
	self->itemsCount++;
}

void Packet_Inventory_RightHandAdd(Packet_Inventory *self, Packet_Item *value)
{
	if (self->rightHandCount >= self->rightHandLength) {
		Packet_Item const **RightHand2 = (Packet_Item const **) malloc(self->rightHandLength * 2 * sizeof(Packet_Item const *));
		self->rightHandLength = self->rightHandLength * 2;
		{
			int i;
			for (i = 0; i < self->rightHandCount; i++) {
				RightHand2[i] = self->rightHand[i];
			}
		}
		self->rightHand = RightHand2;
	}
	self->rightHand[self->rightHandCount] = value;
	self->rightHandCount++;
}

void Packet_Inventory_SetBoots(Packet_Inventory *self, Packet_Item *value)
{
	self->boots = value;
}

void Packet_Inventory_SetDragDropItem(Packet_Inventory *self, Packet_Item *value)
{
	self->dragDropItem = value;
}

void Packet_Inventory_SetGauntlet(Packet_Inventory *self, Packet_Item *value)
{
	self->gauntlet = value;
}

void Packet_Inventory_SetHelmet(Packet_Inventory *self, Packet_Item *value)
{
	self->helmet = value;
}

void Packet_Inventory_SetItems(Packet_Inventory *self, Packet_PositionItem const **value, int count, int length)
{
	self->items = value;
	self->itemsCount = count;
	self->itemsLength = length;
}

void Packet_Inventory_SetMainArmor(Packet_Inventory *self, Packet_Item *value)
{
	self->mainArmor = value;
}

void Packet_Inventory_SetRightHand(Packet_Inventory *self, Packet_Item const **value, int count, int length)
{
	self->rightHand = value;
	self->rightHandCount = count;
	self->rightHandLength = length;
}

Packet_InventoryPosition *Packet_InventoryPosition_New(void)
{
	Packet_InventoryPosition *self = (Packet_InventoryPosition *) malloc(sizeof(Packet_InventoryPosition));
	return self;
}

void Packet_InventoryPosition_Delete(Packet_InventoryPosition *self)
{
	free(self);
}

int Packet_InventoryPosition_GetActiveMaterial(Packet_InventoryPosition const *self)
{
	return self->activeMaterial;
}

int Packet_InventoryPosition_GetAreaX(Packet_InventoryPosition const *self)
{
	return self->areaX;
}

int Packet_InventoryPosition_GetAreaY(Packet_InventoryPosition const *self)
{
	return self->areaY;
}

int Packet_InventoryPosition_GetGroundPositionX(Packet_InventoryPosition const *self)
{
	return self->groundPositionX;
}

int Packet_InventoryPosition_GetGroundPositionY(Packet_InventoryPosition const *self)
{
	return self->groundPositionY;
}

int Packet_InventoryPosition_GetGroundPositionZ(Packet_InventoryPosition const *self)
{
	return self->groundPositionZ;
}

int Packet_InventoryPosition_GetMaterialId(Packet_InventoryPosition const *self)
{
	return self->materialId;
}

int Packet_InventoryPosition_GetType(Packet_InventoryPosition const *self)
{
	return self->type;
}

int Packet_InventoryPosition_GetWearPlace(Packet_InventoryPosition const *self)
{
	return self->wearPlace;
}

void Packet_InventoryPosition_SetActiveMaterial(Packet_InventoryPosition *self, int value)
{
	self->activeMaterial = value;
}

void Packet_InventoryPosition_SetAreaX(Packet_InventoryPosition *self, int value)
{
	self->areaX = value;
}

void Packet_InventoryPosition_SetAreaY(Packet_InventoryPosition *self, int value)
{
	self->areaY = value;
}

void Packet_InventoryPosition_SetGroundPositionX(Packet_InventoryPosition *self, int value)
{
	self->groundPositionX = value;
}

void Packet_InventoryPosition_SetGroundPositionY(Packet_InventoryPosition *self, int value)
{
	self->groundPositionY = value;
}

void Packet_InventoryPosition_SetGroundPositionZ(Packet_InventoryPosition *self, int value)
{
	self->groundPositionZ = value;
}

void Packet_InventoryPosition_SetMaterialId(Packet_InventoryPosition *self, int value)
{
	self->materialId = value;
}

void Packet_InventoryPosition_SetType(Packet_InventoryPosition *self, int value)
{
	self->type = value;
}

void Packet_InventoryPosition_SetWearPlace(Packet_InventoryPosition *self, int value)
{
	self->wearPlace = value;
}

Packet_InventoryPosition const *Packet_InventoryPositionSerializer_Deserialize(CitoStream const *stream, Packet_InventoryPosition *instance)
{
	instance->type = 0;
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->type = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->areaX = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->areaY = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->materialId = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->wearPlace = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->activeMaterial = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->groundPositionX = ProtocolParser_ReadUInt64(stream);
			continue;
		case 64:
			instance->groundPositionY = ProtocolParser_ReadUInt64(stream);
			continue;
		case 72:
			instance->groundPositionZ = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_InventoryPosition const *Packet_InventoryPositionSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_InventoryPosition *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_InventoryPositionSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_InventoryPosition const *Packet_InventoryPositionSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_InventoryPosition *instance)
{
	int limit;
	instance->type = 0;
	limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->type = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->areaX = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->areaY = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->materialId = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->wearPlace = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->activeMaterial = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->groundPositionX = ProtocolParser_ReadUInt64(stream);
			continue;
		case 64:
			instance->groundPositionY = ProtocolParser_ReadUInt64(stream);
			continue;
		case 72:
			instance->groundPositionZ = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_InventoryPosition const *Packet_InventoryPositionSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_InventoryPosition *instance)
{
	int limit;
	instance->type = 0;
	limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->type = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->areaX = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->areaY = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->materialId = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->wearPlace = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->activeMaterial = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->groundPositionX = ProtocolParser_ReadUInt64(stream);
			continue;
		case 64:
			instance->groundPositionY = ProtocolParser_ReadUInt64(stream);
			continue;
		case 72:
			instance->groundPositionZ = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_InventoryPosition *Packet_InventoryPositionSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_InventoryPosition *instance = Packet_InventoryPosition_New();
	Packet_InventoryPositionSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_InventoryPositionSerializer_Serialize(CitoStream const *stream, Packet_InventoryPosition const *instance)
{
	if (instance->type != 0) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
		ProtocolParser_WriteUInt64(stream, instance->type);
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->areaX);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteUInt64(stream, instance->areaY);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
	ProtocolParser_WriteUInt64(stream, instance->materialId);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(40));
	ProtocolParser_WriteUInt64(stream, instance->wearPlace);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(48));
	ProtocolParser_WriteUInt64(stream, instance->activeMaterial);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(56));
	ProtocolParser_WriteUInt64(stream, instance->groundPositionX);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(64));
	ProtocolParser_WriteUInt64(stream, instance->groundPositionY);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(72));
	ProtocolParser_WriteUInt64(stream, instance->groundPositionZ);
}

void Packet_InventoryPositionSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_InventoryPosition const *instance)
{
	unsigned char const *data = Packet_InventoryPositionSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_InventoryPositionSerializer_SerializeToBytes(Packet_InventoryPosition const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_InventoryPositionSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_Inventory const *Packet_InventorySerializer_Deserialize(CitoStream const *stream, Packet_Inventory *instance)
{
	if (instance->items == NULL) {
		instance->items = (Packet_PositionItem const **) malloc(1 * sizeof(Packet_PositionItem const *));
		instance->itemsCount = 0;
		instance->itemsLength = 1;
	}
	if (instance->rightHand == NULL) {
		instance->rightHand = (Packet_Item const **) malloc(1 * sizeof(Packet_Item const *));
		instance->rightHandCount = 0;
		instance->rightHandLength = 1;
	}
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 26:
			if (instance->mainArmor == NULL)
				instance->mainArmor = Packet_ItemSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer_DeserializeLengthDelimited(stream, instance->mainArmor);
			continue;
		case 34:
			if (instance->boots == NULL)
				instance->boots = Packet_ItemSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer_DeserializeLengthDelimited(stream, instance->boots);
			continue;
		case 42:
			if (instance->helmet == NULL)
				instance->helmet = Packet_ItemSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer_DeserializeLengthDelimited(stream, instance->helmet);
			continue;
		case 50:
			if (instance->gauntlet == NULL)
				instance->gauntlet = Packet_ItemSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer_DeserializeLengthDelimited(stream, instance->gauntlet);
			continue;
		case 58:
			Packet_Inventory_ItemsAdd(instance, Packet_PositionItemSerializer_DeserializeLengthDelimitedNew(stream));
			continue;
		case 66:
			if (instance->dragDropItem == NULL)
				instance->dragDropItem = Packet_ItemSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer_DeserializeLengthDelimited(stream, instance->dragDropItem);
			continue;
		case 74:
			Packet_Inventory_RightHandAdd(instance, Packet_ItemSerializer_DeserializeLengthDelimitedNew(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_Inventory const *Packet_InventorySerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_Inventory *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_InventorySerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_Inventory const *Packet_InventorySerializer_DeserializeLength(CitoStream const *stream, int length, Packet_Inventory *instance)
{
	int limit;
	if (instance->items == NULL) {
		instance->items = (Packet_PositionItem const **) malloc(1 * sizeof(Packet_PositionItem const *));
		instance->itemsCount = 0;
		instance->itemsLength = 1;
	}
	if (instance->rightHand == NULL) {
		instance->rightHand = (Packet_Item const **) malloc(1 * sizeof(Packet_Item const *));
		instance->rightHandCount = 0;
		instance->rightHandLength = 1;
	}
	limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 26:
			if (instance->mainArmor == NULL)
				instance->mainArmor = Packet_ItemSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer_DeserializeLengthDelimited(stream, instance->mainArmor);
			continue;
		case 34:
			if (instance->boots == NULL)
				instance->boots = Packet_ItemSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer_DeserializeLengthDelimited(stream, instance->boots);
			continue;
		case 42:
			if (instance->helmet == NULL)
				instance->helmet = Packet_ItemSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer_DeserializeLengthDelimited(stream, instance->helmet);
			continue;
		case 50:
			if (instance->gauntlet == NULL)
				instance->gauntlet = Packet_ItemSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer_DeserializeLengthDelimited(stream, instance->gauntlet);
			continue;
		case 58:
			Packet_Inventory_ItemsAdd(instance, Packet_PositionItemSerializer_DeserializeLengthDelimitedNew(stream));
			continue;
		case 66:
			if (instance->dragDropItem == NULL)
				instance->dragDropItem = Packet_ItemSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer_DeserializeLengthDelimited(stream, instance->dragDropItem);
			continue;
		case 74:
			Packet_Inventory_RightHandAdd(instance, Packet_ItemSerializer_DeserializeLengthDelimitedNew(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_Inventory const *Packet_InventorySerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_Inventory *instance)
{
	int limit;
	if (instance->items == NULL) {
		instance->items = (Packet_PositionItem const **) malloc(1 * sizeof(Packet_PositionItem const *));
		instance->itemsCount = 0;
		instance->itemsLength = 1;
	}
	if (instance->rightHand == NULL) {
		instance->rightHand = (Packet_Item const **) malloc(1 * sizeof(Packet_Item const *));
		instance->rightHandCount = 0;
		instance->rightHandLength = 1;
	}
	limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 26:
			if (instance->mainArmor == NULL)
				instance->mainArmor = Packet_ItemSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer_DeserializeLengthDelimited(stream, instance->mainArmor);
			continue;
		case 34:
			if (instance->boots == NULL)
				instance->boots = Packet_ItemSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer_DeserializeLengthDelimited(stream, instance->boots);
			continue;
		case 42:
			if (instance->helmet == NULL)
				instance->helmet = Packet_ItemSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer_DeserializeLengthDelimited(stream, instance->helmet);
			continue;
		case 50:
			if (instance->gauntlet == NULL)
				instance->gauntlet = Packet_ItemSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer_DeserializeLengthDelimited(stream, instance->gauntlet);
			continue;
		case 58:
			Packet_Inventory_ItemsAdd(instance, Packet_PositionItemSerializer_DeserializeLengthDelimitedNew(stream));
			continue;
		case 66:
			if (instance->dragDropItem == NULL)
				instance->dragDropItem = Packet_ItemSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer_DeserializeLengthDelimited(stream, instance->dragDropItem);
			continue;
		case 74:
			Packet_Inventory_RightHandAdd(instance, Packet_ItemSerializer_DeserializeLengthDelimitedNew(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_Inventory *Packet_InventorySerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_Inventory *instance = Packet_Inventory_New();
	Packet_InventorySerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_InventorySerializer_Serialize(CitoStream const *stream, Packet_Inventory const *instance)
{
	if (instance->mainArmor != NULL) {
		CitoMemoryStream const *ms3;
		int ms3Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(26));
		ms3 = CitoMemoryStream_New();
		Packet_ItemSerializer_Serialize(&ms3->base, instance->mainArmor);
		ms3Length = CitoMemoryStream_Length(ms3);
		ProtocolParser_WriteUInt32_(stream, ms3Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms3), 0, ms3Length);
	}
	if (instance->boots != NULL) {
		CitoMemoryStream const *ms4;
		int ms4Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(34));
		ms4 = CitoMemoryStream_New();
		Packet_ItemSerializer_Serialize(&ms4->base, instance->boots);
		ms4Length = CitoMemoryStream_Length(ms4);
		ProtocolParser_WriteUInt32_(stream, ms4Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms4), 0, ms4Length);
	}
	if (instance->helmet != NULL) {
		CitoMemoryStream const *ms5;
		int ms5Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(42));
		ms5 = CitoMemoryStream_New();
		Packet_ItemSerializer_Serialize(&ms5->base, instance->helmet);
		ms5Length = CitoMemoryStream_Length(ms5);
		ProtocolParser_WriteUInt32_(stream, ms5Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms5), 0, ms5Length);
	}
	if (instance->gauntlet != NULL) {
		CitoMemoryStream const *ms6;
		int ms6Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(50));
		ms6 = CitoMemoryStream_New();
		Packet_ItemSerializer_Serialize(&ms6->base, instance->gauntlet);
		ms6Length = CitoMemoryStream_Length(ms6);
		ProtocolParser_WriteUInt32_(stream, ms6Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms6), 0, ms6Length);
	}
	if (instance->items != NULL) {
		{
			int k;
			for (k = 0; k < instance->itemsCount; k++) {
				Packet_PositionItem const *i7 = instance->items[k];
				CitoMemoryStream const *ms7;
				int ms7Length;
				stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(58));
				ms7 = CitoMemoryStream_New();
				Packet_PositionItemSerializer_Serialize(&ms7->base, i7);
				ms7Length = CitoMemoryStream_Length(ms7);
				ProtocolParser_WriteUInt32_(stream, ms7Length);
				stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms7), 0, ms7Length);
			}
		}
	}
	if (instance->dragDropItem != NULL) {
		CitoMemoryStream const *ms8;
		int ms8Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(66));
		ms8 = CitoMemoryStream_New();
		Packet_ItemSerializer_Serialize(&ms8->base, instance->dragDropItem);
		ms8Length = CitoMemoryStream_Length(ms8);
		ProtocolParser_WriteUInt32_(stream, ms8Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms8), 0, ms8Length);
	}
	if (instance->rightHand != NULL) {
		{
			int k;
			for (k = 0; k < instance->rightHandCount; k++) {
				Packet_Item const *i9 = instance->rightHand[k];
				CitoMemoryStream const *ms9;
				int ms9Length;
				stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(74));
				ms9 = CitoMemoryStream_New();
				Packet_ItemSerializer_Serialize(&ms9->base, i9);
				ms9Length = CitoMemoryStream_Length(ms9);
				ProtocolParser_WriteUInt32_(stream, ms9Length);
				stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms9), 0, ms9Length);
			}
		}
	}
}

void Packet_InventorySerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_Inventory const *instance)
{
	unsigned char const *data = Packet_InventorySerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_InventorySerializer_SerializeToBytes(Packet_Inventory const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_InventorySerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_Item *Packet_Item_New(void)
{
	Packet_Item *self = (Packet_Item *) malloc(sizeof(Packet_Item));
	return self;
}

void Packet_Item_Delete(Packet_Item *self)
{
	free(self);
}

int Packet_Item_GetBlockCount(Packet_Item const *self)
{
	return self->blockCount;
}

int Packet_Item_GetBlockId(Packet_Item const *self)
{
	return self->blockId;
}

int Packet_Item_GetItemClass(Packet_Item const *self)
{
	return self->itemClass;
}

const char *Packet_Item_GetItemId(Packet_Item const *self)
{
	return self->itemId;
}

void Packet_Item_SetBlockCount(Packet_Item *self, int value)
{
	self->blockCount = value;
}

void Packet_Item_SetBlockId(Packet_Item *self, int value)
{
	self->blockId = value;
}

void Packet_Item_SetItemClass(Packet_Item *self, int value)
{
	self->itemClass = value;
}

void Packet_Item_SetItemId(Packet_Item *self, const char *value)
{
	self->itemId = value;
}

Packet_Item const *Packet_ItemSerializer_Deserialize(CitoStream const *stream, Packet_Item *instance)
{
	instance->itemClass = 0;
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->itemClass = ProtocolParser_ReadUInt64(stream);
			continue;
		case 18:
			instance->itemId = ProtocolParser_ReadString(stream);
			continue;
		case 24:
			instance->blockId = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->blockCount = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_Item const *Packet_ItemSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_Item *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ItemSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_Item const *Packet_ItemSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_Item *instance)
{
	int limit;
	instance->itemClass = 0;
	limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->itemClass = ProtocolParser_ReadUInt64(stream);
			continue;
		case 18:
			instance->itemId = ProtocolParser_ReadString(stream);
			continue;
		case 24:
			instance->blockId = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->blockCount = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_Item const *Packet_ItemSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_Item *instance)
{
	int limit;
	instance->itemClass = 0;
	limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->itemClass = ProtocolParser_ReadUInt64(stream);
			continue;
		case 18:
			instance->itemId = ProtocolParser_ReadString(stream);
			continue;
		case 24:
			instance->blockId = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->blockCount = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_Item *Packet_ItemSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_Item *instance = Packet_Item_New();
	Packet_ItemSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ItemSerializer_Serialize(CitoStream const *stream, Packet_Item const *instance)
{
	if (instance->itemClass != 0) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
		ProtocolParser_WriteUInt64(stream, instance->itemClass);
	}
	if (instance->itemId != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(18));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->itemId));
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteUInt64(stream, instance->blockId);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
	ProtocolParser_WriteUInt64(stream, instance->blockCount);
}

void Packet_ItemSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_Item const *instance)
{
	unsigned char const *data = Packet_ItemSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ItemSerializer_SerializeToBytes(Packet_Item const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ItemSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_PositionAndOrientation *Packet_PositionAndOrientation_New(void)
{
	Packet_PositionAndOrientation *self = (Packet_PositionAndOrientation *) malloc(sizeof(Packet_PositionAndOrientation));
	return self;
}

void Packet_PositionAndOrientation_Delete(Packet_PositionAndOrientation *self)
{
	free(self);
}

int Packet_PositionAndOrientation_GetHeading(Packet_PositionAndOrientation const *self)
{
	return self->heading;
}

int Packet_PositionAndOrientation_GetPitch(Packet_PositionAndOrientation const *self)
{
	return self->pitch;
}

int Packet_PositionAndOrientation_GetStance(Packet_PositionAndOrientation const *self)
{
	return self->stance;
}

int Packet_PositionAndOrientation_GetX(Packet_PositionAndOrientation const *self)
{
	return self->x;
}

int Packet_PositionAndOrientation_GetY(Packet_PositionAndOrientation const *self)
{
	return self->y;
}

int Packet_PositionAndOrientation_GetZ(Packet_PositionAndOrientation const *self)
{
	return self->z;
}

void Packet_PositionAndOrientation_SetHeading(Packet_PositionAndOrientation *self, int value)
{
	self->heading = value;
}

void Packet_PositionAndOrientation_SetPitch(Packet_PositionAndOrientation *self, int value)
{
	self->pitch = value;
}

void Packet_PositionAndOrientation_SetStance(Packet_PositionAndOrientation *self, int value)
{
	self->stance = value;
}

void Packet_PositionAndOrientation_SetX(Packet_PositionAndOrientation *self, int value)
{
	self->x = value;
}

void Packet_PositionAndOrientation_SetY(Packet_PositionAndOrientation *self, int value)
{
	self->y = value;
}

void Packet_PositionAndOrientation_SetZ(Packet_PositionAndOrientation *self, int value)
{
	self->z = value;
}

Packet_PositionAndOrientation const *Packet_PositionAndOrientationSerializer_Deserialize(CitoStream const *stream, Packet_PositionAndOrientation *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->heading = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->pitch = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->stance = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_PositionAndOrientation const *Packet_PositionAndOrientationSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_PositionAndOrientation *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_PositionAndOrientationSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_PositionAndOrientation const *Packet_PositionAndOrientationSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_PositionAndOrientation *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->heading = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->pitch = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->stance = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_PositionAndOrientation const *Packet_PositionAndOrientationSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_PositionAndOrientation *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->heading = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->pitch = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->stance = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_PositionAndOrientation *Packet_PositionAndOrientationSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_PositionAndOrientation *instance = Packet_PositionAndOrientation_New();
	Packet_PositionAndOrientationSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_PositionAndOrientationSerializer_Serialize(CitoStream const *stream, Packet_PositionAndOrientation const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->x);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->y);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteUInt64(stream, instance->z);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
	ProtocolParser_WriteUInt64(stream, instance->heading);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(40));
	ProtocolParser_WriteUInt64(stream, instance->pitch);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(48));
	ProtocolParser_WriteUInt64(stream, instance->stance);
}

void Packet_PositionAndOrientationSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_PositionAndOrientation const *instance)
{
	unsigned char const *data = Packet_PositionAndOrientationSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_PositionAndOrientationSerializer_SerializeToBytes(Packet_PositionAndOrientation const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_PositionAndOrientationSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_PositionItem *Packet_PositionItem_New(void)
{
	Packet_PositionItem *self = (Packet_PositionItem *) malloc(sizeof(Packet_PositionItem));
	return self;
}

void Packet_PositionItem_Delete(Packet_PositionItem *self)
{
	free(self);
}

const char *Packet_PositionItem_GetKey_(Packet_PositionItem const *self)
{
	return self->key_;
}

Packet_Item const *Packet_PositionItem_GetValue_(Packet_PositionItem const *self)
{
	return self->value_;
}

int Packet_PositionItem_GetX(Packet_PositionItem const *self)
{
	return self->x;
}

int Packet_PositionItem_GetY(Packet_PositionItem const *self)
{
	return self->y;
}

void Packet_PositionItem_SetKey_(Packet_PositionItem *self, const char *value)
{
	self->key_ = value;
}

void Packet_PositionItem_SetValue_(Packet_PositionItem *self, Packet_Item *value)
{
	self->value_ = value;
}

void Packet_PositionItem_SetX(Packet_PositionItem *self, int value)
{
	self->x = value;
}

void Packet_PositionItem_SetY(Packet_PositionItem *self, int value)
{
	self->y = value;
}

Packet_PositionItem const *Packet_PositionItemSerializer_Deserialize(CitoStream const *stream, Packet_PositionItem *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance->key_ = ProtocolParser_ReadString(stream);
			continue;
		case 18:
			if (instance->value_ == NULL)
				instance->value_ = Packet_ItemSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer_DeserializeLengthDelimited(stream, instance->value_);
			continue;
		case 24:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_PositionItem const *Packet_PositionItemSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_PositionItem *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_PositionItemSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_PositionItem const *Packet_PositionItemSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_PositionItem *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->key_ = ProtocolParser_ReadString(stream);
			continue;
		case 18:
			if (instance->value_ == NULL)
				instance->value_ = Packet_ItemSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer_DeserializeLengthDelimited(stream, instance->value_);
			continue;
		case 24:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_PositionItem const *Packet_PositionItemSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_PositionItem *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->key_ = ProtocolParser_ReadString(stream);
			continue;
		case 18:
			if (instance->value_ == NULL)
				instance->value_ = Packet_ItemSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ItemSerializer_DeserializeLengthDelimited(stream, instance->value_);
			continue;
		case 24:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_PositionItem const *Packet_PositionItemSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_PositionItem *instance = Packet_PositionItem_New();
	Packet_PositionItemSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_PositionItemSerializer_Serialize(CitoStream const *stream, Packet_PositionItem const *instance)
{
	if (instance->key_ != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->key_));
	}
	if (instance->value_ != NULL) {
		CitoMemoryStream const *ms2;
		int ms2Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(18));
		ms2 = CitoMemoryStream_New();
		Packet_ItemSerializer_Serialize(&ms2->base, instance->value_);
		ms2Length = CitoMemoryStream_Length(ms2);
		ProtocolParser_WriteUInt32_(stream, ms2Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms2), 0, ms2Length);
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteUInt64(stream, instance->x);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
	ProtocolParser_WriteUInt64(stream, instance->y);
}

void Packet_PositionItemSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_PositionItem const *instance)
{
	unsigned char const *data = Packet_PositionItemSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_PositionItemSerializer_SerializeToBytes(Packet_PositionItem const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_PositionItemSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_Server *Packet_Server_New(void)
{
	Packet_Server *self = (Packet_Server *) malloc(sizeof(Packet_Server));
	return self;
}

void Packet_Server_Delete(Packet_Server *self)
{
	free(self);
}

Packet_ServerAmmo const *Packet_Server_GetAmmo(Packet_Server const *self)
{
	return self->ammo;
}

Packet_ServerBlobFinalize const *Packet_Server_GetBlobFinalize(Packet_Server const *self)
{
	return self->blobFinalize;
}

Packet_ServerBlobInitialize const *Packet_Server_GetBlobInitialize(Packet_Server const *self)
{
	return self->blobInitialize;
}

Packet_ServerBlobPart const *Packet_Server_GetBlobPart(Packet_Server const *self)
{
	return self->blobPart;
}

Packet_ServerBlockType const *Packet_Server_GetBlockType(Packet_Server const *self)
{
	return self->blockType;
}

Packet_ServerBlockTypes const *Packet_Server_GetBlockTypes(Packet_Server const *self)
{
	return self->blockTypes;
}

Packet_ServerBullet const *Packet_Server_GetBullet(Packet_Server const *self)
{
	return self->bullet;
}

Packet_ServerChunkPart const *Packet_Server_GetChunkPart(Packet_Server const *self)
{
	return self->chunkPart;
}

Packet_ServerChunk const *Packet_Server_GetChunk_(Packet_Server const *self)
{
	return self->chunk_;
}

Packet_ServerCraftingRecipes const *Packet_Server_GetCraftingRecipes(Packet_Server const *self)
{
	return self->craftingRecipes;
}

Packet_ServerDialog const *Packet_Server_GetDialog(Packet_Server const *self)
{
	return self->dialog;
}

Packet_ServerDisconnectPlayer const *Packet_Server_GetDisconnectPlayer(Packet_Server const *self)
{
	return self->disconnectPlayer;
}

Packet_ServerEntityDespawn const *Packet_Server_GetEntityDespawn(Packet_Server const *self)
{
	return self->entityDespawn;
}

Packet_ServerEntityPositionAndOrientation const *Packet_Server_GetEntityPosition(Packet_Server const *self)
{
	return self->entityPosition;
}

Packet_ServerEntitySpawn const *Packet_Server_GetEntitySpawn(Packet_Server const *self)
{
	return self->entitySpawn;
}

Packet_ServerExplosion const *Packet_Server_GetExplosion(Packet_Server const *self)
{
	return self->explosion;
}

Packet_ServerFillArea const *Packet_Server_GetFillArea(Packet_Server const *self)
{
	return self->fillArea;
}

Packet_ServerFillAreaLimit const *Packet_Server_GetFillAreaLimit(Packet_Server const *self)
{
	return self->fillAreaLimit;
}

Packet_ServerFollow const *Packet_Server_GetFollow(Packet_Server const *self)
{
	return self->follow;
}

Packet_ServerFreemove const *Packet_Server_GetFreemove(Packet_Server const *self)
{
	return self->freemove;
}

Packet_ServerHeightmapChunk const *Packet_Server_GetHeightmapChunk(Packet_Server const *self)
{
	return self->heightmapChunk;
}

int Packet_Server_GetId(Packet_Server const *self)
{
	return self->id;
}

Packet_ServerIdentification const *Packet_Server_GetIdentification(Packet_Server const *self)
{
	return self->identification;
}

Packet_ServerInventory const *Packet_Server_GetInventory(Packet_Server const *self)
{
	return self->inventory;
}

Packet_ServerLevelProgress const *Packet_Server_GetLevelDataChunk(Packet_Server const *self)
{
	return self->levelDataChunk;
}

Packet_ServerLevelFinalize const *Packet_Server_GetLevelFinalize(Packet_Server const *self)
{
	return self->levelFinalize;
}

Packet_ServerLevelInitialize const *Packet_Server_GetLevelInitialize(Packet_Server const *self)
{
	return self->levelInitialize;
}

Packet_ServerLightLevels const *Packet_Server_GetLightLevels(Packet_Server const *self)
{
	return self->lightLevels;
}

Packet_ServerMessage const *Packet_Server_GetMessage(Packet_Server const *self)
{
	return self->message;
}

Packet_ServerMonsters const *Packet_Server_GetMonster(Packet_Server const *self)
{
	return self->monster;
}

Packet_ServerPing const *Packet_Server_GetPing(Packet_Server const *self)
{
	return self->ping;
}

Packet_ServerPlayerPing const *Packet_Server_GetPlayerPing(Packet_Server const *self)
{
	return self->playerPing;
}

Packet_ServerPlayerSpawnPosition const *Packet_Server_GetPlayerSpawnPosition(Packet_Server const *self)
{
	return self->playerSpawnPosition;
}

Packet_ServerPlayerStats const *Packet_Server_GetPlayerStats(Packet_Server const *self)
{
	return self->playerStats;
}

Packet_ServerProjectile const *Packet_Server_GetProjectile(Packet_Server const *self)
{
	return self->projectile;
}

Packet_ServerQueryAnswer const *Packet_Server_GetQueryAnswer(Packet_Server const *self)
{
	return self->queryAnswer;
}

Packet_ServerRedirect const *Packet_Server_GetRedirect(Packet_Server const *self)
{
	return self->redirect;
}

Packet_ServerSeason const *Packet_Server_GetSeason(Packet_Server const *self)
{
	return self->season;
}

Packet_ServerSetBlock const *Packet_Server_GetSetBlock(Packet_Server const *self)
{
	return self->setBlock;
}

Packet_ServerSound const *Packet_Server_GetSound(Packet_Server const *self)
{
	return self->sound;
}

Packet_ServerSunLevels const *Packet_Server_GetSunLevels(Packet_Server const *self)
{
	return self->sunLevels;
}

Packet_ServerTranslatedString const *Packet_Server_GetTranslation(Packet_Server const *self)
{
	return self->translation;
}

void Packet_Server_SetAmmo(Packet_Server *self, Packet_ServerAmmo *value)
{
	self->ammo = value;
}

void Packet_Server_SetBlobFinalize(Packet_Server *self, Packet_ServerBlobFinalize const *value)
{
	self->blobFinalize = value;
}

void Packet_Server_SetBlobInitialize(Packet_Server *self, Packet_ServerBlobInitialize *value)
{
	self->blobInitialize = value;
}

void Packet_Server_SetBlobPart(Packet_Server *self, Packet_ServerBlobPart *value)
{
	self->blobPart = value;
}

void Packet_Server_SetBlockType(Packet_Server *self, Packet_ServerBlockType *value)
{
	self->blockType = value;
}

void Packet_Server_SetBlockTypes(Packet_Server *self, Packet_ServerBlockTypes const *value)
{
	self->blockTypes = value;
}

void Packet_Server_SetBullet(Packet_Server *self, Packet_ServerBullet *value)
{
	self->bullet = value;
}

void Packet_Server_SetChunkPart(Packet_Server *self, Packet_ServerChunkPart *value)
{
	self->chunkPart = value;
}

void Packet_Server_SetChunk_(Packet_Server *self, Packet_ServerChunk *value)
{
	self->chunk_ = value;
}

void Packet_Server_SetCraftingRecipes(Packet_Server *self, Packet_ServerCraftingRecipes *value)
{
	self->craftingRecipes = value;
}

void Packet_Server_SetDialog(Packet_Server *self, Packet_ServerDialog *value)
{
	self->dialog = value;
}

void Packet_Server_SetDisconnectPlayer(Packet_Server *self, Packet_ServerDisconnectPlayer *value)
{
	self->disconnectPlayer = value;
}

void Packet_Server_SetEntityDespawn(Packet_Server *self, Packet_ServerEntityDespawn *value)
{
	self->entityDespawn = value;
}

void Packet_Server_SetEntityPosition(Packet_Server *self, Packet_ServerEntityPositionAndOrientation *value)
{
	self->entityPosition = value;
}

void Packet_Server_SetEntitySpawn(Packet_Server *self, Packet_ServerEntitySpawn *value)
{
	self->entitySpawn = value;
}

void Packet_Server_SetExplosion(Packet_Server *self, Packet_ServerExplosion *value)
{
	self->explosion = value;
}

void Packet_Server_SetFillArea(Packet_Server *self, Packet_ServerFillArea *value)
{
	self->fillArea = value;
}

void Packet_Server_SetFillAreaLimit(Packet_Server *self, Packet_ServerFillAreaLimit *value)
{
	self->fillAreaLimit = value;
}

void Packet_Server_SetFollow(Packet_Server *self, Packet_ServerFollow *value)
{
	self->follow = value;
}

void Packet_Server_SetFreemove(Packet_Server *self, Packet_ServerFreemove *value)
{
	self->freemove = value;
}

void Packet_Server_SetHeightmapChunk(Packet_Server *self, Packet_ServerHeightmapChunk *value)
{
	self->heightmapChunk = value;
}

void Packet_Server_SetId(Packet_Server *self, int value)
{
	self->id = value;
}

void Packet_Server_SetIdentification(Packet_Server *self, Packet_ServerIdentification *value)
{
	self->identification = value;
}

void Packet_Server_SetInventory(Packet_Server *self, Packet_ServerInventory *value)
{
	self->inventory = value;
}

void Packet_Server_SetLevelDataChunk(Packet_Server *self, Packet_ServerLevelProgress *value)
{
	self->levelDataChunk = value;
}

void Packet_Server_SetLevelFinalize(Packet_Server *self, Packet_ServerLevelFinalize const *value)
{
	self->levelFinalize = value;
}

void Packet_Server_SetLevelInitialize(Packet_Server *self, Packet_ServerLevelInitialize const *value)
{
	self->levelInitialize = value;
}

void Packet_Server_SetLightLevels(Packet_Server *self, Packet_ServerLightLevels *value)
{
	self->lightLevels = value;
}

void Packet_Server_SetMessage(Packet_Server *self, Packet_ServerMessage *value)
{
	self->message = value;
}

void Packet_Server_SetMonster(Packet_Server *self, Packet_ServerMonsters *value)
{
	self->monster = value;
}

void Packet_Server_SetPing(Packet_Server *self, Packet_ServerPing const *value)
{
	self->ping = value;
}

void Packet_Server_SetPlayerPing(Packet_Server *self, Packet_ServerPlayerPing *value)
{
	self->playerPing = value;
}

void Packet_Server_SetPlayerSpawnPosition(Packet_Server *self, Packet_ServerPlayerSpawnPosition *value)
{
	self->playerSpawnPosition = value;
}

void Packet_Server_SetPlayerStats(Packet_Server *self, Packet_ServerPlayerStats *value)
{
	self->playerStats = value;
}

void Packet_Server_SetProjectile(Packet_Server *self, Packet_ServerProjectile *value)
{
	self->projectile = value;
}

void Packet_Server_SetQueryAnswer(Packet_Server *self, Packet_ServerQueryAnswer *value)
{
	self->queryAnswer = value;
}

void Packet_Server_SetRedirect(Packet_Server *self, Packet_ServerRedirect *value)
{
	self->redirect = value;
}

void Packet_Server_SetSeason(Packet_Server *self, Packet_ServerSeason *value)
{
	self->season = value;
}

void Packet_Server_SetSetBlock(Packet_Server *self, Packet_ServerSetBlock *value)
{
	self->setBlock = value;
}

void Packet_Server_SetSound(Packet_Server *self, Packet_ServerSound *value)
{
	self->sound = value;
}

void Packet_Server_SetSunLevels(Packet_Server *self, Packet_ServerSunLevels *value)
{
	self->sunLevels = value;
}

void Packet_Server_SetTranslation(Packet_Server *self, Packet_ServerTranslatedString *value)
{
	self->translation = value;
}

Packet_ServerAmmo *Packet_ServerAmmo_New(void)
{
	Packet_ServerAmmo *self = (Packet_ServerAmmo *) malloc(sizeof(Packet_ServerAmmo));
	return self;
}

void Packet_ServerAmmo_Delete(Packet_ServerAmmo *self)
{
	free(self);
}

Packet_IntInt const *const *Packet_ServerAmmo_GetTotalAmmo(Packet_ServerAmmo const *self)
{
	return self->totalAmmo;
}

int Packet_ServerAmmo_GetTotalAmmoCount(Packet_ServerAmmo const *self)
{
	return self->totalAmmoCount;
}

int Packet_ServerAmmo_GetTotalAmmoLength(Packet_ServerAmmo const *self)
{
	return self->totalAmmoLength;
}

void Packet_ServerAmmo_SetTotalAmmo(Packet_ServerAmmo *self, Packet_IntInt const **value, int count, int length)
{
	self->totalAmmo = value;
	self->totalAmmoCount = count;
	self->totalAmmoLength = length;
}

void Packet_ServerAmmo_TotalAmmoAdd(Packet_ServerAmmo *self, Packet_IntInt const *value)
{
	if (self->totalAmmoCount >= self->totalAmmoLength) {
		Packet_IntInt const **TotalAmmo2 = (Packet_IntInt const **) malloc(self->totalAmmoLength * 2 * sizeof(Packet_IntInt const *));
		self->totalAmmoLength = self->totalAmmoLength * 2;
		{
			int i;
			for (i = 0; i < self->totalAmmoCount; i++) {
				TotalAmmo2[i] = self->totalAmmo[i];
			}
		}
		self->totalAmmo = TotalAmmo2;
	}
	self->totalAmmo[self->totalAmmoCount] = value;
	self->totalAmmoCount++;
}

Packet_ServerAmmo const *Packet_ServerAmmoSerializer_Deserialize(CitoStream const *stream, Packet_ServerAmmo *instance)
{
	if (instance->totalAmmo == NULL) {
		instance->totalAmmo = (Packet_IntInt const **) malloc(1 * sizeof(Packet_IntInt const *));
		instance->totalAmmoCount = 0;
		instance->totalAmmoLength = 1;
	}
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			Packet_ServerAmmo_TotalAmmoAdd(instance, Packet_IntIntSerializer_DeserializeLengthDelimitedNew(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerAmmo const *Packet_ServerAmmoSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerAmmo *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerAmmoSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerAmmo const *Packet_ServerAmmoSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerAmmo *instance)
{
	int limit;
	if (instance->totalAmmo == NULL) {
		instance->totalAmmo = (Packet_IntInt const **) malloc(1 * sizeof(Packet_IntInt const *));
		instance->totalAmmoCount = 0;
		instance->totalAmmoLength = 1;
	}
	limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			Packet_ServerAmmo_TotalAmmoAdd(instance, Packet_IntIntSerializer_DeserializeLengthDelimitedNew(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerAmmo const *Packet_ServerAmmoSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerAmmo *instance)
{
	int limit;
	if (instance->totalAmmo == NULL) {
		instance->totalAmmo = (Packet_IntInt const **) malloc(1 * sizeof(Packet_IntInt const *));
		instance->totalAmmoCount = 0;
		instance->totalAmmoLength = 1;
	}
	limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			Packet_ServerAmmo_TotalAmmoAdd(instance, Packet_IntIntSerializer_DeserializeLengthDelimitedNew(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerAmmo *Packet_ServerAmmoSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerAmmo *instance = Packet_ServerAmmo_New();
	Packet_ServerAmmoSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerAmmoSerializer_Serialize(CitoStream const *stream, Packet_ServerAmmo const *instance)
{
	if (instance->totalAmmo != NULL) {
		{
			int k;
			for (k = 0; k < instance->totalAmmoCount; k++) {
				Packet_IntInt const *i1 = instance->totalAmmo[k];
				CitoMemoryStream const *ms1;
				int ms1Length;
				stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
				ms1 = CitoMemoryStream_New();
				Packet_IntIntSerializer_Serialize(&ms1->base, i1);
				ms1Length = CitoMemoryStream_Length(ms1);
				ProtocolParser_WriteUInt32_(stream, ms1Length);
				stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms1), 0, ms1Length);
			}
		}
	}
}

void Packet_ServerAmmoSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerAmmo const *instance)
{
	unsigned char const *data = Packet_ServerAmmoSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerAmmoSerializer_SerializeToBytes(Packet_ServerAmmo const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerAmmoSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerBlobFinalize const *Packet_ServerBlobFinalizeSerializer_Deserialize(CitoStream const *stream, Packet_ServerBlobFinalize const *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlobFinalize const *Packet_ServerBlobFinalizeSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerBlobFinalize const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerBlobFinalizeSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerBlobFinalize const *Packet_ServerBlobFinalizeSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerBlobFinalize const *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlobFinalize const *Packet_ServerBlobFinalizeSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerBlobFinalize const *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlobFinalize const *Packet_ServerBlobFinalizeSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerBlobFinalize const *instance = Packet_ServerBlobFinalize_New();
	Packet_ServerBlobFinalizeSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerBlobFinalizeSerializer_Serialize(CitoStream const *stream, Packet_ServerBlobFinalize const *instance)
{
}

void Packet_ServerBlobFinalizeSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerBlobFinalize const *instance)
{
	unsigned char const *data = Packet_ServerBlobFinalizeSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerBlobFinalizeSerializer_SerializeToBytes(Packet_ServerBlobFinalize const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerBlobFinalizeSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerBlobInitialize *Packet_ServerBlobInitialize_New(void)
{
	Packet_ServerBlobInitialize *self = (Packet_ServerBlobInitialize *) malloc(sizeof(Packet_ServerBlobInitialize));
	return self;
}

void Packet_ServerBlobInitialize_Delete(Packet_ServerBlobInitialize *self)
{
	free(self);
}

const char *Packet_ServerBlobInitialize_GetMd5(Packet_ServerBlobInitialize const *self)
{
	return self->md5;
}

const char *Packet_ServerBlobInitialize_GetName(Packet_ServerBlobInitialize const *self)
{
	return self->name;
}

void Packet_ServerBlobInitialize_SetMd5(Packet_ServerBlobInitialize *self, const char *value)
{
	self->md5 = value;
}

void Packet_ServerBlobInitialize_SetName(Packet_ServerBlobInitialize *self, const char *value)
{
	self->name = value;
}

Packet_ServerBlobInitialize const *Packet_ServerBlobInitializeSerializer_Deserialize(CitoStream const *stream, Packet_ServerBlobInitialize *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 18:
			instance->name = ProtocolParser_ReadString(stream);
			continue;
		case 26:
			instance->md5 = ProtocolParser_ReadString(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlobInitialize const *Packet_ServerBlobInitializeSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerBlobInitialize *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerBlobInitializeSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerBlobInitialize const *Packet_ServerBlobInitializeSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerBlobInitialize *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 18:
			instance->name = ProtocolParser_ReadString(stream);
			continue;
		case 26:
			instance->md5 = ProtocolParser_ReadString(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlobInitialize const *Packet_ServerBlobInitializeSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerBlobInitialize *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 18:
			instance->name = ProtocolParser_ReadString(stream);
			continue;
		case 26:
			instance->md5 = ProtocolParser_ReadString(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlobInitialize *Packet_ServerBlobInitializeSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerBlobInitialize *instance = Packet_ServerBlobInitialize_New();
	Packet_ServerBlobInitializeSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerBlobInitializeSerializer_Serialize(CitoStream const *stream, Packet_ServerBlobInitialize const *instance)
{
	if (instance->name != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(18));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->name));
	}
	if (instance->md5 != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(26));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->md5));
	}
}

void Packet_ServerBlobInitializeSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerBlobInitialize const *instance)
{
	unsigned char const *data = Packet_ServerBlobInitializeSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerBlobInitializeSerializer_SerializeToBytes(Packet_ServerBlobInitialize const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerBlobInitializeSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerBlobPart *Packet_ServerBlobPart_New(void)
{
	Packet_ServerBlobPart *self = (Packet_ServerBlobPart *) malloc(sizeof(Packet_ServerBlobPart));
	return self;
}

void Packet_ServerBlobPart_Delete(Packet_ServerBlobPart *self)
{
	free(self);
}

unsigned char const *Packet_ServerBlobPart_GetData(Packet_ServerBlobPart const *self)
{
	return self->data;
}

int Packet_ServerBlobPart_GetIslastpart(Packet_ServerBlobPart const *self)
{
	return self->islastpart;
}

void Packet_ServerBlobPart_SetData(Packet_ServerBlobPart *self, unsigned char const *value)
{
	self->data = value;
}

void Packet_ServerBlobPart_SetIslastpart(Packet_ServerBlobPart *self, int value)
{
	self->islastpart = value;
}

Packet_ServerBlobPart const *Packet_ServerBlobPartSerializer_Deserialize(CitoStream const *stream, Packet_ServerBlobPart *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance->data = ProtocolParser_ReadBytes(stream);
			continue;
		case 16:
			instance->islastpart = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlobPart const *Packet_ServerBlobPartSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerBlobPart *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerBlobPartSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerBlobPart const *Packet_ServerBlobPartSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerBlobPart *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->data = ProtocolParser_ReadBytes(stream);
			continue;
		case 16:
			instance->islastpart = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlobPart const *Packet_ServerBlobPartSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerBlobPart *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->data = ProtocolParser_ReadBytes(stream);
			continue;
		case 16:
			instance->islastpart = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlobPart *Packet_ServerBlobPartSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerBlobPart *instance = Packet_ServerBlobPart_New();
	Packet_ServerBlobPartSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerBlobPartSerializer_Serialize(CitoStream const *stream, Packet_ServerBlobPart const *instance)
{
	if (instance->data != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
		ProtocolParser_WriteBytes(stream, instance->data);
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->islastpart);
}

void Packet_ServerBlobPartSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerBlobPart const *instance)
{
	unsigned char const *data = Packet_ServerBlobPartSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerBlobPartSerializer_SerializeToBytes(Packet_ServerBlobPart const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerBlobPartSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerBlockType *Packet_ServerBlockType_New(void)
{
	Packet_ServerBlockType *self = (Packet_ServerBlockType *) malloc(sizeof(Packet_ServerBlockType));
	return self;
}

void Packet_ServerBlockType_Delete(Packet_ServerBlockType *self)
{
	free(self);
}

Packet_BlockType const *Packet_ServerBlockType_GetBlocktype(Packet_ServerBlockType const *self)
{
	return self->blocktype;
}

int Packet_ServerBlockType_GetId(Packet_ServerBlockType const *self)
{
	return self->id;
}

void Packet_ServerBlockType_SetBlocktype(Packet_ServerBlockType *self, Packet_BlockType *value)
{
	self->blocktype = value;
}

void Packet_ServerBlockType_SetId(Packet_ServerBlockType *self, int value)
{
	self->id = value;
}

Packet_ServerBlockType const *Packet_ServerBlockTypeSerializer_Deserialize(CitoStream const *stream, Packet_ServerBlockType *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->id = ProtocolParser_ReadUInt64(stream);
			continue;
		case 18:
			if (instance->blocktype == NULL)
				instance->blocktype = Packet_BlockTypeSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_BlockTypeSerializer_DeserializeLengthDelimited(stream, instance->blocktype);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlockType const *Packet_ServerBlockTypeSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerBlockType *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerBlockTypeSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerBlockType const *Packet_ServerBlockTypeSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerBlockType *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->id = ProtocolParser_ReadUInt64(stream);
			continue;
		case 18:
			if (instance->blocktype == NULL)
				instance->blocktype = Packet_BlockTypeSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_BlockTypeSerializer_DeserializeLengthDelimited(stream, instance->blocktype);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlockType const *Packet_ServerBlockTypeSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerBlockType *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->id = ProtocolParser_ReadUInt64(stream);
			continue;
		case 18:
			if (instance->blocktype == NULL)
				instance->blocktype = Packet_BlockTypeSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_BlockTypeSerializer_DeserializeLengthDelimited(stream, instance->blocktype);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlockType *Packet_ServerBlockTypeSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerBlockType *instance = Packet_ServerBlockType_New();
	Packet_ServerBlockTypeSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerBlockTypeSerializer_Serialize(CitoStream const *stream, Packet_ServerBlockType const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->id);
	if (instance->blocktype != NULL) {
		CitoMemoryStream const *ms2;
		int ms2Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(18));
		ms2 = CitoMemoryStream_New();
		Packet_BlockTypeSerializer_Serialize(&ms2->base, instance->blocktype);
		ms2Length = CitoMemoryStream_Length(ms2);
		ProtocolParser_WriteUInt32_(stream, ms2Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms2), 0, ms2Length);
	}
}

void Packet_ServerBlockTypeSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerBlockType const *instance)
{
	unsigned char const *data = Packet_ServerBlockTypeSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerBlockTypeSerializer_SerializeToBytes(Packet_ServerBlockType const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerBlockTypeSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerBlockTypes const *Packet_ServerBlockTypesSerializer_Deserialize(CitoStream const *stream, Packet_ServerBlockTypes const *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlockTypes const *Packet_ServerBlockTypesSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerBlockTypes const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerBlockTypesSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerBlockTypes const *Packet_ServerBlockTypesSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerBlockTypes const *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlockTypes const *Packet_ServerBlockTypesSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerBlockTypes const *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBlockTypes const *Packet_ServerBlockTypesSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerBlockTypes const *instance = Packet_ServerBlockTypes_New();
	Packet_ServerBlockTypesSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerBlockTypesSerializer_Serialize(CitoStream const *stream, Packet_ServerBlockTypes const *instance)
{
}

void Packet_ServerBlockTypesSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerBlockTypes const *instance)
{
	unsigned char const *data = Packet_ServerBlockTypesSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerBlockTypesSerializer_SerializeToBytes(Packet_ServerBlockTypes const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerBlockTypesSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerBullet *Packet_ServerBullet_New(void)
{
	Packet_ServerBullet *self = (Packet_ServerBullet *) malloc(sizeof(Packet_ServerBullet));
	return self;
}

void Packet_ServerBullet_Delete(Packet_ServerBullet *self)
{
	free(self);
}

int Packet_ServerBullet_GetFromXFloat(Packet_ServerBullet const *self)
{
	return self->fromXFloat;
}

int Packet_ServerBullet_GetFromYFloat(Packet_ServerBullet const *self)
{
	return self->fromYFloat;
}

int Packet_ServerBullet_GetFromZFloat(Packet_ServerBullet const *self)
{
	return self->fromZFloat;
}

int Packet_ServerBullet_GetSpeedFloat(Packet_ServerBullet const *self)
{
	return self->speedFloat;
}

int Packet_ServerBullet_GetToXFloat(Packet_ServerBullet const *self)
{
	return self->toXFloat;
}

int Packet_ServerBullet_GetToYFloat(Packet_ServerBullet const *self)
{
	return self->toYFloat;
}

int Packet_ServerBullet_GetToZFloat(Packet_ServerBullet const *self)
{
	return self->toZFloat;
}

void Packet_ServerBullet_SetFromXFloat(Packet_ServerBullet *self, int value)
{
	self->fromXFloat = value;
}

void Packet_ServerBullet_SetFromYFloat(Packet_ServerBullet *self, int value)
{
	self->fromYFloat = value;
}

void Packet_ServerBullet_SetFromZFloat(Packet_ServerBullet *self, int value)
{
	self->fromZFloat = value;
}

void Packet_ServerBullet_SetSpeedFloat(Packet_ServerBullet *self, int value)
{
	self->speedFloat = value;
}

void Packet_ServerBullet_SetToXFloat(Packet_ServerBullet *self, int value)
{
	self->toXFloat = value;
}

void Packet_ServerBullet_SetToYFloat(Packet_ServerBullet *self, int value)
{
	self->toYFloat = value;
}

void Packet_ServerBullet_SetToZFloat(Packet_ServerBullet *self, int value)
{
	self->toZFloat = value;
}

Packet_ServerBullet const *Packet_ServerBulletSerializer_Deserialize(CitoStream const *stream, Packet_ServerBullet *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->fromXFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->fromYFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->fromZFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->toXFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->toYFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->toZFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->speedFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBullet const *Packet_ServerBulletSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerBullet *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerBulletSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerBullet const *Packet_ServerBulletSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerBullet *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->fromXFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->fromYFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->fromZFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->toXFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->toYFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->toZFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->speedFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBullet const *Packet_ServerBulletSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerBullet *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->fromXFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->fromYFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->fromZFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->toXFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->toYFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->toZFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->speedFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerBullet *Packet_ServerBulletSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerBullet *instance = Packet_ServerBullet_New();
	Packet_ServerBulletSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerBulletSerializer_Serialize(CitoStream const *stream, Packet_ServerBullet const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->fromXFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->fromYFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteUInt64(stream, instance->fromZFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
	ProtocolParser_WriteUInt64(stream, instance->toXFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(40));
	ProtocolParser_WriteUInt64(stream, instance->toYFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(48));
	ProtocolParser_WriteUInt64(stream, instance->toZFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(56));
	ProtocolParser_WriteUInt64(stream, instance->speedFloat);
}

void Packet_ServerBulletSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerBullet const *instance)
{
	unsigned char const *data = Packet_ServerBulletSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerBulletSerializer_SerializeToBytes(Packet_ServerBullet const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerBulletSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerChunk *Packet_ServerChunk_New(void)
{
	Packet_ServerChunk *self = (Packet_ServerChunk *) malloc(sizeof(Packet_ServerChunk));
	return self;
}

void Packet_ServerChunk_Delete(Packet_ServerChunk *self)
{
	free(self);
}

int Packet_ServerChunk_GetSizeX(Packet_ServerChunk const *self)
{
	return self->sizeX;
}

int Packet_ServerChunk_GetSizeY(Packet_ServerChunk const *self)
{
	return self->sizeY;
}

int Packet_ServerChunk_GetSizeZ(Packet_ServerChunk const *self)
{
	return self->sizeZ;
}

int Packet_ServerChunk_GetX(Packet_ServerChunk const *self)
{
	return self->x;
}

int Packet_ServerChunk_GetY(Packet_ServerChunk const *self)
{
	return self->y;
}

int Packet_ServerChunk_GetZ(Packet_ServerChunk const *self)
{
	return self->z;
}

void Packet_ServerChunk_SetSizeX(Packet_ServerChunk *self, int value)
{
	self->sizeX = value;
}

void Packet_ServerChunk_SetSizeY(Packet_ServerChunk *self, int value)
{
	self->sizeY = value;
}

void Packet_ServerChunk_SetSizeZ(Packet_ServerChunk *self, int value)
{
	self->sizeZ = value;
}

void Packet_ServerChunk_SetX(Packet_ServerChunk *self, int value)
{
	self->x = value;
}

void Packet_ServerChunk_SetY(Packet_ServerChunk *self, int value)
{
	self->y = value;
}

void Packet_ServerChunk_SetZ(Packet_ServerChunk *self, int value)
{
	self->z = value;
}

Packet_ServerChunkPart *Packet_ServerChunkPart_New(void)
{
	Packet_ServerChunkPart *self = (Packet_ServerChunkPart *) malloc(sizeof(Packet_ServerChunkPart));
	return self;
}

void Packet_ServerChunkPart_Delete(Packet_ServerChunkPart *self)
{
	free(self);
}

unsigned char const *Packet_ServerChunkPart_GetCompressedChunkPart(Packet_ServerChunkPart const *self)
{
	return self->compressedChunkPart;
}

void Packet_ServerChunkPart_SetCompressedChunkPart(Packet_ServerChunkPart *self, unsigned char const *value)
{
	self->compressedChunkPart = value;
}

Packet_ServerChunkPart const *Packet_ServerChunkPartSerializer_Deserialize(CitoStream const *stream, Packet_ServerChunkPart *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance->compressedChunkPart = ProtocolParser_ReadBytes(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerChunkPart const *Packet_ServerChunkPartSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerChunkPart *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerChunkPartSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerChunkPart const *Packet_ServerChunkPartSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerChunkPart *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->compressedChunkPart = ProtocolParser_ReadBytes(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerChunkPart const *Packet_ServerChunkPartSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerChunkPart *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->compressedChunkPart = ProtocolParser_ReadBytes(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerChunkPart *Packet_ServerChunkPartSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerChunkPart *instance = Packet_ServerChunkPart_New();
	Packet_ServerChunkPartSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerChunkPartSerializer_Serialize(CitoStream const *stream, Packet_ServerChunkPart const *instance)
{
	if (instance->compressedChunkPart != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
		ProtocolParser_WriteBytes(stream, instance->compressedChunkPart);
	}
}

void Packet_ServerChunkPartSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerChunkPart const *instance)
{
	unsigned char const *data = Packet_ServerChunkPartSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerChunkPartSerializer_SerializeToBytes(Packet_ServerChunkPart const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerChunkPartSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerChunk const *Packet_ServerChunkSerializer_Deserialize(CitoStream const *stream, Packet_ServerChunk *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->sizeX = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->sizeY = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->sizeZ = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerChunk const *Packet_ServerChunkSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerChunk *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerChunkSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerChunk const *Packet_ServerChunkSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerChunk *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->sizeX = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->sizeY = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->sizeZ = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerChunk const *Packet_ServerChunkSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerChunk *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->sizeX = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->sizeY = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->sizeZ = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerChunk *Packet_ServerChunkSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerChunk *instance = Packet_ServerChunk_New();
	Packet_ServerChunkSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerChunkSerializer_Serialize(CitoStream const *stream, Packet_ServerChunk const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->x);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->y);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteUInt64(stream, instance->z);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
	ProtocolParser_WriteUInt64(stream, instance->sizeX);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(40));
	ProtocolParser_WriteUInt64(stream, instance->sizeY);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(48));
	ProtocolParser_WriteUInt64(stream, instance->sizeZ);
}

void Packet_ServerChunkSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerChunk const *instance)
{
	unsigned char const *data = Packet_ServerChunkSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerChunkSerializer_SerializeToBytes(Packet_ServerChunk const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerChunkSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerCraftingRecipes *Packet_ServerCraftingRecipes_New(void)
{
	Packet_ServerCraftingRecipes *self = (Packet_ServerCraftingRecipes *) malloc(sizeof(Packet_ServerCraftingRecipes));
	return self;
}

void Packet_ServerCraftingRecipes_Delete(Packet_ServerCraftingRecipes *self)
{
	free(self);
}

void Packet_ServerCraftingRecipes_CraftingRecipesAdd(Packet_ServerCraftingRecipes *self, Packet_CraftingRecipe const *value)
{
	if (self->craftingRecipesCount >= self->craftingRecipesLength) {
		Packet_CraftingRecipe const **CraftingRecipes2 = (Packet_CraftingRecipe const **) malloc(self->craftingRecipesLength * 2 * sizeof(Packet_CraftingRecipe const *));
		self->craftingRecipesLength = self->craftingRecipesLength * 2;
		{
			int i;
			for (i = 0; i < self->craftingRecipesCount; i++) {
				CraftingRecipes2[i] = self->craftingRecipes[i];
			}
		}
		self->craftingRecipes = CraftingRecipes2;
	}
	self->craftingRecipes[self->craftingRecipesCount] = value;
	self->craftingRecipesCount++;
}

Packet_CraftingRecipe const *const *Packet_ServerCraftingRecipes_GetCraftingRecipes(Packet_ServerCraftingRecipes const *self)
{
	return self->craftingRecipes;
}

int Packet_ServerCraftingRecipes_GetCraftingRecipesCount(Packet_ServerCraftingRecipes const *self)
{
	return self->craftingRecipesCount;
}

int Packet_ServerCraftingRecipes_GetCraftingRecipesLength(Packet_ServerCraftingRecipes const *self)
{
	return self->craftingRecipesLength;
}

void Packet_ServerCraftingRecipes_SetCraftingRecipes(Packet_ServerCraftingRecipes *self, Packet_CraftingRecipe const **value, int count, int length)
{
	self->craftingRecipes = value;
	self->craftingRecipesCount = count;
	self->craftingRecipesLength = length;
}

Packet_ServerCraftingRecipes const *Packet_ServerCraftingRecipesSerializer_Deserialize(CitoStream const *stream, Packet_ServerCraftingRecipes *instance)
{
	if (instance->craftingRecipes == NULL) {
		instance->craftingRecipes = (Packet_CraftingRecipe const **) malloc(1 * sizeof(Packet_CraftingRecipe const *));
		instance->craftingRecipesCount = 0;
		instance->craftingRecipesLength = 1;
	}
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			Packet_ServerCraftingRecipes_CraftingRecipesAdd(instance, Packet_CraftingRecipeSerializer_DeserializeLengthDelimitedNew(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerCraftingRecipes const *Packet_ServerCraftingRecipesSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerCraftingRecipes *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerCraftingRecipesSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerCraftingRecipes const *Packet_ServerCraftingRecipesSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerCraftingRecipes *instance)
{
	int limit;
	if (instance->craftingRecipes == NULL) {
		instance->craftingRecipes = (Packet_CraftingRecipe const **) malloc(1 * sizeof(Packet_CraftingRecipe const *));
		instance->craftingRecipesCount = 0;
		instance->craftingRecipesLength = 1;
	}
	limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			Packet_ServerCraftingRecipes_CraftingRecipesAdd(instance, Packet_CraftingRecipeSerializer_DeserializeLengthDelimitedNew(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerCraftingRecipes const *Packet_ServerCraftingRecipesSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerCraftingRecipes *instance)
{
	int limit;
	if (instance->craftingRecipes == NULL) {
		instance->craftingRecipes = (Packet_CraftingRecipe const **) malloc(1 * sizeof(Packet_CraftingRecipe const *));
		instance->craftingRecipesCount = 0;
		instance->craftingRecipesLength = 1;
	}
	limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			Packet_ServerCraftingRecipes_CraftingRecipesAdd(instance, Packet_CraftingRecipeSerializer_DeserializeLengthDelimitedNew(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerCraftingRecipes *Packet_ServerCraftingRecipesSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerCraftingRecipes *instance = Packet_ServerCraftingRecipes_New();
	Packet_ServerCraftingRecipesSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerCraftingRecipesSerializer_Serialize(CitoStream const *stream, Packet_ServerCraftingRecipes const *instance)
{
	if (instance->craftingRecipes != NULL) {
		{
			int k;
			for (k = 0; k < instance->craftingRecipesCount; k++) {
				Packet_CraftingRecipe const *i1 = instance->craftingRecipes[k];
				CitoMemoryStream const *ms1;
				int ms1Length;
				stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
				ms1 = CitoMemoryStream_New();
				Packet_CraftingRecipeSerializer_Serialize(&ms1->base, i1);
				ms1Length = CitoMemoryStream_Length(ms1);
				ProtocolParser_WriteUInt32_(stream, ms1Length);
				stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms1), 0, ms1Length);
			}
		}
	}
}

void Packet_ServerCraftingRecipesSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerCraftingRecipes const *instance)
{
	unsigned char const *data = Packet_ServerCraftingRecipesSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerCraftingRecipesSerializer_SerializeToBytes(Packet_ServerCraftingRecipes const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerCraftingRecipesSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerDialog *Packet_ServerDialog_New(void)
{
	Packet_ServerDialog *self = (Packet_ServerDialog *) malloc(sizeof(Packet_ServerDialog));
	return self;
}

void Packet_ServerDialog_Delete(Packet_ServerDialog *self)
{
	free(self);
}

Packet_Dialog const *Packet_ServerDialog_GetDialog(Packet_ServerDialog const *self)
{
	return self->dialog;
}

const char *Packet_ServerDialog_GetDialogId(Packet_ServerDialog const *self)
{
	return self->dialogId;
}

void Packet_ServerDialog_SetDialog(Packet_ServerDialog *self, Packet_Dialog *value)
{
	self->dialog = value;
}

void Packet_ServerDialog_SetDialogId(Packet_ServerDialog *self, const char *value)
{
	self->dialogId = value;
}

Packet_ServerDialog const *Packet_ServerDialogSerializer_Deserialize(CitoStream const *stream, Packet_ServerDialog *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance->dialogId = ProtocolParser_ReadString(stream);
			continue;
		case 18:
			if (instance->dialog == NULL)
				instance->dialog = Packet_DialogSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_DialogSerializer_DeserializeLengthDelimited(stream, instance->dialog);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerDialog const *Packet_ServerDialogSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerDialog *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerDialogSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerDialog const *Packet_ServerDialogSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerDialog *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->dialogId = ProtocolParser_ReadString(stream);
			continue;
		case 18:
			if (instance->dialog == NULL)
				instance->dialog = Packet_DialogSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_DialogSerializer_DeserializeLengthDelimited(stream, instance->dialog);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerDialog const *Packet_ServerDialogSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerDialog *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->dialogId = ProtocolParser_ReadString(stream);
			continue;
		case 18:
			if (instance->dialog == NULL)
				instance->dialog = Packet_DialogSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_DialogSerializer_DeserializeLengthDelimited(stream, instance->dialog);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerDialog *Packet_ServerDialogSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerDialog *instance = Packet_ServerDialog_New();
	Packet_ServerDialogSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerDialogSerializer_Serialize(CitoStream const *stream, Packet_ServerDialog const *instance)
{
	if (instance->dialogId != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->dialogId));
	}
	if (instance->dialog != NULL) {
		CitoMemoryStream const *ms2;
		int ms2Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(18));
		ms2 = CitoMemoryStream_New();
		Packet_DialogSerializer_Serialize(&ms2->base, instance->dialog);
		ms2Length = CitoMemoryStream_Length(ms2);
		ProtocolParser_WriteUInt32_(stream, ms2Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms2), 0, ms2Length);
	}
}

void Packet_ServerDialogSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerDialog const *instance)
{
	unsigned char const *data = Packet_ServerDialogSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerDialogSerializer_SerializeToBytes(Packet_ServerDialog const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerDialogSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerDisconnectPlayer *Packet_ServerDisconnectPlayer_New(void)
{
	Packet_ServerDisconnectPlayer *self = (Packet_ServerDisconnectPlayer *) malloc(sizeof(Packet_ServerDisconnectPlayer));
	return self;
}

void Packet_ServerDisconnectPlayer_Delete(Packet_ServerDisconnectPlayer *self)
{
	free(self);
}

const char *Packet_ServerDisconnectPlayer_GetDisconnectReason(Packet_ServerDisconnectPlayer const *self)
{
	return self->disconnectReason;
}

void Packet_ServerDisconnectPlayer_SetDisconnectReason(Packet_ServerDisconnectPlayer *self, const char *value)
{
	self->disconnectReason = value;
}

Packet_ServerDisconnectPlayer const *Packet_ServerDisconnectPlayerSerializer_Deserialize(CitoStream const *stream, Packet_ServerDisconnectPlayer *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance->disconnectReason = ProtocolParser_ReadString(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerDisconnectPlayer const *Packet_ServerDisconnectPlayerSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerDisconnectPlayer *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerDisconnectPlayerSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerDisconnectPlayer const *Packet_ServerDisconnectPlayerSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerDisconnectPlayer *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->disconnectReason = ProtocolParser_ReadString(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerDisconnectPlayer const *Packet_ServerDisconnectPlayerSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerDisconnectPlayer *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->disconnectReason = ProtocolParser_ReadString(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerDisconnectPlayer *Packet_ServerDisconnectPlayerSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerDisconnectPlayer *instance = Packet_ServerDisconnectPlayer_New();
	Packet_ServerDisconnectPlayerSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerDisconnectPlayerSerializer_Serialize(CitoStream const *stream, Packet_ServerDisconnectPlayer const *instance)
{
	if (instance->disconnectReason != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->disconnectReason));
	}
}

void Packet_ServerDisconnectPlayerSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerDisconnectPlayer const *instance)
{
	unsigned char const *data = Packet_ServerDisconnectPlayerSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerDisconnectPlayerSerializer_SerializeToBytes(Packet_ServerDisconnectPlayer const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerDisconnectPlayerSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerEntity *Packet_ServerEntity_New(void)
{
	Packet_ServerEntity *self = (Packet_ServerEntity *) malloc(sizeof(Packet_ServerEntity));
	return self;
}

void Packet_ServerEntity_Delete(Packet_ServerEntity *self)
{
	free(self);
}

Packet_ServerEntityDrawArea const *Packet_ServerEntity_GetDrawArea(Packet_ServerEntity const *self)
{
	return self->drawArea;
}

Packet_ServerEntityDrawBlock const *Packet_ServerEntity_GetDrawBlock(Packet_ServerEntity const *self)
{
	return self->drawBlock;
}

Packet_ServerEntityAnimatedModel const *Packet_ServerEntity_GetDrawModel(Packet_ServerEntity const *self)
{
	return self->drawModel;
}

Packet_ServerEntityDrawName const *Packet_ServerEntity_GetDrawName_(Packet_ServerEntity const *self)
{
	return self->drawName_;
}

Packet_ServerEntityDrawText const *Packet_ServerEntity_GetDrawText(Packet_ServerEntity const *self)
{
	return self->drawText;
}

Packet_ServerPlayerStats const *Packet_ServerEntity_GetPlayerStats(Packet_ServerEntity const *self)
{
	return self->playerStats;
}

Packet_PositionAndOrientation const *Packet_ServerEntity_GetPosition(Packet_ServerEntity const *self)
{
	return self->position;
}

Packet_ServerEntityPush const *Packet_ServerEntity_GetPush(Packet_ServerEntity const *self)
{
	return self->push;
}

cibool Packet_ServerEntity_GetUsable(Packet_ServerEntity const *self)
{
	return self->usable;
}

void Packet_ServerEntity_SetDrawArea(Packet_ServerEntity *self, Packet_ServerEntityDrawArea *value)
{
	self->drawArea = value;
}

void Packet_ServerEntity_SetDrawBlock(Packet_ServerEntity *self, Packet_ServerEntityDrawBlock *value)
{
	self->drawBlock = value;
}

void Packet_ServerEntity_SetDrawModel(Packet_ServerEntity *self, Packet_ServerEntityAnimatedModel *value)
{
	self->drawModel = value;
}

void Packet_ServerEntity_SetDrawName_(Packet_ServerEntity *self, Packet_ServerEntityDrawName *value)
{
	self->drawName_ = value;
}

void Packet_ServerEntity_SetDrawText(Packet_ServerEntity *self, Packet_ServerEntityDrawText *value)
{
	self->drawText = value;
}

void Packet_ServerEntity_SetPlayerStats(Packet_ServerEntity *self, Packet_ServerPlayerStats *value)
{
	self->playerStats = value;
}

void Packet_ServerEntity_SetPosition(Packet_ServerEntity *self, Packet_PositionAndOrientation *value)
{
	self->position = value;
}

void Packet_ServerEntity_SetPush(Packet_ServerEntity *self, Packet_ServerEntityPush *value)
{
	self->push = value;
}

void Packet_ServerEntity_SetUsable(Packet_ServerEntity *self, cibool value)
{
	self->usable = value;
}

Packet_ServerEntityAnimatedModel *Packet_ServerEntityAnimatedModel_New(void)
{
	Packet_ServerEntityAnimatedModel *self = (Packet_ServerEntityAnimatedModel *) malloc(sizeof(Packet_ServerEntityAnimatedModel));
	return self;
}

void Packet_ServerEntityAnimatedModel_Delete(Packet_ServerEntityAnimatedModel *self)
{
	free(self);
}

int Packet_ServerEntityAnimatedModel_GetDownloadSkin(Packet_ServerEntityAnimatedModel const *self)
{
	return self->downloadSkin;
}

int Packet_ServerEntityAnimatedModel_GetEyeHeight(Packet_ServerEntityAnimatedModel const *self)
{
	return self->eyeHeight;
}

int Packet_ServerEntityAnimatedModel_GetModelHeight(Packet_ServerEntityAnimatedModel const *self)
{
	return self->modelHeight;
}

const char *Packet_ServerEntityAnimatedModel_GetModel_(Packet_ServerEntityAnimatedModel const *self)
{
	return self->model_;
}

const char *Packet_ServerEntityAnimatedModel_GetTexture_(Packet_ServerEntityAnimatedModel const *self)
{
	return self->texture_;
}

void Packet_ServerEntityAnimatedModel_SetDownloadSkin(Packet_ServerEntityAnimatedModel *self, int value)
{
	self->downloadSkin = value;
}

void Packet_ServerEntityAnimatedModel_SetEyeHeight(Packet_ServerEntityAnimatedModel *self, int value)
{
	self->eyeHeight = value;
}

void Packet_ServerEntityAnimatedModel_SetModelHeight(Packet_ServerEntityAnimatedModel *self, int value)
{
	self->modelHeight = value;
}

void Packet_ServerEntityAnimatedModel_SetModel_(Packet_ServerEntityAnimatedModel *self, const char *value)
{
	self->model_ = value;
}

void Packet_ServerEntityAnimatedModel_SetTexture_(Packet_ServerEntityAnimatedModel *self, const char *value)
{
	self->texture_ = value;
}

Packet_ServerEntityAnimatedModel const *Packet_ServerEntityAnimatedModelSerializer_Deserialize(CitoStream const *stream, Packet_ServerEntityAnimatedModel *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance->model_ = ProtocolParser_ReadString(stream);
			continue;
		case 18:
			instance->texture_ = ProtocolParser_ReadString(stream);
			continue;
		case 24:
			instance->eyeHeight = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->modelHeight = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->downloadSkin = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityAnimatedModel const *Packet_ServerEntityAnimatedModelSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerEntityAnimatedModel *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerEntityAnimatedModelSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerEntityAnimatedModel const *Packet_ServerEntityAnimatedModelSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerEntityAnimatedModel *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->model_ = ProtocolParser_ReadString(stream);
			continue;
		case 18:
			instance->texture_ = ProtocolParser_ReadString(stream);
			continue;
		case 24:
			instance->eyeHeight = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->modelHeight = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->downloadSkin = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityAnimatedModel const *Packet_ServerEntityAnimatedModelSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerEntityAnimatedModel *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->model_ = ProtocolParser_ReadString(stream);
			continue;
		case 18:
			instance->texture_ = ProtocolParser_ReadString(stream);
			continue;
		case 24:
			instance->eyeHeight = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->modelHeight = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->downloadSkin = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityAnimatedModel *Packet_ServerEntityAnimatedModelSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerEntityAnimatedModel *instance = Packet_ServerEntityAnimatedModel_New();
	Packet_ServerEntityAnimatedModelSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerEntityAnimatedModelSerializer_Serialize(CitoStream const *stream, Packet_ServerEntityAnimatedModel const *instance)
{
	if (instance->model_ != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->model_));
	}
	if (instance->texture_ != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(18));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->texture_));
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteUInt64(stream, instance->eyeHeight);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
	ProtocolParser_WriteUInt64(stream, instance->modelHeight);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(40));
	ProtocolParser_WriteUInt64(stream, instance->downloadSkin);
}

void Packet_ServerEntityAnimatedModelSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerEntityAnimatedModel const *instance)
{
	unsigned char const *data = Packet_ServerEntityAnimatedModelSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerEntityAnimatedModelSerializer_SerializeToBytes(Packet_ServerEntityAnimatedModel const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerEntityAnimatedModelSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerEntityDespawn *Packet_ServerEntityDespawn_New(void)
{
	Packet_ServerEntityDespawn *self = (Packet_ServerEntityDespawn *) malloc(sizeof(Packet_ServerEntityDespawn));
	return self;
}

void Packet_ServerEntityDespawn_Delete(Packet_ServerEntityDespawn *self)
{
	free(self);
}

int Packet_ServerEntityDespawn_GetId(Packet_ServerEntityDespawn const *self)
{
	return self->id;
}

void Packet_ServerEntityDespawn_SetId(Packet_ServerEntityDespawn *self, int value)
{
	self->id = value;
}

Packet_ServerEntityDespawn const *Packet_ServerEntityDespawnSerializer_Deserialize(CitoStream const *stream, Packet_ServerEntityDespawn *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->id = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDespawn const *Packet_ServerEntityDespawnSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerEntityDespawn *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerEntityDespawnSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerEntityDespawn const *Packet_ServerEntityDespawnSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerEntityDespawn *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->id = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDespawn const *Packet_ServerEntityDespawnSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerEntityDespawn *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->id = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDespawn *Packet_ServerEntityDespawnSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerEntityDespawn *instance = Packet_ServerEntityDespawn_New();
	Packet_ServerEntityDespawnSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerEntityDespawnSerializer_Serialize(CitoStream const *stream, Packet_ServerEntityDespawn const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->id);
}

void Packet_ServerEntityDespawnSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerEntityDespawn const *instance)
{
	unsigned char const *data = Packet_ServerEntityDespawnSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerEntityDespawnSerializer_SerializeToBytes(Packet_ServerEntityDespawn const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerEntityDespawnSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerEntityDrawArea *Packet_ServerEntityDrawArea_New(void)
{
	Packet_ServerEntityDrawArea *self = (Packet_ServerEntityDrawArea *) malloc(sizeof(Packet_ServerEntityDrawArea));
	return self;
}

void Packet_ServerEntityDrawArea_Delete(Packet_ServerEntityDrawArea *self)
{
	free(self);
}

int Packet_ServerEntityDrawArea_GetSizex(Packet_ServerEntityDrawArea const *self)
{
	return self->sizex;
}

int Packet_ServerEntityDrawArea_GetSizey(Packet_ServerEntityDrawArea const *self)
{
	return self->sizey;
}

int Packet_ServerEntityDrawArea_GetSizez(Packet_ServerEntityDrawArea const *self)
{
	return self->sizez;
}

int Packet_ServerEntityDrawArea_GetVisibleToClientId(Packet_ServerEntityDrawArea const *self)
{
	return self->visibleToClientId;
}

int Packet_ServerEntityDrawArea_GetX(Packet_ServerEntityDrawArea const *self)
{
	return self->x;
}

int Packet_ServerEntityDrawArea_GetY(Packet_ServerEntityDrawArea const *self)
{
	return self->y;
}

int Packet_ServerEntityDrawArea_GetZ(Packet_ServerEntityDrawArea const *self)
{
	return self->z;
}

void Packet_ServerEntityDrawArea_SetSizex(Packet_ServerEntityDrawArea *self, int value)
{
	self->sizex = value;
}

void Packet_ServerEntityDrawArea_SetSizey(Packet_ServerEntityDrawArea *self, int value)
{
	self->sizey = value;
}

void Packet_ServerEntityDrawArea_SetSizez(Packet_ServerEntityDrawArea *self, int value)
{
	self->sizez = value;
}

void Packet_ServerEntityDrawArea_SetVisibleToClientId(Packet_ServerEntityDrawArea *self, int value)
{
	self->visibleToClientId = value;
}

void Packet_ServerEntityDrawArea_SetX(Packet_ServerEntityDrawArea *self, int value)
{
	self->x = value;
}

void Packet_ServerEntityDrawArea_SetY(Packet_ServerEntityDrawArea *self, int value)
{
	self->y = value;
}

void Packet_ServerEntityDrawArea_SetZ(Packet_ServerEntityDrawArea *self, int value)
{
	self->z = value;
}

Packet_ServerEntityDrawArea const *Packet_ServerEntityDrawAreaSerializer_Deserialize(CitoStream const *stream, Packet_ServerEntityDrawArea *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->sizex = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->sizey = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->sizez = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->visibleToClientId = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDrawArea const *Packet_ServerEntityDrawAreaSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerEntityDrawArea *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerEntityDrawAreaSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerEntityDrawArea const *Packet_ServerEntityDrawAreaSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerEntityDrawArea *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->sizex = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->sizey = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->sizez = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->visibleToClientId = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDrawArea const *Packet_ServerEntityDrawAreaSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerEntityDrawArea *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->sizex = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->sizey = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->sizez = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->visibleToClientId = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDrawArea *Packet_ServerEntityDrawAreaSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerEntityDrawArea *instance = Packet_ServerEntityDrawArea_New();
	Packet_ServerEntityDrawAreaSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerEntityDrawAreaSerializer_Serialize(CitoStream const *stream, Packet_ServerEntityDrawArea const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->x);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->y);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteUInt64(stream, instance->z);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
	ProtocolParser_WriteUInt64(stream, instance->sizex);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(40));
	ProtocolParser_WriteUInt64(stream, instance->sizey);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(48));
	ProtocolParser_WriteUInt64(stream, instance->sizez);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(56));
	ProtocolParser_WriteUInt64(stream, instance->visibleToClientId);
}

void Packet_ServerEntityDrawAreaSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerEntityDrawArea const *instance)
{
	unsigned char const *data = Packet_ServerEntityDrawAreaSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerEntityDrawAreaSerializer_SerializeToBytes(Packet_ServerEntityDrawArea const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerEntityDrawAreaSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerEntityDrawBlock *Packet_ServerEntityDrawBlock_New(void)
{
	Packet_ServerEntityDrawBlock *self = (Packet_ServerEntityDrawBlock *) malloc(sizeof(Packet_ServerEntityDrawBlock));
	return self;
}

void Packet_ServerEntityDrawBlock_Delete(Packet_ServerEntityDrawBlock *self)
{
	free(self);
}

int Packet_ServerEntityDrawBlock_GetBlockType(Packet_ServerEntityDrawBlock const *self)
{
	return self->blockType;
}

void Packet_ServerEntityDrawBlock_SetBlockType(Packet_ServerEntityDrawBlock *self, int value)
{
	self->blockType = value;
}

Packet_ServerEntityDrawBlock const *Packet_ServerEntityDrawBlockSerializer_Deserialize(CitoStream const *stream, Packet_ServerEntityDrawBlock *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->blockType = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDrawBlock const *Packet_ServerEntityDrawBlockSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerEntityDrawBlock *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerEntityDrawBlockSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerEntityDrawBlock const *Packet_ServerEntityDrawBlockSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerEntityDrawBlock *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->blockType = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDrawBlock const *Packet_ServerEntityDrawBlockSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerEntityDrawBlock *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->blockType = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDrawBlock *Packet_ServerEntityDrawBlockSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerEntityDrawBlock *instance = Packet_ServerEntityDrawBlock_New();
	Packet_ServerEntityDrawBlockSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerEntityDrawBlockSerializer_Serialize(CitoStream const *stream, Packet_ServerEntityDrawBlock const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->blockType);
}

void Packet_ServerEntityDrawBlockSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerEntityDrawBlock const *instance)
{
	unsigned char const *data = Packet_ServerEntityDrawBlockSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerEntityDrawBlockSerializer_SerializeToBytes(Packet_ServerEntityDrawBlock const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerEntityDrawBlockSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerEntityDrawName *Packet_ServerEntityDrawName_New(void)
{
	Packet_ServerEntityDrawName *self = (Packet_ServerEntityDrawName *) malloc(sizeof(Packet_ServerEntityDrawName));
	return self;
}

void Packet_ServerEntityDrawName_Delete(Packet_ServerEntityDrawName *self)
{
	free(self);
}

cibool Packet_ServerEntityDrawName_GetClientAutoComplete(Packet_ServerEntityDrawName const *self)
{
	return self->clientAutoComplete;
}

const char *Packet_ServerEntityDrawName_GetColor(Packet_ServerEntityDrawName const *self)
{
	return self->color;
}

const char *Packet_ServerEntityDrawName_GetName(Packet_ServerEntityDrawName const *self)
{
	return self->name;
}

cibool Packet_ServerEntityDrawName_GetOnlyWhenSelected(Packet_ServerEntityDrawName const *self)
{
	return self->onlyWhenSelected;
}

void Packet_ServerEntityDrawName_SetClientAutoComplete(Packet_ServerEntityDrawName *self, cibool value)
{
	self->clientAutoComplete = value;
}

void Packet_ServerEntityDrawName_SetColor(Packet_ServerEntityDrawName *self, const char *value)
{
	self->color = value;
}

void Packet_ServerEntityDrawName_SetName(Packet_ServerEntityDrawName *self, const char *value)
{
	self->name = value;
}

void Packet_ServerEntityDrawName_SetOnlyWhenSelected(Packet_ServerEntityDrawName *self, cibool value)
{
	self->onlyWhenSelected = value;
}

Packet_ServerEntityDrawName const *Packet_ServerEntityDrawNameSerializer_Deserialize(CitoStream const *stream, Packet_ServerEntityDrawName *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance->name = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->onlyWhenSelected = ProtocolParser_ReadBool(stream);
			continue;
		case 24:
			instance->clientAutoComplete = ProtocolParser_ReadBool(stream);
			continue;
		case 34:
			instance->color = ProtocolParser_ReadString(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDrawName const *Packet_ServerEntityDrawNameSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerEntityDrawName *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerEntityDrawNameSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerEntityDrawName const *Packet_ServerEntityDrawNameSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerEntityDrawName *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->name = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->onlyWhenSelected = ProtocolParser_ReadBool(stream);
			continue;
		case 24:
			instance->clientAutoComplete = ProtocolParser_ReadBool(stream);
			continue;
		case 34:
			instance->color = ProtocolParser_ReadString(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDrawName const *Packet_ServerEntityDrawNameSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerEntityDrawName *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->name = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->onlyWhenSelected = ProtocolParser_ReadBool(stream);
			continue;
		case 24:
			instance->clientAutoComplete = ProtocolParser_ReadBool(stream);
			continue;
		case 34:
			instance->color = ProtocolParser_ReadString(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDrawName *Packet_ServerEntityDrawNameSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerEntityDrawName *instance = Packet_ServerEntityDrawName_New();
	Packet_ServerEntityDrawNameSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerEntityDrawNameSerializer_Serialize(CitoStream const *stream, Packet_ServerEntityDrawName const *instance)
{
	if (instance->name != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->name));
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteBool(stream, instance->onlyWhenSelected);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteBool(stream, instance->clientAutoComplete);
	if (instance->color != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(34));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->color));
	}
}

void Packet_ServerEntityDrawNameSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerEntityDrawName const *instance)
{
	unsigned char const *data = Packet_ServerEntityDrawNameSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerEntityDrawNameSerializer_SerializeToBytes(Packet_ServerEntityDrawName const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerEntityDrawNameSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerEntityDrawText *Packet_ServerEntityDrawText_New(void)
{
	Packet_ServerEntityDrawText *self = (Packet_ServerEntityDrawText *) malloc(sizeof(Packet_ServerEntityDrawText));
	return self;
}

void Packet_ServerEntityDrawText_Delete(Packet_ServerEntityDrawText *self)
{
	free(self);
}

int Packet_ServerEntityDrawText_GetDx(Packet_ServerEntityDrawText const *self)
{
	return self->dx;
}

int Packet_ServerEntityDrawText_GetDy(Packet_ServerEntityDrawText const *self)
{
	return self->dy;
}

int Packet_ServerEntityDrawText_GetDz(Packet_ServerEntityDrawText const *self)
{
	return self->dz;
}

int Packet_ServerEntityDrawText_GetRotx(Packet_ServerEntityDrawText const *self)
{
	return self->rotx;
}

int Packet_ServerEntityDrawText_GetRoty(Packet_ServerEntityDrawText const *self)
{
	return self->roty;
}

int Packet_ServerEntityDrawText_GetRotz(Packet_ServerEntityDrawText const *self)
{
	return self->rotz;
}

const char *Packet_ServerEntityDrawText_GetText(Packet_ServerEntityDrawText const *self)
{
	return self->text;
}

void Packet_ServerEntityDrawText_SetDx(Packet_ServerEntityDrawText *self, int value)
{
	self->dx = value;
}

void Packet_ServerEntityDrawText_SetDy(Packet_ServerEntityDrawText *self, int value)
{
	self->dy = value;
}

void Packet_ServerEntityDrawText_SetDz(Packet_ServerEntityDrawText *self, int value)
{
	self->dz = value;
}

void Packet_ServerEntityDrawText_SetRotx(Packet_ServerEntityDrawText *self, int value)
{
	self->rotx = value;
}

void Packet_ServerEntityDrawText_SetRoty(Packet_ServerEntityDrawText *self, int value)
{
	self->roty = value;
}

void Packet_ServerEntityDrawText_SetRotz(Packet_ServerEntityDrawText *self, int value)
{
	self->rotz = value;
}

void Packet_ServerEntityDrawText_SetText(Packet_ServerEntityDrawText *self, const char *value)
{
	self->text = value;
}

Packet_ServerEntityDrawText const *Packet_ServerEntityDrawTextSerializer_Deserialize(CitoStream const *stream, Packet_ServerEntityDrawText *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance->text = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->dx = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->dy = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->dz = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->rotx = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->roty = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->rotz = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDrawText const *Packet_ServerEntityDrawTextSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerEntityDrawText *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerEntityDrawTextSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerEntityDrawText const *Packet_ServerEntityDrawTextSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerEntityDrawText *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->text = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->dx = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->dy = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->dz = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->rotx = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->roty = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->rotz = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDrawText const *Packet_ServerEntityDrawTextSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerEntityDrawText *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->text = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->dx = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->dy = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->dz = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->rotx = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->roty = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->rotz = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityDrawText *Packet_ServerEntityDrawTextSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerEntityDrawText *instance = Packet_ServerEntityDrawText_New();
	Packet_ServerEntityDrawTextSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerEntityDrawTextSerializer_Serialize(CitoStream const *stream, Packet_ServerEntityDrawText const *instance)
{
	if (instance->text != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->text));
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->dx);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteUInt64(stream, instance->dy);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
	ProtocolParser_WriteUInt64(stream, instance->dz);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(40));
	ProtocolParser_WriteUInt64(stream, instance->rotx);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(48));
	ProtocolParser_WriteUInt64(stream, instance->roty);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(56));
	ProtocolParser_WriteUInt64(stream, instance->rotz);
}

void Packet_ServerEntityDrawTextSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerEntityDrawText const *instance)
{
	unsigned char const *data = Packet_ServerEntityDrawTextSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerEntityDrawTextSerializer_SerializeToBytes(Packet_ServerEntityDrawText const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerEntityDrawTextSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerEntityPositionAndOrientation *Packet_ServerEntityPositionAndOrientation_New(void)
{
	Packet_ServerEntityPositionAndOrientation *self = (Packet_ServerEntityPositionAndOrientation *) malloc(sizeof(Packet_ServerEntityPositionAndOrientation));
	return self;
}

void Packet_ServerEntityPositionAndOrientation_Delete(Packet_ServerEntityPositionAndOrientation *self)
{
	free(self);
}

int Packet_ServerEntityPositionAndOrientation_GetId(Packet_ServerEntityPositionAndOrientation const *self)
{
	return self->id;
}

Packet_PositionAndOrientation const *Packet_ServerEntityPositionAndOrientation_GetPositionAndOrientation(Packet_ServerEntityPositionAndOrientation const *self)
{
	return self->positionAndOrientation;
}

void Packet_ServerEntityPositionAndOrientation_SetId(Packet_ServerEntityPositionAndOrientation *self, int value)
{
	self->id = value;
}

void Packet_ServerEntityPositionAndOrientation_SetPositionAndOrientation(Packet_ServerEntityPositionAndOrientation *self, Packet_PositionAndOrientation *value)
{
	self->positionAndOrientation = value;
}

Packet_ServerEntityPositionAndOrientation const *Packet_ServerEntityPositionAndOrientationSerializer_Deserialize(CitoStream const *stream, Packet_ServerEntityPositionAndOrientation *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->id = ProtocolParser_ReadUInt64(stream);
			continue;
		case 18:
			if (instance->positionAndOrientation == NULL)
				instance->positionAndOrientation = Packet_PositionAndOrientationSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_PositionAndOrientationSerializer_DeserializeLengthDelimited(stream, instance->positionAndOrientation);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityPositionAndOrientation const *Packet_ServerEntityPositionAndOrientationSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerEntityPositionAndOrientation *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerEntityPositionAndOrientationSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerEntityPositionAndOrientation const *Packet_ServerEntityPositionAndOrientationSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerEntityPositionAndOrientation *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->id = ProtocolParser_ReadUInt64(stream);
			continue;
		case 18:
			if (instance->positionAndOrientation == NULL)
				instance->positionAndOrientation = Packet_PositionAndOrientationSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_PositionAndOrientationSerializer_DeserializeLengthDelimited(stream, instance->positionAndOrientation);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityPositionAndOrientation const *Packet_ServerEntityPositionAndOrientationSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerEntityPositionAndOrientation *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->id = ProtocolParser_ReadUInt64(stream);
			continue;
		case 18:
			if (instance->positionAndOrientation == NULL)
				instance->positionAndOrientation = Packet_PositionAndOrientationSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_PositionAndOrientationSerializer_DeserializeLengthDelimited(stream, instance->positionAndOrientation);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityPositionAndOrientation *Packet_ServerEntityPositionAndOrientationSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerEntityPositionAndOrientation *instance = Packet_ServerEntityPositionAndOrientation_New();
	Packet_ServerEntityPositionAndOrientationSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerEntityPositionAndOrientationSerializer_Serialize(CitoStream const *stream, Packet_ServerEntityPositionAndOrientation const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->id);
	if (instance->positionAndOrientation != NULL) {
		CitoMemoryStream const *ms2;
		int ms2Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(18));
		ms2 = CitoMemoryStream_New();
		Packet_PositionAndOrientationSerializer_Serialize(&ms2->base, instance->positionAndOrientation);
		ms2Length = CitoMemoryStream_Length(ms2);
		ProtocolParser_WriteUInt32_(stream, ms2Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms2), 0, ms2Length);
	}
}

void Packet_ServerEntityPositionAndOrientationSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerEntityPositionAndOrientation const *instance)
{
	unsigned char const *data = Packet_ServerEntityPositionAndOrientationSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerEntityPositionAndOrientationSerializer_SerializeToBytes(Packet_ServerEntityPositionAndOrientation const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerEntityPositionAndOrientationSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerEntityPush *Packet_ServerEntityPush_New(void)
{
	Packet_ServerEntityPush *self = (Packet_ServerEntityPush *) malloc(sizeof(Packet_ServerEntityPush));
	return self;
}

void Packet_ServerEntityPush_Delete(Packet_ServerEntityPush *self)
{
	free(self);
}

int Packet_ServerEntityPush_GetRangeFloat(Packet_ServerEntityPush const *self)
{
	return self->rangeFloat;
}

void Packet_ServerEntityPush_SetRangeFloat(Packet_ServerEntityPush *self, int value)
{
	self->rangeFloat = value;
}

Packet_ServerEntityPush const *Packet_ServerEntityPushSerializer_Deserialize(CitoStream const *stream, Packet_ServerEntityPush *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->rangeFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityPush const *Packet_ServerEntityPushSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerEntityPush *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerEntityPushSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerEntityPush const *Packet_ServerEntityPushSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerEntityPush *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->rangeFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityPush const *Packet_ServerEntityPushSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerEntityPush *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->rangeFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntityPush *Packet_ServerEntityPushSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerEntityPush *instance = Packet_ServerEntityPush_New();
	Packet_ServerEntityPushSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerEntityPushSerializer_Serialize(CitoStream const *stream, Packet_ServerEntityPush const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->rangeFloat);
}

void Packet_ServerEntityPushSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerEntityPush const *instance)
{
	unsigned char const *data = Packet_ServerEntityPushSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerEntityPushSerializer_SerializeToBytes(Packet_ServerEntityPush const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerEntityPushSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerEntity const *Packet_ServerEntitySerializer_Deserialize(CitoStream const *stream, Packet_ServerEntity *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			if (instance->position == NULL)
				instance->position = Packet_PositionAndOrientationSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_PositionAndOrientationSerializer_DeserializeLengthDelimited(stream, instance->position);
			continue;
		case 18:
			if (instance->drawModel == NULL)
				instance->drawModel = Packet_ServerEntityAnimatedModelSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityAnimatedModelSerializer_DeserializeLengthDelimited(stream, instance->drawModel);
			continue;
		case 26:
			if (instance->drawName_ == NULL)
				instance->drawName_ = Packet_ServerEntityDrawNameSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDrawNameSerializer_DeserializeLengthDelimited(stream, instance->drawName_);
			continue;
		case 34:
			if (instance->drawText == NULL)
				instance->drawText = Packet_ServerEntityDrawTextSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDrawTextSerializer_DeserializeLengthDelimited(stream, instance->drawText);
			continue;
		case 42:
			if (instance->drawBlock == NULL)
				instance->drawBlock = Packet_ServerEntityDrawBlockSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDrawBlockSerializer_DeserializeLengthDelimited(stream, instance->drawBlock);
			continue;
		case 50:
			if (instance->push == NULL)
				instance->push = Packet_ServerEntityPushSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityPushSerializer_DeserializeLengthDelimited(stream, instance->push);
			continue;
		case 56:
			instance->usable = ProtocolParser_ReadBool(stream);
			continue;
		case 66:
			if (instance->playerStats == NULL)
				instance->playerStats = Packet_ServerPlayerStatsSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPlayerStatsSerializer_DeserializeLengthDelimited(stream, instance->playerStats);
			continue;
		case 74:
			if (instance->drawArea == NULL)
				instance->drawArea = Packet_ServerEntityDrawAreaSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDrawAreaSerializer_DeserializeLengthDelimited(stream, instance->drawArea);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntity const *Packet_ServerEntitySerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerEntity *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerEntitySerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerEntity const *Packet_ServerEntitySerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerEntity *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			if (instance->position == NULL)
				instance->position = Packet_PositionAndOrientationSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_PositionAndOrientationSerializer_DeserializeLengthDelimited(stream, instance->position);
			continue;
		case 18:
			if (instance->drawModel == NULL)
				instance->drawModel = Packet_ServerEntityAnimatedModelSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityAnimatedModelSerializer_DeserializeLengthDelimited(stream, instance->drawModel);
			continue;
		case 26:
			if (instance->drawName_ == NULL)
				instance->drawName_ = Packet_ServerEntityDrawNameSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDrawNameSerializer_DeserializeLengthDelimited(stream, instance->drawName_);
			continue;
		case 34:
			if (instance->drawText == NULL)
				instance->drawText = Packet_ServerEntityDrawTextSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDrawTextSerializer_DeserializeLengthDelimited(stream, instance->drawText);
			continue;
		case 42:
			if (instance->drawBlock == NULL)
				instance->drawBlock = Packet_ServerEntityDrawBlockSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDrawBlockSerializer_DeserializeLengthDelimited(stream, instance->drawBlock);
			continue;
		case 50:
			if (instance->push == NULL)
				instance->push = Packet_ServerEntityPushSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityPushSerializer_DeserializeLengthDelimited(stream, instance->push);
			continue;
		case 56:
			instance->usable = ProtocolParser_ReadBool(stream);
			continue;
		case 66:
			if (instance->playerStats == NULL)
				instance->playerStats = Packet_ServerPlayerStatsSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPlayerStatsSerializer_DeserializeLengthDelimited(stream, instance->playerStats);
			continue;
		case 74:
			if (instance->drawArea == NULL)
				instance->drawArea = Packet_ServerEntityDrawAreaSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDrawAreaSerializer_DeserializeLengthDelimited(stream, instance->drawArea);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntity const *Packet_ServerEntitySerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerEntity *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			if (instance->position == NULL)
				instance->position = Packet_PositionAndOrientationSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_PositionAndOrientationSerializer_DeserializeLengthDelimited(stream, instance->position);
			continue;
		case 18:
			if (instance->drawModel == NULL)
				instance->drawModel = Packet_ServerEntityAnimatedModelSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityAnimatedModelSerializer_DeserializeLengthDelimited(stream, instance->drawModel);
			continue;
		case 26:
			if (instance->drawName_ == NULL)
				instance->drawName_ = Packet_ServerEntityDrawNameSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDrawNameSerializer_DeserializeLengthDelimited(stream, instance->drawName_);
			continue;
		case 34:
			if (instance->drawText == NULL)
				instance->drawText = Packet_ServerEntityDrawTextSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDrawTextSerializer_DeserializeLengthDelimited(stream, instance->drawText);
			continue;
		case 42:
			if (instance->drawBlock == NULL)
				instance->drawBlock = Packet_ServerEntityDrawBlockSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDrawBlockSerializer_DeserializeLengthDelimited(stream, instance->drawBlock);
			continue;
		case 50:
			if (instance->push == NULL)
				instance->push = Packet_ServerEntityPushSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityPushSerializer_DeserializeLengthDelimited(stream, instance->push);
			continue;
		case 56:
			instance->usable = ProtocolParser_ReadBool(stream);
			continue;
		case 66:
			if (instance->playerStats == NULL)
				instance->playerStats = Packet_ServerPlayerStatsSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPlayerStatsSerializer_DeserializeLengthDelimited(stream, instance->playerStats);
			continue;
		case 74:
			if (instance->drawArea == NULL)
				instance->drawArea = Packet_ServerEntityDrawAreaSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDrawAreaSerializer_DeserializeLengthDelimited(stream, instance->drawArea);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntity *Packet_ServerEntitySerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerEntity *instance = Packet_ServerEntity_New();
	Packet_ServerEntitySerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerEntitySerializer_Serialize(CitoStream const *stream, Packet_ServerEntity const *instance)
{
	if (instance->position != NULL) {
		CitoMemoryStream const *ms1;
		int ms1Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
		ms1 = CitoMemoryStream_New();
		Packet_PositionAndOrientationSerializer_Serialize(&ms1->base, instance->position);
		ms1Length = CitoMemoryStream_Length(ms1);
		ProtocolParser_WriteUInt32_(stream, ms1Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms1), 0, ms1Length);
	}
	if (instance->drawModel != NULL) {
		CitoMemoryStream const *ms2;
		int ms2Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(18));
		ms2 = CitoMemoryStream_New();
		Packet_ServerEntityAnimatedModelSerializer_Serialize(&ms2->base, instance->drawModel);
		ms2Length = CitoMemoryStream_Length(ms2);
		ProtocolParser_WriteUInt32_(stream, ms2Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms2), 0, ms2Length);
	}
	if (instance->drawName_ != NULL) {
		CitoMemoryStream const *ms3;
		int ms3Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(26));
		ms3 = CitoMemoryStream_New();
		Packet_ServerEntityDrawNameSerializer_Serialize(&ms3->base, instance->drawName_);
		ms3Length = CitoMemoryStream_Length(ms3);
		ProtocolParser_WriteUInt32_(stream, ms3Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms3), 0, ms3Length);
	}
	if (instance->drawText != NULL) {
		CitoMemoryStream const *ms4;
		int ms4Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(34));
		ms4 = CitoMemoryStream_New();
		Packet_ServerEntityDrawTextSerializer_Serialize(&ms4->base, instance->drawText);
		ms4Length = CitoMemoryStream_Length(ms4);
		ProtocolParser_WriteUInt32_(stream, ms4Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms4), 0, ms4Length);
	}
	if (instance->drawBlock != NULL) {
		CitoMemoryStream const *ms5;
		int ms5Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(42));
		ms5 = CitoMemoryStream_New();
		Packet_ServerEntityDrawBlockSerializer_Serialize(&ms5->base, instance->drawBlock);
		ms5Length = CitoMemoryStream_Length(ms5);
		ProtocolParser_WriteUInt32_(stream, ms5Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms5), 0, ms5Length);
	}
	if (instance->push != NULL) {
		CitoMemoryStream const *ms6;
		int ms6Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(50));
		ms6 = CitoMemoryStream_New();
		Packet_ServerEntityPushSerializer_Serialize(&ms6->base, instance->push);
		ms6Length = CitoMemoryStream_Length(ms6);
		ProtocolParser_WriteUInt32_(stream, ms6Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms6), 0, ms6Length);
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(56));
	ProtocolParser_WriteBool(stream, instance->usable);
	if (instance->playerStats != NULL) {
		CitoMemoryStream const *ms8;
		int ms8Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(66));
		ms8 = CitoMemoryStream_New();
		Packet_ServerPlayerStatsSerializer_Serialize(&ms8->base, instance->playerStats);
		ms8Length = CitoMemoryStream_Length(ms8);
		ProtocolParser_WriteUInt32_(stream, ms8Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms8), 0, ms8Length);
	}
	if (instance->drawArea != NULL) {
		CitoMemoryStream const *ms9;
		int ms9Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(74));
		ms9 = CitoMemoryStream_New();
		Packet_ServerEntityDrawAreaSerializer_Serialize(&ms9->base, instance->drawArea);
		ms9Length = CitoMemoryStream_Length(ms9);
		ProtocolParser_WriteUInt32_(stream, ms9Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms9), 0, ms9Length);
	}
}

void Packet_ServerEntitySerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerEntity const *instance)
{
	unsigned char const *data = Packet_ServerEntitySerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerEntitySerializer_SerializeToBytes(Packet_ServerEntity const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerEntitySerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerEntitySpawn *Packet_ServerEntitySpawn_New(void)
{
	Packet_ServerEntitySpawn *self = (Packet_ServerEntitySpawn *) malloc(sizeof(Packet_ServerEntitySpawn));
	return self;
}

void Packet_ServerEntitySpawn_Delete(Packet_ServerEntitySpawn *self)
{
	free(self);
}

Packet_ServerEntity const *Packet_ServerEntitySpawn_GetEntity_(Packet_ServerEntitySpawn const *self)
{
	return self->entity_;
}

int Packet_ServerEntitySpawn_GetId(Packet_ServerEntitySpawn const *self)
{
	return self->id;
}

void Packet_ServerEntitySpawn_SetEntity_(Packet_ServerEntitySpawn *self, Packet_ServerEntity *value)
{
	self->entity_ = value;
}

void Packet_ServerEntitySpawn_SetId(Packet_ServerEntitySpawn *self, int value)
{
	self->id = value;
}

Packet_ServerEntitySpawn const *Packet_ServerEntitySpawnSerializer_Deserialize(CitoStream const *stream, Packet_ServerEntitySpawn *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->id = ProtocolParser_ReadUInt64(stream);
			continue;
		case 18:
			if (instance->entity_ == NULL)
				instance->entity_ = Packet_ServerEntitySerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntitySerializer_DeserializeLengthDelimited(stream, instance->entity_);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntitySpawn const *Packet_ServerEntitySpawnSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerEntitySpawn *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerEntitySpawnSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerEntitySpawn const *Packet_ServerEntitySpawnSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerEntitySpawn *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->id = ProtocolParser_ReadUInt64(stream);
			continue;
		case 18:
			if (instance->entity_ == NULL)
				instance->entity_ = Packet_ServerEntitySerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntitySerializer_DeserializeLengthDelimited(stream, instance->entity_);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntitySpawn const *Packet_ServerEntitySpawnSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerEntitySpawn *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->id = ProtocolParser_ReadUInt64(stream);
			continue;
		case 18:
			if (instance->entity_ == NULL)
				instance->entity_ = Packet_ServerEntitySerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntitySerializer_DeserializeLengthDelimited(stream, instance->entity_);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerEntitySpawn *Packet_ServerEntitySpawnSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerEntitySpawn *instance = Packet_ServerEntitySpawn_New();
	Packet_ServerEntitySpawnSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerEntitySpawnSerializer_Serialize(CitoStream const *stream, Packet_ServerEntitySpawn const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->id);
	if (instance->entity_ != NULL) {
		CitoMemoryStream const *ms2;
		int ms2Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(18));
		ms2 = CitoMemoryStream_New();
		Packet_ServerEntitySerializer_Serialize(&ms2->base, instance->entity_);
		ms2Length = CitoMemoryStream_Length(ms2);
		ProtocolParser_WriteUInt32_(stream, ms2Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms2), 0, ms2Length);
	}
}

void Packet_ServerEntitySpawnSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerEntitySpawn const *instance)
{
	unsigned char const *data = Packet_ServerEntitySpawnSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerEntitySpawnSerializer_SerializeToBytes(Packet_ServerEntitySpawn const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerEntitySpawnSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerExplosion *Packet_ServerExplosion_New(void)
{
	Packet_ServerExplosion *self = (Packet_ServerExplosion *) malloc(sizeof(Packet_ServerExplosion));
	return self;
}

void Packet_ServerExplosion_Delete(Packet_ServerExplosion *self)
{
	free(self);
}

int Packet_ServerExplosion_GetIsRelativeToPlayerPosition(Packet_ServerExplosion const *self)
{
	return self->isRelativeToPlayerPosition;
}

int Packet_ServerExplosion_GetRangeFloat(Packet_ServerExplosion const *self)
{
	return self->rangeFloat;
}

int Packet_ServerExplosion_GetTimeFloat(Packet_ServerExplosion const *self)
{
	return self->timeFloat;
}

int Packet_ServerExplosion_GetXFloat(Packet_ServerExplosion const *self)
{
	return self->xFloat;
}

int Packet_ServerExplosion_GetYFloat(Packet_ServerExplosion const *self)
{
	return self->yFloat;
}

int Packet_ServerExplosion_GetZFloat(Packet_ServerExplosion const *self)
{
	return self->zFloat;
}

void Packet_ServerExplosion_SetIsRelativeToPlayerPosition(Packet_ServerExplosion *self, int value)
{
	self->isRelativeToPlayerPosition = value;
}

void Packet_ServerExplosion_SetRangeFloat(Packet_ServerExplosion *self, int value)
{
	self->rangeFloat = value;
}

void Packet_ServerExplosion_SetTimeFloat(Packet_ServerExplosion *self, int value)
{
	self->timeFloat = value;
}

void Packet_ServerExplosion_SetXFloat(Packet_ServerExplosion *self, int value)
{
	self->xFloat = value;
}

void Packet_ServerExplosion_SetYFloat(Packet_ServerExplosion *self, int value)
{
	self->yFloat = value;
}

void Packet_ServerExplosion_SetZFloat(Packet_ServerExplosion *self, int value)
{
	self->zFloat = value;
}

Packet_ServerExplosion const *Packet_ServerExplosionSerializer_Deserialize(CitoStream const *stream, Packet_ServerExplosion *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->xFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->yFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->zFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->isRelativeToPlayerPosition = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->rangeFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->timeFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerExplosion const *Packet_ServerExplosionSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerExplosion *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerExplosionSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerExplosion const *Packet_ServerExplosionSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerExplosion *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->xFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->yFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->zFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->isRelativeToPlayerPosition = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->rangeFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->timeFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerExplosion const *Packet_ServerExplosionSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerExplosion *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->xFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->yFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->zFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->isRelativeToPlayerPosition = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->rangeFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->timeFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerExplosion *Packet_ServerExplosionSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerExplosion *instance = Packet_ServerExplosion_New();
	Packet_ServerExplosionSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerExplosionSerializer_Serialize(CitoStream const *stream, Packet_ServerExplosion const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->xFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->yFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteUInt64(stream, instance->zFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
	ProtocolParser_WriteUInt64(stream, instance->isRelativeToPlayerPosition);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(40));
	ProtocolParser_WriteUInt64(stream, instance->rangeFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(48));
	ProtocolParser_WriteUInt64(stream, instance->timeFloat);
}

void Packet_ServerExplosionSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerExplosion const *instance)
{
	unsigned char const *data = Packet_ServerExplosionSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerExplosionSerializer_SerializeToBytes(Packet_ServerExplosion const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerExplosionSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerFillArea *Packet_ServerFillArea_New(void)
{
	Packet_ServerFillArea *self = (Packet_ServerFillArea *) malloc(sizeof(Packet_ServerFillArea));
	return self;
}

void Packet_ServerFillArea_Delete(Packet_ServerFillArea *self)
{
	free(self);
}

int Packet_ServerFillArea_GetBlockCount(Packet_ServerFillArea const *self)
{
	return self->blockCount;
}

int Packet_ServerFillArea_GetBlockType(Packet_ServerFillArea const *self)
{
	return self->blockType;
}

int Packet_ServerFillArea_GetX1(Packet_ServerFillArea const *self)
{
	return self->x1;
}

int Packet_ServerFillArea_GetX2(Packet_ServerFillArea const *self)
{
	return self->x2;
}

int Packet_ServerFillArea_GetY1(Packet_ServerFillArea const *self)
{
	return self->y1;
}

int Packet_ServerFillArea_GetY2(Packet_ServerFillArea const *self)
{
	return self->y2;
}

int Packet_ServerFillArea_GetZ1(Packet_ServerFillArea const *self)
{
	return self->z1;
}

int Packet_ServerFillArea_GetZ2(Packet_ServerFillArea const *self)
{
	return self->z2;
}

void Packet_ServerFillArea_SetBlockCount(Packet_ServerFillArea *self, int value)
{
	self->blockCount = value;
}

void Packet_ServerFillArea_SetBlockType(Packet_ServerFillArea *self, int value)
{
	self->blockType = value;
}

void Packet_ServerFillArea_SetX1(Packet_ServerFillArea *self, int value)
{
	self->x1 = value;
}

void Packet_ServerFillArea_SetX2(Packet_ServerFillArea *self, int value)
{
	self->x2 = value;
}

void Packet_ServerFillArea_SetY1(Packet_ServerFillArea *self, int value)
{
	self->y1 = value;
}

void Packet_ServerFillArea_SetY2(Packet_ServerFillArea *self, int value)
{
	self->y2 = value;
}

void Packet_ServerFillArea_SetZ1(Packet_ServerFillArea *self, int value)
{
	self->z1 = value;
}

void Packet_ServerFillArea_SetZ2(Packet_ServerFillArea *self, int value)
{
	self->z2 = value;
}

Packet_ServerFillAreaLimit *Packet_ServerFillAreaLimit_New(void)
{
	Packet_ServerFillAreaLimit *self = (Packet_ServerFillAreaLimit *) malloc(sizeof(Packet_ServerFillAreaLimit));
	return self;
}

void Packet_ServerFillAreaLimit_Delete(Packet_ServerFillAreaLimit *self)
{
	free(self);
}

int Packet_ServerFillAreaLimit_GetLimit(Packet_ServerFillAreaLimit const *self)
{
	return self->limit;
}

void Packet_ServerFillAreaLimit_SetLimit(Packet_ServerFillAreaLimit *self, int value)
{
	self->limit = value;
}

Packet_ServerFillAreaLimit const *Packet_ServerFillAreaLimitSerializer_Deserialize(CitoStream const *stream, Packet_ServerFillAreaLimit *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->limit = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerFillAreaLimit const *Packet_ServerFillAreaLimitSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerFillAreaLimit *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerFillAreaLimitSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerFillAreaLimit const *Packet_ServerFillAreaLimitSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerFillAreaLimit *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->limit = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerFillAreaLimit const *Packet_ServerFillAreaLimitSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerFillAreaLimit *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->limit = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerFillAreaLimit *Packet_ServerFillAreaLimitSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerFillAreaLimit *instance = Packet_ServerFillAreaLimit_New();
	Packet_ServerFillAreaLimitSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerFillAreaLimitSerializer_Serialize(CitoStream const *stream, Packet_ServerFillAreaLimit const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->limit);
}

void Packet_ServerFillAreaLimitSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerFillAreaLimit const *instance)
{
	unsigned char const *data = Packet_ServerFillAreaLimitSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerFillAreaLimitSerializer_SerializeToBytes(Packet_ServerFillAreaLimit const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerFillAreaLimitSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerFillArea const *Packet_ServerFillAreaSerializer_Deserialize(CitoStream const *stream, Packet_ServerFillArea *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->x1 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->x2 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->y1 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->y2 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->z1 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->z2 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->blockType = ProtocolParser_ReadUInt64(stream);
			continue;
		case 64:
			instance->blockCount = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerFillArea const *Packet_ServerFillAreaSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerFillArea *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerFillAreaSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerFillArea const *Packet_ServerFillAreaSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerFillArea *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->x1 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->x2 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->y1 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->y2 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->z1 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->z2 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->blockType = ProtocolParser_ReadUInt64(stream);
			continue;
		case 64:
			instance->blockCount = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerFillArea const *Packet_ServerFillAreaSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerFillArea *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->x1 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->x2 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->y1 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->y2 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->z1 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->z2 = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->blockType = ProtocolParser_ReadUInt64(stream);
			continue;
		case 64:
			instance->blockCount = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerFillArea *Packet_ServerFillAreaSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerFillArea *instance = Packet_ServerFillArea_New();
	Packet_ServerFillAreaSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerFillAreaSerializer_Serialize(CitoStream const *stream, Packet_ServerFillArea const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->x1);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->x2);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteUInt64(stream, instance->y1);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
	ProtocolParser_WriteUInt64(stream, instance->y2);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(40));
	ProtocolParser_WriteUInt64(stream, instance->z1);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(48));
	ProtocolParser_WriteUInt64(stream, instance->z2);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(56));
	ProtocolParser_WriteUInt64(stream, instance->blockType);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(64));
	ProtocolParser_WriteUInt64(stream, instance->blockCount);
}

void Packet_ServerFillAreaSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerFillArea const *instance)
{
	unsigned char const *data = Packet_ServerFillAreaSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerFillAreaSerializer_SerializeToBytes(Packet_ServerFillArea const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerFillAreaSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerFollow *Packet_ServerFollow_New(void)
{
	Packet_ServerFollow *self = (Packet_ServerFollow *) malloc(sizeof(Packet_ServerFollow));
	return self;
}

void Packet_ServerFollow_Delete(Packet_ServerFollow *self)
{
	free(self);
}

const char *Packet_ServerFollow_GetClient(Packet_ServerFollow const *self)
{
	return self->client;
}

int Packet_ServerFollow_GetTpp(Packet_ServerFollow const *self)
{
	return self->tpp;
}

void Packet_ServerFollow_SetClient(Packet_ServerFollow *self, const char *value)
{
	self->client = value;
}

void Packet_ServerFollow_SetTpp(Packet_ServerFollow *self, int value)
{
	self->tpp = value;
}

Packet_ServerFollow const *Packet_ServerFollowSerializer_Deserialize(CitoStream const *stream, Packet_ServerFollow *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance->client = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->tpp = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerFollow const *Packet_ServerFollowSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerFollow *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerFollowSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerFollow const *Packet_ServerFollowSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerFollow *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->client = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->tpp = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerFollow const *Packet_ServerFollowSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerFollow *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->client = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->tpp = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerFollow *Packet_ServerFollowSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerFollow *instance = Packet_ServerFollow_New();
	Packet_ServerFollowSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerFollowSerializer_Serialize(CitoStream const *stream, Packet_ServerFollow const *instance)
{
	if (instance->client != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->client));
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->tpp);
}

void Packet_ServerFollowSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerFollow const *instance)
{
	unsigned char const *data = Packet_ServerFollowSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerFollowSerializer_SerializeToBytes(Packet_ServerFollow const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerFollowSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerFreemove *Packet_ServerFreemove_New(void)
{
	Packet_ServerFreemove *self = (Packet_ServerFreemove *) malloc(sizeof(Packet_ServerFreemove));
	return self;
}

void Packet_ServerFreemove_Delete(Packet_ServerFreemove *self)
{
	free(self);
}

int Packet_ServerFreemove_GetIsEnabled(Packet_ServerFreemove const *self)
{
	return self->isEnabled;
}

void Packet_ServerFreemove_SetIsEnabled(Packet_ServerFreemove *self, int value)
{
	self->isEnabled = value;
}

Packet_ServerFreemove const *Packet_ServerFreemoveSerializer_Deserialize(CitoStream const *stream, Packet_ServerFreemove *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->isEnabled = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerFreemove const *Packet_ServerFreemoveSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerFreemove *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerFreemoveSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerFreemove const *Packet_ServerFreemoveSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerFreemove *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->isEnabled = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerFreemove const *Packet_ServerFreemoveSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerFreemove *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->isEnabled = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerFreemove *Packet_ServerFreemoveSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerFreemove *instance = Packet_ServerFreemove_New();
	Packet_ServerFreemoveSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerFreemoveSerializer_Serialize(CitoStream const *stream, Packet_ServerFreemove const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->isEnabled);
}

void Packet_ServerFreemoveSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerFreemove const *instance)
{
	unsigned char const *data = Packet_ServerFreemoveSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerFreemoveSerializer_SerializeToBytes(Packet_ServerFreemove const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerFreemoveSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerHeightmapChunk *Packet_ServerHeightmapChunk_New(void)
{
	Packet_ServerHeightmapChunk *self = (Packet_ServerHeightmapChunk *) malloc(sizeof(Packet_ServerHeightmapChunk));
	return self;
}

void Packet_ServerHeightmapChunk_Delete(Packet_ServerHeightmapChunk *self)
{
	free(self);
}

unsigned char const *Packet_ServerHeightmapChunk_GetCompressedHeightmap(Packet_ServerHeightmapChunk const *self)
{
	return self->compressedHeightmap;
}

int Packet_ServerHeightmapChunk_GetSizeX(Packet_ServerHeightmapChunk const *self)
{
	return self->sizeX;
}

int Packet_ServerHeightmapChunk_GetSizeY(Packet_ServerHeightmapChunk const *self)
{
	return self->sizeY;
}

int Packet_ServerHeightmapChunk_GetX(Packet_ServerHeightmapChunk const *self)
{
	return self->x;
}

int Packet_ServerHeightmapChunk_GetY(Packet_ServerHeightmapChunk const *self)
{
	return self->y;
}

void Packet_ServerHeightmapChunk_SetCompressedHeightmap(Packet_ServerHeightmapChunk *self, unsigned char const *value)
{
	self->compressedHeightmap = value;
}

void Packet_ServerHeightmapChunk_SetSizeX(Packet_ServerHeightmapChunk *self, int value)
{
	self->sizeX = value;
}

void Packet_ServerHeightmapChunk_SetSizeY(Packet_ServerHeightmapChunk *self, int value)
{
	self->sizeY = value;
}

void Packet_ServerHeightmapChunk_SetX(Packet_ServerHeightmapChunk *self, int value)
{
	self->x = value;
}

void Packet_ServerHeightmapChunk_SetY(Packet_ServerHeightmapChunk *self, int value)
{
	self->y = value;
}

Packet_ServerHeightmapChunk const *Packet_ServerHeightmapChunkSerializer_Deserialize(CitoStream const *stream, Packet_ServerHeightmapChunk *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->sizeX = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->sizeY = ProtocolParser_ReadUInt64(stream);
			continue;
		case 42:
			instance->compressedHeightmap = ProtocolParser_ReadBytes(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerHeightmapChunk const *Packet_ServerHeightmapChunkSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerHeightmapChunk *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerHeightmapChunkSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerHeightmapChunk const *Packet_ServerHeightmapChunkSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerHeightmapChunk *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->sizeX = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->sizeY = ProtocolParser_ReadUInt64(stream);
			continue;
		case 42:
			instance->compressedHeightmap = ProtocolParser_ReadBytes(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerHeightmapChunk const *Packet_ServerHeightmapChunkSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerHeightmapChunk *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->sizeX = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->sizeY = ProtocolParser_ReadUInt64(stream);
			continue;
		case 42:
			instance->compressedHeightmap = ProtocolParser_ReadBytes(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerHeightmapChunk *Packet_ServerHeightmapChunkSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerHeightmapChunk *instance = Packet_ServerHeightmapChunk_New();
	Packet_ServerHeightmapChunkSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerHeightmapChunkSerializer_Serialize(CitoStream const *stream, Packet_ServerHeightmapChunk const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->x);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->y);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteUInt64(stream, instance->sizeX);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
	ProtocolParser_WriteUInt64(stream, instance->sizeY);
	if (instance->compressedHeightmap != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(42));
		ProtocolParser_WriteBytes(stream, instance->compressedHeightmap);
	}
}

void Packet_ServerHeightmapChunkSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerHeightmapChunk const *instance)
{
	unsigned char const *data = Packet_ServerHeightmapChunkSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerHeightmapChunkSerializer_SerializeToBytes(Packet_ServerHeightmapChunk const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerHeightmapChunkSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerIdentification *Packet_ServerIdentification_New(void)
{
	Packet_ServerIdentification *self = (Packet_ServerIdentification *) malloc(sizeof(Packet_ServerIdentification));
	return self;
}

void Packet_ServerIdentification_Delete(Packet_ServerIdentification *self)
{
	free(self);
}

int Packet_ServerIdentification_GetAssignedClientId(Packet_ServerIdentification const *self)
{
	return self->assignedClientId;
}

int Packet_ServerIdentification_GetDisableShadows(Packet_ServerIdentification const *self)
{
	return self->disableShadows;
}

int Packet_ServerIdentification_GetMapSizeX(Packet_ServerIdentification const *self)
{
	return self->mapSizeX;
}

int Packet_ServerIdentification_GetMapSizeY(Packet_ServerIdentification const *self)
{
	return self->mapSizeY;
}

int Packet_ServerIdentification_GetMapSizeZ(Packet_ServerIdentification const *self)
{
	return self->mapSizeZ;
}

const char *Packet_ServerIdentification_GetMdProtocolVersion(Packet_ServerIdentification const *self)
{
	return self->mdProtocolVersion;
}

int Packet_ServerIdentification_GetPlayerAreaSize(Packet_ServerIdentification const *self)
{
	return self->playerAreaSize;
}

int Packet_ServerIdentification_GetRenderHint_(Packet_ServerIdentification const *self)
{
	return self->renderHint_;
}

Packet_StringList const *Packet_ServerIdentification_GetRequiredBlobMd5(Packet_ServerIdentification const *self)
{
	return self->requiredBlobMd5;
}

Packet_StringList const *Packet_ServerIdentification_GetRequiredBlobName(Packet_ServerIdentification const *self)
{
	return self->requiredBlobName;
}

const char *Packet_ServerIdentification_GetServerMotd(Packet_ServerIdentification const *self)
{
	return self->serverMotd;
}

const char *Packet_ServerIdentification_GetServerName(Packet_ServerIdentification const *self)
{
	return self->serverName;
}

void Packet_ServerIdentification_SetAssignedClientId(Packet_ServerIdentification *self, int value)
{
	self->assignedClientId = value;
}

void Packet_ServerIdentification_SetDisableShadows(Packet_ServerIdentification *self, int value)
{
	self->disableShadows = value;
}

void Packet_ServerIdentification_SetMapSizeX(Packet_ServerIdentification *self, int value)
{
	self->mapSizeX = value;
}

void Packet_ServerIdentification_SetMapSizeY(Packet_ServerIdentification *self, int value)
{
	self->mapSizeY = value;
}

void Packet_ServerIdentification_SetMapSizeZ(Packet_ServerIdentification *self, int value)
{
	self->mapSizeZ = value;
}

void Packet_ServerIdentification_SetMdProtocolVersion(Packet_ServerIdentification *self, const char *value)
{
	self->mdProtocolVersion = value;
}

void Packet_ServerIdentification_SetPlayerAreaSize(Packet_ServerIdentification *self, int value)
{
	self->playerAreaSize = value;
}

void Packet_ServerIdentification_SetRenderHint_(Packet_ServerIdentification *self, int value)
{
	self->renderHint_ = value;
}

void Packet_ServerIdentification_SetRequiredBlobMd5(Packet_ServerIdentification *self, Packet_StringList *value)
{
	self->requiredBlobMd5 = value;
}

void Packet_ServerIdentification_SetRequiredBlobName(Packet_ServerIdentification *self, Packet_StringList *value)
{
	self->requiredBlobName = value;
}

void Packet_ServerIdentification_SetServerMotd(Packet_ServerIdentification *self, const char *value)
{
	self->serverMotd = value;
}

void Packet_ServerIdentification_SetServerName(Packet_ServerIdentification *self, const char *value)
{
	self->serverName = value;
}

Packet_ServerIdentification const *Packet_ServerIdentificationSerializer_Deserialize(CitoStream const *stream, Packet_ServerIdentification *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance->mdProtocolVersion = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->assignedClientId = ProtocolParser_ReadUInt64(stream);
			continue;
		case 26:
			instance->serverName = ProtocolParser_ReadString(stream);
			continue;
		case 34:
			instance->serverMotd = ProtocolParser_ReadString(stream);
			continue;
		case 56:
			instance->mapSizeX = ProtocolParser_ReadUInt64(stream);
			continue;
		case 64:
			instance->mapSizeY = ProtocolParser_ReadUInt64(stream);
			continue;
		case 72:
			instance->mapSizeZ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 88:
			instance->disableShadows = ProtocolParser_ReadUInt64(stream);
			continue;
		case 96:
			instance->playerAreaSize = ProtocolParser_ReadUInt64(stream);
			continue;
		case 104:
			instance->renderHint_ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 114:
			if (instance->requiredBlobMd5 == NULL)
				instance->requiredBlobMd5 = Packet_StringListSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_StringListSerializer_DeserializeLengthDelimited(stream, instance->requiredBlobMd5);
			continue;
		case 122:
			if (instance->requiredBlobName == NULL)
				instance->requiredBlobName = Packet_StringListSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_StringListSerializer_DeserializeLengthDelimited(stream, instance->requiredBlobName);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerIdentification const *Packet_ServerIdentificationSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerIdentification *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerIdentificationSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerIdentification const *Packet_ServerIdentificationSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerIdentification *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->mdProtocolVersion = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->assignedClientId = ProtocolParser_ReadUInt64(stream);
			continue;
		case 26:
			instance->serverName = ProtocolParser_ReadString(stream);
			continue;
		case 34:
			instance->serverMotd = ProtocolParser_ReadString(stream);
			continue;
		case 56:
			instance->mapSizeX = ProtocolParser_ReadUInt64(stream);
			continue;
		case 64:
			instance->mapSizeY = ProtocolParser_ReadUInt64(stream);
			continue;
		case 72:
			instance->mapSizeZ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 88:
			instance->disableShadows = ProtocolParser_ReadUInt64(stream);
			continue;
		case 96:
			instance->playerAreaSize = ProtocolParser_ReadUInt64(stream);
			continue;
		case 104:
			instance->renderHint_ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 114:
			if (instance->requiredBlobMd5 == NULL)
				instance->requiredBlobMd5 = Packet_StringListSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_StringListSerializer_DeserializeLengthDelimited(stream, instance->requiredBlobMd5);
			continue;
		case 122:
			if (instance->requiredBlobName == NULL)
				instance->requiredBlobName = Packet_StringListSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_StringListSerializer_DeserializeLengthDelimited(stream, instance->requiredBlobName);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerIdentification const *Packet_ServerIdentificationSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerIdentification *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->mdProtocolVersion = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->assignedClientId = ProtocolParser_ReadUInt64(stream);
			continue;
		case 26:
			instance->serverName = ProtocolParser_ReadString(stream);
			continue;
		case 34:
			instance->serverMotd = ProtocolParser_ReadString(stream);
			continue;
		case 56:
			instance->mapSizeX = ProtocolParser_ReadUInt64(stream);
			continue;
		case 64:
			instance->mapSizeY = ProtocolParser_ReadUInt64(stream);
			continue;
		case 72:
			instance->mapSizeZ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 88:
			instance->disableShadows = ProtocolParser_ReadUInt64(stream);
			continue;
		case 96:
			instance->playerAreaSize = ProtocolParser_ReadUInt64(stream);
			continue;
		case 104:
			instance->renderHint_ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 114:
			if (instance->requiredBlobMd5 == NULL)
				instance->requiredBlobMd5 = Packet_StringListSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_StringListSerializer_DeserializeLengthDelimited(stream, instance->requiredBlobMd5);
			continue;
		case 122:
			if (instance->requiredBlobName == NULL)
				instance->requiredBlobName = Packet_StringListSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_StringListSerializer_DeserializeLengthDelimited(stream, instance->requiredBlobName);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerIdentification *Packet_ServerIdentificationSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerIdentification *instance = Packet_ServerIdentification_New();
	Packet_ServerIdentificationSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerIdentificationSerializer_Serialize(CitoStream const *stream, Packet_ServerIdentification const *instance)
{
	if (instance->mdProtocolVersion != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->mdProtocolVersion));
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->assignedClientId);
	if (instance->serverName != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(26));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->serverName));
	}
	if (instance->serverMotd != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(34));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->serverMotd));
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(56));
	ProtocolParser_WriteUInt64(stream, instance->mapSizeX);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(64));
	ProtocolParser_WriteUInt64(stream, instance->mapSizeY);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(72));
	ProtocolParser_WriteUInt64(stream, instance->mapSizeZ);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(88));
	ProtocolParser_WriteUInt64(stream, instance->disableShadows);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(96));
	ProtocolParser_WriteUInt64(stream, instance->playerAreaSize);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(104));
	ProtocolParser_WriteUInt64(stream, instance->renderHint_);
	if (instance->requiredBlobMd5 != NULL) {
		CitoMemoryStream const *ms14;
		int ms14Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(114));
		ms14 = CitoMemoryStream_New();
		Packet_StringListSerializer_Serialize(&ms14->base, instance->requiredBlobMd5);
		ms14Length = CitoMemoryStream_Length(ms14);
		ProtocolParser_WriteUInt32_(stream, ms14Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms14), 0, ms14Length);
	}
	if (instance->requiredBlobName != NULL) {
		CitoMemoryStream const *ms15;
		int ms15Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(122));
		ms15 = CitoMemoryStream_New();
		Packet_StringListSerializer_Serialize(&ms15->base, instance->requiredBlobName);
		ms15Length = CitoMemoryStream_Length(ms15);
		ProtocolParser_WriteUInt32_(stream, ms15Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms15), 0, ms15Length);
	}
}

void Packet_ServerIdentificationSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerIdentification const *instance)
{
	unsigned char const *data = Packet_ServerIdentificationSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerIdentificationSerializer_SerializeToBytes(Packet_ServerIdentification const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerIdentificationSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerInventory *Packet_ServerInventory_New(void)
{
	Packet_ServerInventory *self = (Packet_ServerInventory *) malloc(sizeof(Packet_ServerInventory));
	return self;
}

void Packet_ServerInventory_Delete(Packet_ServerInventory *self)
{
	free(self);
}

Packet_Inventory const *Packet_ServerInventory_GetInventory(Packet_ServerInventory const *self)
{
	return self->inventory;
}

void Packet_ServerInventory_SetInventory(Packet_ServerInventory *self, Packet_Inventory *value)
{
	self->inventory = value;
}

Packet_ServerInventory const *Packet_ServerInventorySerializer_Deserialize(CitoStream const *stream, Packet_ServerInventory *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 34:
			if (instance->inventory == NULL)
				instance->inventory = Packet_InventorySerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_InventorySerializer_DeserializeLengthDelimited(stream, instance->inventory);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerInventory const *Packet_ServerInventorySerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerInventory *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerInventorySerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerInventory const *Packet_ServerInventorySerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerInventory *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 34:
			if (instance->inventory == NULL)
				instance->inventory = Packet_InventorySerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_InventorySerializer_DeserializeLengthDelimited(stream, instance->inventory);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerInventory const *Packet_ServerInventorySerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerInventory *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 34:
			if (instance->inventory == NULL)
				instance->inventory = Packet_InventorySerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_InventorySerializer_DeserializeLengthDelimited(stream, instance->inventory);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerInventory *Packet_ServerInventorySerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerInventory *instance = Packet_ServerInventory_New();
	Packet_ServerInventorySerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerInventorySerializer_Serialize(CitoStream const *stream, Packet_ServerInventory const *instance)
{
	if (instance->inventory != NULL) {
		CitoMemoryStream const *ms4;
		int ms4Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(34));
		ms4 = CitoMemoryStream_New();
		Packet_InventorySerializer_Serialize(&ms4->base, instance->inventory);
		ms4Length = CitoMemoryStream_Length(ms4);
		ProtocolParser_WriteUInt32_(stream, ms4Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms4), 0, ms4Length);
	}
}

void Packet_ServerInventorySerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerInventory const *instance)
{
	unsigned char const *data = Packet_ServerInventorySerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerInventorySerializer_SerializeToBytes(Packet_ServerInventory const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerInventorySerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerLevelFinalize const *Packet_ServerLevelFinalizeSerializer_Deserialize(CitoStream const *stream, Packet_ServerLevelFinalize const *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerLevelFinalize const *Packet_ServerLevelFinalizeSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerLevelFinalize const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerLevelFinalizeSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerLevelFinalize const *Packet_ServerLevelFinalizeSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerLevelFinalize const *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerLevelFinalize const *Packet_ServerLevelFinalizeSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerLevelFinalize const *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerLevelFinalize const *Packet_ServerLevelFinalizeSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerLevelFinalize const *instance = Packet_ServerLevelFinalize_New();
	Packet_ServerLevelFinalizeSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerLevelFinalizeSerializer_Serialize(CitoStream const *stream, Packet_ServerLevelFinalize const *instance)
{
}

void Packet_ServerLevelFinalizeSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerLevelFinalize const *instance)
{
	unsigned char const *data = Packet_ServerLevelFinalizeSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerLevelFinalizeSerializer_SerializeToBytes(Packet_ServerLevelFinalize const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerLevelFinalizeSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerLevelInitialize const *Packet_ServerLevelInitializeSerializer_Deserialize(CitoStream const *stream, Packet_ServerLevelInitialize const *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerLevelInitialize const *Packet_ServerLevelInitializeSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerLevelInitialize const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerLevelInitializeSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerLevelInitialize const *Packet_ServerLevelInitializeSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerLevelInitialize const *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerLevelInitialize const *Packet_ServerLevelInitializeSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerLevelInitialize const *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerLevelInitialize const *Packet_ServerLevelInitializeSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerLevelInitialize const *instance = Packet_ServerLevelInitialize_New();
	Packet_ServerLevelInitializeSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerLevelInitializeSerializer_Serialize(CitoStream const *stream, Packet_ServerLevelInitialize const *instance)
{
}

void Packet_ServerLevelInitializeSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerLevelInitialize const *instance)
{
	unsigned char const *data = Packet_ServerLevelInitializeSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerLevelInitializeSerializer_SerializeToBytes(Packet_ServerLevelInitialize const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerLevelInitializeSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerLevelProgress *Packet_ServerLevelProgress_New(void)
{
	Packet_ServerLevelProgress *self = (Packet_ServerLevelProgress *) malloc(sizeof(Packet_ServerLevelProgress));
	return self;
}

void Packet_ServerLevelProgress_Delete(Packet_ServerLevelProgress *self)
{
	free(self);
}

int Packet_ServerLevelProgress_GetPercentComplete(Packet_ServerLevelProgress const *self)
{
	return self->percentComplete;
}

int Packet_ServerLevelProgress_GetPercentCompleteSubitem(Packet_ServerLevelProgress const *self)
{
	return self->percentCompleteSubitem;
}

const char *Packet_ServerLevelProgress_GetStatus(Packet_ServerLevelProgress const *self)
{
	return self->status;
}

void Packet_ServerLevelProgress_SetPercentComplete(Packet_ServerLevelProgress *self, int value)
{
	self->percentComplete = value;
}

void Packet_ServerLevelProgress_SetPercentCompleteSubitem(Packet_ServerLevelProgress *self, int value)
{
	self->percentCompleteSubitem = value;
}

void Packet_ServerLevelProgress_SetStatus(Packet_ServerLevelProgress *self, const char *value)
{
	self->status = value;
}

Packet_ServerLevelProgress const *Packet_ServerLevelProgressSerializer_Deserialize(CitoStream const *stream, Packet_ServerLevelProgress *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 16:
			instance->percentComplete = ProtocolParser_ReadUInt64(stream);
			continue;
		case 26:
			instance->status = ProtocolParser_ReadString(stream);
			continue;
		case 32:
			instance->percentCompleteSubitem = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerLevelProgress const *Packet_ServerLevelProgressSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerLevelProgress *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerLevelProgressSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerLevelProgress const *Packet_ServerLevelProgressSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerLevelProgress *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 16:
			instance->percentComplete = ProtocolParser_ReadUInt64(stream);
			continue;
		case 26:
			instance->status = ProtocolParser_ReadString(stream);
			continue;
		case 32:
			instance->percentCompleteSubitem = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerLevelProgress const *Packet_ServerLevelProgressSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerLevelProgress *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 16:
			instance->percentComplete = ProtocolParser_ReadUInt64(stream);
			continue;
		case 26:
			instance->status = ProtocolParser_ReadString(stream);
			continue;
		case 32:
			instance->percentCompleteSubitem = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerLevelProgress *Packet_ServerLevelProgressSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerLevelProgress *instance = Packet_ServerLevelProgress_New();
	Packet_ServerLevelProgressSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerLevelProgressSerializer_Serialize(CitoStream const *stream, Packet_ServerLevelProgress const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->percentComplete);
	if (instance->status != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(26));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->status));
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
	ProtocolParser_WriteUInt64(stream, instance->percentCompleteSubitem);
}

void Packet_ServerLevelProgressSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerLevelProgress const *instance)
{
	unsigned char const *data = Packet_ServerLevelProgressSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerLevelProgressSerializer_SerializeToBytes(Packet_ServerLevelProgress const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerLevelProgressSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerLightLevels *Packet_ServerLightLevels_New(void)
{
	Packet_ServerLightLevels *self = (Packet_ServerLightLevels *) malloc(sizeof(Packet_ServerLightLevels));
	return self;
}

void Packet_ServerLightLevels_Delete(Packet_ServerLightLevels *self)
{
	free(self);
}

int const *Packet_ServerLightLevels_GetLightlevels(Packet_ServerLightLevels const *self)
{
	return self->lightlevels;
}

int Packet_ServerLightLevels_GetLightlevelsCount(Packet_ServerLightLevels const *self)
{
	return self->lightlevelsCount;
}

int Packet_ServerLightLevels_GetLightlevelsLength(Packet_ServerLightLevels const *self)
{
	return self->lightlevelsLength;
}

void Packet_ServerLightLevels_LightlevelsAdd(Packet_ServerLightLevels *self, int value)
{
	if (self->lightlevelsCount >= self->lightlevelsLength) {
		int *Lightlevels2 = (int *) malloc(self->lightlevelsLength * 2 * sizeof(int ));
		self->lightlevelsLength = self->lightlevelsLength * 2;
		{
			int i;
			for (i = 0; i < self->lightlevelsCount; i++) {
				Lightlevels2[i] = self->lightlevels[i];
			}
		}
		self->lightlevels = Lightlevels2;
	}
	self->lightlevels[self->lightlevelsCount] = value;
	self->lightlevelsCount++;
}

void Packet_ServerLightLevels_SetLightlevels(Packet_ServerLightLevels *self, int *value, int count, int length)
{
	self->lightlevels = value;
	self->lightlevelsCount = count;
	self->lightlevelsLength = length;
}

Packet_ServerLightLevels const *Packet_ServerLightLevelsSerializer_Deserialize(CitoStream const *stream, Packet_ServerLightLevels *instance)
{
	if (instance->lightlevels == NULL) {
		instance->lightlevels = (int *) malloc(1 * sizeof(int ));
		instance->lightlevelsCount = 0;
		instance->lightlevelsLength = 1;
	}
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			Packet_ServerLightLevels_LightlevelsAdd(instance, ProtocolParser_ReadUInt64(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerLightLevels const *Packet_ServerLightLevelsSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerLightLevels *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerLightLevelsSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerLightLevels const *Packet_ServerLightLevelsSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerLightLevels *instance)
{
	int limit;
	if (instance->lightlevels == NULL) {
		instance->lightlevels = (int *) malloc(1 * sizeof(int ));
		instance->lightlevelsCount = 0;
		instance->lightlevelsLength = 1;
	}
	limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			Packet_ServerLightLevels_LightlevelsAdd(instance, ProtocolParser_ReadUInt64(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerLightLevels const *Packet_ServerLightLevelsSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerLightLevels *instance)
{
	int limit;
	if (instance->lightlevels == NULL) {
		instance->lightlevels = (int *) malloc(1 * sizeof(int ));
		instance->lightlevelsCount = 0;
		instance->lightlevelsLength = 1;
	}
	limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			Packet_ServerLightLevels_LightlevelsAdd(instance, ProtocolParser_ReadUInt64(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerLightLevels *Packet_ServerLightLevelsSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerLightLevels *instance = Packet_ServerLightLevels_New();
	Packet_ServerLightLevelsSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerLightLevelsSerializer_Serialize(CitoStream const *stream, Packet_ServerLightLevels const *instance)
{
	if (instance->lightlevels != NULL) {
		{
			int k;
			for (k = 0; k < instance->lightlevelsCount; k++) {
				int i1 = instance->lightlevels[k];
				stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
				ProtocolParser_WriteUInt64(stream, i1);
			}
		}
	}
}

void Packet_ServerLightLevelsSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerLightLevels const *instance)
{
	unsigned char const *data = Packet_ServerLightLevelsSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerLightLevelsSerializer_SerializeToBytes(Packet_ServerLightLevels const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerLightLevelsSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerMessage *Packet_ServerMessage_New(void)
{
	Packet_ServerMessage *self = (Packet_ServerMessage *) malloc(sizeof(Packet_ServerMessage));
	return self;
}

void Packet_ServerMessage_Delete(Packet_ServerMessage *self)
{
	free(self);
}

const char *Packet_ServerMessage_GetMessage(Packet_ServerMessage const *self)
{
	return self->message;
}

void Packet_ServerMessage_SetMessage(Packet_ServerMessage *self, const char *value)
{
	self->message = value;
}

Packet_ServerMessage const *Packet_ServerMessageSerializer_Deserialize(CitoStream const *stream, Packet_ServerMessage *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 18:
			instance->message = ProtocolParser_ReadString(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerMessage const *Packet_ServerMessageSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerMessage *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerMessageSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerMessage const *Packet_ServerMessageSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerMessage *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 18:
			instance->message = ProtocolParser_ReadString(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerMessage const *Packet_ServerMessageSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerMessage *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 18:
			instance->message = ProtocolParser_ReadString(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerMessage *Packet_ServerMessageSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerMessage *instance = Packet_ServerMessage_New();
	Packet_ServerMessageSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerMessageSerializer_Serialize(CitoStream const *stream, Packet_ServerMessage const *instance)
{
	if (instance->message != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(18));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->message));
	}
}

void Packet_ServerMessageSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerMessage const *instance)
{
	unsigned char const *data = Packet_ServerMessageSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerMessageSerializer_SerializeToBytes(Packet_ServerMessage const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerMessageSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerMonster *Packet_ServerMonster_New(void)
{
	Packet_ServerMonster *self = (Packet_ServerMonster *) malloc(sizeof(Packet_ServerMonster));
	return self;
}

void Packet_ServerMonster_Delete(Packet_ServerMonster *self)
{
	free(self);
}

int Packet_ServerMonster_GetHealth(Packet_ServerMonster const *self)
{
	return self->health;
}

int Packet_ServerMonster_GetId(Packet_ServerMonster const *self)
{
	return self->id;
}

int Packet_ServerMonster_GetMonsterType(Packet_ServerMonster const *self)
{
	return self->monsterType;
}

Packet_PositionAndOrientation const *Packet_ServerMonster_GetPositionAndOrientation(Packet_ServerMonster const *self)
{
	return self->positionAndOrientation;
}

void Packet_ServerMonster_SetHealth(Packet_ServerMonster *self, int value)
{
	self->health = value;
}

void Packet_ServerMonster_SetId(Packet_ServerMonster *self, int value)
{
	self->id = value;
}

void Packet_ServerMonster_SetMonsterType(Packet_ServerMonster *self, int value)
{
	self->monsterType = value;
}

void Packet_ServerMonster_SetPositionAndOrientation(Packet_ServerMonster *self, Packet_PositionAndOrientation *value)
{
	self->positionAndOrientation = value;
}

Packet_ServerMonster const *Packet_ServerMonsterSerializer_Deserialize(CitoStream const *stream, Packet_ServerMonster *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->id = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->monsterType = ProtocolParser_ReadUInt64(stream);
			continue;
		case 26:
			if (instance->positionAndOrientation == NULL)
				instance->positionAndOrientation = Packet_PositionAndOrientationSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_PositionAndOrientationSerializer_DeserializeLengthDelimited(stream, instance->positionAndOrientation);
			continue;
		case 32:
			instance->health = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerMonster const *Packet_ServerMonsterSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerMonster *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerMonsterSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerMonster const *Packet_ServerMonsterSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerMonster *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->id = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->monsterType = ProtocolParser_ReadUInt64(stream);
			continue;
		case 26:
			if (instance->positionAndOrientation == NULL)
				instance->positionAndOrientation = Packet_PositionAndOrientationSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_PositionAndOrientationSerializer_DeserializeLengthDelimited(stream, instance->positionAndOrientation);
			continue;
		case 32:
			instance->health = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerMonster const *Packet_ServerMonsterSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerMonster *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->id = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->monsterType = ProtocolParser_ReadUInt64(stream);
			continue;
		case 26:
			if (instance->positionAndOrientation == NULL)
				instance->positionAndOrientation = Packet_PositionAndOrientationSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_PositionAndOrientationSerializer_DeserializeLengthDelimited(stream, instance->positionAndOrientation);
			continue;
		case 32:
			instance->health = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerMonster const *Packet_ServerMonsterSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerMonster *instance = Packet_ServerMonster_New();
	Packet_ServerMonsterSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerMonsterSerializer_Serialize(CitoStream const *stream, Packet_ServerMonster const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->id);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->monsterType);
	if (instance->positionAndOrientation != NULL) {
		CitoMemoryStream const *ms3;
		int ms3Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(26));
		ms3 = CitoMemoryStream_New();
		Packet_PositionAndOrientationSerializer_Serialize(&ms3->base, instance->positionAndOrientation);
		ms3Length = CitoMemoryStream_Length(ms3);
		ProtocolParser_WriteUInt32_(stream, ms3Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms3), 0, ms3Length);
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
	ProtocolParser_WriteUInt64(stream, instance->health);
}

void Packet_ServerMonsterSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerMonster const *instance)
{
	unsigned char const *data = Packet_ServerMonsterSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerMonsterSerializer_SerializeToBytes(Packet_ServerMonster const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerMonsterSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerMonsters *Packet_ServerMonsters_New(void)
{
	Packet_ServerMonsters *self = (Packet_ServerMonsters *) malloc(sizeof(Packet_ServerMonsters));
	return self;
}

void Packet_ServerMonsters_Delete(Packet_ServerMonsters *self)
{
	free(self);
}

Packet_ServerMonster const *const *Packet_ServerMonsters_GetMonsters(Packet_ServerMonsters const *self)
{
	return self->monsters;
}

int Packet_ServerMonsters_GetMonstersCount(Packet_ServerMonsters const *self)
{
	return self->monstersCount;
}

int Packet_ServerMonsters_GetMonstersLength(Packet_ServerMonsters const *self)
{
	return self->monstersLength;
}

void Packet_ServerMonsters_MonstersAdd(Packet_ServerMonsters *self, Packet_ServerMonster const *value)
{
	if (self->monstersCount >= self->monstersLength) {
		Packet_ServerMonster const **Monsters2 = (Packet_ServerMonster const **) malloc(self->monstersLength * 2 * sizeof(Packet_ServerMonster const *));
		self->monstersLength = self->monstersLength * 2;
		{
			int i;
			for (i = 0; i < self->monstersCount; i++) {
				Monsters2[i] = self->monsters[i];
			}
		}
		self->monsters = Monsters2;
	}
	self->monsters[self->monstersCount] = value;
	self->monstersCount++;
}

void Packet_ServerMonsters_SetMonsters(Packet_ServerMonsters *self, Packet_ServerMonster const **value, int count, int length)
{
	self->monsters = value;
	self->monstersCount = count;
	self->monstersLength = length;
}

Packet_ServerMonsters const *Packet_ServerMonstersSerializer_Deserialize(CitoStream const *stream, Packet_ServerMonsters *instance)
{
	if (instance->monsters == NULL) {
		instance->monsters = (Packet_ServerMonster const **) malloc(1 * sizeof(Packet_ServerMonster const *));
		instance->monstersCount = 0;
		instance->monstersLength = 1;
	}
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			Packet_ServerMonsters_MonstersAdd(instance, Packet_ServerMonsterSerializer_DeserializeLengthDelimitedNew(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerMonsters const *Packet_ServerMonstersSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerMonsters *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerMonstersSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerMonsters const *Packet_ServerMonstersSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerMonsters *instance)
{
	int limit;
	if (instance->monsters == NULL) {
		instance->monsters = (Packet_ServerMonster const **) malloc(1 * sizeof(Packet_ServerMonster const *));
		instance->monstersCount = 0;
		instance->monstersLength = 1;
	}
	limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			Packet_ServerMonsters_MonstersAdd(instance, Packet_ServerMonsterSerializer_DeserializeLengthDelimitedNew(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerMonsters const *Packet_ServerMonstersSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerMonsters *instance)
{
	int limit;
	if (instance->monsters == NULL) {
		instance->monsters = (Packet_ServerMonster const **) malloc(1 * sizeof(Packet_ServerMonster const *));
		instance->monstersCount = 0;
		instance->monstersLength = 1;
	}
	limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			Packet_ServerMonsters_MonstersAdd(instance, Packet_ServerMonsterSerializer_DeserializeLengthDelimitedNew(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerMonsters *Packet_ServerMonstersSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerMonsters *instance = Packet_ServerMonsters_New();
	Packet_ServerMonstersSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerMonstersSerializer_Serialize(CitoStream const *stream, Packet_ServerMonsters const *instance)
{
	if (instance->monsters != NULL) {
		{
			int k;
			for (k = 0; k < instance->monstersCount; k++) {
				Packet_ServerMonster const *i1 = instance->monsters[k];
				CitoMemoryStream const *ms1;
				int ms1Length;
				stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
				ms1 = CitoMemoryStream_New();
				Packet_ServerMonsterSerializer_Serialize(&ms1->base, i1);
				ms1Length = CitoMemoryStream_Length(ms1);
				ProtocolParser_WriteUInt32_(stream, ms1Length);
				stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms1), 0, ms1Length);
			}
		}
	}
}

void Packet_ServerMonstersSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerMonsters const *instance)
{
	unsigned char const *data = Packet_ServerMonstersSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerMonstersSerializer_SerializeToBytes(Packet_ServerMonsters const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerMonstersSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerPing const *Packet_ServerPingSerializer_Deserialize(CitoStream const *stream, Packet_ServerPing const *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerPing const *Packet_ServerPingSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerPing const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerPingSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerPing const *Packet_ServerPingSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerPing const *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerPing const *Packet_ServerPingSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerPing const *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerPing const *Packet_ServerPingSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerPing const *instance = Packet_ServerPing_New();
	Packet_ServerPingSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerPingSerializer_Serialize(CitoStream const *stream, Packet_ServerPing const *instance)
{
}

void Packet_ServerPingSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerPing const *instance)
{
	unsigned char const *data = Packet_ServerPingSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerPingSerializer_SerializeToBytes(Packet_ServerPing const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerPingSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerPlayerPing *Packet_ServerPlayerPing_New(void)
{
	Packet_ServerPlayerPing *self = (Packet_ServerPlayerPing *) malloc(sizeof(Packet_ServerPlayerPing));
	return self;
}

void Packet_ServerPlayerPing_Delete(Packet_ServerPlayerPing *self)
{
	free(self);
}

int Packet_ServerPlayerPing_GetClientId(Packet_ServerPlayerPing const *self)
{
	return self->clientId;
}

int Packet_ServerPlayerPing_GetPing(Packet_ServerPlayerPing const *self)
{
	return self->ping;
}

void Packet_ServerPlayerPing_SetClientId(Packet_ServerPlayerPing *self, int value)
{
	self->clientId = value;
}

void Packet_ServerPlayerPing_SetPing(Packet_ServerPlayerPing *self, int value)
{
	self->ping = value;
}

Packet_ServerPlayerPing const *Packet_ServerPlayerPingSerializer_Deserialize(CitoStream const *stream, Packet_ServerPlayerPing *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->clientId = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->ping = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerPlayerPing const *Packet_ServerPlayerPingSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerPlayerPing *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerPlayerPingSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerPlayerPing const *Packet_ServerPlayerPingSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerPlayerPing *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->clientId = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->ping = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerPlayerPing const *Packet_ServerPlayerPingSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerPlayerPing *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->clientId = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->ping = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerPlayerPing *Packet_ServerPlayerPingSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerPlayerPing *instance = Packet_ServerPlayerPing_New();
	Packet_ServerPlayerPingSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerPlayerPingSerializer_Serialize(CitoStream const *stream, Packet_ServerPlayerPing const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->clientId);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->ping);
}

void Packet_ServerPlayerPingSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerPlayerPing const *instance)
{
	unsigned char const *data = Packet_ServerPlayerPingSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerPlayerPingSerializer_SerializeToBytes(Packet_ServerPlayerPing const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerPlayerPingSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerPlayerSpawnPosition *Packet_ServerPlayerSpawnPosition_New(void)
{
	Packet_ServerPlayerSpawnPosition *self = (Packet_ServerPlayerSpawnPosition *) malloc(sizeof(Packet_ServerPlayerSpawnPosition));
	return self;
}

void Packet_ServerPlayerSpawnPosition_Delete(Packet_ServerPlayerSpawnPosition *self)
{
	free(self);
}

int Packet_ServerPlayerSpawnPosition_GetX(Packet_ServerPlayerSpawnPosition const *self)
{
	return self->x;
}

int Packet_ServerPlayerSpawnPosition_GetY(Packet_ServerPlayerSpawnPosition const *self)
{
	return self->y;
}

int Packet_ServerPlayerSpawnPosition_GetZ(Packet_ServerPlayerSpawnPosition const *self)
{
	return self->z;
}

void Packet_ServerPlayerSpawnPosition_SetX(Packet_ServerPlayerSpawnPosition *self, int value)
{
	self->x = value;
}

void Packet_ServerPlayerSpawnPosition_SetY(Packet_ServerPlayerSpawnPosition *self, int value)
{
	self->y = value;
}

void Packet_ServerPlayerSpawnPosition_SetZ(Packet_ServerPlayerSpawnPosition *self, int value)
{
	self->z = value;
}

Packet_ServerPlayerSpawnPosition const *Packet_ServerPlayerSpawnPositionSerializer_Deserialize(CitoStream const *stream, Packet_ServerPlayerSpawnPosition *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerPlayerSpawnPosition const *Packet_ServerPlayerSpawnPositionSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerPlayerSpawnPosition *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerPlayerSpawnPositionSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerPlayerSpawnPosition const *Packet_ServerPlayerSpawnPositionSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerPlayerSpawnPosition *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerPlayerSpawnPosition const *Packet_ServerPlayerSpawnPositionSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerPlayerSpawnPosition *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerPlayerSpawnPosition *Packet_ServerPlayerSpawnPositionSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerPlayerSpawnPosition *instance = Packet_ServerPlayerSpawnPosition_New();
	Packet_ServerPlayerSpawnPositionSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerPlayerSpawnPositionSerializer_Serialize(CitoStream const *stream, Packet_ServerPlayerSpawnPosition const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->x);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->y);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteUInt64(stream, instance->z);
}

void Packet_ServerPlayerSpawnPositionSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerPlayerSpawnPosition const *instance)
{
	unsigned char const *data = Packet_ServerPlayerSpawnPositionSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerPlayerSpawnPositionSerializer_SerializeToBytes(Packet_ServerPlayerSpawnPosition const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerPlayerSpawnPositionSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerPlayerStats *Packet_ServerPlayerStats_New(void)
{
	Packet_ServerPlayerStats *self = (Packet_ServerPlayerStats *) malloc(sizeof(Packet_ServerPlayerStats));
	return self;
}

void Packet_ServerPlayerStats_Delete(Packet_ServerPlayerStats *self)
{
	free(self);
}

int Packet_ServerPlayerStats_GetCurrentHealth(Packet_ServerPlayerStats const *self)
{
	return self->currentHealth;
}

int Packet_ServerPlayerStats_GetCurrentOxygen(Packet_ServerPlayerStats const *self)
{
	return self->currentOxygen;
}

int Packet_ServerPlayerStats_GetMaxHealth(Packet_ServerPlayerStats const *self)
{
	return self->maxHealth;
}

int Packet_ServerPlayerStats_GetMaxOxygen(Packet_ServerPlayerStats const *self)
{
	return self->maxOxygen;
}

void Packet_ServerPlayerStats_SetCurrentHealth(Packet_ServerPlayerStats *self, int value)
{
	self->currentHealth = value;
}

void Packet_ServerPlayerStats_SetCurrentOxygen(Packet_ServerPlayerStats *self, int value)
{
	self->currentOxygen = value;
}

void Packet_ServerPlayerStats_SetMaxHealth(Packet_ServerPlayerStats *self, int value)
{
	self->maxHealth = value;
}

void Packet_ServerPlayerStats_SetMaxOxygen(Packet_ServerPlayerStats *self, int value)
{
	self->maxOxygen = value;
}

Packet_ServerPlayerStats const *Packet_ServerPlayerStatsSerializer_Deserialize(CitoStream const *stream, Packet_ServerPlayerStats *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->currentHealth = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->maxHealth = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->currentOxygen = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->maxOxygen = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerPlayerStats const *Packet_ServerPlayerStatsSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerPlayerStats *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerPlayerStatsSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerPlayerStats const *Packet_ServerPlayerStatsSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerPlayerStats *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->currentHealth = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->maxHealth = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->currentOxygen = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->maxOxygen = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerPlayerStats const *Packet_ServerPlayerStatsSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerPlayerStats *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->currentHealth = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->maxHealth = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->currentOxygen = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->maxOxygen = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerPlayerStats *Packet_ServerPlayerStatsSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerPlayerStats *instance = Packet_ServerPlayerStats_New();
	Packet_ServerPlayerStatsSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerPlayerStatsSerializer_Serialize(CitoStream const *stream, Packet_ServerPlayerStats const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->currentHealth);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->maxHealth);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteUInt64(stream, instance->currentOxygen);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
	ProtocolParser_WriteUInt64(stream, instance->maxOxygen);
}

void Packet_ServerPlayerStatsSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerPlayerStats const *instance)
{
	unsigned char const *data = Packet_ServerPlayerStatsSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerPlayerStatsSerializer_SerializeToBytes(Packet_ServerPlayerStats const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerPlayerStatsSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerProjectile *Packet_ServerProjectile_New(void)
{
	Packet_ServerProjectile *self = (Packet_ServerProjectile *) malloc(sizeof(Packet_ServerProjectile));
	return self;
}

void Packet_ServerProjectile_Delete(Packet_ServerProjectile *self)
{
	free(self);
}

int Packet_ServerProjectile_GetBlockId(Packet_ServerProjectile const *self)
{
	return self->blockId;
}

int Packet_ServerProjectile_GetExplodesAfterFloat(Packet_ServerProjectile const *self)
{
	return self->explodesAfterFloat;
}

int Packet_ServerProjectile_GetFromXFloat(Packet_ServerProjectile const *self)
{
	return self->fromXFloat;
}

int Packet_ServerProjectile_GetFromYFloat(Packet_ServerProjectile const *self)
{
	return self->fromYFloat;
}

int Packet_ServerProjectile_GetFromZFloat(Packet_ServerProjectile const *self)
{
	return self->fromZFloat;
}

int Packet_ServerProjectile_GetSourcePlayerID(Packet_ServerProjectile const *self)
{
	return self->sourcePlayerID;
}

int Packet_ServerProjectile_GetVelocityXFloat(Packet_ServerProjectile const *self)
{
	return self->velocityXFloat;
}

int Packet_ServerProjectile_GetVelocityYFloat(Packet_ServerProjectile const *self)
{
	return self->velocityYFloat;
}

int Packet_ServerProjectile_GetVelocityZFloat(Packet_ServerProjectile const *self)
{
	return self->velocityZFloat;
}

void Packet_ServerProjectile_SetBlockId(Packet_ServerProjectile *self, int value)
{
	self->blockId = value;
}

void Packet_ServerProjectile_SetExplodesAfterFloat(Packet_ServerProjectile *self, int value)
{
	self->explodesAfterFloat = value;
}

void Packet_ServerProjectile_SetFromXFloat(Packet_ServerProjectile *self, int value)
{
	self->fromXFloat = value;
}

void Packet_ServerProjectile_SetFromYFloat(Packet_ServerProjectile *self, int value)
{
	self->fromYFloat = value;
}

void Packet_ServerProjectile_SetFromZFloat(Packet_ServerProjectile *self, int value)
{
	self->fromZFloat = value;
}

void Packet_ServerProjectile_SetSourcePlayerID(Packet_ServerProjectile *self, int value)
{
	self->sourcePlayerID = value;
}

void Packet_ServerProjectile_SetVelocityXFloat(Packet_ServerProjectile *self, int value)
{
	self->velocityXFloat = value;
}

void Packet_ServerProjectile_SetVelocityYFloat(Packet_ServerProjectile *self, int value)
{
	self->velocityYFloat = value;
}

void Packet_ServerProjectile_SetVelocityZFloat(Packet_ServerProjectile *self, int value)
{
	self->velocityZFloat = value;
}

Packet_ServerProjectile const *Packet_ServerProjectileSerializer_Deserialize(CitoStream const *stream, Packet_ServerProjectile *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->fromXFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->fromYFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->fromZFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->velocityXFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->velocityYFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->velocityZFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->blockId = ProtocolParser_ReadUInt64(stream);
			continue;
		case 64:
			instance->explodesAfterFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 72:
			instance->sourcePlayerID = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerProjectile const *Packet_ServerProjectileSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerProjectile *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerProjectileSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerProjectile const *Packet_ServerProjectileSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerProjectile *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->fromXFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->fromYFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->fromZFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->velocityXFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->velocityYFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->velocityZFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->blockId = ProtocolParser_ReadUInt64(stream);
			continue;
		case 64:
			instance->explodesAfterFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 72:
			instance->sourcePlayerID = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerProjectile const *Packet_ServerProjectileSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerProjectile *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->fromXFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->fromYFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->fromZFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->velocityXFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->velocityYFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->velocityZFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 56:
			instance->blockId = ProtocolParser_ReadUInt64(stream);
			continue;
		case 64:
			instance->explodesAfterFloat = ProtocolParser_ReadUInt64(stream);
			continue;
		case 72:
			instance->sourcePlayerID = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerProjectile *Packet_ServerProjectileSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerProjectile *instance = Packet_ServerProjectile_New();
	Packet_ServerProjectileSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerProjectileSerializer_Serialize(CitoStream const *stream, Packet_ServerProjectile const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->fromXFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->fromYFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteUInt64(stream, instance->fromZFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
	ProtocolParser_WriteUInt64(stream, instance->velocityXFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(40));
	ProtocolParser_WriteUInt64(stream, instance->velocityYFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(48));
	ProtocolParser_WriteUInt64(stream, instance->velocityZFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(56));
	ProtocolParser_WriteUInt64(stream, instance->blockId);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(64));
	ProtocolParser_WriteUInt64(stream, instance->explodesAfterFloat);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(72));
	ProtocolParser_WriteUInt64(stream, instance->sourcePlayerID);
}

void Packet_ServerProjectileSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerProjectile const *instance)
{
	unsigned char const *data = Packet_ServerProjectileSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerProjectileSerializer_SerializeToBytes(Packet_ServerProjectile const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerProjectileSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerQueryAnswer *Packet_ServerQueryAnswer_New(void)
{
	Packet_ServerQueryAnswer *self = (Packet_ServerQueryAnswer *) malloc(sizeof(Packet_ServerQueryAnswer));
	return self;
}

void Packet_ServerQueryAnswer_Delete(Packet_ServerQueryAnswer *self)
{
	free(self);
}

const char *Packet_ServerQueryAnswer_GetGameMode(Packet_ServerQueryAnswer const *self)
{
	return self->gameMode;
}

const char *Packet_ServerQueryAnswer_GetMOTD(Packet_ServerQueryAnswer const *self)
{
	return self->mOTD;
}

int Packet_ServerQueryAnswer_GetMapSizeX(Packet_ServerQueryAnswer const *self)
{
	return self->mapSizeX;
}

int Packet_ServerQueryAnswer_GetMapSizeY(Packet_ServerQueryAnswer const *self)
{
	return self->mapSizeY;
}

int Packet_ServerQueryAnswer_GetMapSizeZ(Packet_ServerQueryAnswer const *self)
{
	return self->mapSizeZ;
}

int Packet_ServerQueryAnswer_GetMaxPlayers(Packet_ServerQueryAnswer const *self)
{
	return self->maxPlayers;
}

const char *Packet_ServerQueryAnswer_GetName(Packet_ServerQueryAnswer const *self)
{
	return self->name;
}

cibool Packet_ServerQueryAnswer_GetPassword(Packet_ServerQueryAnswer const *self)
{
	return self->password;
}

int Packet_ServerQueryAnswer_GetPlayerCount(Packet_ServerQueryAnswer const *self)
{
	return self->playerCount;
}

const char *Packet_ServerQueryAnswer_GetPlayerList(Packet_ServerQueryAnswer const *self)
{
	return self->playerList;
}

int Packet_ServerQueryAnswer_GetPort(Packet_ServerQueryAnswer const *self)
{
	return self->port;
}

const char *Packet_ServerQueryAnswer_GetPublicHash(Packet_ServerQueryAnswer const *self)
{
	return self->publicHash;
}

unsigned char const *Packet_ServerQueryAnswer_GetServerThumbnail(Packet_ServerQueryAnswer const *self)
{
	return self->serverThumbnail;
}

const char *Packet_ServerQueryAnswer_GetServerVersion(Packet_ServerQueryAnswer const *self)
{
	return self->serverVersion;
}

void Packet_ServerQueryAnswer_SetGameMode(Packet_ServerQueryAnswer *self, const char *value)
{
	self->gameMode = value;
}

void Packet_ServerQueryAnswer_SetMOTD(Packet_ServerQueryAnswer *self, const char *value)
{
	self->mOTD = value;
}

void Packet_ServerQueryAnswer_SetMapSizeX(Packet_ServerQueryAnswer *self, int value)
{
	self->mapSizeX = value;
}

void Packet_ServerQueryAnswer_SetMapSizeY(Packet_ServerQueryAnswer *self, int value)
{
	self->mapSizeY = value;
}

void Packet_ServerQueryAnswer_SetMapSizeZ(Packet_ServerQueryAnswer *self, int value)
{
	self->mapSizeZ = value;
}

void Packet_ServerQueryAnswer_SetMaxPlayers(Packet_ServerQueryAnswer *self, int value)
{
	self->maxPlayers = value;
}

void Packet_ServerQueryAnswer_SetName(Packet_ServerQueryAnswer *self, const char *value)
{
	self->name = value;
}

void Packet_ServerQueryAnswer_SetPassword(Packet_ServerQueryAnswer *self, cibool value)
{
	self->password = value;
}

void Packet_ServerQueryAnswer_SetPlayerCount(Packet_ServerQueryAnswer *self, int value)
{
	self->playerCount = value;
}

void Packet_ServerQueryAnswer_SetPlayerList(Packet_ServerQueryAnswer *self, const char *value)
{
	self->playerList = value;
}

void Packet_ServerQueryAnswer_SetPort(Packet_ServerQueryAnswer *self, int value)
{
	self->port = value;
}

void Packet_ServerQueryAnswer_SetPublicHash(Packet_ServerQueryAnswer *self, const char *value)
{
	self->publicHash = value;
}

void Packet_ServerQueryAnswer_SetServerThumbnail(Packet_ServerQueryAnswer *self, unsigned char const *value)
{
	self->serverThumbnail = value;
}

void Packet_ServerQueryAnswer_SetServerVersion(Packet_ServerQueryAnswer *self, const char *value)
{
	self->serverVersion = value;
}

Packet_ServerQueryAnswer const *Packet_ServerQueryAnswerSerializer_Deserialize(CitoStream const *stream, Packet_ServerQueryAnswer *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance->name = ProtocolParser_ReadString(stream);
			continue;
		case 18:
			instance->mOTD = ProtocolParser_ReadString(stream);
			continue;
		case 24:
			instance->playerCount = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->maxPlayers = ProtocolParser_ReadUInt64(stream);
			continue;
		case 42:
			instance->playerList = ProtocolParser_ReadString(stream);
			continue;
		case 48:
			instance->port = ProtocolParser_ReadUInt64(stream);
			continue;
		case 58:
			instance->gameMode = ProtocolParser_ReadString(stream);
			continue;
		case 64:
			instance->password = ProtocolParser_ReadBool(stream);
			continue;
		case 74:
			instance->publicHash = ProtocolParser_ReadString(stream);
			continue;
		case 82:
			instance->serverVersion = ProtocolParser_ReadString(stream);
			continue;
		case 88:
			instance->mapSizeX = ProtocolParser_ReadUInt64(stream);
			continue;
		case 96:
			instance->mapSizeY = ProtocolParser_ReadUInt64(stream);
			continue;
		case 104:
			instance->mapSizeZ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 114:
			instance->serverThumbnail = ProtocolParser_ReadBytes(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerQueryAnswer const *Packet_ServerQueryAnswerSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerQueryAnswer *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerQueryAnswerSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerQueryAnswer const *Packet_ServerQueryAnswerSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerQueryAnswer *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->name = ProtocolParser_ReadString(stream);
			continue;
		case 18:
			instance->mOTD = ProtocolParser_ReadString(stream);
			continue;
		case 24:
			instance->playerCount = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->maxPlayers = ProtocolParser_ReadUInt64(stream);
			continue;
		case 42:
			instance->playerList = ProtocolParser_ReadString(stream);
			continue;
		case 48:
			instance->port = ProtocolParser_ReadUInt64(stream);
			continue;
		case 58:
			instance->gameMode = ProtocolParser_ReadString(stream);
			continue;
		case 64:
			instance->password = ProtocolParser_ReadBool(stream);
			continue;
		case 74:
			instance->publicHash = ProtocolParser_ReadString(stream);
			continue;
		case 82:
			instance->serverVersion = ProtocolParser_ReadString(stream);
			continue;
		case 88:
			instance->mapSizeX = ProtocolParser_ReadUInt64(stream);
			continue;
		case 96:
			instance->mapSizeY = ProtocolParser_ReadUInt64(stream);
			continue;
		case 104:
			instance->mapSizeZ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 114:
			instance->serverThumbnail = ProtocolParser_ReadBytes(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerQueryAnswer const *Packet_ServerQueryAnswerSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerQueryAnswer *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->name = ProtocolParser_ReadString(stream);
			continue;
		case 18:
			instance->mOTD = ProtocolParser_ReadString(stream);
			continue;
		case 24:
			instance->playerCount = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->maxPlayers = ProtocolParser_ReadUInt64(stream);
			continue;
		case 42:
			instance->playerList = ProtocolParser_ReadString(stream);
			continue;
		case 48:
			instance->port = ProtocolParser_ReadUInt64(stream);
			continue;
		case 58:
			instance->gameMode = ProtocolParser_ReadString(stream);
			continue;
		case 64:
			instance->password = ProtocolParser_ReadBool(stream);
			continue;
		case 74:
			instance->publicHash = ProtocolParser_ReadString(stream);
			continue;
		case 82:
			instance->serverVersion = ProtocolParser_ReadString(stream);
			continue;
		case 88:
			instance->mapSizeX = ProtocolParser_ReadUInt64(stream);
			continue;
		case 96:
			instance->mapSizeY = ProtocolParser_ReadUInt64(stream);
			continue;
		case 104:
			instance->mapSizeZ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 114:
			instance->serverThumbnail = ProtocolParser_ReadBytes(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerQueryAnswer *Packet_ServerQueryAnswerSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerQueryAnswer *instance = Packet_ServerQueryAnswer_New();
	Packet_ServerQueryAnswerSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerQueryAnswerSerializer_Serialize(CitoStream const *stream, Packet_ServerQueryAnswer const *instance)
{
	if (instance->name != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->name));
	}
	if (instance->mOTD != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(18));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->mOTD));
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteUInt64(stream, instance->playerCount);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
	ProtocolParser_WriteUInt64(stream, instance->maxPlayers);
	if (instance->playerList != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(42));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->playerList));
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(48));
	ProtocolParser_WriteUInt64(stream, instance->port);
	if (instance->gameMode != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(58));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->gameMode));
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(64));
	ProtocolParser_WriteBool(stream, instance->password);
	if (instance->publicHash != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(74));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->publicHash));
	}
	if (instance->serverVersion != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(82));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->serverVersion));
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(88));
	ProtocolParser_WriteUInt64(stream, instance->mapSizeX);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(96));
	ProtocolParser_WriteUInt64(stream, instance->mapSizeY);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(104));
	ProtocolParser_WriteUInt64(stream, instance->mapSizeZ);
	if (instance->serverThumbnail != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(114));
		ProtocolParser_WriteBytes(stream, instance->serverThumbnail);
	}
}

void Packet_ServerQueryAnswerSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerQueryAnswer const *instance)
{
	unsigned char const *data = Packet_ServerQueryAnswerSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerQueryAnswerSerializer_SerializeToBytes(Packet_ServerQueryAnswer const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerQueryAnswerSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerRedirect *Packet_ServerRedirect_New(void)
{
	Packet_ServerRedirect *self = (Packet_ServerRedirect *) malloc(sizeof(Packet_ServerRedirect));
	return self;
}

void Packet_ServerRedirect_Delete(Packet_ServerRedirect *self)
{
	free(self);
}

const char *Packet_ServerRedirect_GetIP(Packet_ServerRedirect const *self)
{
	return self->iP;
}

int Packet_ServerRedirect_GetPort(Packet_ServerRedirect const *self)
{
	return self->port;
}

void Packet_ServerRedirect_SetIP(Packet_ServerRedirect *self, const char *value)
{
	self->iP = value;
}

void Packet_ServerRedirect_SetPort(Packet_ServerRedirect *self, int value)
{
	self->port = value;
}

Packet_ServerRedirect const *Packet_ServerRedirectSerializer_Deserialize(CitoStream const *stream, Packet_ServerRedirect *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance->iP = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->port = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerRedirect const *Packet_ServerRedirectSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerRedirect *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerRedirectSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerRedirect const *Packet_ServerRedirectSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerRedirect *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->iP = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->port = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerRedirect const *Packet_ServerRedirectSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerRedirect *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->iP = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->port = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerRedirect *Packet_ServerRedirectSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerRedirect *instance = Packet_ServerRedirect_New();
	Packet_ServerRedirectSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerRedirectSerializer_Serialize(CitoStream const *stream, Packet_ServerRedirect const *instance)
{
	if (instance->iP != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->iP));
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->port);
}

void Packet_ServerRedirectSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerRedirect const *instance)
{
	unsigned char const *data = Packet_ServerRedirectSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerRedirectSerializer_SerializeToBytes(Packet_ServerRedirect const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerRedirectSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerSeason *Packet_ServerSeason_New(void)
{
	Packet_ServerSeason *self = (Packet_ServerSeason *) malloc(sizeof(Packet_ServerSeason));
	return self;
}

void Packet_ServerSeason_Delete(Packet_ServerSeason *self)
{
	free(self);
}

int Packet_ServerSeason_GetDayNightCycleSpeedup(Packet_ServerSeason const *self)
{
	return self->dayNightCycleSpeedup;
}

int Packet_ServerSeason_GetHour(Packet_ServerSeason const *self)
{
	return self->hour;
}

int Packet_ServerSeason_GetMoon(Packet_ServerSeason const *self)
{
	return self->moon;
}

void Packet_ServerSeason_SetDayNightCycleSpeedup(Packet_ServerSeason *self, int value)
{
	self->dayNightCycleSpeedup = value;
}

void Packet_ServerSeason_SetHour(Packet_ServerSeason *self, int value)
{
	self->hour = value;
}

void Packet_ServerSeason_SetMoon(Packet_ServerSeason *self, int value)
{
	self->moon = value;
}

Packet_ServerSeason const *Packet_ServerSeasonSerializer_Deserialize(CitoStream const *stream, Packet_ServerSeason *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 16:
			instance->hour = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->dayNightCycleSpeedup = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->moon = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSeason const *Packet_ServerSeasonSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerSeason *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerSeasonSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerSeason const *Packet_ServerSeasonSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerSeason *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 16:
			instance->hour = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->dayNightCycleSpeedup = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->moon = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSeason const *Packet_ServerSeasonSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerSeason *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 16:
			instance->hour = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->dayNightCycleSpeedup = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->moon = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSeason *Packet_ServerSeasonSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerSeason *instance = Packet_ServerSeason_New();
	Packet_ServerSeasonSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerSeasonSerializer_Serialize(CitoStream const *stream, Packet_ServerSeason const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->hour);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteUInt64(stream, instance->dayNightCycleSpeedup);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
	ProtocolParser_WriteUInt64(stream, instance->moon);
}

void Packet_ServerSeasonSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerSeason const *instance)
{
	unsigned char const *data = Packet_ServerSeasonSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerSeasonSerializer_SerializeToBytes(Packet_ServerSeason const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerSeasonSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_Server const *Packet_ServerSerializer_Deserialize(CitoStream const *stream, Packet_Server *instance)
{
	instance->id = 0;
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			if (instance->identification == NULL)
				instance->identification = Packet_ServerIdentificationSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerIdentificationSerializer_DeserializeLengthDelimited(stream, instance->identification);
			continue;
		case 18:
			if (instance->levelInitialize == NULL)
				instance->levelInitialize = Packet_ServerLevelInitializeSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerLevelInitializeSerializer_DeserializeLengthDelimited(stream, instance->levelInitialize);
			continue;
		case 26:
			if (instance->levelDataChunk == NULL)
				instance->levelDataChunk = Packet_ServerLevelProgressSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerLevelProgressSerializer_DeserializeLengthDelimited(stream, instance->levelDataChunk);
			continue;
		case 34:
			if (instance->levelFinalize == NULL)
				instance->levelFinalize = Packet_ServerLevelFinalizeSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerLevelFinalizeSerializer_DeserializeLengthDelimited(stream, instance->levelFinalize);
			continue;
		case 42:
			if (instance->setBlock == NULL)
				instance->setBlock = Packet_ServerSetBlockSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerSetBlockSerializer_DeserializeLengthDelimited(stream, instance->setBlock);
			continue;
		case 74:
			if (instance->message == NULL)
				instance->message = Packet_ServerMessageSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerMessageSerializer_DeserializeLengthDelimited(stream, instance->message);
			continue;
		case 82:
			if (instance->disconnectPlayer == NULL)
				instance->disconnectPlayer = Packet_ServerDisconnectPlayerSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerDisconnectPlayerSerializer_DeserializeLengthDelimited(stream, instance->disconnectPlayer);
			continue;
		case 90:
			if (instance->chunk_ == NULL)
				instance->chunk_ = Packet_ServerChunkSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerChunkSerializer_DeserializeLengthDelimited(stream, instance->chunk_);
			continue;
		case 98:
			if (instance->inventory == NULL)
				instance->inventory = Packet_ServerInventorySerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerInventorySerializer_DeserializeLengthDelimited(stream, instance->inventory);
			continue;
		case 106:
			if (instance->season == NULL)
				instance->season = Packet_ServerSeasonSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerSeasonSerializer_DeserializeLengthDelimited(stream, instance->season);
			continue;
		case 114:
			if (instance->blobInitialize == NULL)
				instance->blobInitialize = Packet_ServerBlobInitializeSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlobInitializeSerializer_DeserializeLengthDelimited(stream, instance->blobInitialize);
			continue;
		case 122:
			if (instance->blobPart == NULL)
				instance->blobPart = Packet_ServerBlobPartSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlobPartSerializer_DeserializeLengthDelimited(stream, instance->blobPart);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		case 90:
			if (Key_GetWireType(key) != 0)
				break;
			instance->id = ProtocolParser_ReadUInt64(stream);
			continue;
		case 51:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->fillArea == NULL)
				instance->fillArea = Packet_ServerFillAreaSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerFillAreaSerializer_DeserializeLengthDelimited(stream, instance->fillArea);
			continue;
		case 52:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->fillAreaLimit == NULL)
				instance->fillAreaLimit = Packet_ServerFillAreaLimitSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerFillAreaLimitSerializer_DeserializeLengthDelimited(stream, instance->fillAreaLimit);
			continue;
		case 53:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->freemove == NULL)
				instance->freemove = Packet_ServerFreemoveSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerFreemoveSerializer_DeserializeLengthDelimited(stream, instance->freemove);
			continue;
		case 16:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->blobFinalize == NULL)
				instance->blobFinalize = Packet_ServerBlobFinalizeSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlobFinalizeSerializer_DeserializeLengthDelimited(stream, instance->blobFinalize);
			continue;
		case 17:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->heightmapChunk == NULL)
				instance->heightmapChunk = Packet_ServerHeightmapChunkSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerHeightmapChunkSerializer_DeserializeLengthDelimited(stream, instance->heightmapChunk);
			continue;
		case 18:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->ping == NULL)
				instance->ping = Packet_ServerPingSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPingSerializer_DeserializeLengthDelimited(stream, instance->ping);
			continue;
		case 181:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->playerPing == NULL)
				instance->playerPing = Packet_ServerPlayerPingSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPlayerPingSerializer_DeserializeLengthDelimited(stream, instance->playerPing);
			continue;
		case 19:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->sound == NULL)
				instance->sound = Packet_ServerSoundSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerSoundSerializer_DeserializeLengthDelimited(stream, instance->sound);
			continue;
		case 20:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->playerStats == NULL)
				instance->playerStats = Packet_ServerPlayerStatsSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPlayerStatsSerializer_DeserializeLengthDelimited(stream, instance->playerStats);
			continue;
		case 21:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->monster == NULL)
				instance->monster = Packet_ServerMonstersSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerMonstersSerializer_DeserializeLengthDelimited(stream, instance->monster);
			continue;
		case 22:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->playerSpawnPosition == NULL)
				instance->playerSpawnPosition = Packet_ServerPlayerSpawnPositionSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPlayerSpawnPositionSerializer_DeserializeLengthDelimited(stream, instance->playerSpawnPosition);
			continue;
		case 23:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->blockTypes == NULL)
				instance->blockTypes = Packet_ServerBlockTypesSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlockTypesSerializer_DeserializeLengthDelimited(stream, instance->blockTypes);
			continue;
		case 24:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->sunLevels == NULL)
				instance->sunLevels = Packet_ServerSunLevelsSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerSunLevelsSerializer_DeserializeLengthDelimited(stream, instance->sunLevels);
			continue;
		case 25:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->lightLevels == NULL)
				instance->lightLevels = Packet_ServerLightLevelsSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerLightLevelsSerializer_DeserializeLengthDelimited(stream, instance->lightLevels);
			continue;
		case 26:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->craftingRecipes == NULL)
				instance->craftingRecipes = Packet_ServerCraftingRecipesSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerCraftingRecipesSerializer_DeserializeLengthDelimited(stream, instance->craftingRecipes);
			continue;
		case 27:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->dialog == NULL)
				instance->dialog = Packet_ServerDialogSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerDialogSerializer_DeserializeLengthDelimited(stream, instance->dialog);
			continue;
		case 28:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->follow == NULL)
				instance->follow = Packet_ServerFollowSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerFollowSerializer_DeserializeLengthDelimited(stream, instance->follow);
			continue;
		case 29:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->bullet == NULL)
				instance->bullet = Packet_ServerBulletSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBulletSerializer_DeserializeLengthDelimited(stream, instance->bullet);
			continue;
		case 30:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->ammo == NULL)
				instance->ammo = Packet_ServerAmmoSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerAmmoSerializer_DeserializeLengthDelimited(stream, instance->ammo);
			continue;
		case 31:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->blockType == NULL)
				instance->blockType = Packet_ServerBlockTypeSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlockTypeSerializer_DeserializeLengthDelimited(stream, instance->blockType);
			continue;
		case 32:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->chunkPart == NULL)
				instance->chunkPart = Packet_ServerChunkPartSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerChunkPartSerializer_DeserializeLengthDelimited(stream, instance->chunkPart);
			continue;
		case 33:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->explosion == NULL)
				instance->explosion = Packet_ServerExplosionSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerExplosionSerializer_DeserializeLengthDelimited(stream, instance->explosion);
			continue;
		case 34:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->projectile == NULL)
				instance->projectile = Packet_ServerProjectileSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerProjectileSerializer_DeserializeLengthDelimited(stream, instance->projectile);
			continue;
		case 35:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->translation == NULL)
				instance->translation = Packet_ServerTranslatedStringSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerTranslatedStringSerializer_DeserializeLengthDelimited(stream, instance->translation);
			continue;
		case 36:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->queryAnswer == NULL)
				instance->queryAnswer = Packet_ServerQueryAnswerSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerQueryAnswerSerializer_DeserializeLengthDelimited(stream, instance->queryAnswer);
			continue;
		case 37:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->redirect == NULL)
				instance->redirect = Packet_ServerRedirectSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerRedirectSerializer_DeserializeLengthDelimited(stream, instance->redirect);
			continue;
		case 39:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->entitySpawn == NULL)
				instance->entitySpawn = Packet_ServerEntitySpawnSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntitySpawnSerializer_DeserializeLengthDelimited(stream, instance->entitySpawn);
			continue;
		case 40:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->entityPosition == NULL)
				instance->entityPosition = Packet_ServerEntityPositionAndOrientationSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityPositionAndOrientationSerializer_DeserializeLengthDelimited(stream, instance->entityPosition);
			continue;
		case 41:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->entityDespawn == NULL)
				instance->entityDespawn = Packet_ServerEntityDespawnSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDespawnSerializer_DeserializeLengthDelimited(stream, instance->entityDespawn);
			continue;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_Server const *Packet_ServerSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_Server *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_Server const *Packet_ServerSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_Server *instance)
{
	int limit;
	instance->id = 0;
	limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			if (instance->identification == NULL)
				instance->identification = Packet_ServerIdentificationSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerIdentificationSerializer_DeserializeLengthDelimited(stream, instance->identification);
			continue;
		case 18:
			if (instance->levelInitialize == NULL)
				instance->levelInitialize = Packet_ServerLevelInitializeSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerLevelInitializeSerializer_DeserializeLengthDelimited(stream, instance->levelInitialize);
			continue;
		case 26:
			if (instance->levelDataChunk == NULL)
				instance->levelDataChunk = Packet_ServerLevelProgressSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerLevelProgressSerializer_DeserializeLengthDelimited(stream, instance->levelDataChunk);
			continue;
		case 34:
			if (instance->levelFinalize == NULL)
				instance->levelFinalize = Packet_ServerLevelFinalizeSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerLevelFinalizeSerializer_DeserializeLengthDelimited(stream, instance->levelFinalize);
			continue;
		case 42:
			if (instance->setBlock == NULL)
				instance->setBlock = Packet_ServerSetBlockSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerSetBlockSerializer_DeserializeLengthDelimited(stream, instance->setBlock);
			continue;
		case 74:
			if (instance->message == NULL)
				instance->message = Packet_ServerMessageSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerMessageSerializer_DeserializeLengthDelimited(stream, instance->message);
			continue;
		case 82:
			if (instance->disconnectPlayer == NULL)
				instance->disconnectPlayer = Packet_ServerDisconnectPlayerSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerDisconnectPlayerSerializer_DeserializeLengthDelimited(stream, instance->disconnectPlayer);
			continue;
		case 90:
			if (instance->chunk_ == NULL)
				instance->chunk_ = Packet_ServerChunkSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerChunkSerializer_DeserializeLengthDelimited(stream, instance->chunk_);
			continue;
		case 98:
			if (instance->inventory == NULL)
				instance->inventory = Packet_ServerInventorySerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerInventorySerializer_DeserializeLengthDelimited(stream, instance->inventory);
			continue;
		case 106:
			if (instance->season == NULL)
				instance->season = Packet_ServerSeasonSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerSeasonSerializer_DeserializeLengthDelimited(stream, instance->season);
			continue;
		case 114:
			if (instance->blobInitialize == NULL)
				instance->blobInitialize = Packet_ServerBlobInitializeSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlobInitializeSerializer_DeserializeLengthDelimited(stream, instance->blobInitialize);
			continue;
		case 122:
			if (instance->blobPart == NULL)
				instance->blobPart = Packet_ServerBlobPartSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlobPartSerializer_DeserializeLengthDelimited(stream, instance->blobPart);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		case 90:
			if (Key_GetWireType(key) != 0)
				break;
			instance->id = ProtocolParser_ReadUInt64(stream);
			continue;
		case 51:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->fillArea == NULL)
				instance->fillArea = Packet_ServerFillAreaSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerFillAreaSerializer_DeserializeLengthDelimited(stream, instance->fillArea);
			continue;
		case 52:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->fillAreaLimit == NULL)
				instance->fillAreaLimit = Packet_ServerFillAreaLimitSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerFillAreaLimitSerializer_DeserializeLengthDelimited(stream, instance->fillAreaLimit);
			continue;
		case 53:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->freemove == NULL)
				instance->freemove = Packet_ServerFreemoveSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerFreemoveSerializer_DeserializeLengthDelimited(stream, instance->freemove);
			continue;
		case 16:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->blobFinalize == NULL)
				instance->blobFinalize = Packet_ServerBlobFinalizeSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlobFinalizeSerializer_DeserializeLengthDelimited(stream, instance->blobFinalize);
			continue;
		case 17:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->heightmapChunk == NULL)
				instance->heightmapChunk = Packet_ServerHeightmapChunkSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerHeightmapChunkSerializer_DeserializeLengthDelimited(stream, instance->heightmapChunk);
			continue;
		case 18:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->ping == NULL)
				instance->ping = Packet_ServerPingSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPingSerializer_DeserializeLengthDelimited(stream, instance->ping);
			continue;
		case 181:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->playerPing == NULL)
				instance->playerPing = Packet_ServerPlayerPingSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPlayerPingSerializer_DeserializeLengthDelimited(stream, instance->playerPing);
			continue;
		case 19:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->sound == NULL)
				instance->sound = Packet_ServerSoundSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerSoundSerializer_DeserializeLengthDelimited(stream, instance->sound);
			continue;
		case 20:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->playerStats == NULL)
				instance->playerStats = Packet_ServerPlayerStatsSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPlayerStatsSerializer_DeserializeLengthDelimited(stream, instance->playerStats);
			continue;
		case 21:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->monster == NULL)
				instance->monster = Packet_ServerMonstersSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerMonstersSerializer_DeserializeLengthDelimited(stream, instance->monster);
			continue;
		case 22:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->playerSpawnPosition == NULL)
				instance->playerSpawnPosition = Packet_ServerPlayerSpawnPositionSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPlayerSpawnPositionSerializer_DeserializeLengthDelimited(stream, instance->playerSpawnPosition);
			continue;
		case 23:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->blockTypes == NULL)
				instance->blockTypes = Packet_ServerBlockTypesSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlockTypesSerializer_DeserializeLengthDelimited(stream, instance->blockTypes);
			continue;
		case 24:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->sunLevels == NULL)
				instance->sunLevels = Packet_ServerSunLevelsSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerSunLevelsSerializer_DeserializeLengthDelimited(stream, instance->sunLevels);
			continue;
		case 25:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->lightLevels == NULL)
				instance->lightLevels = Packet_ServerLightLevelsSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerLightLevelsSerializer_DeserializeLengthDelimited(stream, instance->lightLevels);
			continue;
		case 26:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->craftingRecipes == NULL)
				instance->craftingRecipes = Packet_ServerCraftingRecipesSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerCraftingRecipesSerializer_DeserializeLengthDelimited(stream, instance->craftingRecipes);
			continue;
		case 27:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->dialog == NULL)
				instance->dialog = Packet_ServerDialogSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerDialogSerializer_DeserializeLengthDelimited(stream, instance->dialog);
			continue;
		case 28:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->follow == NULL)
				instance->follow = Packet_ServerFollowSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerFollowSerializer_DeserializeLengthDelimited(stream, instance->follow);
			continue;
		case 29:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->bullet == NULL)
				instance->bullet = Packet_ServerBulletSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBulletSerializer_DeserializeLengthDelimited(stream, instance->bullet);
			continue;
		case 30:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->ammo == NULL)
				instance->ammo = Packet_ServerAmmoSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerAmmoSerializer_DeserializeLengthDelimited(stream, instance->ammo);
			continue;
		case 31:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->blockType == NULL)
				instance->blockType = Packet_ServerBlockTypeSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlockTypeSerializer_DeserializeLengthDelimited(stream, instance->blockType);
			continue;
		case 32:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->chunkPart == NULL)
				instance->chunkPart = Packet_ServerChunkPartSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerChunkPartSerializer_DeserializeLengthDelimited(stream, instance->chunkPart);
			continue;
		case 33:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->explosion == NULL)
				instance->explosion = Packet_ServerExplosionSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerExplosionSerializer_DeserializeLengthDelimited(stream, instance->explosion);
			continue;
		case 34:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->projectile == NULL)
				instance->projectile = Packet_ServerProjectileSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerProjectileSerializer_DeserializeLengthDelimited(stream, instance->projectile);
			continue;
		case 35:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->translation == NULL)
				instance->translation = Packet_ServerTranslatedStringSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerTranslatedStringSerializer_DeserializeLengthDelimited(stream, instance->translation);
			continue;
		case 36:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->queryAnswer == NULL)
				instance->queryAnswer = Packet_ServerQueryAnswerSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerQueryAnswerSerializer_DeserializeLengthDelimited(stream, instance->queryAnswer);
			continue;
		case 37:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->redirect == NULL)
				instance->redirect = Packet_ServerRedirectSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerRedirectSerializer_DeserializeLengthDelimited(stream, instance->redirect);
			continue;
		case 39:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->entitySpawn == NULL)
				instance->entitySpawn = Packet_ServerEntitySpawnSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntitySpawnSerializer_DeserializeLengthDelimited(stream, instance->entitySpawn);
			continue;
		case 40:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->entityPosition == NULL)
				instance->entityPosition = Packet_ServerEntityPositionAndOrientationSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityPositionAndOrientationSerializer_DeserializeLengthDelimited(stream, instance->entityPosition);
			continue;
		case 41:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->entityDespawn == NULL)
				instance->entityDespawn = Packet_ServerEntityDespawnSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDespawnSerializer_DeserializeLengthDelimited(stream, instance->entityDespawn);
			continue;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_Server const *Packet_ServerSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_Server *instance)
{
	int limit;
	instance->id = 0;
	limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			if (instance->identification == NULL)
				instance->identification = Packet_ServerIdentificationSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerIdentificationSerializer_DeserializeLengthDelimited(stream, instance->identification);
			continue;
		case 18:
			if (instance->levelInitialize == NULL)
				instance->levelInitialize = Packet_ServerLevelInitializeSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerLevelInitializeSerializer_DeserializeLengthDelimited(stream, instance->levelInitialize);
			continue;
		case 26:
			if (instance->levelDataChunk == NULL)
				instance->levelDataChunk = Packet_ServerLevelProgressSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerLevelProgressSerializer_DeserializeLengthDelimited(stream, instance->levelDataChunk);
			continue;
		case 34:
			if (instance->levelFinalize == NULL)
				instance->levelFinalize = Packet_ServerLevelFinalizeSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerLevelFinalizeSerializer_DeserializeLengthDelimited(stream, instance->levelFinalize);
			continue;
		case 42:
			if (instance->setBlock == NULL)
				instance->setBlock = Packet_ServerSetBlockSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerSetBlockSerializer_DeserializeLengthDelimited(stream, instance->setBlock);
			continue;
		case 74:
			if (instance->message == NULL)
				instance->message = Packet_ServerMessageSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerMessageSerializer_DeserializeLengthDelimited(stream, instance->message);
			continue;
		case 82:
			if (instance->disconnectPlayer == NULL)
				instance->disconnectPlayer = Packet_ServerDisconnectPlayerSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerDisconnectPlayerSerializer_DeserializeLengthDelimited(stream, instance->disconnectPlayer);
			continue;
		case 90:
			if (instance->chunk_ == NULL)
				instance->chunk_ = Packet_ServerChunkSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerChunkSerializer_DeserializeLengthDelimited(stream, instance->chunk_);
			continue;
		case 98:
			if (instance->inventory == NULL)
				instance->inventory = Packet_ServerInventorySerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerInventorySerializer_DeserializeLengthDelimited(stream, instance->inventory);
			continue;
		case 106:
			if (instance->season == NULL)
				instance->season = Packet_ServerSeasonSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerSeasonSerializer_DeserializeLengthDelimited(stream, instance->season);
			continue;
		case 114:
			if (instance->blobInitialize == NULL)
				instance->blobInitialize = Packet_ServerBlobInitializeSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlobInitializeSerializer_DeserializeLengthDelimited(stream, instance->blobInitialize);
			continue;
		case 122:
			if (instance->blobPart == NULL)
				instance->blobPart = Packet_ServerBlobPartSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlobPartSerializer_DeserializeLengthDelimited(stream, instance->blobPart);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		case 90:
			if (Key_GetWireType(key) != 0)
				break;
			instance->id = ProtocolParser_ReadUInt64(stream);
			continue;
		case 51:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->fillArea == NULL)
				instance->fillArea = Packet_ServerFillAreaSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerFillAreaSerializer_DeserializeLengthDelimited(stream, instance->fillArea);
			continue;
		case 52:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->fillAreaLimit == NULL)
				instance->fillAreaLimit = Packet_ServerFillAreaLimitSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerFillAreaLimitSerializer_DeserializeLengthDelimited(stream, instance->fillAreaLimit);
			continue;
		case 53:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->freemove == NULL)
				instance->freemove = Packet_ServerFreemoveSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerFreemoveSerializer_DeserializeLengthDelimited(stream, instance->freemove);
			continue;
		case 16:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->blobFinalize == NULL)
				instance->blobFinalize = Packet_ServerBlobFinalizeSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlobFinalizeSerializer_DeserializeLengthDelimited(stream, instance->blobFinalize);
			continue;
		case 17:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->heightmapChunk == NULL)
				instance->heightmapChunk = Packet_ServerHeightmapChunkSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerHeightmapChunkSerializer_DeserializeLengthDelimited(stream, instance->heightmapChunk);
			continue;
		case 18:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->ping == NULL)
				instance->ping = Packet_ServerPingSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPingSerializer_DeserializeLengthDelimited(stream, instance->ping);
			continue;
		case 181:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->playerPing == NULL)
				instance->playerPing = Packet_ServerPlayerPingSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPlayerPingSerializer_DeserializeLengthDelimited(stream, instance->playerPing);
			continue;
		case 19:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->sound == NULL)
				instance->sound = Packet_ServerSoundSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerSoundSerializer_DeserializeLengthDelimited(stream, instance->sound);
			continue;
		case 20:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->playerStats == NULL)
				instance->playerStats = Packet_ServerPlayerStatsSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPlayerStatsSerializer_DeserializeLengthDelimited(stream, instance->playerStats);
			continue;
		case 21:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->monster == NULL)
				instance->monster = Packet_ServerMonstersSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerMonstersSerializer_DeserializeLengthDelimited(stream, instance->monster);
			continue;
		case 22:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->playerSpawnPosition == NULL)
				instance->playerSpawnPosition = Packet_ServerPlayerSpawnPositionSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerPlayerSpawnPositionSerializer_DeserializeLengthDelimited(stream, instance->playerSpawnPosition);
			continue;
		case 23:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->blockTypes == NULL)
				instance->blockTypes = Packet_ServerBlockTypesSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlockTypesSerializer_DeserializeLengthDelimited(stream, instance->blockTypes);
			continue;
		case 24:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->sunLevels == NULL)
				instance->sunLevels = Packet_ServerSunLevelsSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerSunLevelsSerializer_DeserializeLengthDelimited(stream, instance->sunLevels);
			continue;
		case 25:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->lightLevels == NULL)
				instance->lightLevels = Packet_ServerLightLevelsSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerLightLevelsSerializer_DeserializeLengthDelimited(stream, instance->lightLevels);
			continue;
		case 26:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->craftingRecipes == NULL)
				instance->craftingRecipes = Packet_ServerCraftingRecipesSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerCraftingRecipesSerializer_DeserializeLengthDelimited(stream, instance->craftingRecipes);
			continue;
		case 27:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->dialog == NULL)
				instance->dialog = Packet_ServerDialogSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerDialogSerializer_DeserializeLengthDelimited(stream, instance->dialog);
			continue;
		case 28:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->follow == NULL)
				instance->follow = Packet_ServerFollowSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerFollowSerializer_DeserializeLengthDelimited(stream, instance->follow);
			continue;
		case 29:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->bullet == NULL)
				instance->bullet = Packet_ServerBulletSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBulletSerializer_DeserializeLengthDelimited(stream, instance->bullet);
			continue;
		case 30:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->ammo == NULL)
				instance->ammo = Packet_ServerAmmoSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerAmmoSerializer_DeserializeLengthDelimited(stream, instance->ammo);
			continue;
		case 31:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->blockType == NULL)
				instance->blockType = Packet_ServerBlockTypeSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerBlockTypeSerializer_DeserializeLengthDelimited(stream, instance->blockType);
			continue;
		case 32:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->chunkPart == NULL)
				instance->chunkPart = Packet_ServerChunkPartSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerChunkPartSerializer_DeserializeLengthDelimited(stream, instance->chunkPart);
			continue;
		case 33:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->explosion == NULL)
				instance->explosion = Packet_ServerExplosionSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerExplosionSerializer_DeserializeLengthDelimited(stream, instance->explosion);
			continue;
		case 34:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->projectile == NULL)
				instance->projectile = Packet_ServerProjectileSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerProjectileSerializer_DeserializeLengthDelimited(stream, instance->projectile);
			continue;
		case 35:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->translation == NULL)
				instance->translation = Packet_ServerTranslatedStringSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerTranslatedStringSerializer_DeserializeLengthDelimited(stream, instance->translation);
			continue;
		case 36:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->queryAnswer == NULL)
				instance->queryAnswer = Packet_ServerQueryAnswerSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerQueryAnswerSerializer_DeserializeLengthDelimited(stream, instance->queryAnswer);
			continue;
		case 37:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->redirect == NULL)
				instance->redirect = Packet_ServerRedirectSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerRedirectSerializer_DeserializeLengthDelimited(stream, instance->redirect);
			continue;
		case 39:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->entitySpawn == NULL)
				instance->entitySpawn = Packet_ServerEntitySpawnSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntitySpawnSerializer_DeserializeLengthDelimited(stream, instance->entitySpawn);
			continue;
		case 40:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->entityPosition == NULL)
				instance->entityPosition = Packet_ServerEntityPositionAndOrientationSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityPositionAndOrientationSerializer_DeserializeLengthDelimited(stream, instance->entityPosition);
			continue;
		case 41:
			if (Key_GetWireType(key) != 2)
				break;
			if (instance->entityDespawn == NULL)
				instance->entityDespawn = Packet_ServerEntityDespawnSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_ServerEntityDespawnSerializer_DeserializeLengthDelimited(stream, instance->entityDespawn);
			continue;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_Server const *Packet_ServerSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_Server *instance = Packet_Server_New();
	Packet_ServerSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerSerializer_Serialize(CitoStream const *stream, Packet_Server const *instance)
{
	if (instance->id != 0) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(208));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(5));
		ProtocolParser_WriteUInt64(stream, instance->id);
	}
	if (instance->identification != NULL) {
		CitoMemoryStream const *ms1;
		int ms1Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
		ms1 = CitoMemoryStream_New();
		Packet_ServerIdentificationSerializer_Serialize(&ms1->base, instance->identification);
		ms1Length = CitoMemoryStream_Length(ms1);
		ProtocolParser_WriteUInt32_(stream, ms1Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms1), 0, ms1Length);
	}
	if (instance->levelInitialize != NULL) {
		CitoMemoryStream const *ms2;
		int ms2Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(18));
		ms2 = CitoMemoryStream_New();
		Packet_ServerLevelInitializeSerializer_Serialize(&ms2->base, instance->levelInitialize);
		ms2Length = CitoMemoryStream_Length(ms2);
		ProtocolParser_WriteUInt32_(stream, ms2Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms2), 0, ms2Length);
	}
	if (instance->levelDataChunk != NULL) {
		CitoMemoryStream const *ms3;
		int ms3Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(26));
		ms3 = CitoMemoryStream_New();
		Packet_ServerLevelProgressSerializer_Serialize(&ms3->base, instance->levelDataChunk);
		ms3Length = CitoMemoryStream_Length(ms3);
		ProtocolParser_WriteUInt32_(stream, ms3Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms3), 0, ms3Length);
	}
	if (instance->levelFinalize != NULL) {
		CitoMemoryStream const *ms4;
		int ms4Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(34));
		ms4 = CitoMemoryStream_New();
		Packet_ServerLevelFinalizeSerializer_Serialize(&ms4->base, instance->levelFinalize);
		ms4Length = CitoMemoryStream_Length(ms4);
		ProtocolParser_WriteUInt32_(stream, ms4Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms4), 0, ms4Length);
	}
	if (instance->setBlock != NULL) {
		CitoMemoryStream const *ms5;
		int ms5Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(42));
		ms5 = CitoMemoryStream_New();
		Packet_ServerSetBlockSerializer_Serialize(&ms5->base, instance->setBlock);
		ms5Length = CitoMemoryStream_Length(ms5);
		ProtocolParser_WriteUInt32_(stream, ms5Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms5), 0, ms5Length);
	}
	if (instance->fillArea != NULL) {
		CitoMemoryStream const *ms51;
		int ms51Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(154));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(3));
		ms51 = CitoMemoryStream_New();
		Packet_ServerFillAreaSerializer_Serialize(&ms51->base, instance->fillArea);
		ms51Length = CitoMemoryStream_Length(ms51);
		ProtocolParser_WriteUInt32_(stream, ms51Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms51), 0, ms51Length);
	}
	if (instance->fillAreaLimit != NULL) {
		CitoMemoryStream const *ms52;
		int ms52Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(162));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(3));
		ms52 = CitoMemoryStream_New();
		Packet_ServerFillAreaLimitSerializer_Serialize(&ms52->base, instance->fillAreaLimit);
		ms52Length = CitoMemoryStream_Length(ms52);
		ProtocolParser_WriteUInt32_(stream, ms52Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms52), 0, ms52Length);
	}
	if (instance->freemove != NULL) {
		CitoMemoryStream const *ms53;
		int ms53Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(170));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(3));
		ms53 = CitoMemoryStream_New();
		Packet_ServerFreemoveSerializer_Serialize(&ms53->base, instance->freemove);
		ms53Length = CitoMemoryStream_Length(ms53);
		ProtocolParser_WriteUInt32_(stream, ms53Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms53), 0, ms53Length);
	}
	if (instance->message != NULL) {
		CitoMemoryStream const *ms9;
		int ms9Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(74));
		ms9 = CitoMemoryStream_New();
		Packet_ServerMessageSerializer_Serialize(&ms9->base, instance->message);
		ms9Length = CitoMemoryStream_Length(ms9);
		ProtocolParser_WriteUInt32_(stream, ms9Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms9), 0, ms9Length);
	}
	if (instance->disconnectPlayer != NULL) {
		CitoMemoryStream const *ms10;
		int ms10Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(82));
		ms10 = CitoMemoryStream_New();
		Packet_ServerDisconnectPlayerSerializer_Serialize(&ms10->base, instance->disconnectPlayer);
		ms10Length = CitoMemoryStream_Length(ms10);
		ProtocolParser_WriteUInt32_(stream, ms10Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms10), 0, ms10Length);
	}
	if (instance->chunk_ != NULL) {
		CitoMemoryStream const *ms11;
		int ms11Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(90));
		ms11 = CitoMemoryStream_New();
		Packet_ServerChunkSerializer_Serialize(&ms11->base, instance->chunk_);
		ms11Length = CitoMemoryStream_Length(ms11);
		ProtocolParser_WriteUInt32_(stream, ms11Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms11), 0, ms11Length);
	}
	if (instance->inventory != NULL) {
		CitoMemoryStream const *ms12;
		int ms12Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(98));
		ms12 = CitoMemoryStream_New();
		Packet_ServerInventorySerializer_Serialize(&ms12->base, instance->inventory);
		ms12Length = CitoMemoryStream_Length(ms12);
		ProtocolParser_WriteUInt32_(stream, ms12Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms12), 0, ms12Length);
	}
	if (instance->season != NULL) {
		CitoMemoryStream const *ms13;
		int ms13Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(106));
		ms13 = CitoMemoryStream_New();
		Packet_ServerSeasonSerializer_Serialize(&ms13->base, instance->season);
		ms13Length = CitoMemoryStream_Length(ms13);
		ProtocolParser_WriteUInt32_(stream, ms13Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms13), 0, ms13Length);
	}
	if (instance->blobInitialize != NULL) {
		CitoMemoryStream const *ms14;
		int ms14Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(114));
		ms14 = CitoMemoryStream_New();
		Packet_ServerBlobInitializeSerializer_Serialize(&ms14->base, instance->blobInitialize);
		ms14Length = CitoMemoryStream_Length(ms14);
		ProtocolParser_WriteUInt32_(stream, ms14Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms14), 0, ms14Length);
	}
	if (instance->blobPart != NULL) {
		CitoMemoryStream const *ms15;
		int ms15Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(122));
		ms15 = CitoMemoryStream_New();
		Packet_ServerBlobPartSerializer_Serialize(&ms15->base, instance->blobPart);
		ms15Length = CitoMemoryStream_Length(ms15);
		ProtocolParser_WriteUInt32_(stream, ms15Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms15), 0, ms15Length);
	}
	if (instance->blobFinalize != NULL) {
		CitoMemoryStream const *ms16;
		int ms16Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(130));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
		ms16 = CitoMemoryStream_New();
		Packet_ServerBlobFinalizeSerializer_Serialize(&ms16->base, instance->blobFinalize);
		ms16Length = CitoMemoryStream_Length(ms16);
		ProtocolParser_WriteUInt32_(stream, ms16Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms16), 0, ms16Length);
	}
	if (instance->heightmapChunk != NULL) {
		CitoMemoryStream const *ms17;
		int ms17Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(138));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
		ms17 = CitoMemoryStream_New();
		Packet_ServerHeightmapChunkSerializer_Serialize(&ms17->base, instance->heightmapChunk);
		ms17Length = CitoMemoryStream_Length(ms17);
		ProtocolParser_WriteUInt32_(stream, ms17Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms17), 0, ms17Length);
	}
	if (instance->ping != NULL) {
		CitoMemoryStream const *ms18;
		int ms18Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(146));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
		ms18 = CitoMemoryStream_New();
		Packet_ServerPingSerializer_Serialize(&ms18->base, instance->ping);
		ms18Length = CitoMemoryStream_Length(ms18);
		ProtocolParser_WriteUInt32_(stream, ms18Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms18), 0, ms18Length);
	}
	if (instance->playerPing != NULL) {
		CitoMemoryStream const *ms181;
		int ms181Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(170));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(11));
		ms181 = CitoMemoryStream_New();
		Packet_ServerPlayerPingSerializer_Serialize(&ms181->base, instance->playerPing);
		ms181Length = CitoMemoryStream_Length(ms181);
		ProtocolParser_WriteUInt32_(stream, ms181Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms181), 0, ms181Length);
	}
	if (instance->sound != NULL) {
		CitoMemoryStream const *ms19;
		int ms19Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(154));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
		ms19 = CitoMemoryStream_New();
		Packet_ServerSoundSerializer_Serialize(&ms19->base, instance->sound);
		ms19Length = CitoMemoryStream_Length(ms19);
		ProtocolParser_WriteUInt32_(stream, ms19Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms19), 0, ms19Length);
	}
	if (instance->playerStats != NULL) {
		CitoMemoryStream const *ms20;
		int ms20Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(162));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
		ms20 = CitoMemoryStream_New();
		Packet_ServerPlayerStatsSerializer_Serialize(&ms20->base, instance->playerStats);
		ms20Length = CitoMemoryStream_Length(ms20);
		ProtocolParser_WriteUInt32_(stream, ms20Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms20), 0, ms20Length);
	}
	if (instance->monster != NULL) {
		CitoMemoryStream const *ms21;
		int ms21Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(170));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
		ms21 = CitoMemoryStream_New();
		Packet_ServerMonstersSerializer_Serialize(&ms21->base, instance->monster);
		ms21Length = CitoMemoryStream_Length(ms21);
		ProtocolParser_WriteUInt32_(stream, ms21Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms21), 0, ms21Length);
	}
	if (instance->playerSpawnPosition != NULL) {
		CitoMemoryStream const *ms22;
		int ms22Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(178));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
		ms22 = CitoMemoryStream_New();
		Packet_ServerPlayerSpawnPositionSerializer_Serialize(&ms22->base, instance->playerSpawnPosition);
		ms22Length = CitoMemoryStream_Length(ms22);
		ProtocolParser_WriteUInt32_(stream, ms22Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms22), 0, ms22Length);
	}
	if (instance->blockTypes != NULL) {
		CitoMemoryStream const *ms23;
		int ms23Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(186));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
		ms23 = CitoMemoryStream_New();
		Packet_ServerBlockTypesSerializer_Serialize(&ms23->base, instance->blockTypes);
		ms23Length = CitoMemoryStream_Length(ms23);
		ProtocolParser_WriteUInt32_(stream, ms23Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms23), 0, ms23Length);
	}
	if (instance->sunLevels != NULL) {
		CitoMemoryStream const *ms24;
		int ms24Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(194));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
		ms24 = CitoMemoryStream_New();
		Packet_ServerSunLevelsSerializer_Serialize(&ms24->base, instance->sunLevels);
		ms24Length = CitoMemoryStream_Length(ms24);
		ProtocolParser_WriteUInt32_(stream, ms24Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms24), 0, ms24Length);
	}
	if (instance->lightLevels != NULL) {
		CitoMemoryStream const *ms25;
		int ms25Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(202));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
		ms25 = CitoMemoryStream_New();
		Packet_ServerLightLevelsSerializer_Serialize(&ms25->base, instance->lightLevels);
		ms25Length = CitoMemoryStream_Length(ms25);
		ProtocolParser_WriteUInt32_(stream, ms25Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms25), 0, ms25Length);
	}
	if (instance->craftingRecipes != NULL) {
		CitoMemoryStream const *ms26;
		int ms26Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(210));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
		ms26 = CitoMemoryStream_New();
		Packet_ServerCraftingRecipesSerializer_Serialize(&ms26->base, instance->craftingRecipes);
		ms26Length = CitoMemoryStream_Length(ms26);
		ProtocolParser_WriteUInt32_(stream, ms26Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms26), 0, ms26Length);
	}
	if (instance->dialog != NULL) {
		CitoMemoryStream const *ms27;
		int ms27Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(218));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
		ms27 = CitoMemoryStream_New();
		Packet_ServerDialogSerializer_Serialize(&ms27->base, instance->dialog);
		ms27Length = CitoMemoryStream_Length(ms27);
		ProtocolParser_WriteUInt32_(stream, ms27Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms27), 0, ms27Length);
	}
	if (instance->follow != NULL) {
		CitoMemoryStream const *ms28;
		int ms28Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(226));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
		ms28 = CitoMemoryStream_New();
		Packet_ServerFollowSerializer_Serialize(&ms28->base, instance->follow);
		ms28Length = CitoMemoryStream_Length(ms28);
		ProtocolParser_WriteUInt32_(stream, ms28Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms28), 0, ms28Length);
	}
	if (instance->bullet != NULL) {
		CitoMemoryStream const *ms29;
		int ms29Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(234));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
		ms29 = CitoMemoryStream_New();
		Packet_ServerBulletSerializer_Serialize(&ms29->base, instance->bullet);
		ms29Length = CitoMemoryStream_Length(ms29);
		ProtocolParser_WriteUInt32_(stream, ms29Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms29), 0, ms29Length);
	}
	if (instance->ammo != NULL) {
		CitoMemoryStream const *ms30;
		int ms30Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(242));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
		ms30 = CitoMemoryStream_New();
		Packet_ServerAmmoSerializer_Serialize(&ms30->base, instance->ammo);
		ms30Length = CitoMemoryStream_Length(ms30);
		ProtocolParser_WriteUInt32_(stream, ms30Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms30), 0, ms30Length);
	}
	if (instance->blockType != NULL) {
		CitoMemoryStream const *ms31;
		int ms31Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(250));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(1));
		ms31 = CitoMemoryStream_New();
		Packet_ServerBlockTypeSerializer_Serialize(&ms31->base, instance->blockType);
		ms31Length = CitoMemoryStream_Length(ms31);
		ProtocolParser_WriteUInt32_(stream, ms31Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms31), 0, ms31Length);
	}
	if (instance->chunkPart != NULL) {
		CitoMemoryStream const *ms32;
		int ms32Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(130));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(2));
		ms32 = CitoMemoryStream_New();
		Packet_ServerChunkPartSerializer_Serialize(&ms32->base, instance->chunkPart);
		ms32Length = CitoMemoryStream_Length(ms32);
		ProtocolParser_WriteUInt32_(stream, ms32Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms32), 0, ms32Length);
	}
	if (instance->explosion != NULL) {
		CitoMemoryStream const *ms33;
		int ms33Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(138));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(2));
		ms33 = CitoMemoryStream_New();
		Packet_ServerExplosionSerializer_Serialize(&ms33->base, instance->explosion);
		ms33Length = CitoMemoryStream_Length(ms33);
		ProtocolParser_WriteUInt32_(stream, ms33Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms33), 0, ms33Length);
	}
	if (instance->projectile != NULL) {
		CitoMemoryStream const *ms34;
		int ms34Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(146));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(2));
		ms34 = CitoMemoryStream_New();
		Packet_ServerProjectileSerializer_Serialize(&ms34->base, instance->projectile);
		ms34Length = CitoMemoryStream_Length(ms34);
		ProtocolParser_WriteUInt32_(stream, ms34Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms34), 0, ms34Length);
	}
	if (instance->translation != NULL) {
		CitoMemoryStream const *ms35;
		int ms35Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(154));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(2));
		ms35 = CitoMemoryStream_New();
		Packet_ServerTranslatedStringSerializer_Serialize(&ms35->base, instance->translation);
		ms35Length = CitoMemoryStream_Length(ms35);
		ProtocolParser_WriteUInt32_(stream, ms35Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms35), 0, ms35Length);
	}
	if (instance->queryAnswer != NULL) {
		CitoMemoryStream const *ms36;
		int ms36Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(162));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(2));
		ms36 = CitoMemoryStream_New();
		Packet_ServerQueryAnswerSerializer_Serialize(&ms36->base, instance->queryAnswer);
		ms36Length = CitoMemoryStream_Length(ms36);
		ProtocolParser_WriteUInt32_(stream, ms36Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms36), 0, ms36Length);
	}
	if (instance->redirect != NULL) {
		CitoMemoryStream const *ms37;
		int ms37Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(170));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(2));
		ms37 = CitoMemoryStream_New();
		Packet_ServerRedirectSerializer_Serialize(&ms37->base, instance->redirect);
		ms37Length = CitoMemoryStream_Length(ms37);
		ProtocolParser_WriteUInt32_(stream, ms37Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms37), 0, ms37Length);
	}
	if (instance->entitySpawn != NULL) {
		CitoMemoryStream const *ms39;
		int ms39Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(186));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(2));
		ms39 = CitoMemoryStream_New();
		Packet_ServerEntitySpawnSerializer_Serialize(&ms39->base, instance->entitySpawn);
		ms39Length = CitoMemoryStream_Length(ms39);
		ProtocolParser_WriteUInt32_(stream, ms39Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms39), 0, ms39Length);
	}
	if (instance->entityPosition != NULL) {
		CitoMemoryStream const *ms40;
		int ms40Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(194));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(2));
		ms40 = CitoMemoryStream_New();
		Packet_ServerEntityPositionAndOrientationSerializer_Serialize(&ms40->base, instance->entityPosition);
		ms40Length = CitoMemoryStream_Length(ms40);
		ProtocolParser_WriteUInt32_(stream, ms40Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms40), 0, ms40Length);
	}
	if (instance->entityDespawn != NULL) {
		CitoMemoryStream const *ms41;
		int ms41Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(202));
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(2));
		ms41 = CitoMemoryStream_New();
		Packet_ServerEntityDespawnSerializer_Serialize(&ms41->base, instance->entityDespawn);
		ms41Length = CitoMemoryStream_Length(ms41);
		ProtocolParser_WriteUInt32_(stream, ms41Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms41), 0, ms41Length);
	}
}

void Packet_ServerSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_Server const *instance)
{
	unsigned char const *data = Packet_ServerSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerSerializer_SerializeToBytes(Packet_Server const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerSetBlock *Packet_ServerSetBlock_New(void)
{
	Packet_ServerSetBlock *self = (Packet_ServerSetBlock *) malloc(sizeof(Packet_ServerSetBlock));
	return self;
}

void Packet_ServerSetBlock_Delete(Packet_ServerSetBlock *self)
{
	free(self);
}

int Packet_ServerSetBlock_GetBlockType(Packet_ServerSetBlock const *self)
{
	return self->blockType;
}

int Packet_ServerSetBlock_GetX(Packet_ServerSetBlock const *self)
{
	return self->x;
}

int Packet_ServerSetBlock_GetY(Packet_ServerSetBlock const *self)
{
	return self->y;
}

int Packet_ServerSetBlock_GetZ(Packet_ServerSetBlock const *self)
{
	return self->z;
}

void Packet_ServerSetBlock_SetBlockType(Packet_ServerSetBlock *self, int value)
{
	self->blockType = value;
}

void Packet_ServerSetBlock_SetX(Packet_ServerSetBlock *self, int value)
{
	self->x = value;
}

void Packet_ServerSetBlock_SetY(Packet_ServerSetBlock *self, int value)
{
	self->y = value;
}

void Packet_ServerSetBlock_SetZ(Packet_ServerSetBlock *self, int value)
{
	self->z = value;
}

Packet_ServerSetBlock const *Packet_ServerSetBlockSerializer_Deserialize(CitoStream const *stream, Packet_ServerSetBlock *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->blockType = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSetBlock const *Packet_ServerSetBlockSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerSetBlock *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerSetBlockSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerSetBlock const *Packet_ServerSetBlockSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerSetBlock *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->blockType = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSetBlock const *Packet_ServerSetBlockSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerSetBlock *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 16:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->blockType = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSetBlock *Packet_ServerSetBlockSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerSetBlock *instance = Packet_ServerSetBlock_New();
	Packet_ServerSetBlockSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerSetBlockSerializer_Serialize(CitoStream const *stream, Packet_ServerSetBlock const *instance)
{
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
	ProtocolParser_WriteUInt64(stream, instance->x);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->y);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteUInt64(stream, instance->z);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
	ProtocolParser_WriteUInt64(stream, instance->blockType);
}

void Packet_ServerSetBlockSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerSetBlock const *instance)
{
	unsigned char const *data = Packet_ServerSetBlockSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerSetBlockSerializer_SerializeToBytes(Packet_ServerSetBlock const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerSetBlockSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerSound *Packet_ServerSound_New(void)
{
	Packet_ServerSound *self = (Packet_ServerSound *) malloc(sizeof(Packet_ServerSound));
	return self;
}

void Packet_ServerSound_Delete(Packet_ServerSound *self)
{
	free(self);
}

const char *Packet_ServerSound_GetName(Packet_ServerSound const *self)
{
	return self->name;
}

int Packet_ServerSound_GetX(Packet_ServerSound const *self)
{
	return self->x;
}

int Packet_ServerSound_GetY(Packet_ServerSound const *self)
{
	return self->y;
}

int Packet_ServerSound_GetZ(Packet_ServerSound const *self)
{
	return self->z;
}

void Packet_ServerSound_SetName(Packet_ServerSound *self, const char *value)
{
	self->name = value;
}

void Packet_ServerSound_SetX(Packet_ServerSound *self, int value)
{
	self->x = value;
}

void Packet_ServerSound_SetY(Packet_ServerSound *self, int value)
{
	self->y = value;
}

void Packet_ServerSound_SetZ(Packet_ServerSound *self, int value)
{
	self->z = value;
}

Packet_ServerSound const *Packet_ServerSoundSerializer_Deserialize(CitoStream const *stream, Packet_ServerSound *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance->name = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSound const *Packet_ServerSoundSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerSound *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerSoundSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerSound const *Packet_ServerSoundSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerSound *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->name = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSound const *Packet_ServerSoundSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerSound *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->name = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->z = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSound *Packet_ServerSoundSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerSound *instance = Packet_ServerSound_New();
	Packet_ServerSoundSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerSoundSerializer_Serialize(CitoStream const *stream, Packet_ServerSound const *instance)
{
	if (instance->name != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->name));
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->x);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteUInt64(stream, instance->y);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
	ProtocolParser_WriteUInt64(stream, instance->z);
}

void Packet_ServerSoundSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerSound const *instance)
{
	unsigned char const *data = Packet_ServerSoundSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerSoundSerializer_SerializeToBytes(Packet_ServerSound const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerSoundSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerSunLevels *Packet_ServerSunLevels_New(void)
{
	Packet_ServerSunLevels *self = (Packet_ServerSunLevels *) malloc(sizeof(Packet_ServerSunLevels));
	return self;
}

void Packet_ServerSunLevels_Delete(Packet_ServerSunLevels *self)
{
	free(self);
}

int const *Packet_ServerSunLevels_GetSunlevels(Packet_ServerSunLevels const *self)
{
	return self->sunlevels;
}

int Packet_ServerSunLevels_GetSunlevelsCount(Packet_ServerSunLevels const *self)
{
	return self->sunlevelsCount;
}

int Packet_ServerSunLevels_GetSunlevelsLength(Packet_ServerSunLevels const *self)
{
	return self->sunlevelsLength;
}

void Packet_ServerSunLevels_SetSunlevels(Packet_ServerSunLevels *self, int *value, int count, int length)
{
	self->sunlevels = value;
	self->sunlevelsCount = count;
	self->sunlevelsLength = length;
}

void Packet_ServerSunLevels_SunlevelsAdd(Packet_ServerSunLevels *self, int value)
{
	if (self->sunlevelsCount >= self->sunlevelsLength) {
		int *Sunlevels2 = (int *) malloc(self->sunlevelsLength * 2 * sizeof(int ));
		self->sunlevelsLength = self->sunlevelsLength * 2;
		{
			int i;
			for (i = 0; i < self->sunlevelsCount; i++) {
				Sunlevels2[i] = self->sunlevels[i];
			}
		}
		self->sunlevels = Sunlevels2;
	}
	self->sunlevels[self->sunlevelsCount] = value;
	self->sunlevelsCount++;
}

Packet_ServerSunLevels const *Packet_ServerSunLevelsSerializer_Deserialize(CitoStream const *stream, Packet_ServerSunLevels *instance)
{
	if (instance->sunlevels == NULL) {
		instance->sunlevels = (int *) malloc(1 * sizeof(int ));
		instance->sunlevelsCount = 0;
		instance->sunlevelsLength = 1;
	}
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 8:
			Packet_ServerSunLevels_SunlevelsAdd(instance, ProtocolParser_ReadUInt64(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSunLevels const *Packet_ServerSunLevelsSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerSunLevels *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerSunLevelsSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerSunLevels const *Packet_ServerSunLevelsSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerSunLevels *instance)
{
	int limit;
	if (instance->sunlevels == NULL) {
		instance->sunlevels = (int *) malloc(1 * sizeof(int ));
		instance->sunlevelsCount = 0;
		instance->sunlevelsLength = 1;
	}
	limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			Packet_ServerSunLevels_SunlevelsAdd(instance, ProtocolParser_ReadUInt64(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSunLevels const *Packet_ServerSunLevelsSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerSunLevels *instance)
{
	int limit;
	if (instance->sunlevels == NULL) {
		instance->sunlevels = (int *) malloc(1 * sizeof(int ));
		instance->sunlevelsCount = 0;
		instance->sunlevelsLength = 1;
	}
	limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 8:
			Packet_ServerSunLevels_SunlevelsAdd(instance, ProtocolParser_ReadUInt64(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerSunLevels *Packet_ServerSunLevelsSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerSunLevels *instance = Packet_ServerSunLevels_New();
	Packet_ServerSunLevelsSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerSunLevelsSerializer_Serialize(CitoStream const *stream, Packet_ServerSunLevels const *instance)
{
	if (instance->sunlevels != NULL) {
		{
			int k;
			for (k = 0; k < instance->sunlevelsCount; k++) {
				int i1 = instance->sunlevels[k];
				stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(8));
				ProtocolParser_WriteUInt64(stream, i1);
			}
		}
	}
}

void Packet_ServerSunLevelsSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerSunLevels const *instance)
{
	unsigned char const *data = Packet_ServerSunLevelsSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerSunLevelsSerializer_SerializeToBytes(Packet_ServerSunLevels const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerSunLevelsSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_ServerTranslatedString *Packet_ServerTranslatedString_New(void)
{
	Packet_ServerTranslatedString *self = (Packet_ServerTranslatedString *) malloc(sizeof(Packet_ServerTranslatedString));
	return self;
}

void Packet_ServerTranslatedString_Delete(Packet_ServerTranslatedString *self)
{
	free(self);
}

const char *Packet_ServerTranslatedString_GetId(Packet_ServerTranslatedString const *self)
{
	return self->id;
}

const char *Packet_ServerTranslatedString_GetLang(Packet_ServerTranslatedString const *self)
{
	return self->lang;
}

const char *Packet_ServerTranslatedString_GetTranslation(Packet_ServerTranslatedString const *self)
{
	return self->translation;
}

void Packet_ServerTranslatedString_SetId(Packet_ServerTranslatedString *self, const char *value)
{
	self->id = value;
}

void Packet_ServerTranslatedString_SetLang(Packet_ServerTranslatedString *self, const char *value)
{
	self->lang = value;
}

void Packet_ServerTranslatedString_SetTranslation(Packet_ServerTranslatedString *self, const char *value)
{
	self->translation = value;
}

Packet_ServerTranslatedString const *Packet_ServerTranslatedStringSerializer_Deserialize(CitoStream const *stream, Packet_ServerTranslatedString *instance)
{
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance->lang = ProtocolParser_ReadString(stream);
			continue;
		case 18:
			instance->id = ProtocolParser_ReadString(stream);
			continue;
		case 26:
			instance->translation = ProtocolParser_ReadString(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerTranslatedString const *Packet_ServerTranslatedStringSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_ServerTranslatedString *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_ServerTranslatedStringSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_ServerTranslatedString const *Packet_ServerTranslatedStringSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_ServerTranslatedString *instance)
{
	int limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->lang = ProtocolParser_ReadString(stream);
			continue;
		case 18:
			instance->id = ProtocolParser_ReadString(stream);
			continue;
		case 26:
			instance->translation = ProtocolParser_ReadString(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerTranslatedString const *Packet_ServerTranslatedStringSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_ServerTranslatedString *instance)
{
	int limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->lang = ProtocolParser_ReadString(stream);
			continue;
		case 18:
			instance->id = ProtocolParser_ReadString(stream);
			continue;
		case 26:
			instance->translation = ProtocolParser_ReadString(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_ServerTranslatedString *Packet_ServerTranslatedStringSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_ServerTranslatedString *instance = Packet_ServerTranslatedString_New();
	Packet_ServerTranslatedStringSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_ServerTranslatedStringSerializer_Serialize(CitoStream const *stream, Packet_ServerTranslatedString const *instance)
{
	if (instance->lang != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->lang));
	}
	if (instance->id != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(18));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->id));
	}
	if (instance->translation != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(26));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->translation));
	}
}

void Packet_ServerTranslatedStringSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_ServerTranslatedString const *instance)
{
	unsigned char const *data = Packet_ServerTranslatedStringSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_ServerTranslatedStringSerializer_SerializeToBytes(Packet_ServerTranslatedString const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_ServerTranslatedStringSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_SoundSet *Packet_SoundSet_New(void)
{
	Packet_SoundSet *self = (Packet_SoundSet *) malloc(sizeof(Packet_SoundSet));
	return self;
}

void Packet_SoundSet_Delete(Packet_SoundSet *self)
{
	free(self);
}

void Packet_SoundSet_Break1Add(Packet_SoundSet *self, const char *value)
{
	if (self->break1Count >= self->break1Length) {
		const char **Break12 = (const char **) malloc(self->break1Length * 2 * sizeof(const char *));
		self->break1Length = self->break1Length * 2;
		{
			int i;
			for (i = 0; i < self->break1Count; i++) {
				Break12[i] = self->break1[i];
			}
		}
		self->break1 = Break12;
	}
	self->break1[self->break1Count] = value;
	self->break1Count++;
}

void Packet_SoundSet_BuildAdd(Packet_SoundSet *self, const char *value)
{
	if (self->buildCount >= self->buildLength) {
		const char **Build2 = (const char **) malloc(self->buildLength * 2 * sizeof(const char *));
		self->buildLength = self->buildLength * 2;
		{
			int i;
			for (i = 0; i < self->buildCount; i++) {
				Build2[i] = self->build[i];
			}
		}
		self->build = Build2;
	}
	self->build[self->buildCount] = value;
	self->buildCount++;
}

void Packet_SoundSet_CloneAdd(Packet_SoundSet *self, const char *value)
{
	if (self->cloneCount >= self->cloneLength) {
		const char **Clone2 = (const char **) malloc(self->cloneLength * 2 * sizeof(const char *));
		self->cloneLength = self->cloneLength * 2;
		{
			int i;
			for (i = 0; i < self->cloneCount; i++) {
				Clone2[i] = self->clone[i];
			}
		}
		self->clone = Clone2;
	}
	self->clone[self->cloneCount] = value;
	self->cloneCount++;
}

const char *const *Packet_SoundSet_GetBreak1(Packet_SoundSet const *self)
{
	return self->break1;
}

int Packet_SoundSet_GetBreak1Count(Packet_SoundSet const *self)
{
	return self->break1Count;
}

int Packet_SoundSet_GetBreak1Length(Packet_SoundSet const *self)
{
	return self->break1Length;
}

const char *const *Packet_SoundSet_GetBuild(Packet_SoundSet const *self)
{
	return self->build;
}

int Packet_SoundSet_GetBuildCount(Packet_SoundSet const *self)
{
	return self->buildCount;
}

int Packet_SoundSet_GetBuildLength(Packet_SoundSet const *self)
{
	return self->buildLength;
}

const char *const *Packet_SoundSet_GetClone(Packet_SoundSet const *self)
{
	return self->clone;
}

int Packet_SoundSet_GetCloneCount(Packet_SoundSet const *self)
{
	return self->cloneCount;
}

int Packet_SoundSet_GetCloneLength(Packet_SoundSet const *self)
{
	return self->cloneLength;
}

const char *const *Packet_SoundSet_GetReload(Packet_SoundSet const *self)
{
	return self->reload;
}

int Packet_SoundSet_GetReloadCount(Packet_SoundSet const *self)
{
	return self->reloadCount;
}

int Packet_SoundSet_GetReloadLength(Packet_SoundSet const *self)
{
	return self->reloadLength;
}

const char *const *Packet_SoundSet_GetShoot(Packet_SoundSet const *self)
{
	return self->shoot;
}

int Packet_SoundSet_GetShootCount(Packet_SoundSet const *self)
{
	return self->shootCount;
}

const char *const *Packet_SoundSet_GetShootEnd(Packet_SoundSet const *self)
{
	return self->shootEnd;
}

int Packet_SoundSet_GetShootEndCount(Packet_SoundSet const *self)
{
	return self->shootEndCount;
}

int Packet_SoundSet_GetShootEndLength(Packet_SoundSet const *self)
{
	return self->shootEndLength;
}

int Packet_SoundSet_GetShootLength(Packet_SoundSet const *self)
{
	return self->shootLength;
}

const char *const *Packet_SoundSet_GetWalk(Packet_SoundSet const *self)
{
	return self->walk;
}

int Packet_SoundSet_GetWalkCount(Packet_SoundSet const *self)
{
	return self->walkCount;
}

int Packet_SoundSet_GetWalkLength(Packet_SoundSet const *self)
{
	return self->walkLength;
}

void Packet_SoundSet_ReloadAdd(Packet_SoundSet *self, const char *value)
{
	if (self->reloadCount >= self->reloadLength) {
		const char **Reload2 = (const char **) malloc(self->reloadLength * 2 * sizeof(const char *));
		self->reloadLength = self->reloadLength * 2;
		{
			int i;
			for (i = 0; i < self->reloadCount; i++) {
				Reload2[i] = self->reload[i];
			}
		}
		self->reload = Reload2;
	}
	self->reload[self->reloadCount] = value;
	self->reloadCount++;
}

void Packet_SoundSet_SetBreak1(Packet_SoundSet *self, const char **value, int count, int length)
{
	self->break1 = value;
	self->break1Count = count;
	self->break1Length = length;
}

void Packet_SoundSet_SetBuild(Packet_SoundSet *self, const char **value, int count, int length)
{
	self->build = value;
	self->buildCount = count;
	self->buildLength = length;
}

void Packet_SoundSet_SetClone(Packet_SoundSet *self, const char **value, int count, int length)
{
	self->clone = value;
	self->cloneCount = count;
	self->cloneLength = length;
}

void Packet_SoundSet_SetReload(Packet_SoundSet *self, const char **value, int count, int length)
{
	self->reload = value;
	self->reloadCount = count;
	self->reloadLength = length;
}

void Packet_SoundSet_SetShoot(Packet_SoundSet *self, const char **value, int count, int length)
{
	self->shoot = value;
	self->shootCount = count;
	self->shootLength = length;
}

void Packet_SoundSet_SetShootEnd(Packet_SoundSet *self, const char **value, int count, int length)
{
	self->shootEnd = value;
	self->shootEndCount = count;
	self->shootEndLength = length;
}

void Packet_SoundSet_SetWalk(Packet_SoundSet *self, const char **value, int count, int length)
{
	self->walk = value;
	self->walkCount = count;
	self->walkLength = length;
}

void Packet_SoundSet_ShootAdd(Packet_SoundSet *self, const char *value)
{
	if (self->shootCount >= self->shootLength) {
		const char **Shoot2 = (const char **) malloc(self->shootLength * 2 * sizeof(const char *));
		self->shootLength = self->shootLength * 2;
		{
			int i;
			for (i = 0; i < self->shootCount; i++) {
				Shoot2[i] = self->shoot[i];
			}
		}
		self->shoot = Shoot2;
	}
	self->shoot[self->shootCount] = value;
	self->shootCount++;
}

void Packet_SoundSet_ShootEndAdd(Packet_SoundSet *self, const char *value)
{
	if (self->shootEndCount >= self->shootEndLength) {
		const char **ShootEnd2 = (const char **) malloc(self->shootEndLength * 2 * sizeof(const char *));
		self->shootEndLength = self->shootEndLength * 2;
		{
			int i;
			for (i = 0; i < self->shootEndCount; i++) {
				ShootEnd2[i] = self->shootEnd[i];
			}
		}
		self->shootEnd = ShootEnd2;
	}
	self->shootEnd[self->shootEndCount] = value;
	self->shootEndCount++;
}

void Packet_SoundSet_WalkAdd(Packet_SoundSet *self, const char *value)
{
	if (self->walkCount >= self->walkLength) {
		const char **Walk2 = (const char **) malloc(self->walkLength * 2 * sizeof(const char *));
		self->walkLength = self->walkLength * 2;
		{
			int i;
			for (i = 0; i < self->walkCount; i++) {
				Walk2[i] = self->walk[i];
			}
		}
		self->walk = Walk2;
	}
	self->walk[self->walkCount] = value;
	self->walkCount++;
}

Packet_SoundSet const *Packet_SoundSetSerializer_Deserialize(CitoStream const *stream, Packet_SoundSet *instance)
{
	if (instance->walk == NULL) {
		instance->walk = (const char **) malloc(1 * sizeof(const char *));
		instance->walkCount = 0;
		instance->walkLength = 1;
	}
	if (instance->break1 == NULL) {
		instance->break1 = (const char **) malloc(1 * sizeof(const char *));
		instance->break1Count = 0;
		instance->break1Length = 1;
	}
	if (instance->build == NULL) {
		instance->build = (const char **) malloc(1 * sizeof(const char *));
		instance->buildCount = 0;
		instance->buildLength = 1;
	}
	if (instance->clone == NULL) {
		instance->clone = (const char **) malloc(1 * sizeof(const char *));
		instance->cloneCount = 0;
		instance->cloneLength = 1;
	}
	if (instance->shoot == NULL) {
		instance->shoot = (const char **) malloc(1 * sizeof(const char *));
		instance->shootCount = 0;
		instance->shootLength = 1;
	}
	if (instance->shootEnd == NULL) {
		instance->shootEnd = (const char **) malloc(1 * sizeof(const char *));
		instance->shootEndCount = 0;
		instance->shootEndLength = 1;
	}
	if (instance->reload == NULL) {
		instance->reload = (const char **) malloc(1 * sizeof(const char *));
		instance->reloadCount = 0;
		instance->reloadLength = 1;
	}
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			Packet_SoundSet_WalkAdd(instance, ProtocolParser_ReadString(stream));
			continue;
		case 18:
			Packet_SoundSet_Break1Add(instance, ProtocolParser_ReadString(stream));
			continue;
		case 26:
			Packet_SoundSet_BuildAdd(instance, ProtocolParser_ReadString(stream));
			continue;
		case 34:
			Packet_SoundSet_CloneAdd(instance, ProtocolParser_ReadString(stream));
			continue;
		case 42:
			Packet_SoundSet_ShootAdd(instance, ProtocolParser_ReadString(stream));
			continue;
		case 50:
			Packet_SoundSet_ShootEndAdd(instance, ProtocolParser_ReadString(stream));
			continue;
		case 58:
			Packet_SoundSet_ReloadAdd(instance, ProtocolParser_ReadString(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_SoundSet const *Packet_SoundSetSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_SoundSet *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_SoundSetSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_SoundSet const *Packet_SoundSetSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_SoundSet *instance)
{
	int limit;
	if (instance->walk == NULL) {
		instance->walk = (const char **) malloc(1 * sizeof(const char *));
		instance->walkCount = 0;
		instance->walkLength = 1;
	}
	if (instance->break1 == NULL) {
		instance->break1 = (const char **) malloc(1 * sizeof(const char *));
		instance->break1Count = 0;
		instance->break1Length = 1;
	}
	if (instance->build == NULL) {
		instance->build = (const char **) malloc(1 * sizeof(const char *));
		instance->buildCount = 0;
		instance->buildLength = 1;
	}
	if (instance->clone == NULL) {
		instance->clone = (const char **) malloc(1 * sizeof(const char *));
		instance->cloneCount = 0;
		instance->cloneLength = 1;
	}
	if (instance->shoot == NULL) {
		instance->shoot = (const char **) malloc(1 * sizeof(const char *));
		instance->shootCount = 0;
		instance->shootLength = 1;
	}
	if (instance->shootEnd == NULL) {
		instance->shootEnd = (const char **) malloc(1 * sizeof(const char *));
		instance->shootEndCount = 0;
		instance->shootEndLength = 1;
	}
	if (instance->reload == NULL) {
		instance->reload = (const char **) malloc(1 * sizeof(const char *));
		instance->reloadCount = 0;
		instance->reloadLength = 1;
	}
	limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			Packet_SoundSet_WalkAdd(instance, ProtocolParser_ReadString(stream));
			continue;
		case 18:
			Packet_SoundSet_Break1Add(instance, ProtocolParser_ReadString(stream));
			continue;
		case 26:
			Packet_SoundSet_BuildAdd(instance, ProtocolParser_ReadString(stream));
			continue;
		case 34:
			Packet_SoundSet_CloneAdd(instance, ProtocolParser_ReadString(stream));
			continue;
		case 42:
			Packet_SoundSet_ShootAdd(instance, ProtocolParser_ReadString(stream));
			continue;
		case 50:
			Packet_SoundSet_ShootEndAdd(instance, ProtocolParser_ReadString(stream));
			continue;
		case 58:
			Packet_SoundSet_ReloadAdd(instance, ProtocolParser_ReadString(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_SoundSet const *Packet_SoundSetSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_SoundSet *instance)
{
	int limit;
	if (instance->walk == NULL) {
		instance->walk = (const char **) malloc(1 * sizeof(const char *));
		instance->walkCount = 0;
		instance->walkLength = 1;
	}
	if (instance->break1 == NULL) {
		instance->break1 = (const char **) malloc(1 * sizeof(const char *));
		instance->break1Count = 0;
		instance->break1Length = 1;
	}
	if (instance->build == NULL) {
		instance->build = (const char **) malloc(1 * sizeof(const char *));
		instance->buildCount = 0;
		instance->buildLength = 1;
	}
	if (instance->clone == NULL) {
		instance->clone = (const char **) malloc(1 * sizeof(const char *));
		instance->cloneCount = 0;
		instance->cloneLength = 1;
	}
	if (instance->shoot == NULL) {
		instance->shoot = (const char **) malloc(1 * sizeof(const char *));
		instance->shootCount = 0;
		instance->shootLength = 1;
	}
	if (instance->shootEnd == NULL) {
		instance->shootEnd = (const char **) malloc(1 * sizeof(const char *));
		instance->shootEndCount = 0;
		instance->shootEndLength = 1;
	}
	if (instance->reload == NULL) {
		instance->reload = (const char **) malloc(1 * sizeof(const char *));
		instance->reloadCount = 0;
		instance->reloadLength = 1;
	}
	limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			Packet_SoundSet_WalkAdd(instance, ProtocolParser_ReadString(stream));
			continue;
		case 18:
			Packet_SoundSet_Break1Add(instance, ProtocolParser_ReadString(stream));
			continue;
		case 26:
			Packet_SoundSet_BuildAdd(instance, ProtocolParser_ReadString(stream));
			continue;
		case 34:
			Packet_SoundSet_CloneAdd(instance, ProtocolParser_ReadString(stream));
			continue;
		case 42:
			Packet_SoundSet_ShootAdd(instance, ProtocolParser_ReadString(stream));
			continue;
		case 50:
			Packet_SoundSet_ShootEndAdd(instance, ProtocolParser_ReadString(stream));
			continue;
		case 58:
			Packet_SoundSet_ReloadAdd(instance, ProtocolParser_ReadString(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_SoundSet *Packet_SoundSetSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_SoundSet *instance = Packet_SoundSet_New();
	Packet_SoundSetSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_SoundSetSerializer_Serialize(CitoStream const *stream, Packet_SoundSet const *instance)
{
	if (instance->walk != NULL) {
		{
			int k;
			for (k = 0; k < instance->walkCount; k++) {
				const char *i1 = instance->walk[k];
				stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
				ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(i1));
			}
		}
	}
	if (instance->break1 != NULL) {
		{
			int k;
			for (k = 0; k < instance->break1Count; k++) {
				const char *i2 = instance->break1[k];
				stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(18));
				ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(i2));
			}
		}
	}
	if (instance->build != NULL) {
		{
			int k;
			for (k = 0; k < instance->buildCount; k++) {
				const char *i3 = instance->build[k];
				stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(26));
				ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(i3));
			}
		}
	}
	if (instance->clone != NULL) {
		{
			int k;
			for (k = 0; k < instance->cloneCount; k++) {
				const char *i4 = instance->clone[k];
				stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(34));
				ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(i4));
			}
		}
	}
	if (instance->shoot != NULL) {
		{
			int k;
			for (k = 0; k < instance->shootCount; k++) {
				const char *i5 = instance->shoot[k];
				stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(42));
				ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(i5));
			}
		}
	}
	if (instance->shootEnd != NULL) {
		{
			int k;
			for (k = 0; k < instance->shootEndCount; k++) {
				const char *i6 = instance->shootEnd[k];
				stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(50));
				ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(i6));
			}
		}
	}
	if (instance->reload != NULL) {
		{
			int k;
			for (k = 0; k < instance->reloadCount; k++) {
				const char *i7 = instance->reload[k];
				stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(58));
				ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(i7));
			}
		}
	}
}

void Packet_SoundSetSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_SoundSet const *instance)
{
	unsigned char const *data = Packet_SoundSetSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_SoundSetSerializer_SerializeToBytes(Packet_SoundSet const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_SoundSetSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_StringList *Packet_StringList_New(void)
{
	Packet_StringList *self = (Packet_StringList *) malloc(sizeof(Packet_StringList));
	return self;
}

void Packet_StringList_Delete(Packet_StringList *self)
{
	free(self);
}

const char *const *Packet_StringList_GetItems(Packet_StringList const *self)
{
	return self->items;
}

int Packet_StringList_GetItemsCount(Packet_StringList const *self)
{
	return self->itemsCount;
}

int Packet_StringList_GetItemsLength(Packet_StringList const *self)
{
	return self->itemsLength;
}

void Packet_StringList_ItemsAdd(Packet_StringList *self, const char *value)
{
	if (self->itemsCount >= self->itemsLength) {
		const char **Items2 = (const char **) malloc(self->itemsLength * 2 * sizeof(const char *));
		self->itemsLength = self->itemsLength * 2;
		{
			int i;
			for (i = 0; i < self->itemsCount; i++) {
				Items2[i] = self->items[i];
			}
		}
		self->items = Items2;
	}
	self->items[self->itemsCount] = value;
	self->itemsCount++;
}

void Packet_StringList_SetItems(Packet_StringList *self, const char **value, int count, int length)
{
	self->items = value;
	self->itemsCount = count;
	self->itemsLength = length;
}

Packet_StringList const *Packet_StringListSerializer_Deserialize(CitoStream const *stream, Packet_StringList *instance)
{
	if (instance->items == NULL) {
		instance->items = (const char **) malloc(1 * sizeof(const char *));
		instance->itemsCount = 0;
		instance->itemsLength = 1;
	}
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			Packet_StringList_ItemsAdd(instance, ProtocolParser_ReadString(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_StringList const *Packet_StringListSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_StringList *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_StringListSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_StringList const *Packet_StringListSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_StringList *instance)
{
	int limit;
	if (instance->items == NULL) {
		instance->items = (const char **) malloc(1 * sizeof(const char *));
		instance->itemsCount = 0;
		instance->itemsLength = 1;
	}
	limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			Packet_StringList_ItemsAdd(instance, ProtocolParser_ReadString(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_StringList const *Packet_StringListSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_StringList *instance)
{
	int limit;
	if (instance->items == NULL) {
		instance->items = (const char **) malloc(1 * sizeof(const char *));
		instance->itemsCount = 0;
		instance->itemsLength = 1;
	}
	limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			Packet_StringList_ItemsAdd(instance, ProtocolParser_ReadString(stream));
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_StringList *Packet_StringListSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_StringList *instance = Packet_StringList_New();
	Packet_StringListSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_StringListSerializer_Serialize(CitoStream const *stream, Packet_StringList const *instance)
{
	if (instance->items != NULL) {
		{
			int k;
			for (k = 0; k < instance->itemsCount; k++) {
				const char *i1 = instance->items[k];
				stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
				ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(i1));
			}
		}
	}
}

void Packet_StringListSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_StringList const *instance)
{
	unsigned char const *data = Packet_StringListSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_StringListSerializer_SerializeToBytes(Packet_StringList const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_StringListSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

Packet_Widget *Packet_Widget_New(void)
{
	Packet_Widget *self = (Packet_Widget *) malloc(sizeof(Packet_Widget));
	return self;
}

void Packet_Widget_Delete(Packet_Widget *self)
{
	free(self);
}

int Packet_Widget_GetClick(Packet_Widget const *self)
{
	return self->click;
}

int Packet_Widget_GetClickKey(Packet_Widget const *self)
{
	return self->clickKey;
}

int Packet_Widget_GetColor(Packet_Widget const *self)
{
	return self->color;
}

Packet_DialogFont const *Packet_Widget_GetFont(Packet_Widget const *self)
{
	return self->font;
}

int Packet_Widget_GetHeight_(Packet_Widget const *self)
{
	return self->height_;
}

const char *Packet_Widget_GetId(Packet_Widget const *self)
{
	return self->id;
}

const char *Packet_Widget_GetImage(Packet_Widget const *self)
{
	return self->image;
}

const char *Packet_Widget_GetText(Packet_Widget const *self)
{
	return self->text;
}

int Packet_Widget_GetType(Packet_Widget const *self)
{
	return self->type;
}

int Packet_Widget_GetWidth(Packet_Widget const *self)
{
	return self->width;
}

int Packet_Widget_GetX(Packet_Widget const *self)
{
	return self->x;
}

int Packet_Widget_GetY(Packet_Widget const *self)
{
	return self->y;
}

void Packet_Widget_SetClick(Packet_Widget *self, int value)
{
	self->click = value;
}

void Packet_Widget_SetClickKey(Packet_Widget *self, int value)
{
	self->clickKey = value;
}

void Packet_Widget_SetColor(Packet_Widget *self, int value)
{
	self->color = value;
}

void Packet_Widget_SetFont(Packet_Widget *self, Packet_DialogFont *value)
{
	self->font = value;
}

void Packet_Widget_SetHeight_(Packet_Widget *self, int value)
{
	self->height_ = value;
}

void Packet_Widget_SetId(Packet_Widget *self, const char *value)
{
	self->id = value;
}

void Packet_Widget_SetImage(Packet_Widget *self, const char *value)
{
	self->image = value;
}

void Packet_Widget_SetText(Packet_Widget *self, const char *value)
{
	self->text = value;
}

void Packet_Widget_SetType(Packet_Widget *self, int value)
{
	self->type = value;
}

void Packet_Widget_SetWidth(Packet_Widget *self, int value)
{
	self->width = value;
}

void Packet_Widget_SetX(Packet_Widget *self, int value)
{
	self->x = value;
}

void Packet_Widget_SetY(Packet_Widget *self, int value)
{
	self->y = value;
}

Packet_Widget const *Packet_WidgetSerializer_Deserialize(CitoStream const *stream, Packet_Widget *instance)
{
	instance->type = 0;
	while (TRUE) {
		int keyByte = stream->vtbl->readByte(stream);
		Key const *key;
		if (keyByte == -1)
			break;
		switch (keyByte) {
		case 10:
			instance->id = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->click = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->width = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->height_ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 58:
			instance->text = ProtocolParser_ReadString(stream);
			continue;
		case 64:
			instance->clickKey = ProtocolParser_ReadUInt64(stream);
			continue;
		case 74:
			instance->image = ProtocolParser_ReadString(stream);
			continue;
		case 80:
			instance->color = ProtocolParser_ReadUInt64(stream);
			continue;
		case 90:
			if (instance->font == NULL)
				instance->font = Packet_DialogFontSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_DialogFontSerializer_DeserializeLengthDelimited(stream, instance->font);
			continue;
		case 96:
			instance->type = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_Widget const *Packet_WidgetSerializer_DeserializeBuffer(unsigned char *buffer, int length, Packet_Widget *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_Create(buffer, length);
	Packet_WidgetSerializer_Deserialize(&ms->base, instance);
	return instance;
}

Packet_Widget const *Packet_WidgetSerializer_DeserializeLength(CitoStream const *stream, int length, Packet_Widget *instance)
{
	int limit;
	instance->type = 0;
	limit = stream->vtbl->position(stream) + length;
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->id = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->click = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->width = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->height_ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 58:
			instance->text = ProtocolParser_ReadString(stream);
			continue;
		case 64:
			instance->clickKey = ProtocolParser_ReadUInt64(stream);
			continue;
		case 74:
			instance->image = ProtocolParser_ReadString(stream);
			continue;
		case 80:
			instance->color = ProtocolParser_ReadUInt64(stream);
			continue;
		case 90:
			if (instance->font == NULL)
				instance->font = Packet_DialogFontSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_DialogFontSerializer_DeserializeLengthDelimited(stream, instance->font);
			continue;
		case 96:
			instance->type = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_Widget const *Packet_WidgetSerializer_DeserializeLengthDelimited(CitoStream const *stream, Packet_Widget *instance)
{
	int limit;
	instance->type = 0;
	limit = ProtocolParser_ReadUInt32(stream);
	limit += stream->vtbl->position(stream);
	while (TRUE) {
		int keyByte;
		Key const *key;
		if (stream->vtbl->position(stream) >= limit) {
			if (stream->vtbl->position(stream) == limit)
				break;
			else
				return NULL;
		}
		keyByte = stream->vtbl->readByte(stream);
		if (keyByte == -1)
			return NULL;
		switch (keyByte) {
		case 10:
			instance->id = ProtocolParser_ReadString(stream);
			continue;
		case 16:
			instance->click = ProtocolParser_ReadUInt64(stream);
			continue;
		case 24:
			instance->x = ProtocolParser_ReadUInt64(stream);
			continue;
		case 32:
			instance->y = ProtocolParser_ReadUInt64(stream);
			continue;
		case 40:
			instance->width = ProtocolParser_ReadUInt64(stream);
			continue;
		case 48:
			instance->height_ = ProtocolParser_ReadUInt64(stream);
			continue;
		case 58:
			instance->text = ProtocolParser_ReadString(stream);
			continue;
		case 64:
			instance->clickKey = ProtocolParser_ReadUInt64(stream);
			continue;
		case 74:
			instance->image = ProtocolParser_ReadString(stream);
			continue;
		case 80:
			instance->color = ProtocolParser_ReadUInt64(stream);
			continue;
		case 90:
			if (instance->font == NULL)
				instance->font = Packet_DialogFontSerializer_DeserializeLengthDelimitedNew(stream);
			else
				Packet_DialogFontSerializer_DeserializeLengthDelimited(stream, instance->font);
			continue;
		case 96:
			instance->type = ProtocolParser_ReadUInt64(stream);
			continue;
		default:
			break;
		}
		key = ProtocolParser_ReadKey_((unsigned char) keyByte, stream);
		switch (Key_GetField(key)) {
		case 0:
			return NULL;
		default:
			ProtocolParser_SkipKey(stream, key);
			break;
		}
	}
	return instance;
}

Packet_Widget const *Packet_WidgetSerializer_DeserializeLengthDelimitedNew(CitoStream const *stream)
{
	Packet_Widget *instance = Packet_Widget_New();
	Packet_WidgetSerializer_DeserializeLengthDelimited(stream, instance);
	return instance;
}

void Packet_WidgetSerializer_Serialize(CitoStream const *stream, Packet_Widget const *instance)
{
	if (instance->id != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(10));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->id));
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(16));
	ProtocolParser_WriteUInt64(stream, instance->click);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(24));
	ProtocolParser_WriteUInt64(stream, instance->x);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(32));
	ProtocolParser_WriteUInt64(stream, instance->y);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(40));
	ProtocolParser_WriteUInt64(stream, instance->width);
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(48));
	ProtocolParser_WriteUInt64(stream, instance->height_);
	if (instance->text != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(58));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->text));
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(64));
	ProtocolParser_WriteUInt64(stream, instance->clickKey);
	if (instance->image != NULL) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(74));
		ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(instance->image));
	}
	stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(80));
	ProtocolParser_WriteUInt64(stream, instance->color);
	if (instance->font != NULL) {
		CitoMemoryStream const *ms11;
		int ms11Length;
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(90));
		ms11 = CitoMemoryStream_New();
		Packet_DialogFontSerializer_Serialize(&ms11->base, instance->font);
		ms11Length = CitoMemoryStream_Length(ms11);
		ProtocolParser_WriteUInt32_(stream, ms11Length);
		stream->vtbl->write(stream, CitoMemoryStream_GetBuffer(ms11), 0, ms11Length);
	}
	if (instance->type != 0) {
		stream->vtbl->writeByte(stream, ProtoPlatform_IntToByte(96));
		ProtocolParser_WriteUInt64(stream, instance->type);
	}
}

void Packet_WidgetSerializer_SerializeLengthDelimited(CitoStream const *stream, Packet_Widget const *instance)
{
	unsigned char const *data = Packet_WidgetSerializer_SerializeToBytes(instance);
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(data));
	stream->vtbl->write(stream, data, 0, ProtoPlatform_ArrayLength(data));
}

unsigned char const *Packet_WidgetSerializer_SerializeToBytes(Packet_Widget const *instance)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	Packet_WidgetSerializer_Serialize(&ms->base, instance);
	return CitoMemoryStream_ToArray(ms);
}

static void Ping__Construct(Ping_ *self)
{
	self->roundtripTimeMilliseconds = 0;
	self->ready = TRUE;
	self->timeSendMilliseconds = 0;
	self->timeout = 10;
}

Ping_ *Ping__New(void)
{
	Ping_ *self = (Ping_ *) malloc(sizeof(Ping_));
	if (self != NULL)
		Ping__Construct(self);
	return self;
}

void Ping__Delete(Ping_ *self)
{
	free(self);
}

int Ping__GetTimeoutValue(Ping_ const *self)
{
	return self->timeout;
}

cibool Ping__Receive(Ping_ *self, GamePlatform const *platform)
{
	if (self->ready) {
		return FALSE;
	}
	self->roundtripTimeMilliseconds = platform->vtbl->timeMillisecondsFromStart(platform) - self->timeSendMilliseconds;
	self->ready = TRUE;
	return TRUE;
}

static int Ping__RoundtripTimeTotalMilliseconds(Ping_ const *self)
{
	return self->roundtripTimeMilliseconds;
}

cibool Ping__Send(Ping_ *self, GamePlatform const *platform)
{
	if (!self->ready) {
		return FALSE;
	}
	self->ready = FALSE;
	self->timeSendMilliseconds = platform->vtbl->timeMillisecondsFromStart(platform);
	return TRUE;
}

void Ping__SetTimeoutValue(Ping_ *self, int value)
{
	self->timeout = value;
}

cibool Ping__Timeout(Ping_ *self, GamePlatform const *platform)
{
	if ((platform->vtbl->timeMillisecondsFromStart(platform) - self->timeSendMilliseconds) / 1000 > self->timeout) {
		self->ready = TRUE;
		return TRUE;
	}
	return FALSE;
}

float Platform_Acos(float a)
{
	
            return acos(a);
        return 0;
}

float Platform_Cos(float a)
{
	
            return cos(a);
        return 0;
}

float Platform_Sin(float a)
{
	
            return sin(a);
        return 0;
}

float Platform_Sqrt(float a)
{
	
            return sqrt(a);
        return 0;
}

float Platform_Tan(float a)
{
	
            return tan(a);
        return 0;
}

void Platform_WriteInt(int a)
{
	
            printf("%i", a);
        }

void Platform_WriteString(const char *a)
{
	
            printf("%s", a);
        }

static void Player_Construct(Player *self)
{
	self->animationHint_ = AnimationHint_New();
	self->model_ = "player.txt";
	self->eyeHeight = Player_DefaultEyeHeight(self);
	self->modelHeight = Player_DefaultModelHeight(self);
	self->currentTexture = -1;
}

Player *Player_New(void)
{
	Player *self = (Player *) malloc(sizeof(Player));
	if (self != NULL)
		Player_Construct(self);
	return self;
}

void Player_Delete(Player *self)
{
	free(self);
}

float Player_DefaultEyeHeight(Player const *self)
{
	float one = 1;
	return one * 15 / 10;
}

float Player_DefaultModelHeight(Player const *self)
{
	float one = 1;
	return one * 17 / 10;
}

static void PlayerDrawInfo_Construct(PlayerDrawInfo *self)
{
	self->anim = AnimationState_New();
	self->animationHint_ = AnimationHint_New();
}

PlayerDrawInfo *PlayerDrawInfo_New(void)
{
	PlayerDrawInfo *self = (PlayerDrawInfo *) malloc(sizeof(PlayerDrawInfo));
	if (self != NULL)
		PlayerDrawInfo_Construct(self);
	return self;
}

void PlayerDrawInfo_Delete(PlayerDrawInfo *self)
{
	free(self);
}

static void PlayerInterpolate_Construct(PlayerInterpolate *self, const IInterpolationVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_PlayerInterpolate;
	IInterpolation_Construct(&self->base, vtbl);
}

PlayerInterpolate *PlayerInterpolate_New(void)
{
	PlayerInterpolate *self = (PlayerInterpolate *) malloc(sizeof(PlayerInterpolate));
	if (self != NULL)
		PlayerInterpolate_Construct(self, NULL);
	return self;
}

void PlayerInterpolate_Delete(PlayerInterpolate *self)
{
	free(self);
}

float PlayerInterpolate_DegToRad(float deg)
{
	return deg / 360 * 2 * Game_GetPi();
}

InterpolatedObject const *PlayerInterpolate_Interpolate(PlayerInterpolate const *self, InterpolatedObject const *a, InterpolatedObject const *b, float progress)
{
	PlayerInterpolationState const *aa = self->platform->vtbl->castToPlayerInterpolationState(self->platform, a);
	PlayerInterpolationState const *bb = self->platform->vtbl->castToPlayerInterpolationState(self->platform, b);
	PlayerInterpolationState *cc = PlayerInterpolationState_New();
	cc->positionX = aa->positionX + (bb->positionX - aa->positionX) * progress;
	cc->positionY = aa->positionY + (bb->positionY - aa->positionY) * progress;
	cc->positionZ = aa->positionZ + (bb->positionZ - aa->positionZ) * progress;
	cc->rotx = PlayerInterpolate_DegToRad(AngleInterpolation_InterpolateAngle360(self->platform, PlayerInterpolate_RadToDeg(aa->rotx), PlayerInterpolate_RadToDeg(bb->rotx), progress));
	cc->roty = PlayerInterpolate_DegToRad(AngleInterpolation_InterpolateAngle360(self->platform, PlayerInterpolate_RadToDeg(aa->roty), PlayerInterpolate_RadToDeg(bb->roty), progress));
	cc->rotz = PlayerInterpolate_DegToRad(AngleInterpolation_InterpolateAngle360(self->platform, PlayerInterpolate_RadToDeg(aa->rotz), PlayerInterpolate_RadToDeg(bb->rotz), progress));
	return &cc->base;
}

float PlayerInterpolate_RadToDeg(float rad)
{
	return rad / (2 * Game_GetPi()) * 360;
}

PlayerInterpolationState *PlayerInterpolationState_New(void)
{
	PlayerInterpolationState *self = (PlayerInterpolationState *) malloc(sizeof(PlayerInterpolationState));
	return self;
}

void PlayerInterpolationState_Delete(PlayerInterpolationState *self)
{
	free(self);
}

PointFloatRef *PointFloatRef_New(void)
{
	PointFloatRef *self = (PointFloatRef *) malloc(sizeof(PointFloatRef));
	return self;
}

void PointFloatRef_Delete(PointFloatRef *self)
{
	free(self);
}

PointFloatRef const *PointFloatRef_Create(float x_, float y_)
{
	PointFloatRef *p = PointFloatRef_New();
	p->x = x_;
	p->y = y_;
	return p;
}

PointRef *PointRef_New(void)
{
	PointRef *self = (PointRef *) malloc(sizeof(PointRef));
	return self;
}

void PointRef_Delete(PointRef *self)
{
	free(self);
}

PointRef *PointRef_Create(int x_, int y_)
{
	PointRef *p = PointRef_New();
	p->x = x_;
	p->y = y_;
	return p;
}

static void PredicateBox3D_Construct(PredicateBox3D *self, const PredicateBox3DVtbl *vtbl)
{
	self->vtbl = vtbl;
}

static void PredicateBox3DHit_Construct(PredicateBox3DHit *self, const PredicateBox3DVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_PredicateBox3DHit;
	PredicateBox3D_Construct(&self->base, vtbl);
}

PredicateBox3DHit *PredicateBox3DHit_New(void)
{
	PredicateBox3DHit *self = (PredicateBox3DHit *) malloc(sizeof(PredicateBox3DHit));
	if (self != NULL)
		PredicateBox3DHit_Construct(self, NULL);
	return self;
}

void PredicateBox3DHit_Delete(PredicateBox3DHit *self)
{
	free(self);
}

PredicateBox3DHit const *PredicateBox3DHit_Create(BlockOctreeSearcher const *s_)
{
	PredicateBox3DHit *p = PredicateBox3DHit_New();
	p->s = s_;
	return p;
}

cibool PredicateBox3DHit_Hit(PredicateBox3DHit const *self, Box3D const *o)
{
	return BlockOctreeSearcher_BoxHit(self->s, o);
}

static void Preferences_Construct(Preferences *self)
{
	self->items = DictionaryStringString_New();
}

Preferences *Preferences_New(void)
{
	Preferences *self = (Preferences *) malloc(sizeof(Preferences));
	if (self != NULL)
		Preferences_Construct(self);
	return self;
}

void Preferences_Delete(Preferences *self)
{
	free(self);
}

cibool Preferences_GetBool(Preferences const *self, const char *key, cibool default_)
{
	const char *value = Preferences_GetString(self, key, NULL);
	if (value == NULL) {
		return default_;
	}
	if (strcmp(value, "0") == 0) {
		return FALSE;
	}
	if (strcmp(value, "1") == 0) {
		return TRUE;
	}
	return default_;
}

int Preferences_GetInt(Preferences const *self, const char *key, int default_)
{
	FloatRef const *ret;
	if (Preferences_GetString(self, key, NULL) == NULL) {
		return default_;
	}
	ret = FloatRef_New();
	if (self->platform->vtbl->floatTryParse(self->platform, Preferences_GetString(self, key, NULL), ret)) {
		return self->platform->vtbl->floatToInt(self->platform, ret->value);
	}
	return default_;
}

const char *Preferences_GetKey(Preferences const *self, int i)
{
	if (self->items->items[i] != NULL) {
		return self->items->items[i]->key;
	}
	else {
		return NULL;
	}
}

int Preferences_GetKeysCount(Preferences const *self)
{
	return self->items->count;
}

const char *Preferences_GetString(Preferences const *self, const char *key, const char *default_)
{
	if (!DictionaryStringString_ContainsKey(self->items, key)) {
		return default_;
	}
	return DictionaryStringString_Get(self->items, key);
}

static void Preferences_Remove(Preferences const *self, const char *key)
{
	DictionaryStringString_Remove(self->items, key);
}

void Preferences_SetBool(Preferences const *self, const char *key, cibool value)
{
	Preferences_SetString(self, key, value ? "1" : "0");
}

void Preferences_SetInt(Preferences const *self, const char *key, int value)
{
	Preferences_SetString(self, key, self->platform->vtbl->intToString(self->platform, value));
}

void Preferences_SetString(Preferences const *self, const char *key, const char *value)
{
	DictionaryStringString_Set(self->items, key, value);
}

static void ProcessPacketTask_Construct(ProcessPacketTask *self, const Action_Vtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ProcessPacketTask;
	Action__Construct(&self->base, vtbl);
}

ProcessPacketTask *ProcessPacketTask_New(void)
{
	ProcessPacketTask *self = (ProcessPacketTask *) malloc(sizeof(ProcessPacketTask));
	if (self != NULL)
		ProcessPacketTask_Construct(self, NULL);
	return self;
}

void ProcessPacketTask_Delete(ProcessPacketTask *self)
{
	free(self);
}

static cibool ProcessPacketTask_Contains(ProcessPacketTask const *self, const char *const *arr, int arrLength, const char *value)
{
	return ProcessPacketTask_IndexOf(self, arr, arrLength, value) != -1;
}

static int ProcessPacketTask_IndexOf(ProcessPacketTask const *self, const char *const *arr, int arrLength, const char *value)
{
	{
		int i;
		for (i = 0; i < arrLength; i++) {
			if (Game_StringEquals(arr[i], value)) {
				return i;
			}
		}
	}
	return -1;
}

static void ProcessPacketTask_ProcessPacket(ProcessPacketTask const *self, Packet_Server const *packet)
{
	if (self->game->packetHandlers[packet->id] != NULL) {
		self->game->packetHandlers[packet->id]->vtbl->handle(self->game->packetHandlers[packet->id], self->game, packet);
	}
	switch (packet->id) {
		IntRef const *oldFollowId;
		int textureInAtlasIdsCount;
		const char **textureInAtlasIds;
		int lastTextureId;
	case 0:
		{
			const char *invalidversionstr = Language_InvalidVersionConnectAnyway(self->game->language);
			self->game->serverGameVersion = packet->identification->mdProtocolVersion;
			if (strcmp(self->game->serverGameVersion, self->game->platform->vtbl->getGameVersion(self->game->platform)) != 0) {
				const char *q;
				Game_ChatLog(self->game, "[GAME] Different game versions");
				q = self->game->platform->vtbl->stringFormat2(self->game->platform, invalidversionstr, self->game->platform->vtbl->getGameVersion(self->game->platform), self->game->serverGameVersion);
				self->game->invalidVersionDrawMessage = q;
				self->game->invalidVersionPacketIdentification = packet;
			}
			else {
				Game_ProcessServerIdentification(self->game, packet);
			}
			self->game->receivedMapLength = 0;
		}
		break;
	case 1:
		{
			Game_SendPingReply(self->game);
			Ping__Send(self->game->serverInfo->serverPing, self->game->platform);
		}
		break;
	case 111:
		{
			Ping__Receive(self->game->serverInfo->serverPing, self->game->platform);
		}
		break;
	case 2:
		{
			Game_ChatLog(self->game, "[GAME] Initialized map loading");
			self->game->receivedMapLength = 0;
			Game_InvokeMapLoadingProgress(self->game, 0, 0, Language_Connecting(self->game->language));
		}
		break;
	case 3:
		{
			Game_InvokeMapLoadingProgress(self->game, packet->levelDataChunk->percentComplete, self->game->receivedMapLength, packet->levelDataChunk->status);
		}
		break;
	case 4:
		{
			Game_ChatLog(self->game, "[GAME] Finished map loading");
		}
		break;
	case 6:
		{
			int x = packet->setBlock->x;
			int y = packet->setBlock->y;
			int z = packet->setBlock->z;
			int type = packet->setBlock->blockType;
			{
				Game_SetTileAndUpdate(self->game, x, y, z, type);
			}
		}
		break;
	case 61:
		{
			int ax = packet->fillArea->x1;
			int ay = packet->fillArea->y1;
			int az = packet->fillArea->z1;
			int bx = packet->fillArea->x2;
			int by = packet->fillArea->y2;
			int bz = packet->fillArea->z2;
			int startx = MathCi_MinInt(ax, bx);
			int endx = MathCi_MaxInt(ax, bx);
			int starty = MathCi_MinInt(ay, by);
			int endy = MathCi_MaxInt(ay, by);
			int startz = MathCi_MinInt(az, bz);
			int endz = MathCi_MaxInt(az, bz);
			int blockCount = packet->fillArea->blockCount;
			{
				{
					int x;
					for (x = startx; x <= endx; x++) {
						{
							int y;
							for (y = starty; y <= endy; y++) {
								{
									int z;
									for (z = startz; z <= endz; z++) {
										if (blockCount == 0) {
											return;
										}
										{
											Game_SetTileAndUpdate(self->game, x, y, z, packet->fillArea->blockType);
										}
										blockCount--;
									}
								}
							}
						}
					}
				}
			}
		}
		break;
	case 62:
		{
			self->game->fillAreaLimit = packet->fillAreaLimit->limit;
			if (self->game->fillAreaLimit > 100000) {
				self->game->fillAreaLimit = 100000;
			}
		}
		break;
	case 51:
		{
			self->game->allowFreemove = packet->freemove->isEnabled != 0;
			if (!self->game->allowFreemove) {
				Controls_SetFreemove(self->game->controls, 0);
				self->game->movespeed = self->game->basemovespeed;
				Game_Log(self->game, Language_MoveNormal(self->game->language));
			}
		}
		break;
	case 26:
		{
			int x = packet->playerSpawnPosition->x;
			int y = packet->playerSpawnPosition->y;
			int z = packet->playerSpawnPosition->z;
			self->game->playerPositionSpawnX = x;
			self->game->playerPositionSpawnY = z;
			self->game->playerPositionSpawnZ = y;
			Game_Log(self->game, self->game->platform->vtbl->stringFormat(self->game->platform, Language_SpawnPositionSetTo(self->game->language), self->game->platform->vtbl->stringFormat3(self->game->platform, "{0},{1},{2}", self->game->platform->vtbl->intToString(self->game->platform, x), self->game->platform->vtbl->intToString(self->game->platform, y), self->game->platform->vtbl->intToString(self->game->platform, z))));
		}
		break;
	case 13:
		{
			Game_AddChatline(self->game, packet->message->message);
			Game_ChatLog(self->game, packet->message->message);
		}
		break;
	case 14:
		{
			Game_ChatLog(self->game, self->game->platform->vtbl->stringFormat(self->game->platform, "[GAME] Disconnected by the server ({0})", packet->disconnectPlayer->disconnectReason));
			if (self->game->platform->vtbl->isMousePointerLocked(self->game->platform)) {
				self->game->platform->vtbl->exitMousePointerLock(self->game->platform);
			}
			self->game->platform->vtbl->messageBoxShowError(self->game->platform, packet->disconnectPlayer->disconnectReason, "Disconnected from server");
			Game_ExitToMainMenu_(self->game);
			break;
		}
	case 23:
		{
			Packet_ServerPlayerStats *p = packet->playerStats;
			self->game->playerStats = p;
		}
		break;
	case 16:
		{
			if (packet->inventory->inventory != NULL) {
				Game_UseInventory(self->game, packet->inventory->inventory);
			}
		}
		break;
	case 17:
		{
			int sunlight;
			int hour;
			packet->season->hour -= 1;
			if (packet->season->hour < 0) {
				packet->season->hour = 48;
			}
			sunlight = self->game->nightLevels[packet->season->hour];
			self->game->skySphereNight = sunlight < 8;
			self->game->d_SunMoonRenderer->day_length_in_seconds = 86400 / packet->season->dayNightCycleSpeedup;
			hour = packet->season->hour / 4;
			if (SunMoonRenderer_GetHour(self->game->d_SunMoonRenderer) != hour) {
				SunMoonRenderer_SetHour(self->game->d_SunMoonRenderer, hour);
			}
			if (self->game->sunlight_ != sunlight) {
				self->game->sunlight_ = sunlight;
				Game_RedrawAllBlocks(self->game);
			}
		}
		break;
	case 18:
		{
			self->game->blobdownload = CitoMemoryStream_New();
			self->game->blobdownloadname = packet->blobInitialize->name;
			self->game->blobdownloadmd5 = packet->blobInitialize->md5;
		}
		break;
	case 19:
		{
			int length = self->game->platform->vtbl->byteArrayLength(self->game->platform, packet->blobPart->data);
			self->game->blobdownload->base.vtbl->write(&self->game->blobdownload->base, packet->blobPart->data, 0, length);
			self->game->receivedMapLength += length;
		}
		break;
	case 20:
		{
			unsigned char const *downloaded = CitoMemoryStream_ToArray(self->game->blobdownload);
			if (self->game->blobdownloadname != NULL) {
				Game_SetFile(self->game, self->game->blobdownloadname, self->game->blobdownloadmd5, downloaded, CitoMemoryStream_Length(self->game->blobdownload));
			}
			self->game->blobdownload = NULL;
		}
		break;
	case 22:
		{
			Game_PlaySoundAt(self->game, packet->sound->name, packet->sound->x, packet->sound->y, packet->sound->z);
		}
		break;
	case 50:
		{
			{
				int i;
				for (i = 128; i < 256; i++) {
					self->game->entities[i] = NULL;
				}
			}
		}
		break;
	case 60:
		Language_Override(self->game->language, packet->translation->lang, packet->translation->id, packet->translation->translation);
		break;
	case 56:
		self->game->newBlockTypes[packet->blockType->id] = packet->blockType->blocktype;
		break;
	case 28:
		self->game->nightLevels = packet->sunLevels->sunlevels;
		break;
	case 29:
		{
			int i;
			for (i = 0; i < packet->lightLevels->lightlevelsCount; i++) {
				self->game->mLightLevels[i] = Game_DeserializeFloat(self->game, packet->lightLevels->lightlevels[i]);
			}
		}
		break;
	case 53:
		oldFollowId = Game_FollowId(self->game);
		self->game->follow = packet->follow->client;
		if (packet->follow->tpp != 0) {
			Game_SetCamera(self->game, CameraType_OVERHEAD);
			self->game->player->position->rotx = Game_GetPi();
			Game_GuiStateBackToGame(self->game);
		}
		else {
			Game_SetCamera(self->game, CameraType_FPP);
		}
		break;
	case 54:
		Game_EntityAddLocal(self->game, Game_CreateBulletEntity(self->game, Game_DeserializeFloat(self->game, packet->bullet->fromXFloat), Game_DeserializeFloat(self->game, packet->bullet->fromYFloat), Game_DeserializeFloat(self->game, packet->bullet->fromZFloat), Game_DeserializeFloat(self->game, packet->bullet->toXFloat), Game_DeserializeFloat(self->game, packet->bullet->toYFloat), Game_DeserializeFloat(self->game, packet->bullet->toZFloat), Game_DeserializeFloat(self->game, packet->bullet->speedFloat)));
		break;
	case 55:
		if (!self->game->ammostarted) {
			self->game->ammostarted = TRUE;
			{
				int i;
				for (i = 0; i < packet->ammo->totalAmmoCount; i++) {
					Packet_IntInt const *k = packet->ammo->totalAmmo[i];
					self->game->loadedAmmo[k->key_] = MathCi_MinInt(k->value_, self->game->blocktypes[k->key_]->ammoMagazine);
				}
			}
		}
		self->game->totalAmmo = (int *) malloc(1024 * sizeof(int ));
		{
			int i;
			for (i = 0; i < packet->ammo->totalAmmoCount; i++) {
				self->game->totalAmmo[packet->ammo->totalAmmo[i]->key_] = packet->ammo->totalAmmo[i]->value_;
			}
		}
		break;
	case 58:
		{
			Entity *entity = Entity_New();
			entity->expires = Expires_New();
			entity->expires->timeLeft = Game_DeserializeFloat(self->game, packet->explosion->timeFloat);
			entity->push = packet->explosion;
			Game_EntityAddLocal(self->game, entity);
		}
		break;
	case 59:
		{
			Entity *entity = Entity_New();
			Sprite *sprite = Sprite_New();
			Grenade_ *grenade;
			sprite->image = "ChemicalGreen.png";
			sprite->size = 14;
			sprite->animationcount = 0;
			sprite->positionX = Game_DeserializeFloat(self->game, packet->projectile->fromXFloat);
			sprite->positionY = Game_DeserializeFloat(self->game, packet->projectile->fromYFloat);
			sprite->positionZ = Game_DeserializeFloat(self->game, packet->projectile->fromZFloat);
			entity->sprite = sprite;
			grenade = Grenade__New();
			grenade->velocityX = Game_DeserializeFloat(self->game, packet->projectile->velocityXFloat);
			grenade->velocityY = Game_DeserializeFloat(self->game, packet->projectile->velocityYFloat);
			grenade->velocityZ = Game_DeserializeFloat(self->game, packet->projectile->velocityZFloat);
			grenade->block = packet->projectile->blockId;
			grenade->sourcePlayer = packet->projectile->sourcePlayerID;
			entity->grenade = grenade;
			entity->expires = Expires_Create(Game_DeserializeFloat(self->game, packet->projectile->explodesAfterFloat));
			Game_EntityAddLocal(self->game, entity);
		}
		break;
	case 27:
		self->game->blocktypes = self->game->newBlockTypes;
		self->game->newBlockTypes = (Packet_BlockType const **) malloc(1024 * sizeof(Packet_BlockType const *));
		textureInAtlasIdsCount = 1024;
		textureInAtlasIds = (const char **) malloc(textureInAtlasIdsCount * sizeof(const char *));
		lastTextureId = 0;
		{
			int i;
			for (i = 0; i < 1024; i++) {
				if (self->game->blocktypes[i] != NULL) {
					const char **to_load = (const char **) malloc(7 * sizeof(const char *));
					int to_loadLength = 7;
					{
						to_load[0] = self->game->blocktypes[i]->textureIdLeft;
						to_load[1] = self->game->blocktypes[i]->textureIdRight;
						to_load[2] = self->game->blocktypes[i]->textureIdFront;
						to_load[3] = self->game->blocktypes[i]->textureIdBack;
						to_load[4] = self->game->blocktypes[i]->textureIdTop;
						to_load[5] = self->game->blocktypes[i]->textureIdBottom;
						to_load[6] = self->game->blocktypes[i]->textureIdForInventory;
					}
					{
						int k;
						for (k = 0; k < to_loadLength; k++) {
							if (!ProcessPacketTask_Contains(self, textureInAtlasIds, textureInAtlasIdsCount, to_load[k])) {
								textureInAtlasIds[lastTextureId++] = to_load[k];
							}
						}
					}
				}
			}
		}
		GameData_UseBlockTypes(self->game->d_Data, self->game->platform, self->game->blocktypes, 1024);
		{
			int i;
			for (i = 0; i < 1024; i++) {
				Packet_BlockType const *b = self->game->blocktypes[i];
				if (b == NULL) {
					continue;
				}
				if (textureInAtlasIds != NULL) {
					self->game->textureId[i][0] = ProcessPacketTask_IndexOf(self, textureInAtlasIds, textureInAtlasIdsCount, b->textureIdTop);
					self->game->textureId[i][1] = ProcessPacketTask_IndexOf(self, textureInAtlasIds, textureInAtlasIdsCount, b->textureIdBottom);
					self->game->textureId[i][2] = ProcessPacketTask_IndexOf(self, textureInAtlasIds, textureInAtlasIdsCount, b->textureIdFront);
					self->game->textureId[i][3] = ProcessPacketTask_IndexOf(self, textureInAtlasIds, textureInAtlasIdsCount, b->textureIdBack);
					self->game->textureId[i][4] = ProcessPacketTask_IndexOf(self, textureInAtlasIds, textureInAtlasIdsCount, b->textureIdLeft);
					self->game->textureId[i][5] = ProcessPacketTask_IndexOf(self, textureInAtlasIds, textureInAtlasIdsCount, b->textureIdRight);
					self->game->textureIdForInventory[i] = ProcessPacketTask_IndexOf(self, textureInAtlasIds, textureInAtlasIdsCount, b->textureIdForInventory);
				}
			}
		}
		Game_UseTerrainTextures(self->game, textureInAtlasIds, textureInAtlasIdsCount);
		self->game->handRedraw = TRUE;
		Game_RedrawAllBlocks(self->game);
		break;
	case 65:
		Game_ChatLog(self->game, "[GAME] Received server redirect");
		Game_SendLeave(self->game, 0);
		Game_ExitAndSwitchServer(self->game, packet->redirect);
		break;
	}
}

void ProcessPacketTask_Run(ProcessPacketTask const *self)
{
	ProcessPacketTask_ProcessPacket(self, self->packet_);
}

int ProtoPlatform_ArrayLength(unsigned char const *a)
{
	int len;
	len = 0;
	return len;
}

const char *ProtoPlatform_BytesToString(unsigned char const *bytes, int length)
{
	const char *s;
	s = NULL;
	return s;
}

unsigned char ProtoPlatform_IntToByte(int a)
{
	return (unsigned char) a;
}

unsigned char const *ProtoPlatform_StringToBytes(const char *s)
{
	unsigned char const *b;
	b = NULL;
	return b;
}

int ProtoPlatform_logical_right_shift(int x, int n)
{
	int mask = ~(-1 << n) << (32 - n);
	return ~mask & ((x >> n) | mask);
}

cibool ProtocolParser_ReadBool(CitoStream const *stream)
{
	int b = stream->vtbl->readByte(stream);
	if (b < 0)
		return FALSE;
	if (b == 1)
		return TRUE;
	if (b == 0)
		return FALSE;
	return FALSE;
}

unsigned char const *ProtocolParser_ReadBytes(CitoStream const *stream)
{
	int length = ProtocolParser_ReadUInt32(stream);
	unsigned char const *buffer = (unsigned char *) malloc(length * sizeof(unsigned char ));
	int read = 0;
	while (read < length) {
		int r = stream->vtbl->read(stream, buffer, read, length - read);
		if (r == 0)
			return NULL;
		read += r;
	}
	return buffer;
}

int ProtocolParser_ReadInt32(CitoStream const *stream)
{
	return ProtocolParser_ReadUInt64(stream);
}

int ProtocolParser_ReadInt64(CitoStream const *stream)
{
	return ProtocolParser_ReadUInt64(stream);
}

Key const *ProtocolParser_ReadKey(CitoStream const *stream)
{
	int n = ProtocolParser_ReadUInt32(stream);
	return Key_Create(n >> 3, n & 7);
}

Key const *ProtocolParser_ReadKey_(unsigned char firstByte, CitoStream const *stream)
{
	int fieldID;
	if (firstByte < 128)
		return Key_Create(firstByte >> 3, firstByte & 7);
	fieldID = (ProtocolParser_ReadUInt32(stream) << 4) | ((firstByte >> 3) & 15);
	return Key_Create(fieldID, firstByte & 7);
}

void ProtocolParser_ReadSkipVarInt(CitoStream const *stream)
{
	while (TRUE) {
		int b = stream->vtbl->readByte(stream);
		if (b < 0)
			return;
		if ((b & 128) == 0)
			return;
	}
}

const char *ProtocolParser_ReadString(CitoStream const *stream)
{
	unsigned char const *bytes = ProtocolParser_ReadBytes(stream);
	return ProtoPlatform_BytesToString(bytes, 0);
}

int ProtocolParser_ReadUInt32(CitoStream const *stream)
{
	int b;
	int val = 0;
	{
		int n;
		for (n = 0; n < 5; n++) {
			b = stream->vtbl->readByte(stream);
			if (b < 0)
				return 0;
			if (n == 4 && (b & 240) != 0)
				return 0;
			if ((b & 128) == 0)
				return val | (b << 7 * n);
			val |= (b & 127) << 7 * n;
		}
	}
	return 0;
}

int ProtocolParser_ReadUInt64(CitoStream const *stream)
{
	int b;
	int val = 0;
	{
		int n;
		for (n = 0; n < 10; n++) {
			b = stream->vtbl->readByte(stream);
			if (b < 0)
				return 0;
			if (n == 9 && (b & 254) != 0)
				return 0;
			if ((b & 128) == 0)
				return val | (b << 7 * n);
			val |= (b & 127) << 7 * n;
		}
	}
	return 0;
}

unsigned char const *ProtocolParser_ReadValueBytes(CitoStream const *stream, Key const *key)
{
	unsigned char *b;
	int offset = 0;
	switch (Key_GetWireType(key)) {
		int length;
		CitoMemoryStream const *ms;
	case 5:
		b = (unsigned char *) malloc(4 * sizeof(unsigned char ));
		while (offset < 4)
			offset += stream->vtbl->read(stream, b, offset, 4 - offset);
		return b;
	case 1:
		b = (unsigned char *) malloc(8 * sizeof(unsigned char ));
		while (offset < 8)
			offset += stream->vtbl->read(stream, b, offset, 8 - offset);
		return b;
	case 2:
		length = ProtocolParser_ReadUInt32(stream);
		ms = CitoMemoryStream_New();
		{
			unsigned char const *arr;
			ProtocolParser_WriteUInt32(ms, length);
			b = (unsigned char *) malloc((length + CitoMemoryStream_Length(ms)) * sizeof(unsigned char ));
			arr = CitoMemoryStream_ToArray(ms);
			{
				int i;
				for (i = 0; i < ProtoPlatform_ArrayLength(arr); i++) {
					b[i] = arr[i];
				}
			}
			offset = CitoMemoryStream_Length(ms);
		}
		while (offset < ProtoPlatform_ArrayLength(b))
			offset += stream->vtbl->read(stream, b, offset, ProtoPlatform_ArrayLength(b) - offset);
		return b;
	case 0:
		return ProtocolParser_ReadVarIntBytes(stream);
	default:
		return NULL;
	}
}

unsigned char const *ProtocolParser_ReadVarIntBytes(CitoStream const *stream)
{
	unsigned char *buffer = (unsigned char *) malloc(10 * sizeof(unsigned char ));
	int offset = 0;
	unsigned char *ret;
	while (TRUE) {
		int b = stream->vtbl->readByte(stream);
		if (b < 0)
			return NULL;
		buffer[offset] = (unsigned char) b;
		offset += 1;
		if ((b & 128) == 0)
			break;
		if (offset >= ProtoPlatform_ArrayLength(buffer))
			return NULL;
	}
	ret = (unsigned char *) malloc(offset * sizeof(unsigned char ));
	{
		int i;
		for (i = 0; i < offset; i++) {
			ret[i] = buffer[i];
		}
	}
	return ret;
}

int ProtocolParser_ReadZInt32(CitoStream const *stream)
{
	int val = ProtocolParser_ReadUInt32(stream);
	return (val >> 1) ^ (val << 31 >> 31);
}

int ProtocolParser_ReadZInt64(CitoStream const *stream)
{
	int val = ProtocolParser_ReadUInt64(stream);
	return (val >> 1) ^ (val << 63 >> 63);
}

void ProtocolParser_SkipBytes(CitoStream const *stream)
{
	int length = ProtocolParser_ReadUInt32(stream);
	if (stream->vtbl->canSeek(stream))
		stream->vtbl->seek(stream, length, CitoSeekOrigin_CURRENT);
	else
		ProtocolParser_ReadBytes(stream);
}

void ProtocolParser_SkipKey(CitoStream const *stream, Key const *key)
{
	switch (Key_GetWireType(key)) {
	case 5:
		stream->vtbl->seek(stream, 4, CitoSeekOrigin_CURRENT);
		return;
	case 1:
		stream->vtbl->seek(stream, 8, CitoSeekOrigin_CURRENT);
		return;
	case 2:
		stream->vtbl->seek(stream, ProtocolParser_ReadUInt32(stream), CitoSeekOrigin_CURRENT);
		return;
	case 0:
		ProtocolParser_ReadSkipVarInt(stream);
		return;
	default:
		return;
	}
}

void ProtocolParser_WriteBool(CitoStream const *stream, cibool val)
{
	unsigned char ret = 0;
	if (val) {
		ret = 1;
	}
	stream->vtbl->writeByte(stream, ret);
}

void ProtocolParser_WriteBytes(CitoStream const *stream, unsigned char const *val)
{
	ProtocolParser_WriteUInt32_(stream, ProtoPlatform_ArrayLength(val));
	stream->vtbl->write(stream, val, 0, ProtoPlatform_ArrayLength(val));
}

void ProtocolParser_WriteInt32(CitoStream const *stream, int val)
{
	ProtocolParser_WriteUInt64(stream, val);
}

void ProtocolParser_WriteInt64(CitoStream const *stream, int val)
{
	ProtocolParser_WriteUInt64(stream, val);
}

void ProtocolParser_WriteKey(CitoStream const *stream, Key const *key)
{
	int n = (Key_GetField(key) << 3) | Key_GetWireType(key);
	ProtocolParser_WriteUInt32_(stream, n);
}

void ProtocolParser_WriteString(CitoStream const *stream, const char *val)
{
	ProtocolParser_WriteBytes(stream, ProtoPlatform_StringToBytes(val));
}

static void ProtocolParser_WriteUInt32(CitoMemoryStream const *ms, int length)
{
}

void ProtocolParser_WriteUInt32_(CitoStream const *stream, int val)
{
	unsigned char *buffer = (unsigned char *) malloc(5 * sizeof(unsigned char ));
	int count = 0;
	while (TRUE) {
		buffer[count] = (unsigned char) (val & 127);
		val = val >> 7;
		if (val == 0)
			break;
		buffer[count] |= 128;
		count += 1;
	}
	stream->vtbl->write(stream, buffer, 0, count + 1);
}

void ProtocolParser_WriteUInt64(CitoStream const *stream, int val)
{
	unsigned char *buffer = (unsigned char *) malloc(10 * sizeof(unsigned char ));
	int count = 0;
	while (TRUE) {
		buffer[count] = (unsigned char) (val & 127);
		val = ProtoPlatform_logical_right_shift(val, 7);
		if (val == 0)
			break;
		buffer[count] |= 128;
		count += 1;
	}
	stream->vtbl->write(stream, buffer, 0, count + 1);
}

void ProtocolParser_WriteZInt32(CitoStream const *stream, int val)
{
	ProtocolParser_WriteUInt32_(stream, (val << 1) ^ (val >> 31));
}

void ProtocolParser_WriteZInt64(CitoStream const *stream, int val)
{
	ProtocolParser_WriteUInt64(stream, (val << 1) ^ (val >> 63));
}

ModelData const *QuadModelData_GetQuadModelData(void)
{
	ModelData *m = ModelData_New();
	float *xyz = (float *) malloc(12 * sizeof(float ));
	float *uv;
	{
		int i;
		for (i = 0; i < 12; i++) {
			xyz[i] = QuadModelData_cubeVertices[i];
		}
	}
	ModelData_setXyz(m, xyz);
	uv = (float *) malloc(8 * sizeof(float ));
	{
		int i;
		for (i = 0; i < 8; i++) {
			uv[i] = QuadModelData_quadTextureCoords[i];
		}
	}
	ModelData_setUv(m, uv);
	ModelData_SetVerticesCount(m, 4);
	ModelData_setIndices(m, QuadModelData_quadVertexIndices);
	ModelData_SetIndicesCount(m, 6);
	return m;
}

ModelData const *QuadModelData_GetQuadModelData2(float sx, float sy, float sw, float sh, float dx, float dy, float dw, float dh, unsigned char r, unsigned char g, unsigned char b, unsigned char a)
{
	ModelData *m = ModelData_New();
	float *xyz = (float *) malloc(12 * sizeof(float ));
	float *uv;
	unsigned char *rgba;
	xyz[0] = dx;
	xyz[1] = dy;
	xyz[2] = 0;
	xyz[3] = dx + dw;
	xyz[4] = dy;
	xyz[5] = 0;
	xyz[6] = dx + dw;
	xyz[7] = dy + dh;
	xyz[8] = 0;
	xyz[9] = dx;
	xyz[10] = dy + dh;
	xyz[11] = 0;
	ModelData_setXyz(m, xyz);
	uv = (float *) malloc(8 * sizeof(float ));
	uv[0] = sx;
	uv[1] = sy;
	uv[2] = sx + sw;
	uv[3] = sy;
	uv[4] = sx + sw;
	uv[5] = sy + sh;
	uv[6] = sx;
	uv[7] = sy + sh;
	ModelData_setUv(m, uv);
	rgba = (unsigned char *) malloc(16 * sizeof(unsigned char ));
	{
		int i;
		for (i = 0; i < 4; i++) {
			rgba[i * 4 + 0] = r;
			rgba[i * 4 + 1] = g;
			rgba[i * 4 + 2] = b;
			rgba[i * 4 + 3] = a;
		}
	}
	ModelData_setRgba(m, rgba);
	ModelData_SetVerticesCount(m, 4);
	ModelData_setIndices(m, QuadModelData_quadVertexIndices);
	ModelData_SetIndicesCount(m, 6);
	return m;
}

float const *Quat_Add(float *output, float const *a, float const *b)
{
	return Vec4_Add(output, a, b);
}

float const *Quat_CalculateW(float *output, float const *a)
{
	float x = a[0];
	float y = a[1];
	float z = a[2];
	float one;
	output[0] = x;
	output[1] = y;
	output[2] = z;
	one = 1;
	output[3] = -Platform_Sqrt(GlMatrixMath_Abs(one - x * x - y * y - z * z));
	return output;
}

float const *Quat_CloneIt(float const *a)
{
	return Vec4_CloneIt(a);
}

float const *Quat_Conjugate(Quat const *self, float *output, float const *a)
{
	output[0] = -a[0];
	output[1] = -a[1];
	output[2] = -a[2];
	output[3] = a[3];
	return output;
}

float const *Quat_Copy(float *output, float const *a)
{
	return Vec4_Copy(output, a);
}

float const *Quat_Create(void)
{
	float *output = (float *) malloc(4 * sizeof(float ));
	output[0] = 0;
	output[1] = 0;
	output[2] = 0;
	output[3] = 1;
	return output;
}

float Quat_Dot(float const *a, float const *b)
{
	return Vec4_Dot(a, b);
}

float const *Quat_FromMat3(float *output, float const *m)
{
	float fTrace = m[0] + m[4] + m[8];
	float fRoot;
	float zero = 0;
	float one = 1;
	float half = one / 2;
	if (fTrace > zero) {
		fRoot = Platform_Sqrt(fTrace + one);
		output[3] = half * fRoot;
		fRoot = half / fRoot;
		output[0] = (m[7] - m[5]) * fRoot;
		output[1] = (m[2] - m[6]) * fRoot;
		output[2] = (m[3] - m[1]) * fRoot;
	}
	else {
		int i = 0;
		int j;
		int k;
		if (m[4] > m[0])
			i = 1;
		if (m[8] > m[i * 3 + i])
			i = 2;
		j = (i + 1) % 3;
		k = (i + 2) % 3;
		fRoot = Platform_Sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + one);
		output[i] = half * fRoot;
		fRoot = half / fRoot;
		output[3] = (m[k * 3 + j] - m[j * 3 + k]) * fRoot;
		output[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
		output[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
	}
	return output;
}

float const *Quat_FromValues(float x, float y, float z, float w)
{
	return Vec4_FromValues(x, y, z, w);
}

float const *Quat_Identity_(float *output)
{
	output[0] = 0;
	output[1] = 0;
	output[2] = 0;
	output[3] = 1;
	return output;
}

float const *Quat_Invert(Quat const *self, float *output, float const *a)
{
	float a0 = a[0];
	float a1 = a[1];
	float a2 = a[2];
	float a3 = a[3];
	float dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
	float one = 1;
	float invDot = dot != 0 ? one / dot : 0;
	output[0] = -a0 * invDot;
	output[1] = -a1 * invDot;
	output[2] = -a2 * invDot;
	output[3] = a3 * invDot;
	return output;
}

float Quat_Len(float const *a)
{
	return Quat_Length_(a);
}

float Quat_Length_(float const *a)
{
	return Vec4_Length_(a);
}

float const *Quat_Lerp(float *output, float const *a, float const *b, float t)
{
	return Vec4_Lerp(output, a, b, t);
}

float const *Quat_Mul(float *output, float const *a, float const *b)
{
	return Quat_Multiply(output, a, b);
}

float const *Quat_Multiply(float *output, float const *a, float const *b)
{
	float ax = a[0];
	float ay = a[1];
	float az = a[2];
	float aw = a[3];
	float bx = b[0];
	float by = b[1];
	float bz = b[2];
	float bw = b[3];
	output[0] = ax * bw + aw * bx + ay * bz - az * by;
	output[1] = ay * bw + aw * by + az * bx - ax * bz;
	output[2] = az * bw + aw * bz + ax * by - ay * bx;
	output[3] = aw * bw - ax * bx - ay * by - az * bz;
	return output;
}

float const *Quat_Normalize(float *output, float const *a)
{
	return Vec4_Normalize(output, a);
}

float const *Quat_RotateX(float *output, float const *a, float rad)
{
	float ax;
	float ay;
	float az;
	float aw;
	float bx;
	float bw;
	rad /= 2;
	ax = a[0];
	ay = a[1];
	az = a[2];
	aw = a[3];
	bx = Platform_Sin(rad);
	bw = Platform_Cos(rad);
	output[0] = ax * bw + aw * bx;
	output[1] = ay * bw + az * bx;
	output[2] = az * bw - ay * bx;
	output[3] = aw * bw - ax * bx;
	return output;
}

float const *Quat_RotateY(float *output, float const *a, float rad)
{
	float ax;
	float ay;
	float az;
	float aw;
	float by;
	float bw;
	rad /= 2;
	ax = a[0];
	ay = a[1];
	az = a[2];
	aw = a[3];
	by = Platform_Sin(rad);
	bw = Platform_Cos(rad);
	output[0] = ax * bw - az * by;
	output[1] = ay * bw + aw * by;
	output[2] = az * bw + ax * by;
	output[3] = aw * bw - ay * by;
	return output;
}

float const *Quat_RotateZ(float *output, float const *a, float rad)
{
	float ax;
	float ay;
	float az;
	float aw;
	float bz;
	float bw;
	rad /= 2;
	ax = a[0];
	ay = a[1];
	az = a[2];
	aw = a[3];
	bz = Platform_Sin(rad);
	bw = Platform_Cos(rad);
	output[0] = ax * bw + ay * bz;
	output[1] = ay * bw - ax * bz;
	output[2] = az * bw + aw * bz;
	output[3] = aw * bw - az * bz;
	return output;
}

float const *Quat_RotationTo(float *output, float const *a, float const *b)
{
	float *tmpvec3 = Vec3_Create();
	float const *xUnitVec3 = Vec3_FromValues(1, 0, 0);
	float const *yUnitVec3 = Vec3_FromValues(0, 1, 0);
	float dot = Vec3_Dot(a, b);
	float nines = 999999;
	float epsilon;
	nines /= 1000000;
	epsilon = 1;
	epsilon /= 1000000;
	if (dot < -nines) {
		Vec3_Cross(tmpvec3, xUnitVec3, a);
		if (Vec3_Length_(tmpvec3) < epsilon)
			Vec3_Cross(tmpvec3, yUnitVec3, a);
		Vec3_Normalize(tmpvec3, tmpvec3);
		Quat_SetAxisAngle(output, tmpvec3, GlMatrixMath_PI());
		return output;
	}
	else if (dot > nines) {
		output[0] = 0;
		output[1] = 0;
		output[2] = 0;
		output[3] = 1;
		return output;
	}
	else {
		Vec3_Cross(tmpvec3, a, b);
		output[0] = tmpvec3[0];
		output[1] = tmpvec3[1];
		output[2] = tmpvec3[2];
		output[3] = 1 + dot;
		return Quat_Normalize(output, output);
	}
}

float const *Quat_Scale(float *output, float const *a, float b)
{
	return Vec4_Scale(output, a, b);
}

float const *Quat_Set(float *output, float x, float y, float z, float w)
{
	return Vec4_Set(output, x, y, z, w);
}

float const *Quat_SetAxes(float *output, float const *view, float const *right, float const *up)
{
	float *matr = Mat3_Create();
	matr[0] = right[0];
	matr[3] = right[1];
	matr[6] = right[2];
	matr[1] = up[0];
	matr[4] = up[1];
	matr[7] = up[2];
	matr[2] = view[0];
	matr[5] = view[1];
	matr[8] = view[2];
	return Quat_Normalize(output, Quat_FromMat3(output, matr));
}

float const *Quat_SetAxisAngle(float *output, float const *axis, float rad)
{
	float s;
	rad = rad / 2;
	s = Platform_Sin(rad);
	output[0] = s * axis[0];
	output[1] = s * axis[1];
	output[2] = s * axis[2];
	output[3] = Platform_Cos(rad);
	return output;
}

float const *Quat_Slerp(float *output, float const *a, float const *b, float t)
{
	float ax = a[0];
	float ay = a[1];
	float az = a[2];
	float aw = a[3];
	float bx = b[0];
	float by = b[1];
	float bz = b[2];
	float bw = b[3];
	float omega;
	float cosom;
	float sinom;
	float scale0;
	float scale1;
	float one;
	float epsilon;
	cosom = ax * bx + ay * by + az * bz + aw * bw;
	if (cosom < 0) {
		cosom = -cosom;
		bx = -bx;
		by = -by;
		bz = -bz;
		bw = -bw;
	}
	one = 1;
	epsilon = one / 1000000;
	if (one - cosom > epsilon) {
		omega = Platform_Acos(cosom);
		sinom = Platform_Sin(omega);
		scale0 = Platform_Sin((one - t) * omega) / sinom;
		scale1 = Platform_Sin(t * omega) / sinom;
	}
	else {
		scale0 = one - t;
		scale1 = t;
	}
	output[0] = scale0 * ax + scale1 * bx;
	output[1] = scale0 * ay + scale1 * by;
	output[2] = scale0 * az + scale1 * bz;
	output[3] = scale0 * aw + scale1 * bw;
	return output;
}

float Quat_SqrLen(float const *a)
{
	return Quat_SquaredLength(a);
}

float Quat_SquaredLength(float const *a)
{
	return Vec4_SquaredLength(a);
}

static void QueryClient_Construct(QueryClient *self)
{
	self->result = QueryResult_New();
	self->querySuccess = FALSE;
	self->queryPerformed = FALSE;
}

QueryClient *QueryClient_New(void)
{
	QueryClient *self = (QueryClient *) malloc(sizeof(QueryClient));
	if (self != NULL)
		QueryClient_Construct(self);
	return self;
}

void QueryClient_Delete(QueryClient *self)
{
	free(self);
}

QueryResult const *QueryClient_GetResult(QueryClient const *self)
{
	return self->result;
}

const char *QueryClient_GetServerMessage(QueryClient const *self)
{
	return self->serverMessage;
}

void QueryClient_PerformQuery(QueryClient *self, const char *ip, int port)
{
	NetClient const *client;
	self->serverMessage = "";
	if (self->p->vtbl->enetAvailable(self->p)) {
		EnetNetClient *c = EnetNetClient_New();
		EnetNetClient_SetPlatform(c, self->p);
		client = &c->base;
	}
	else {
		TcpNetClient *c = TcpNetClient_New();
		TcpNetClient_SetPlatform(c, self->p);
		client = &c->base;
	}
	client->vtbl->start(client);
	client->vtbl->connect(client, ip, port);
	QueryClient_SendRequest(self, client);
	QueryClient_ReadPacket(self, client);
	self->queryPerformed = TRUE;
}

static void QueryClient_ReadPacket(QueryClient *self, NetClient const *client)
{
	cibool success = FALSE;
	int started = self->p->vtbl->timeMillisecondsFromStart(self->p);
	int timeout = 2000;
	while (self->p->vtbl->timeMillisecondsFromStart(self->p) < started + timeout) {
		NetIncomingMessage const *msg;
		Packet_Server *packet;
		if (success) {
			self->querySuccess = TRUE;
			return;
		}
		msg = client->vtbl->readMessage(client);
		if (msg == NULL) {
			continue;
		}
		packet = Packet_Server_New();
		Packet_ServerSerializer_DeserializeBuffer(msg->message, msg->messageLength, packet);
		switch (packet->id) {
		case 64:
			self->result->name = packet->queryAnswer->name;
			self->result->mOTD = packet->queryAnswer->mOTD;
			self->result->playerCount = packet->queryAnswer->playerCount;
			self->result->maxPlayers = packet->queryAnswer->maxPlayers;
			self->result->playerList = packet->queryAnswer->playerList;
			self->result->port = packet->queryAnswer->port;
			self->result->gameMode = packet->queryAnswer->gameMode;
			self->result->password = packet->queryAnswer->password;
			self->result->publicHash = packet->queryAnswer->publicHash;
			self->result->serverVersion = packet->queryAnswer->serverVersion;
			self->result->mapSizeX = packet->queryAnswer->mapSizeX;
			self->result->mapSizeY = packet->queryAnswer->mapSizeY;
			self->result->mapSizeZ = packet->queryAnswer->mapSizeZ;
			self->result->serverThumbnail = packet->queryAnswer->serverThumbnail;
			success = TRUE;
			continue;
		case 14:
			self->serverMessage = packet->disconnectPlayer->disconnectReason;
			return;
		default:
			continue;
		}
	}
	self->serverMessage = "Timeout while querying server!";
}

static void QueryClient_SendRequest(QueryClient const *self, NetClient const *client)
{
	Packet_Client const *pp = ClientPackets_ServerQuery();
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	unsigned char const *data;
	INetOutgoingMessage *msg;
	Packet_ClientSerializer_Serialize(&ms->base, pp);
	data = CitoMemoryStream_ToArray(ms);
	msg = INetOutgoingMessage_New();
	INetOutgoingMessage_Write(msg, data, CitoMemoryStream_Length(ms));
	client->vtbl->sendMessage(client, msg, MyNetDeliveryMethod_RELIABLE_ORDERED);
}

void QueryClient_SetPlatform(QueryClient *self, GamePlatform const *p_)
{
	self->p = p_;
}

QueryResult *QueryResult_New(void)
{
	QueryResult *self = (QueryResult *) malloc(sizeof(QueryResult));
	return self;
}

void QueryResult_Delete(QueryResult *self)
{
	free(self);
}

static void QueueAction_Construct(QueueAction *self)
{
	QueueAction_Start(self, 128);
}

QueueAction *QueueAction_New(void)
{
	QueueAction *self = (QueueAction *) malloc(sizeof(QueueAction));
	if (self != NULL)
		QueueAction_Construct(self);
	return self;
}

void QueueAction_Delete(QueueAction *self)
{
	free(self);
}

int QueueAction_Count(QueueAction const *self)
{
	return self->count;
}

QueueAction const *QueueAction_Create(int max_)
{
	QueueAction *queue = QueueAction_New();
	QueueAction_Start(queue, max_);
	return queue;
}

Action_ const *QueueAction_Dequeue(QueueAction *self)
{
	Action_ const *ret = self->items[self->start];
	self->items[self->start] = NULL;
	self->start++;
	self->start = self->start % self->max;
	self->count--;
	return ret;
}

void QueueAction_Enqueue(QueueAction *self, Action_ const *value)
{
	int pos;
	if (self->count == self->max) {
		QueueAction_Resize(self, self->max * 2);
	}
	pos = self->start + self->count;
	pos = pos % self->max;
	self->count++;
	self->items[pos] = value;
}

static void QueueAction_Resize(QueueAction *self, int newSize)
{
	Action_ const **items2 = (Action_ const **) malloc(newSize * sizeof(Action_ const *));
	{
		int i;
		for (i = 0; i < self->max; i++) {
			items2[i] = self->items[(self->start + i) % self->max];
		}
	}
	self->items = items2;
	self->start = 0;
	self->max = newSize;
}

static void QueueAction_Start(QueueAction *self, int max_)
{
	self->max = max_;
	self->items = (Action_ const **) malloc(max_ * sizeof(Action_ const *));
	self->count = 0;
}

static void QueueByte_Construct(QueueByte *self)
{
	self->max = 5242880;
	self->items = (unsigned char *) malloc(self->max * sizeof(unsigned char ));
}

QueueByte *QueueByte_New(void)
{
	QueueByte *self = (QueueByte *) malloc(sizeof(QueueByte));
	if (self != NULL)
		QueueByte_Construct(self);
	return self;
}

void QueueByte_Delete(QueueByte *self)
{
	free(self);
}

unsigned char QueueByte_Dequeue(QueueByte *self)
{
	unsigned char ret = self->items[self->start];
	self->start++;
	self->start = self->start % self->max;
	self->count--;
	return ret;
}

void QueueByte_DequeueRange(QueueByte *self, unsigned char *data, int length)
{
	{
		int i;
		for (i = 0; i < length; i++) {
			data[i] = QueueByte_Dequeue(self);
		}
	}
}

void QueueByte_Enqueue(QueueByte *self, unsigned char value)
{
	int pos = self->start + self->count;
	pos = pos % self->max;
	self->count++;
	self->items[pos] = value;
}

int QueueByte_GetCount(QueueByte const *self)
{
	return self->count;
}

static void QueueByte_PeekRange(QueueByte const *self, unsigned char *data, int length)
{
	{
		int i;
		for (i = 0; i < length; i++) {
			data[i] = self->items[(self->start + i) % self->max];
		}
	}
}

static void QueueByteArray_Construct(QueueByteArray *self)
{
	self->items = (ByteArray const **) malloc(1 * sizeof(ByteArray const *));
	self->itemsSize = 1;
	self->count = 0;
}

QueueByteArray *QueueByteArray_New(void)
{
	QueueByteArray *self = (QueueByteArray *) malloc(sizeof(QueueByteArray));
	if (self != NULL)
		QueueByteArray_Construct(self);
	return self;
}

void QueueByteArray_Delete(QueueByteArray *self)
{
	free(self);
}

static int QueueByteArray_Count(QueueByteArray const *self)
{
	return self->count;
}

static ByteArray const *QueueByteArray_Dequeue(QueueByteArray *self)
{
	ByteArray const *ret = self->items[0];
	{
		int i;
		for (i = 0; i < self->count - 1; i++) {
			self->items[i] = self->items[i + 1];
		}
	}
	self->count--;
	return ret;
}

static void QueueByteArray_Enqueue(QueueByteArray *self, ByteArray const *p)
{
	if (self->count == self->itemsSize) {
		ByteArray const **items2 = (ByteArray const **) malloc(self->itemsSize * 2 * sizeof(ByteArray const *));
		{
			int i;
			for (i = 0; i < self->itemsSize; i++) {
				items2[i] = self->items[i];
			}
		}
		self->itemsSize = self->itemsSize * 2;
		self->items = items2;
	}
	self->items[self->count++] = p;
}

static void QueueINetOutgoingMessage_Construct(QueueINetOutgoingMessage *self)
{
	self->items = (INetOutgoingMessage const **) malloc(1 * sizeof(INetOutgoingMessage const *));
	self->itemsSize = 1;
	self->count = 0;
}

QueueINetOutgoingMessage *QueueINetOutgoingMessage_New(void)
{
	QueueINetOutgoingMessage *self = (QueueINetOutgoingMessage *) malloc(sizeof(QueueINetOutgoingMessage));
	if (self != NULL)
		QueueINetOutgoingMessage_Construct(self);
	return self;
}

void QueueINetOutgoingMessage_Delete(QueueINetOutgoingMessage *self)
{
	free(self);
}

static int QueueINetOutgoingMessage_Count(QueueINetOutgoingMessage const *self)
{
	return self->count;
}

static INetOutgoingMessage const *QueueINetOutgoingMessage_Dequeue(QueueINetOutgoingMessage *self)
{
	INetOutgoingMessage const *ret = self->items[0];
	{
		int i;
		for (i = 0; i < self->count - 1; i++) {
			self->items[i] = self->items[i + 1];
		}
	}
	self->count--;
	return ret;
}

static void QueueINetOutgoingMessage_Enqueue(QueueINetOutgoingMessage *self, INetOutgoingMessage const *p)
{
	if (self->count == self->itemsSize) {
		INetOutgoingMessage const **items2 = (INetOutgoingMessage const **) malloc(self->itemsSize * 2 * sizeof(INetOutgoingMessage const *));
		{
			int i;
			for (i = 0; i < self->itemsSize; i++) {
				items2[i] = self->items[i];
			}
		}
		self->itemsSize = self->itemsSize * 2;
		self->items = items2;
	}
	self->items[self->count++] = p;
}

static void QueueNetIncomingMessage_Construct(QueueNetIncomingMessage *self)
{
	self->items = (NetIncomingMessage const **) malloc(1 * sizeof(NetIncomingMessage const *));
	self->itemsSize = 1;
	self->count = 0;
}

QueueNetIncomingMessage *QueueNetIncomingMessage_New(void)
{
	QueueNetIncomingMessage *self = (QueueNetIncomingMessage *) malloc(sizeof(QueueNetIncomingMessage));
	if (self != NULL)
		QueueNetIncomingMessage_Construct(self);
	return self;
}

void QueueNetIncomingMessage_Delete(QueueNetIncomingMessage *self)
{
	free(self);
}

static int QueueNetIncomingMessage_Count(QueueNetIncomingMessage const *self)
{
	return self->count;
}

static NetIncomingMessage const *QueueNetIncomingMessage_Dequeue(QueueNetIncomingMessage *self)
{
	NetIncomingMessage const *ret = self->items[0];
	{
		int i;
		for (i = 0; i < self->count - 1; i++) {
			self->items[i] = self->items[i + 1];
		}
	}
	self->count--;
	return ret;
}

static void QueueNetIncomingMessage_Enqueue(QueueNetIncomingMessage *self, NetIncomingMessage const *p)
{
	if (self->count == self->itemsSize) {
		NetIncomingMessage const **items2 = (NetIncomingMessage const **) malloc(self->itemsSize * 2 * sizeof(NetIncomingMessage const *));
		{
			int i;
			for (i = 0; i < self->itemsSize; i++) {
				items2[i] = self->items[i];
			}
		}
		self->itemsSize = self->itemsSize * 2;
		self->items = items2;
	}
	self->items[self->count++] = p;
}

RailMapUtil *RailMapUtil_New(void)
{
	RailMapUtil *self = (RailMapUtil *) malloc(sizeof(RailMapUtil));
	return self;
}

void RailMapUtil_Delete(RailMapUtil *self)
{
	free(self);
}

RailSlope RailMapUtil_GetRailSlope(RailMapUtil const *self, int x, int y, int z)
{
	int tiletype = Map_GetBlock(self->game->map, x, y, z);
	int railDirectionFlags = self->game->blocktypes[tiletype]->rail;
	int blocknear;
	if (x < self->game->map->mapSizeX - 1) {
		blocknear = Map_GetBlock(self->game->map, x + 1, y, z);
		if (railDirectionFlags == 1 && blocknear != 0 && self->game->blocktypes[blocknear]->rail == 0) {
			return RailSlope_TWO_RIGHT_RAISED;
		}
	}
	if (x > 0) {
		blocknear = Map_GetBlock(self->game->map, x - 1, y, z);
		if (railDirectionFlags == 1 && blocknear != 0 && self->game->blocktypes[blocknear]->rail == 0) {
			return RailSlope_TWO_LEFT_RAISED;
		}
	}
	if (y > 0) {
		blocknear = Map_GetBlock(self->game->map, x, y - 1, z);
		if (railDirectionFlags == 2 && blocknear != 0 && self->game->blocktypes[blocknear]->rail == 0) {
			return RailSlope_TWO_UP_RAISED;
		}
	}
	if (y < self->game->map->mapSizeY - 1) {
		blocknear = Map_GetBlock(self->game->map, x, y + 1, z);
		if (railDirectionFlags == 2 && blocknear != 0 && self->game->blocktypes[blocknear]->rail == 0) {
			return RailSlope_TWO_DOWN_RAISED;
		}
	}
	return RailSlope_FLAT;
}

static void RandomCi_Construct(RandomCi *self, const RandomCiVtbl *vtbl)
{
	self->vtbl = vtbl;
}

RectFRef *RectFRef_New(void)
{
	RectFRef *self = (RectFRef *) malloc(sizeof(RectFRef));
	return self;
}

void RectFRef_Delete(RectFRef *self)
{
	free(self);
}

static float RectFRef_Bottom(RectFRef const *self)
{
	return self->y + self->h;
}

RectFRef *RectFRef_Create(float x_, float y_, float w_, float h_)
{
	RectFRef *r = RectFRef_New();
	r->x = x_;
	r->y = y_;
	r->w = w_;
	r->h = h_;
	return r;
}

static float RectFRef_Left(RectFRef const *self)
{
	return self->x;
}

static float RectFRef_Right(RectFRef const *self)
{
	return self->x + self->w;
}

static float RectFRef_Top(RectFRef const *self)
{
	return self->y;
}

RectangleFloat *RectangleFloat_New(void)
{
	RectangleFloat *self = (RectangleFloat *) malloc(sizeof(RectangleFloat));
	return self;
}

void RectangleFloat_Delete(RectangleFloat *self)
{
	free(self);
}

float RectangleFloat_Bottom(RectangleFloat const *self)
{
	return self->y + self->height;
}

RectangleFloat const *RectangleFloat_Create(float x_, float y_, float width_, float height_)
{
	RectangleFloat *r = RectangleFloat_New();
	r->x = x_;
	r->y = y_;
	r->width = width_;
	r->height = height_;
	return r;
}

static void RenderedChunk_Construct(RenderedChunk *self)
{
	self->dirty = TRUE;
}

RenderedChunk *RenderedChunk_New(void)
{
	RenderedChunk *self = (RenderedChunk *) malloc(sizeof(RenderedChunk));
	if (self != NULL)
		RenderedChunk_Construct(self);
	return self;
}

void RenderedChunk_Delete(RenderedChunk *self)
{
	free(self);
}

static void Screen_Construct(Screen *self, const ScreenVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_Screen;
	self->vtbl = vtbl;
	self->widgetCount = 64;
	self->widgets = (MenuWidget const **) malloc(self->widgetCount * sizeof(MenuWidget const *));
}

Screen *Screen_New(void)
{
	Screen *self = (Screen *) malloc(sizeof(Screen));
	if (self != NULL)
		Screen_Construct(self, NULL);
	return self;
}

void Screen_Delete(Screen *self)
{
	free(self);
}

static void Screen_AllLoseFocus(Screen const *self)
{
	{
		int i;
		for (i = 0; i < self->widgetCount; i++) {
			MenuWidget *w = self->widgets[i];
			if (w != NULL) {
				MenuWidget_LoseFocus(w);
			}
		}
	}
}

void Screen_DrawWidgets(Screen const *self)
{
	{
		int i;
		for (i = 0; i < self->widgetCount; i++) {
			MenuWidget const *w = self->widgets[i];
			if (w != NULL) {
				const char *text;
				if (!w->visible) {
					continue;
				}
				text = w->text;
				if (w->selected) {
					text = StringTools_StringAppend(self->menu->p, "&2", text);
				}
				if (w->type == WidgetType_BUTTON) {
					if (w->buttonStyle == ButtonStyle_TEXT) {
						if (w->image != NULL) {
							MainMenu_Draw2dQuad(self->menu, MainMenu_GetTexture(self->menu, w->image), w->x, w->y, w->sizex, w->sizey);
						}
						MainMenu_DrawText(self->menu, text, w->fontSize, w->x, w->y + w->sizey / 2, TextAlign_LEFT, TextBaseline_MIDDLE);
					}
					else if (w->buttonStyle == ButtonStyle_BUTTON) {
						MainMenu_DrawButton(self->menu, text, w->fontSize, w->x, w->y, w->sizex, w->sizey, w->hover || w->hasKeyboardFocus);
						if (w->description != NULL) {
							MainMenu_DrawText(self->menu, w->description, w->fontSize, w->x, w->y + w->sizey / 2, TextAlign_RIGHT, TextBaseline_MIDDLE);
						}
					}
					else {
						const char **strings = self->menu->p->vtbl->stringSplit(self->menu->p, w->text, "\n", IntRef_New());
						if (w->selected) {
							strings[0] = StringTools_StringAppend(self->menu->p, "&2", strings[0]);
							strings[1] = StringTools_StringAppend(self->menu->p, "&2", strings[1]);
							strings[2] = StringTools_StringAppend(self->menu->p, "&2", strings[2]);
							strings[3] = StringTools_StringAppend(self->menu->p, "&2", strings[3]);
						}
						MainMenu_DrawServerButton(self->menu, strings[0], strings[1], strings[2], strings[3], w->x, w->y, w->sizex, w->sizey, w->image);
						if (w->description != NULL) {
							MainMenu_Draw2dQuad(self->menu, MainMenu_GetTexture(self->menu, "serverlist_entry_noresponse.png"), w->x - 38 * MainMenu_GetScale(self->menu), w->y, w->sizey / 2, w->sizey / 2);
						}
						if (strcmp(strings[4], self->menu->p->vtbl->getGameVersion(self->menu->p)) != 0) {
							MainMenu_Draw2dQuad(self->menu, MainMenu_GetTexture(self->menu, "serverlist_entry_differentversion.png"), w->x - 38 * MainMenu_GetScale(self->menu), w->y + w->sizey / 2, w->sizey / 2, w->sizey / 2);
						}
					}
				}
				if (w->type == WidgetType_TEXTBOX) {
					if (w->password) {
						text = MainMenu_CharRepeat(self->menu, 42, MainMenu_StringLength(self->menu, w->text));
					}
					if (w->editing) {
						text = StringTools_StringAppend(self->menu->p, text, "_");
					}
					if (w->buttonStyle == ButtonStyle_TEXT) {
						if (w->image != NULL) {
							MainMenu_Draw2dQuad(self->menu, MainMenu_GetTexture(self->menu, w->image), w->x, w->y, w->sizex, w->sizey);
						}
						MainMenu_DrawText(self->menu, text, w->fontSize, w->x, w->y, TextAlign_LEFT, TextBaseline_TOP);
					}
					else {
						MainMenu_DrawButton(self->menu, text, w->fontSize, w->x, w->y, w->sizex, w->sizey, w->hover || w->editing || w->hasKeyboardFocus);
					}
					if (w->description != NULL) {
						MainMenu_DrawText(self->menu, w->description, w->fontSize, w->x, w->y + w->sizey / 2, TextAlign_RIGHT, TextBaseline_MIDDLE);
					}
				}
			}
		}
	}
}

static void Screen_KeyDown(Screen const *self, KeyEventArgs const *e)
{
	{
		int i;
		for (i = 0; i < self->widgetCount; i++) {
			MenuWidget *w = self->widgets[i];
			if (w == NULL) {
				continue;
			}
			if (w->hasKeyboardFocus) {
				if (KeyEventArgs_GetKeyCode(e) == 52 || KeyEventArgs_GetKeyCode(e) == 49) {
					if (w->type == WidgetType_BUTTON && KeyEventArgs_GetKeyCode(e) == 49) {
						self->vtbl->onButton(self, w);
						return;
					}
					if (w->nextWidget != -1) {
						MenuWidget_LoseFocus(w);
						MenuWidget_GetFocus(self->widgets[w->nextWidget]);
						return;
					}
				}
			}
			if (w->type == WidgetType_TEXTBOX) {
				if (w->editing) {
					int key = KeyEventArgs_GetKeyCode(e);
					if (KeyEventArgs_GetCtrlPressed(e) && key == 104) {
						if (self->menu->p->vtbl->clipboardContainsText(self->menu->p)) {
							w->text = StringTools_StringAppend(self->menu->p, w->text, self->menu->p->vtbl->clipboardGetText(self->menu->p));
						}
						return;
					}
					if (key == 53) {
						if (MainMenu_StringLength(self->menu, w->text) > 0) {
							w->text = StringTools_StringSubstring(self->menu->p, w->text, 0, MainMenu_StringLength(self->menu, w->text) - 1);
						}
						return;
					}
				}
			}
		}
	}
}

static void Screen_KeyPress(Screen const *self, KeyPressEventArgs const *e)
{
	{
		int i;
		for (i = 0; i < self->widgetCount; i++) {
			MenuWidget *w = self->widgets[i];
			if (w != NULL) {
				if (w->type == WidgetType_TEXTBOX) {
					if (w->editing) {
						if (self->menu->p->vtbl->isValidTypingChar(self->menu->p, KeyPressEventArgs_GetKeyChar(e))) {
							w->text = StringTools_StringAppend(self->menu->p, w->text, MainMenu_CharToString(self->menu, KeyPressEventArgs_GetKeyChar(e)));
						}
					}
				}
			}
		}
	}
}

void Screen_LoadTranslations(Screen const *self)
{
}

static void Screen_MouseDown(Screen const *self, int x, int y)
{
	cibool editingChange = FALSE;
	{
		int i;
		for (i = 0; i < self->widgetCount; i++) {
			MenuWidget *w = self->widgets[i];
			if (w != NULL) {
				if (w->type == WidgetType_BUTTON) {
					w->pressed = Screen_pointInRect(self, x, y, w->x, w->y, w->sizex, w->sizey);
				}
				if (w->type == WidgetType_TEXTBOX) {
					cibool wasEditing;
					w->pressed = Screen_pointInRect(self, x, y, w->x, w->y, w->sizex, w->sizey);
					wasEditing = w->editing;
					w->editing = w->pressed;
					if (w->editing && !wasEditing) {
						self->menu->p->vtbl->showKeyboard(self->menu->p, TRUE);
						editingChange = TRUE;
					}
					if (!w->editing && wasEditing && !editingChange) {
						self->menu->p->vtbl->showKeyboard(self->menu->p, FALSE);
					}
				}
				if (w->pressed) {
					Screen_AllLoseFocus(self);
					MenuWidget_GetFocus(w);
				}
			}
		}
	}
}

static void Screen_MouseMove(Screen const *self, MouseEventArgs const *e)
{
	if (MouseEventArgs_GetEmulated(e) && !MouseEventArgs_GetForceUsage(e)) {
		return;
	}
	{
		int i;
		for (i = 0; i < self->widgetCount; i++) {
			MenuWidget *w = self->widgets[i];
			if (w != NULL) {
				w->hover = Screen_pointInRect(self, MouseEventArgs_GetX(e), MouseEventArgs_GetY(e), w->x, w->y, w->sizex, w->sizey);
			}
		}
	}
}

static void Screen_MouseUp(Screen const *self, int x, int y)
{
	{
		int i;
		for (i = 0; i < self->widgetCount; i++) {
			MenuWidget *w = self->widgets[i];
			if (w != NULL) {
				w->pressed = FALSE;
			}
		}
	}
	{
		int i;
		for (i = 0; i < self->widgetCount; i++) {
			MenuWidget const *w = self->widgets[i];
			if (w != NULL) {
				if (w->type == WidgetType_BUTTON) {
					if (Screen_pointInRect(self, x, y, w->x, w->y, w->sizex, w->sizey)) {
						self->vtbl->onButton(self, w);
					}
				}
			}
		}
	}
}

void Screen_OnBackPressed(Screen const *self)
{
}

void Screen_OnButton(Screen const *self, MenuWidget const *w)
{
}

void Screen_OnKeyDown(Screen const *self, KeyEventArgs const *e)
{
	Screen_KeyDown(self, e);
}

void Screen_OnKeyPress(Screen const *self, KeyPressEventArgs const *e)
{
	Screen_KeyPress(self, e);
}

void Screen_OnKeyUp(Screen const *self, KeyEventArgs const *e)
{
}

void Screen_OnMouseDown(Screen const *self, MouseEventArgs const *e)
{
	Screen_MouseDown(self, MouseEventArgs_GetX(e), MouseEventArgs_GetY(e));
}

void Screen_OnMouseMove(Screen const *self, MouseEventArgs const *e)
{
	Screen_MouseMove(self, e);
}

void Screen_OnMouseUp(Screen const *self, MouseEventArgs const *e)
{
	Screen_MouseUp(self, MouseEventArgs_GetX(e), MouseEventArgs_GetY(e));
}

void Screen_OnMouseWheel(Screen const *self, MouseWheelEventArgs const *e)
{
}

void Screen_OnTouchEnd(Screen const *self, TouchEventArgs const *e)
{
	Screen_MouseUp(self, TouchEventArgs_GetX(e), TouchEventArgs_GetY(e));
}

void Screen_OnTouchMove(Screen const *self, TouchEventArgs const *e)
{
}

void Screen_OnTouchStart(Screen const *self, TouchEventArgs const *e)
{
	Screen_MouseDown(self, TouchEventArgs_GetX(e), TouchEventArgs_GetY(e));
}

void Screen_Render(Screen const *self, float dt)
{
}

static cibool Screen_pointInRect(Screen const *self, float x, float y, float rx, float ry, float rw, float rh)
{
	return x >= rx && y >= ry && x < rx + rw && y < ry + rh;
}

static void ScreenConnectToIp_Construct(ScreenConnectToIp *self, const ScreenVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ScreenConnectToIp;
	Screen_Construct(&self->base, vtbl);
	self->buttonConnect = MenuWidget_New();
	self->buttonConnect->text = "Connect";
	self->buttonConnect->type = WidgetType_BUTTON;
	self->buttonConnect->nextWidget = 3;
	self->textboxIp = MenuWidget_New();
	self->textboxIp->type = WidgetType_TEXTBOX;
	self->textboxIp->text = "";
	self->textboxIp->description = "Ip";
	self->textboxIp->nextWidget = 2;
	self->textboxPort = MenuWidget_New();
	self->textboxPort->type = WidgetType_TEXTBOX;
	self->textboxPort->text = "";
	self->textboxPort->description = "Port";
	self->textboxPort->nextWidget = 0;
	self->back = MenuWidget_New();
	self->back->text = "Back";
	self->back->type = WidgetType_BUTTON;
	self->back->nextWidget = 1;
	self->title = "Connect to IP";
	self->base.widgets[0] = self->buttonConnect;
	self->base.widgets[1] = self->textboxIp;
	self->base.widgets[2] = self->textboxPort;
	self->base.widgets[3] = self->back;
	MenuWidget_GetFocus(self->textboxIp);
}

ScreenConnectToIp *ScreenConnectToIp_New(void)
{
	ScreenConnectToIp *self = (ScreenConnectToIp *) malloc(sizeof(ScreenConnectToIp));
	if (self != NULL)
		ScreenConnectToIp_Construct(self, NULL);
	return self;
}

void ScreenConnectToIp_Delete(ScreenConnectToIp *self)
{
	free(self);
}

void ScreenConnectToIp_LoadTranslations(ScreenConnectToIp *self)
{
	self->buttonConnect->text = Language_Get(self->base.menu->lang, "MainMenu_ConnectToIpConnect");
	self->textboxIp->description = Language_Get(self->base.menu->lang, "MainMenu_ConnectToIpIp");
	self->textboxPort->description = Language_Get(self->base.menu->lang, "MainMenu_ConnectToIpPort");
	self->title = Language_Get(self->base.menu->lang, "MainMenu_MultiplayerConnectIP");
}

void ScreenConnectToIp_OnBackPressed(ScreenConnectToIp const *self)
{
	MainMenu_StartMultiplayer(self->base.menu);
}

void ScreenConnectToIp_OnButton(ScreenConnectToIp const *self, MenuWidget const *w)
{
	if (w == self->buttonConnect) {
		FloatRef const *ret = FloatRef_New();
		if (!Game_StringEquals(self->textboxIp->text, "") && self->base.menu->p->vtbl->floatTryParse(self->base.menu->p, self->textboxPort->text, ret)) {
			MainMenu_StartLogin(self->base.menu, NULL, self->textboxIp->text, self->base.menu->p->vtbl->intParse(self->base.menu->p, self->textboxPort->text));
		}
	}
	if (w == self->back) {
		self->base.vtbl->onBackPressed(&self->base);
	}
}

void ScreenConnectToIp_Render(ScreenConnectToIp *self, float dt)
{
	GamePlatform const *p;
	float scale;
	float leftx;
	float y;
	const char *loginResultText;
	if (!self->loaded) {
		self->preferences_ip = Preferences_GetString(self->base.menu->p->vtbl->getPreferences(self->base.menu->p), "ConnectToIpIp", "127.0.0.1");
		self->preferences_port = Preferences_GetString(self->base.menu->p->vtbl->getPreferences(self->base.menu->p), "ConnectToIpPort", "25565");
		self->textboxIp->text = self->preferences_ip;
		self->textboxPort->text = self->preferences_port;
		self->loaded = TRUE;
	}
	if (strcmp(self->textboxIp->text, self->preferences_ip) != 0 || strcmp(self->textboxPort->text, self->preferences_port) != 0) {
		Preferences const *preferences;
		self->preferences_ip = self->textboxIp->text;
		self->preferences_port = self->textboxPort->text;
		preferences = self->base.menu->p->vtbl->getPreferences(self->base.menu->p);
		Preferences_SetString(preferences, "ConnectToIpIp", self->preferences_ip);
		Preferences_SetString(preferences, "ConnectToIpPort", self->preferences_port);
		self->base.menu->p->vtbl->setPreferences(self->base.menu->p, preferences);
	}
	p = self->base.menu->p;
	scale = MainMenu_GetScale(self->base.menu);
	MainMenu_DrawBackground(self->base.menu);
	leftx = p->vtbl->getCanvasWidth(p) / 2 - 400 * scale;
	y = p->vtbl->getCanvasHeight(p) / 2 - 250 * scale;
	loginResultText = NULL;
	if (self->errorText != NULL) {
		MainMenu_DrawText(self->base.menu, loginResultText, 14 * scale, leftx, y - 50 * scale, TextAlign_LEFT, TextBaseline_TOP);
	}
	MainMenu_DrawText(self->base.menu, self->title, 14 * scale, leftx, y + 50 * scale, TextAlign_LEFT, TextBaseline_TOP);
	self->textboxIp->x = leftx;
	self->textboxIp->y = y + 100 * scale;
	self->textboxIp->sizex = 256 * scale;
	self->textboxIp->sizey = 64 * scale;
	self->textboxIp->fontSize = 14 * scale;
	self->textboxPort->x = leftx;
	self->textboxPort->y = y + 200 * scale;
	self->textboxPort->sizex = 256 * scale;
	self->textboxPort->sizey = 64 * scale;
	self->textboxPort->fontSize = 14 * scale;
	self->buttonConnect->x = leftx;
	self->buttonConnect->y = y + 400 * scale;
	self->buttonConnect->sizex = 256 * scale;
	self->buttonConnect->sizey = 64 * scale;
	self->buttonConnect->fontSize = 14 * scale;
	self->back->x = 40 * scale;
	self->back->y = p->vtbl->getCanvasHeight(p) - 104 * scale;
	self->back->sizex = 256 * scale;
	self->back->sizey = 64 * scale;
	self->back->fontSize = 14 * scale;
	Screen_DrawWidgets(&self->base);
}

static void ScreenGame_Construct(ScreenGame *self, const ScreenVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ScreenGame;
	Screen_Construct(&self->base, vtbl);
	self->game = Game_New();
}

ScreenGame *ScreenGame_New(void)
{
	ScreenGame *self = (ScreenGame *) malloc(sizeof(ScreenGame));
	if (self != NULL)
		ScreenGame_Construct(self, NULL);
	return self;
}

void ScreenGame_Delete(ScreenGame *self)
{
	free(self);
}

static void ScreenGame_Connect(ScreenGame *self, GamePlatform const *platform)
{
	if (self->singleplayer) {
		DummyNetClient *netclient;
		if (platform->vtbl->singlePlayerServerAvailable(platform)) {
			platform->vtbl->singlePlayerServerStart(platform, self->singleplayerSavePath);
		}
		else {
			DummyNetwork *network;
			DummyNetServer *server;
			self->serverSimple = ServerSimple_New();
			network = platform->vtbl->singlePlayerServerGetNetwork(platform);
			DummyNetwork_Start(network, platform->vtbl->monitorCreate(platform), platform->vtbl->monitorCreate(platform));
			server = DummyNetServer_New();
			server->network = network;
			server->platform = platform;
			server->base.vtbl->start(&server->base);
			ServerSimple_Start(self->serverSimple, &server->base, self->singleplayerSavePath, platform);
			self->serverSimpleMod = ModServerSimple_New();
			self->serverSimpleMod->server = self->serverSimple;
			Game_AddMod(self->game, &self->serverSimpleMod->base);
			QueueByteArray_Enqueue(platform->vtbl->singlePlayerServerGetNetwork(platform)->serverReceiveBuffer, ByteArray_New());
		}
		self->connectData = ConnectData_New();
		self->connectData->username = "Local";
		self->game->connectdata = self->connectData;
		netclient = DummyNetClient_New();
		DummyNetClient_SetPlatform(netclient, platform);
		DummyNetClient_SetNetwork(netclient, platform->vtbl->singlePlayerServerGetNetwork(platform));
		self->game->main = &netclient->base;
	}
	else {
		self->game->connectdata = self->connectData;
		if (platform->vtbl->enetAvailable(platform)) {
			EnetNetClient *client = EnetNetClient_New();
			EnetNetClient_SetPlatform(client, platform);
			self->game->main = &client->base;
		}
		else if (platform->vtbl->tcpAvailable(platform)) {
			TcpNetClient *client = TcpNetClient_New();
			TcpNetClient_SetPlatform(client, platform);
			self->game->main = &client->base;
		}
		else if (platform->vtbl->webSocketAvailable(platform)) {
			WebSocketClient *client = WebSocketClient_New();
			WebSocketClient_SetPlatform(client, platform);
			self->game->main = &client->base;
		}
		else {
			platform->vtbl->throwException(platform, "Network not implemented");
		}
	}
}

void ScreenGame_OnBackPressed(ScreenGame const *self)
{
	Game_OnBackPressed(self->game);
}

void ScreenGame_OnKeyDown(ScreenGame const *self, KeyEventArgs const *e)
{
	Game_KeyDown(self->game, KeyEventArgs_GetKeyCode(e));
}

void ScreenGame_OnKeyPress(ScreenGame const *self, KeyPressEventArgs const *e)
{
	Game_KeyPress(self->game, KeyPressEventArgs_GetKeyChar(e));
}

void ScreenGame_OnKeyUp(ScreenGame const *self, KeyEventArgs const *e)
{
	Game_KeyUp(self->game, KeyEventArgs_GetKeyCode(e));
}

void ScreenGame_OnMouseDown(ScreenGame const *self, MouseEventArgs const *e)
{
	if (!self->game->platform->vtbl->focused(self->game->platform)) {
		return;
	}
	Game_MouseDown(self->game, e);
}

void ScreenGame_OnMouseMove(ScreenGame const *self, MouseEventArgs const *e)
{
	if (!self->game->platform->vtbl->focused(self->game->platform)) {
		return;
	}
	Game_MouseMove(self->game, e);
}

void ScreenGame_OnMouseUp(ScreenGame const *self, MouseEventArgs const *e)
{
	if (!self->game->platform->vtbl->focused(self->game->platform)) {
		return;
	}
	Game_MouseUp(self->game, e);
}

void ScreenGame_OnMouseWheel(ScreenGame const *self, MouseWheelEventArgs const *e)
{
	Game_MouseWheelChanged(self->game, e);
}

void ScreenGame_OnTouchEnd(ScreenGame const *self, TouchEventArgs const *e)
{
	Game_OnTouchEnd(self->game, e);
}

void ScreenGame_OnTouchMove(ScreenGame const *self, TouchEventArgs const *e)
{
	Game_OnTouchMove(self->game, e);
}

void ScreenGame_OnTouchStart(ScreenGame const *self, TouchEventArgs const *e)
{
	Game_OnTouchStart(self->game, e);
}

void ScreenGame_Render(ScreenGame const *self, float dt)
{
	if (self->game->reconnect) {
		Game_Dispose(self->game);
		MainMenu_StartGame(self->base.menu, self->singleplayer, self->singleplayerSavePath, self->connectData);
		return;
	}
	if (self->game->exitToMainMenu) {
		Game_Dispose(self->game);
		if (Game_GetRedirect(self->game) != NULL) {
			QueryClient *qclient = QueryClient_New();
			QueryResult const *qresult;
			LoginClientCi *lic;
			LoginData *lidata;
			const char *token;
			QueryClient_SetPlatform(qclient, self->platform);
			QueryClient_PerformQuery(qclient, Packet_ServerRedirect_GetIP(Game_GetRedirect(self->game)), Packet_ServerRedirect_GetPort(Game_GetRedirect(self->game)));
			if (qclient->queryPerformed && !qclient->querySuccess) {
				self->platform->vtbl->messageBoxShowError(self->platform, QueryClient_GetServerMessage(qclient), "Redirection error");
				MainMenu_StartMainMenu(self->base.menu);
				return;
			}
			qresult = QueryClient_GetResult(qclient);
			lic = LoginClientCi_New();
			lidata = LoginData_New();
			token = self->platform->vtbl->stringSplit(self->platform, qresult->publicHash, "=", IntRef_New())[1];
			LoginClientCi_Login(lic, self->platform, self->connectData->username, "", token, Preferences_GetString(self->platform->vtbl->getPreferences(self->platform), "Password", ""), LoginResultRef_New(), lidata);
			while (lic->loginResult->value == LoginResult_CONNECTING) {
				LoginClientCi_Update(lic, self->platform);
			}
			if (!lidata->serverCorrect) {
				self->platform->vtbl->messageBoxShowError(self->platform, "Invalid server address!", "Redirection error!");
				MainMenu_StartMainMenu(self->base.menu);
			}
			else if (!lidata->passwordCorrect) {
				MainMenu_StartLogin(self->base.menu, token, NULL, 0);
			}
			else if (lidata->serverAddress != NULL && strcmp(lidata->serverAddress, "") != 0) {
				MainMenu_ConnectToGame(self->base.menu, lidata, self->connectData->username);
			}
		}
		else {
			MainMenu_StartMainMenu(self->base.menu);
		}
		return;
	}
	Game_OnRenderFrame(self->game, dt);
}

void ScreenGame_Start(ScreenGame *self, GamePlatform const *platform_, cibool singleplayer_, const char *singleplayerSavePath_, ConnectData *connectData_)
{
	self->platform = platform_;
	self->singleplayer = singleplayer_;
	self->singleplayerSavePath = singleplayerSavePath_;
	self->connectData = connectData_;
	self->game->platform = self->platform;
	self->game->issingleplayer = self->singleplayer;
	self->game->assets = self->base.menu->assets;
	self->game->assetsLoadProgress = self->base.menu->assetsLoadProgress;
	Game_Start(self->game);
	ScreenGame_Connect(self, self->platform);
}

static void ScreenLogin_Construct(ScreenLogin *self, const ScreenVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ScreenLogin;
	Screen_Construct(&self->base, vtbl);
	self->login = MenuWidget_New();
	self->login->text = "Login";
	self->login->type = WidgetType_BUTTON;
	self->login->nextWidget = 9;
	self->loginUsername = MenuWidget_New();
	self->loginUsername->type = WidgetType_TEXTBOX;
	self->loginUsername->text = "";
	self->loginUsername->description = "Username";
	self->loginUsername->nextWidget = 2;
	self->loginPassword = MenuWidget_New();
	self->loginPassword->type = WidgetType_TEXTBOX;
	self->loginPassword->text = "";
	self->loginPassword->description = "Password";
	self->loginPassword->password = TRUE;
	self->loginPassword->nextWidget = 3;
	self->loginRememberMe = MenuWidget_New();
	self->loginRememberMe->text = "Yes";
	self->loginRememberMe->type = WidgetType_BUTTON;
	self->loginRememberMe->description = "Remember me";
	self->loginRememberMe->nextWidget = 0;
	self->createAccount = MenuWidget_New();
	self->createAccount->text = "Create account";
	self->createAccount->type = WidgetType_BUTTON;
	self->createAccountUsername = MenuWidget_New();
	self->createAccountUsername->text = "";
	self->createAccountUsername->type = WidgetType_TEXTBOX;
	self->createAccountUsername->description = "Username";
	self->createAccountPassword = MenuWidget_New();
	self->createAccountPassword->text = "";
	self->createAccountPassword->type = WidgetType_TEXTBOX;
	self->createAccountPassword->description = "Password";
	self->createAccountPassword->password = TRUE;
	self->createAccountRememberMe = MenuWidget_New();
	self->createAccountRememberMe->text = "Yes";
	self->createAccountRememberMe->type = WidgetType_BUTTON;
	self->createAccountRememberMe->description = "Remember me";
	self->back = MenuWidget_New();
	self->back->text = "Back";
	self->back->type = WidgetType_BUTTON;
	self->back->nextWidget = 1;
	self->title = "Login";
	self->base.widgets[0] = self->login;
	self->base.widgets[1] = self->loginUsername;
	self->base.widgets[2] = self->loginPassword;
	self->base.widgets[3] = self->loginRememberMe;
	self->base.widgets[4] = self->createAccount;
	self->base.widgets[5] = self->createAccountUsername;
	self->base.widgets[6] = self->createAccountPassword;
	self->base.widgets[7] = self->createAccountRememberMe;
	self->base.widgets[9] = self->back;
	MenuWidget_GetFocus(self->loginUsername);
	self->loginResult = LoginResultRef_New();
}

ScreenLogin *ScreenLogin_New(void)
{
	ScreenLogin *self = (ScreenLogin *) malloc(sizeof(ScreenLogin));
	if (self != NULL)
		ScreenLogin_Construct(self, NULL);
	return self;
}

void ScreenLogin_Delete(ScreenLogin *self)
{
	free(self);
}

void ScreenLogin_LoadTranslations(ScreenLogin *self)
{
	self->login->text = Language_Get(self->base.menu->lang, "MainMenu_Login");
	self->loginUsername->description = Language_Get(self->base.menu->lang, "MainMenu_LoginUsername");
	self->loginPassword->description = Language_Get(self->base.menu->lang, "MainMenu_LoginPassword");
	self->loginRememberMe->text = Language_Get(self->base.menu->lang, "MainMenu_ChoiceYes");
	self->loginRememberMe->description = Language_Get(self->base.menu->lang, "MainMenu_LoginRemember");
	self->back->text = Language_Get(self->base.menu->lang, "MainMenu_ButtonBack");
	self->title = Language_Get(self->base.menu->lang, "MainMenu_Login");
}

void ScreenLogin_OnBackPressed(ScreenLogin const *self)
{
	MainMenu_StartMultiplayer(self->base.menu);
}

void ScreenLogin_OnButton(ScreenLogin *self, MenuWidget *w)
{
	if (w == self->login) {
		self->loginResultData = LoginData_New();
		if (self->serverHash != NULL) {
			MainMenu_Login(self->base.menu, self->loginUsername->text, self->loginPassword->text, self->serverHash, "", self->loginResult, self->loginResultData);
		}
		else {
			ConnectData *connectdata;
			if (strcmp(self->loginRememberMe->text, Language_Get(self->base.menu->lang, "MainMenu_ChoiceYes")) == 0) {
				Preferences const *preferences = self->base.menu->p->vtbl->getPreferences(self->base.menu->p);
				Preferences_SetString(preferences, "Username", self->loginUsername->text);
				self->base.menu->p->vtbl->setPreferences(self->base.menu->p, preferences);
			}
			connectdata = ConnectData_New();
			connectdata->ip = self->serverIp;
			connectdata->port = self->serverPort;
			connectdata->username = self->loginUsername->text;
			MainMenu_StartGame(self->base.menu, FALSE, NULL, connectdata);
		}
	}
	if (w == self->createAccount) {
		MainMenu_CreateAccount(self->base.menu, self->createAccountUsername->text, self->createAccountPassword->text, self->loginResult);
	}
	if (w == self->loginRememberMe || w == self->createAccountRememberMe) {
		if (strcmp(w->text, Language_Get(self->base.menu->lang, "MainMenu_ChoiceYes")) == 0) {
			w->text = Language_Get(self->base.menu->lang, "MainMenu_ChoiceNo");
		}
		else {
			w->text = Language_Get(self->base.menu->lang, "MainMenu_ChoiceYes");
		}
	}
	if (w == self->back) {
		self->base.vtbl->onBackPressed(&self->base);
	}
}

void ScreenLogin_Render(ScreenLogin *self, float dt)
{
	GamePlatform const *p;
	float scale;
	float leftx;
	float y;
	const char *loginResultText;
	float rightx;
	if (!self->triedSavedLogin) {
		Preferences const *preferences = self->base.menu->p->vtbl->getPreferences(self->base.menu->p);
		const char *token;
		self->loginUsername->text = Preferences_GetString(preferences, "Username", "");
		self->loginPassword->text = "";
		token = Preferences_GetString(preferences, "Password", "");
		self->loginResultData = LoginData_New();
		if (self->serverHash != NULL && strcmp(token, "") != 0) {
			MainMenu_Login(self->base.menu, self->loginUsername->text, self->loginPassword->text, self->serverHash, token, self->loginResult, self->loginResultData);
		}
		self->triedSavedLogin = TRUE;
	}
	if (self->loginResultData != NULL && self->loginResultData->serverCorrect && self->loginResultData->passwordCorrect) {
		if (strcmp(self->loginRememberMe->text, Language_Get(self->base.menu->lang, "MainMenu_ChoiceYes")) == 0) {
			Preferences const *preferences = self->base.menu->p->vtbl->getPreferences(self->base.menu->p);
			Preferences_SetString(preferences, "Username", self->loginUsername->text);
			if (self->loginResultData->token != NULL && strcmp(self->loginResultData->token, "") != 0) {
				Preferences_SetString(preferences, "Password", self->loginResultData->token);
			}
			self->base.menu->p->vtbl->setPreferences(self->base.menu->p, preferences);
		}
		MainMenu_ConnectToGame(self->base.menu, self->loginResultData, self->loginUsername->text);
	}
	p = self->base.menu->p;
	scale = MainMenu_GetScale(self->base.menu);
	MainMenu_DrawBackground(self->base.menu);
	leftx = p->vtbl->getCanvasWidth(p) / 2 - 400 * scale;
	y = p->vtbl->getCanvasHeight(p) / 2 - 250 * scale;
	loginResultText = NULL;
	if (self->loginResult->value == LoginResult_FAILED) {
		loginResultText = Language_Get(self->base.menu->lang, "MainMenu_LoginInvalid");
	}
	if (self->loginResult->value == LoginResult_CONNECTING) {
		loginResultText = Language_Get(self->base.menu->lang, "MainMenu_LoginConnecting");
	}
	if (loginResultText != NULL) {
		MainMenu_DrawText(self->base.menu, loginResultText, 14 * scale, leftx, y - 50 * scale, TextAlign_LEFT, TextBaseline_TOP);
	}
	MainMenu_DrawText(self->base.menu, self->title, 14 * scale, leftx, y + 50 * scale, TextAlign_LEFT, TextBaseline_TOP);
	self->loginUsername->x = leftx;
	self->loginUsername->y = y + 100 * scale;
	self->loginUsername->sizex = 256 * scale;
	self->loginUsername->sizey = 64 * scale;
	self->loginUsername->fontSize = 14 * scale;
	self->loginPassword->x = leftx;
	self->loginPassword->y = y + 200 * scale;
	self->loginPassword->sizex = 256 * scale;
	self->loginPassword->sizey = 64 * scale;
	self->loginPassword->fontSize = 14 * scale;
	self->loginRememberMe->x = leftx;
	self->loginRememberMe->y = y + 300 * scale;
	self->loginRememberMe->sizex = 256 * scale;
	self->loginRememberMe->sizey = 64 * scale;
	self->loginRememberMe->fontSize = 14 * scale;
	self->login->x = leftx;
	self->login->y = y + 400 * scale;
	self->login->sizex = 256 * scale;
	self->login->sizey = 64 * scale;
	self->login->fontSize = 14 * scale;
	rightx = p->vtbl->getCanvasWidth(p) / 2 + 150 * scale;
	self->createAccountUsername->x = rightx;
	self->createAccountUsername->y = y + 100 * scale;
	self->createAccountUsername->sizex = 256 * scale;
	self->createAccountUsername->sizey = 64 * scale;
	self->createAccountUsername->fontSize = 14 * scale;
	self->createAccountPassword->x = rightx;
	self->createAccountPassword->y = y + 200 * scale;
	self->createAccountPassword->sizex = 256 * scale;
	self->createAccountPassword->sizey = 64 * scale;
	self->createAccountPassword->fontSize = 14 * scale;
	self->createAccountRememberMe->x = rightx;
	self->createAccountRememberMe->y = y + 300 * scale;
	self->createAccountRememberMe->sizex = 256 * scale;
	self->createAccountRememberMe->sizey = 64 * scale;
	self->createAccountRememberMe->fontSize = 14 * scale;
	self->createAccount->x = rightx;
	self->createAccount->y = y + 400 * scale;
	self->createAccount->sizex = 256 * scale;
	self->createAccount->sizey = 64 * scale;
	self->createAccount->fontSize = 14 * scale;
	self->createAccountUsername->visible = FALSE;
	self->createAccountPassword->visible = FALSE;
	self->createAccountRememberMe->visible = FALSE;
	self->createAccount->visible = FALSE;
	self->back->x = 40 * scale;
	self->back->y = p->vtbl->getCanvasHeight(p) - 104 * scale;
	self->back->sizex = 256 * scale;
	self->back->sizey = 64 * scale;
	self->back->fontSize = 14 * scale;
	Screen_DrawWidgets(&self->base);
}

static void ScreenMain_Construct(ScreenMain *self, const ScreenVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ScreenMain;
	Screen_Construct(&self->base, vtbl);
	self->singleplayer = MenuWidget_New();
	self->multiplayer = MenuWidget_New();
	self->exit = MenuWidget_New();
	self->base.widgets[0] = self->singleplayer;
	self->base.widgets[1] = self->multiplayer;
	self->base.widgets[2] = self->exit;
	self->queryStringChecked = FALSE;
	self->cursorLoaded = FALSE;
}

ScreenMain *ScreenMain_New(void)
{
	ScreenMain *self = (ScreenMain *) malloc(sizeof(ScreenMain));
	if (self != NULL)
		ScreenMain_Construct(self, NULL);
	return self;
}

void ScreenMain_Delete(ScreenMain *self)
{
	free(self);
}

void ScreenMain_OnBackPressed(ScreenMain const *self)
{
	MainMenu_Exit(self->base.menu);
}

void ScreenMain_OnButton(ScreenMain const *self, MenuWidget const *w)
{
	if (w == self->singleplayer) {
		MainMenu_StartSingleplayer(self->base.menu);
	}
	if (w == self->multiplayer) {
		MainMenu_StartMultiplayer(self->base.menu);
	}
	if (w == self->exit) {
		MainMenu_Exit(self->base.menu);
	}
}

void ScreenMain_OnKeyDown(ScreenMain const *self, KeyEventArgs const *e)
{
	if (KeyEventArgs_GetKeyCode(e) == 14) {
		self->base.menu->p->vtbl->singlePlayerServerDisable(self->base.menu->p);
		MainMenu_StartGame(self->base.menu, TRUE, self->base.menu->p->vtbl->pathCombine(self->base.menu->p, self->base.menu->p->vtbl->pathSavegames(self->base.menu->p), "Default.mdss"), NULL);
	}
	if (KeyEventArgs_GetKeyCode(e) == 15) {
		MainMenu_StartGame(self->base.menu, TRUE, self->base.menu->p->vtbl->pathCombine(self->base.menu->p, self->base.menu->p->vtbl->pathSavegames(self->base.menu->p), "Default.mddbs"), NULL);
	}
}

void ScreenMain_Render(ScreenMain *self, float dt)
{
	float scale;
	int buttonheight;
	int buttonwidth;
	int spacebetween;
	int offsetfromborder;
	self->windowX = self->base.menu->p->vtbl->getCanvasWidth(self->base.menu->p);
	self->windowY = self->base.menu->p->vtbl->getCanvasHeight(self->base.menu->p);
	scale = MainMenu_GetScale(self->base.menu);
	if (self->base.menu->assetsLoadProgress->value != 1) {
		const char *s = self->base.menu->p->vtbl->stringFormat(self->base.menu->p, Language_Get(self->base.menu->lang, "MainMenu_AssetsLoadProgress"), self->base.menu->p->vtbl->floatToString(self->base.menu->p, self->base.menu->p->vtbl->floatToInt(self->base.menu->p, self->base.menu->assetsLoadProgress->value * 100)));
		MainMenu_DrawText(self->base.menu, s, 20 * scale, self->windowX / 2, self->windowY / 2, TextAlign_CENTER, TextBaseline_MIDDLE);
		return;
	}
	if (!self->cursorLoaded) {
		self->base.menu->p->vtbl->setWindowCursor(self->base.menu->p, 0, 0, 32, 32, MainMenu_GetFile(self->base.menu, "mousecursor.png"), MainMenu_GetFileLength(self->base.menu, "mousecursor.png"));
		self->cursorLoaded = TRUE;
	}
	ScreenMain_UseQueryStringIpAndPort(self, self->base.menu);
	MainMenu_DrawBackground(self->base.menu);
	MainMenu_Draw2dQuad(self->base.menu, MainMenu_GetTexture(self->base.menu, "logo.png"), self->windowX / 2 - 1024 * scale / 2, 0, 1024 * scale, 512 * scale);
	buttonheight = 64;
	buttonwidth = 256;
	spacebetween = 5;
	offsetfromborder = 50;
	self->singleplayer->text = Language_Get(self->base.menu->lang, "MainMenu_Singleplayer");
	self->singleplayer->x = self->windowX / 2 - buttonwidth / 2 * scale;
	self->singleplayer->y = self->windowY - 3 * (buttonheight * scale + spacebetween) - offsetfromborder * scale;
	self->singleplayer->sizex = buttonwidth * scale;
	self->singleplayer->sizey = buttonheight * scale;
	self->multiplayer->text = Language_Get(self->base.menu->lang, "MainMenu_Multiplayer");
	self->multiplayer->x = self->windowX / 2 - buttonwidth / 2 * scale;
	self->multiplayer->y = self->windowY - 2 * (buttonheight * scale + spacebetween) - offsetfromborder * scale;
	self->multiplayer->sizex = buttonwidth * scale;
	self->multiplayer->sizey = buttonheight * scale;
	self->exit->visible = self->base.menu->p->vtbl->exitAvailable(self->base.menu->p);
	self->exit->text = Language_Get(self->base.menu->lang, "MainMenu_Quit");
	self->exit->x = self->windowX / 2 - buttonwidth / 2 * scale;
	self->exit->y = self->windowY - 1 * (buttonheight * scale + spacebetween) - offsetfromborder * scale;
	self->exit->sizex = buttonwidth * scale;
	self->exit->sizey = buttonheight * scale;
	Screen_DrawWidgets(&self->base);
}

static void ScreenMain_UseQueryStringIpAndPort(ScreenMain *self, MainMenu *menu)
{
	const char *ip;
	const char *port;
	int portInt;
	if (self->queryStringChecked) {
		return;
	}
	self->queryStringChecked = TRUE;
	ip = menu->p->vtbl->queryStringValue(menu->p, "ip");
	port = menu->p->vtbl->queryStringValue(menu->p, "port");
	portInt = 25565;
	if (port != NULL && menu->p->vtbl->floatTryParse(menu->p, port, FloatRef_New())) {
		portInt = menu->p->vtbl->intParse(menu->p, port);
	}
	if (ip != NULL) {
		MainMenu_StartLogin(menu, NULL, ip, portInt);
	}
}

static void ScreenModifyWorld_Construct(ScreenModifyWorld *self, const ScreenVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ScreenModifyWorld;
	Screen_Construct(&self->base, vtbl);
	self->back = MenuWidget_New();
	self->back->text = "Back";
	self->back->type = WidgetType_BUTTON;
	self->base.widgets[0] = self->back;
}

ScreenModifyWorld *ScreenModifyWorld_New(void)
{
	ScreenModifyWorld *self = (ScreenModifyWorld *) malloc(sizeof(ScreenModifyWorld));
	if (self != NULL)
		ScreenModifyWorld_Construct(self, NULL);
	return self;
}

void ScreenModifyWorld_Delete(ScreenModifyWorld *self)
{
	free(self);
}

void ScreenModifyWorld_OnBackPressed(ScreenModifyWorld const *self)
{
	MainMenu_StartSingleplayer(self->base.menu);
}

void ScreenModifyWorld_OnButton(ScreenModifyWorld const *self, MenuWidget const *w)
{
	if (w == self->back) {
		self->base.vtbl->onBackPressed(&self->base);
	}
}

void ScreenModifyWorld_Render(ScreenModifyWorld const *self, float dt)
{
	GamePlatform const *p = self->base.menu->p;
	float scale = MainMenu_GetScale(self->base.menu);
	MainMenu_DrawBackground(self->base.menu);
	MainMenu_DrawText(self->base.menu, "Modify World", 14 * scale, self->base.menu->p->vtbl->getCanvasWidth(self->base.menu->p) / 2, 0, TextAlign_CENTER, TextBaseline_TOP);
	self->back->x = 40 * scale;
	self->back->y = p->vtbl->getCanvasHeight(p) - 104 * scale;
	self->back->sizex = 256 * scale;
	self->back->sizey = 64 * scale;
	self->back->fontSize = 14 * scale;
	Screen_DrawWidgets(&self->base);
}

static void ScreenMultiplayer_Construct(ScreenMultiplayer *self, const ScreenVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ScreenMultiplayer;
	Screen_Construct(&self->base, vtbl);
	self->base.widgetCount = 1088;
	self->base.widgets = (MenuWidget const **) malloc(self->base.widgetCount * sizeof(MenuWidget const *));
	self->back = MenuWidget_New();
	self->back->text = "Back";
	self->back->type = WidgetType_BUTTON;
	self->back->nextWidget = 1;
	self->connect = MenuWidget_New();
	self->connect->text = "Connect";
	self->connect->type = WidgetType_BUTTON;
	self->connect->nextWidget = 3;
	self->connectToIp = MenuWidget_New();
	self->connectToIp->text = "Connect to IP";
	self->connectToIp->type = WidgetType_BUTTON;
	self->connectToIp->nextWidget = 2;
	self->refresh = MenuWidget_New();
	self->refresh->text = "Refresh";
	self->refresh->type = WidgetType_BUTTON;
	self->refresh->nextWidget = 0;
	self->page = 0;
	self->pageUp = MenuWidget_New();
	self->pageUp->text = "";
	self->pageUp->type = WidgetType_BUTTON;
	self->pageUp->buttonStyle = ButtonStyle_TEXT;
	self->pageUp->visible = FALSE;
	self->pageDown = MenuWidget_New();
	self->pageDown->text = "";
	self->pageDown->type = WidgetType_BUTTON;
	self->pageDown->buttonStyle = ButtonStyle_TEXT;
	self->pageDown->visible = FALSE;
	self->loggedInName = MenuWidget_New();
	self->loggedInName->text = "";
	self->loggedInName->type = WidgetType_BUTTON;
	self->loggedInName->buttonStyle = ButtonStyle_TEXT;
	self->logout = MenuWidget_New();
	self->logout->text = "";
	self->logout->type = WidgetType_BUTTON;
	self->logout->buttonStyle = ButtonStyle_BUTTON;
	self->title = "Multiplayer";
	self->base.widgets[0] = self->back;
	self->base.widgets[1] = self->connect;
	self->base.widgets[2] = self->refresh;
	self->base.widgets[3] = self->connectToIp;
	self->base.widgets[4] = self->pageUp;
	self->base.widgets[5] = self->pageDown;
	self->base.widgets[6] = self->loggedInName;
	self->base.widgets[7] = self->logout;
	self->serverListAddress = HttpResponseCi_New();
	self->serverListCsv = HttpResponseCi_New();
	self->serversOnList = (ServerOnList const **) malloc(1024 * sizeof(ServerOnList const *));
	self->thumbResponses = (ThumbnailResponseCi const **) malloc(1024 * sizeof(ThumbnailResponseCi const *));
	self->serverButtons = (MenuWidget const **) malloc(1024 * sizeof(MenuWidget const *));
	{
		int i;
		for (i = 0; i < 1024; i++) {
			MenuWidget *b = MenuWidget_New();
			b = MenuWidget_New();
			b->text = "Invalid";
			b->type = WidgetType_BUTTON;
			b->visible = FALSE;
			b->image = "serverlist_entry_noimage.png";
			self->serverButtons[i] = b;
			self->base.widgets[8 + i] = b;
		}
	}
	self->loading = TRUE;
}

ScreenMultiplayer *ScreenMultiplayer_New(void)
{
	ScreenMultiplayer *self = (ScreenMultiplayer *) malloc(sizeof(ScreenMultiplayer));
	if (self != NULL)
		ScreenMultiplayer_Construct(self, NULL);
	return self;
}

void ScreenMultiplayer_Delete(ScreenMultiplayer *self)
{
	free(self);
}

void ScreenMultiplayer_LoadTranslations(ScreenMultiplayer *self)
{
	self->back->text = Language_Get(self->base.menu->lang, "MainMenu_ButtonBack");
	self->connect->text = Language_Get(self->base.menu->lang, "MainMenu_MultiplayerConnect");
	self->connectToIp->text = Language_Get(self->base.menu->lang, "MainMenu_MultiplayerConnectIP");
	self->refresh->text = Language_Get(self->base.menu->lang, "MainMenu_MultiplayerRefresh");
	self->title = Language_Get(self->base.menu->lang, "MainMenu_Multiplayer");
}

void ScreenMultiplayer_OnBackPressed(ScreenMultiplayer const *self)
{
	MainMenu_StartMainMenu(self->base.menu);
}

void ScreenMultiplayer_OnButton(ScreenMultiplayer *self, MenuWidget const *w)
{
	{
		int i;
		for (i = 0; i < 1024; i++) {
			self->serverButtons[i]->selected = FALSE;
			if (self->serverButtons[i] == w) {
				self->serverButtons[i]->selected = TRUE;
				if (self->serversOnList[i + self->serversPerPage * self->page] != NULL) {
					self->selectedServerHash = self->serversOnList[i + self->serversPerPage * self->page]->hash;
				}
			}
		}
	}
	if (w == self->pageUp) {
		ScreenMultiplayer_PageUp_(self);
	}
	if (w == self->pageDown) {
		ScreenMultiplayer_PageDown_(self);
	}
	if (w == self->back) {
		self->base.vtbl->onBackPressed(&self->base);
	}
	if (w == self->connect) {
		if (self->selectedServerHash != NULL) {
			MainMenu_StartLogin(self->base.menu, self->selectedServerHash, NULL, 0);
		}
	}
	if (w == self->connectToIp) {
		MainMenu_StartConnectToIp(self->base.menu);
	}
	if (w == self->refresh) {
		self->loaded = FALSE;
		self->loading = TRUE;
	}
	if (w == self->logout) {
		Preferences const *pref = self->base.menu->p->vtbl->getPreferences(self->base.menu->p);
		Preferences_Remove(pref, "Username");
		Preferences_Remove(pref, "Password");
		self->base.menu->p->vtbl->setPreferences(self->base.menu->p, pref);
		self->loggedInName->text = "";
	}
}

void ScreenMultiplayer_OnMouseWheel(ScreenMultiplayer *self, MouseWheelEventArgs const *e)
{
	if (MouseWheelEventArgs_GetDelta(e) < 0) {
		ScreenMultiplayer_PageUp_(self);
	}
	else if (MouseWheelEventArgs_GetDelta(e) > 0) {
		ScreenMultiplayer_PageDown_(self);
	}
}

void ScreenMultiplayer_PageDown_(ScreenMultiplayer *self)
{
	if (self->page > 0) {
		self->page--;
	}
}

void ScreenMultiplayer_PageUp_(ScreenMultiplayer *self)
{
	if (self->pageUp->visible && self->page < 1024 / self->serversPerPage - 1) {
		self->page++;
	}
}

void ScreenMultiplayer_Render(ScreenMultiplayer *self, float dt)
{
	GamePlatform const *p;
	float scale;
	if (!self->loaded) {
		self->base.menu->p->vtbl->webClientDownloadDataAsync(self->base.menu->p, "http://manicdigger.sourceforge.net/serverlistcsv.php", self->serverListAddress);
		self->loaded = TRUE;
	}
	if (self->serverListAddress->done) {
		self->serverListAddress->done = FALSE;
		self->base.menu->p->vtbl->webClientDownloadDataAsync(self->base.menu->p, HttpResponseCi_GetString(self->serverListAddress, self->base.menu->p), self->serverListCsv);
	}
	if (self->serverListCsv->done) {
		IntRef const *serversCount;
		const char *const *servers;
		self->loading = FALSE;
		self->serverListCsv->done = FALSE;
		{
			int i;
			for (i = 0; i < 1024; i++) {
				self->serversOnList[i] = NULL;
				self->thumbResponses[i] = NULL;
			}
		}
		serversCount = IntRef_New();
		servers = self->base.menu->p->vtbl->stringSplit(self->base.menu->p, HttpResponseCi_GetString(self->serverListCsv, self->base.menu->p), "\n", serversCount);
		{
			int i;
			for (i = 0; i < serversCount->value; i++) {
				IntRef const *ssCount = IntRef_New();
				const char *const *ss = self->base.menu->p->vtbl->stringSplit(self->base.menu->p, servers[i], "\t", ssCount);
				ServerOnList *s;
				if (ssCount->value < 10) {
					continue;
				}
				s = ServerOnList_New();
				s->hash = ss[0];
				s->name = self->base.menu->p->vtbl->decodeHTMLEntities(self->base.menu->p, ss[1]);
				s->motd = self->base.menu->p->vtbl->decodeHTMLEntities(self->base.menu->p, ss[2]);
				s->port = self->base.menu->p->vtbl->intParse(self->base.menu->p, ss[3]);
				s->ip = ss[4];
				s->version = ss[5];
				s->users = self->base.menu->p->vtbl->intParse(self->base.menu->p, ss[6]);
				s->max = self->base.menu->p->vtbl->intParse(self->base.menu->p, ss[7]);
				s->gamemode = ss[8];
				s->players = ss[9];
				self->serversOnList[i] = s;
			}
		}
	}
	p = self->base.menu->p;
	scale = MainMenu_GetScale(self->base.menu);
	self->back->x = 40 * scale;
	self->back->y = p->vtbl->getCanvasHeight(p) - 104 * scale;
	self->back->sizex = 256 * scale;
	self->back->sizey = 64 * scale;
	self->back->fontSize = 14 * scale;
	self->connect->x = p->vtbl->getCanvasWidth(p) / 2 - 300 * scale;
	self->connect->y = p->vtbl->getCanvasHeight(p) - 104 * scale;
	self->connect->sizex = 256 * scale;
	self->connect->sizey = 64 * scale;
	self->connect->fontSize = 14 * scale;
	self->connectToIp->x = p->vtbl->getCanvasWidth(p) / 2 - 0 * scale;
	self->connectToIp->y = p->vtbl->getCanvasHeight(p) - 104 * scale;
	self->connectToIp->sizex = 256 * scale;
	self->connectToIp->sizey = 64 * scale;
	self->connectToIp->fontSize = 14 * scale;
	self->refresh->x = p->vtbl->getCanvasWidth(p) / 2 + 350 * scale;
	self->refresh->y = p->vtbl->getCanvasHeight(p) - 104 * scale;
	self->refresh->sizex = 256 * scale;
	self->refresh->sizey = 64 * scale;
	self->refresh->fontSize = 14 * scale;
	self->pageUp->x = p->vtbl->getCanvasWidth(p) - 94 * scale;
	self->pageUp->y = 100 * scale + (self->serversPerPage - 1) * 70 * scale;
	self->pageUp->sizex = 64 * scale;
	self->pageUp->sizey = 64 * scale;
	self->pageUp->image = "serverlist_nav_down.png";
	self->pageDown->x = p->vtbl->getCanvasWidth(p) - 94 * scale;
	self->pageDown->y = 100 * scale;
	self->pageDown->sizex = 64 * scale;
	self->pageDown->sizey = 64 * scale;
	self->pageDown->image = "serverlist_nav_up.png";
	self->loggedInName->x = p->vtbl->getCanvasWidth(p) - 228 * scale;
	self->loggedInName->y = 32 * scale;
	self->loggedInName->sizex = 128 * scale;
	self->loggedInName->sizey = 32 * scale;
	self->loggedInName->fontSize = 12 * scale;
	if (strcmp(self->loggedInName->text, "") == 0) {
		if (strcmp(Preferences_GetString(p->vtbl->getPreferences(p), "Password", ""), "") != 0) {
			self->loggedInName->text = Preferences_GetString(p->vtbl->getPreferences(p), "Username", "Invalid");
		}
	}
	self->logout->visible = strcmp(self->loggedInName->text, "") != 0;
	self->logout->x = p->vtbl->getCanvasWidth(p) - 228 * scale;
	self->logout->y = 62 * scale;
	self->logout->sizex = 128 * scale;
	self->logout->sizey = 32 * scale;
	self->logout->fontSize = 12 * scale;
	self->logout->text = "Logout";
	MainMenu_DrawBackground(self->base.menu);
	MainMenu_DrawText(self->base.menu, self->title, 20 * scale, p->vtbl->getCanvasWidth(p) / 2, 10, TextAlign_CENTER, TextBaseline_TOP);
	MainMenu_DrawText(self->base.menu, p->vtbl->intToString(p, self->page + 1), 14 * scale, p->vtbl->getCanvasWidth(p) - 68 * scale, p->vtbl->getCanvasHeight(p) / 2, TextAlign_CENTER, TextBaseline_MIDDLE);
	if (self->loading) {
		MainMenu_DrawText(self->base.menu, Language_Get(self->base.menu->lang, "MainMenu_MultiplayerLoading"), 14 * scale, 100 * scale, 50 * scale, TextAlign_LEFT, TextBaseline_TOP);
	}
	ScreenMultiplayer_UpdateThumbnails(self);
	{
		int i;
		for (i = 0; i < 1024; i++) {
			self->serverButtons[i]->visible = FALSE;
		}
	}
	self->serversPerPage = self->base.menu->p->vtbl->floatToInt(self->base.menu->p, (self->base.menu->p->vtbl->getCanvasHeight(self->base.menu->p) - 200 * scale) / 70 * scale);
	if (self->serversPerPage <= 0) {
		self->serversPerPage = 1;
	}
	{
		int i;
		for (i = 0; i < self->serversPerPage; i++) {
			int index = i + self->serversPerPage * self->page;
			ServerOnList const *s;
			const char *t;
			if (index > 1024) {
				self->page = 0;
				index = i + self->serversPerPage * self->page;
			}
			s = self->serversOnList[index];
			if (s == NULL) {
				continue;
			}
			t = self->base.menu->p->vtbl->stringFormat2(self->base.menu->p, "{1}", self->base.menu->p->vtbl->intToString(self->base.menu->p, index), s->name);
			t = self->base.menu->p->vtbl->stringFormat2(self->base.menu->p, "{0}\n{1}", t, s->motd);
			t = self->base.menu->p->vtbl->stringFormat2(self->base.menu->p, "{0}\n{1}", t, s->gamemode);
			t = self->base.menu->p->vtbl->stringFormat2(self->base.menu->p, "{0}\n{1}", t, self->base.menu->p->vtbl->intToString(self->base.menu->p, s->users));
			t = self->base.menu->p->vtbl->stringFormat2(self->base.menu->p, "{0}/{1}", t, self->base.menu->p->vtbl->intToString(self->base.menu->p, s->max));
			t = self->base.menu->p->vtbl->stringFormat2(self->base.menu->p, "{0}\n{1}", t, s->version);
			self->serverButtons[i]->text = t;
			self->serverButtons[i]->x = 100 * scale;
			self->serverButtons[i]->y = 100 * scale + i * 70 * scale;
			self->serverButtons[i]->sizex = p->vtbl->getCanvasWidth(p) - 200 * scale;
			self->serverButtons[i]->sizey = 64 * scale;
			self->serverButtons[i]->visible = TRUE;
			self->serverButtons[i]->buttonStyle = ButtonStyle_SERVER_ENTRY;
			if (s->thumbnailError) {
				self->serverButtons[i]->description = "Server did not respond to query!";
			}
			else {
				self->serverButtons[i]->description = NULL;
			}
			if (s->thumbnailFetched && !s->thumbnailError) {
				self->serverButtons[i]->image = self->base.menu->p->vtbl->stringFormat(self->base.menu->p, "serverlist_entry_{0}.png", s->hash);
			}
			else {
				self->serverButtons[i]->image = "serverlist_entry_noimage.png";
			}
		}
	}
	ScreenMultiplayer_UpdateScrollButtons(self);
	Screen_DrawWidgets(&self->base);
}

void ScreenMultiplayer_UpdateScrollButtons(ScreenMultiplayer const *self)
{
	cibool maxpage = FALSE;
	if ((self->page + 1) * self->serversPerPage >= 1024) {
		maxpage = TRUE;
	}
	else {
		if (self->serversOnList[(self->page + 1) * self->serversPerPage] == NULL) {
			maxpage = TRUE;
		}
	}
	if (self->page == 0) {
		self->pageDown->visible = FALSE;
	}
	else {
		self->pageDown->visible = TRUE;
	}
	if (maxpage) {
		self->pageUp->visible = FALSE;
	}
	else {
		self->pageUp->visible = TRUE;
	}
}

void ScreenMultiplayer_UpdateThumbnails(ScreenMultiplayer const *self)
{
	{
		int i;
		for (i = 0; i < 1024; i++) {
			ServerOnList *server = self->serversOnList[i];
			if (server == NULL) {
				continue;
			}
			if (server->thumbnailFetched) {
				continue;
			}
			if (!server->thumbnailDownloading) {
				self->thumbResponses[i] = ThumbnailResponseCi_New();
				self->base.menu->p->vtbl->thumbnailDownloadAsync(self->base.menu->p, server->ip, server->port, self->thumbResponses[i]);
				server->thumbnailDownloading = TRUE;
			}
			else {
				if (self->thumbResponses[i] != NULL) {
					if (self->thumbResponses[i]->done) {
						BitmapCi const *bmp = self->base.menu->p->vtbl->bitmapCreateFromPng(self->base.menu->p, self->thumbResponses[i]->data, self->thumbResponses[i]->dataLength);
						if (bmp != NULL) {
							int texture = self->base.menu->p->vtbl->loadTextureFromBitmap(self->base.menu->p, bmp);
							DictionaryStringInt1024_Set(self->base.menu->textures, self->base.menu->p->vtbl->stringFormat(self->base.menu->p, "serverlist_entry_{0}.png", server->hash), texture);
							self->base.menu->p->vtbl->bitmapDelete(self->base.menu->p, bmp);
						}
						server->thumbnailDownloading = FALSE;
						server->thumbnailFetched = TRUE;
					}
					if (self->thumbResponses[i]->error) {
						server->thumbnailDownloading = FALSE;
						server->thumbnailError = TRUE;
						server->thumbnailFetched = TRUE;
					}
				}
				else {
					server->thumbnailDownloading = FALSE;
					server->thumbnailError = TRUE;
					server->thumbnailFetched = TRUE;
				}
			}
		}
	}
}

static void ScreenSingleplayer_Construct(ScreenSingleplayer *self, const ScreenVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ScreenSingleplayer;
	Screen_Construct(&self->base, vtbl);
	self->play = MenuWidget_New();
	self->play->text = "Play";
	self->newWorld = MenuWidget_New();
	self->newWorld->text = "New World";
	self->modify = MenuWidget_New();
	self->modify->text = "Modify";
	self->back = MenuWidget_New();
	self->back->text = "Back";
	self->back->type = WidgetType_BUTTON;
	self->open = MenuWidget_New();
	self->open->text = "Create or open...";
	self->open->type = WidgetType_BUTTON;
	self->title = "Singleplayer";
	self->base.widgets[0] = self->play;
	self->base.widgets[1] = self->newWorld;
	self->base.widgets[2] = self->modify;
	self->base.widgets[3] = self->back;
	self->base.widgets[4] = self->open;
	self->worldButtons = (MenuWidget const **) malloc(10 * sizeof(MenuWidget const *));
	{
		int i;
		for (i = 0; i < 10; i++) {
			self->worldButtons[i] = MenuWidget_New();
			self->worldButtons[i]->visible = FALSE;
			self->base.widgets[5 + i] = self->worldButtons[i];
		}
	}
}

ScreenSingleplayer *ScreenSingleplayer_New(void)
{
	ScreenSingleplayer *self = (ScreenSingleplayer *) malloc(sizeof(ScreenSingleplayer));
	if (self != NULL)
		ScreenSingleplayer_Construct(self, NULL);
	return self;
}

void ScreenSingleplayer_Delete(ScreenSingleplayer *self)
{
	free(self);
}

void ScreenSingleplayer_LoadTranslations(ScreenSingleplayer *self)
{
	self->back->text = Language_Get(self->base.menu->lang, "MainMenu_ButtonBack");
	self->open->text = Language_Get(self->base.menu->lang, "MainMenu_SingleplayerButtonCreate");
	self->title = Language_Get(self->base.menu->lang, "MainMenu_Singleplayer");
}

void ScreenSingleplayer_OnBackPressed(ScreenSingleplayer const *self)
{
	MainMenu_StartMainMenu(self->base.menu);
}

void ScreenSingleplayer_OnButton(ScreenSingleplayer const *self, MenuWidget const *w)
{
	{
		int i;
		for (i = 0; i < 10; i++) {
			self->worldButtons[i]->selected = FALSE;
		}
	}
	{
		int i;
		for (i = 0; i < 10; i++) {
			if (self->worldButtons[i] == w) {
				self->worldButtons[i]->selected = TRUE;
			}
		}
	}
	if (w == self->newWorld) {
		MainMenu_StartNewWorld(self->base.menu);
	}
	if (w == self->play) {
	}
	if (w == self->modify) {
		MainMenu_StartModifyWorld(self->base.menu);
	}
	if (w == self->back) {
		self->base.vtbl->onBackPressed(&self->base);
	}
	if (w == self->open) {
		const char *extension;
		const char *result;
		if (self->base.menu->p->vtbl->singlePlayerServerAvailable(self->base.menu->p)) {
			extension = "mddbs";
		}
		else {
			extension = "mdss";
		}
		result = self->base.menu->p->vtbl->fileOpenDialog(self->base.menu->p, extension, "Manic Digger Savegame", self->base.menu->p->vtbl->pathSavegames(self->base.menu->p));
		if (result != NULL) {
			MainMenu_ConnectToSingleplayer(self->base.menu, result);
		}
	}
}

void ScreenSingleplayer_Render(ScreenSingleplayer *self, float dt)
{
	GamePlatform const *p = self->base.menu->p;
	float scale = MainMenu_GetScale(self->base.menu);
	float leftx;
	float y;
	MainMenu_DrawBackground(self->base.menu);
	MainMenu_DrawText(self->base.menu, self->title, 20 * scale, p->vtbl->getCanvasWidth(p) / 2, 10, TextAlign_CENTER, TextBaseline_TOP);
	leftx = p->vtbl->getCanvasWidth(p) / 2 - 128 * scale;
	y = p->vtbl->getCanvasHeight(p) / 2 + 0 * scale;
	self->play->x = leftx;
	self->play->y = y + 100 * scale;
	self->play->sizex = 256 * scale;
	self->play->sizey = 64 * scale;
	self->play->fontSize = 14 * scale;
	self->newWorld->x = leftx;
	self->newWorld->y = y + 170 * scale;
	self->newWorld->sizex = 256 * scale;
	self->newWorld->sizey = 64 * scale;
	self->newWorld->fontSize = 14 * scale;
	self->modify->x = leftx;
	self->modify->y = y + 240 * scale;
	self->modify->sizex = 256 * scale;
	self->modify->sizey = 64 * scale;
	self->modify->fontSize = 14 * scale;
	self->back->x = 40 * scale;
	self->back->y = p->vtbl->getCanvasHeight(p) - 104 * scale;
	self->back->sizex = 256 * scale;
	self->back->sizey = 64 * scale;
	self->back->fontSize = 14 * scale;
	self->open->x = leftx;
	self->open->y = y + 0 * scale;
	self->open->sizex = 256 * scale;
	self->open->sizey = 64 * scale;
	self->open->fontSize = 14 * scale;
	if (self->savegames == NULL) {
		IntRef *savegamesCount_ = IntRef_New();
		self->savegames = MainMenu_GetSavegames(self->base.menu, savegamesCount_);
		self->savegamesCount = savegamesCount_->value;
	}
	{
		int i;
		for (i = 0; i < 10; i++) {
			self->worldButtons[i]->visible = FALSE;
		}
	}
	{
		int i;
		for (i = 0; i < self->savegamesCount; i++) {
			self->worldButtons[i]->visible = TRUE;
			self->worldButtons[i]->text = self->base.menu->p->vtbl->fileName(self->base.menu->p, self->savegames[i]);
			self->worldButtons[i]->x = leftx;
			self->worldButtons[i]->y = 100 + 100 * scale * i;
			self->worldButtons[i]->sizex = 256 * scale;
			self->worldButtons[i]->sizey = 64 * scale;
			self->worldButtons[i]->fontSize = 14 * scale;
		}
	}
	self->open->visible = self->base.menu->p->vtbl->singlePlayerServerAvailable(self->base.menu->p);
	self->play->visible = FALSE;
	self->newWorld->visible = FALSE;
	self->modify->visible = FALSE;
	{
		int i;
		for (i = 0; i < self->savegamesCount; i++) {
			self->worldButtons[i]->visible = FALSE;
		}
	}
	Screen_DrawWidgets(&self->base);
	if (!self->base.menu->p->vtbl->singlePlayerServerAvailable(self->base.menu->p)) {
		MainMenu_DrawText(self->base.menu, "Singleplayer is only available on desktop (Windows, Linux, Mac) version of game.", 16 * scale, self->base.menu->p->vtbl->getCanvasWidth(self->base.menu->p) / 2, self->base.menu->p->vtbl->getCanvasHeight(self->base.menu->p) / 2, TextAlign_CENTER, TextBaseline_MIDDLE);
	}
}

static void Script_Construct(Script *self, const ScriptVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_Script;
	self->vtbl = vtbl;
}

Script *Script_New(void)
{
	Script *self = (Script *) malloc(sizeof(Script));
	if (self != NULL)
		Script_Construct(self, NULL);
	return self;
}

void Script_Delete(Script *self)
{
	free(self);
}

void Script_OnCreate(Script const *self, ScriptManager const *manager)
{
}

void Script_OnUse(Script const *self)
{
}

static void ScriptCharacterPhysics_Construct(ScriptCharacterPhysics *self, const EntityScriptVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_ScriptCharacterPhysics;
	EntityScript_Construct(&self->base, vtbl);
	self->movedz = 0;
	self->curspeed = Vector3Ref_New();
	self->jumpacceleration = 0;
	self->isplayeronground = FALSE;
	self->acceleration = Acceleration_New();
	self->jumpstartacceleration = 0;
	self->jumpstartaccelerationhalf = 0;
	self->movespeednow = 0;
	self->tmpPlayerPosition = (float *) malloc(3 * sizeof(float ));
	self->tmpBlockingBlockType = IntRef_New();
	self->constGravity = 0.3f;
	self->constWaterGravityMultiplier = 3;
	self->constEnableAcceleration = TRUE;
	self->constJump = 2.1f;
}

ScriptCharacterPhysics *ScriptCharacterPhysics_New(void)
{
	ScriptCharacterPhysics *self = (ScriptCharacterPhysics *) malloc(sizeof(ScriptCharacterPhysics));
	if (self != NULL)
		ScriptCharacterPhysics_Construct(self, NULL);
	return self;
}

void ScriptCharacterPhysics_Delete(ScriptCharacterPhysics *self)
{
	free(self);
}

float ScriptCharacterPhysics_BoxPointDistance(float minX, float minY, float minZ, float maxX, float maxY, float maxZ, float pX, float pY, float pZ)
{
	float dx = ScriptCharacterPhysics_Max3(minX - pX, 0, pX - maxX);
	float dy = ScriptCharacterPhysics_Max3(minY - pY, 0, pY - maxY);
	float dz = ScriptCharacterPhysics_Max3(minZ - pZ, 0, pZ - maxZ);
	return ScriptCharacterPhysics_Max3(dx, dy, dz);
}

static int ScriptCharacterPhysics_FloatToInt(ScriptCharacterPhysics const *self, float value)
{
	return self->game->platform->vtbl->floatToInt(self->game->platform, value);
}

static cibool ScriptCharacterPhysics_IsEmptyPoint(ScriptCharacterPhysics const *self, float x, float y, float z, IntRef *blockingBlocktype)
{
	{
		int xx;
		for (xx = 0; xx < 3; xx++) {
			{
				int yy;
				for (yy = 0; yy < 3; yy++) {
					{
						int zz;
						for (zz = 0; zz < 3; zz++) {
							if (!ScriptCharacterPhysics_IsTileEmptyForPhysics(self, ScriptCharacterPhysics_FloatToInt(self, x + xx - 1), ScriptCharacterPhysics_FloatToInt(self, z + zz - 1), ScriptCharacterPhysics_FloatToInt(self, y + yy - 1))) {
								float minX = ScriptCharacterPhysics_FloatToInt(self, x + xx - 1);
								float minY = ScriptCharacterPhysics_FloatToInt(self, y + yy - 1);
								float minZ = ScriptCharacterPhysics_FloatToInt(self, z + zz - 1);
								float maxX = minX + 1;
								float maxY = minY + Game_getblockheight(self->game, ScriptCharacterPhysics_FloatToInt(self, x + xx - 1), ScriptCharacterPhysics_FloatToInt(self, z + zz - 1), ScriptCharacterPhysics_FloatToInt(self, y + yy - 1));
								float maxZ = minZ + 1;
								if (ScriptCharacterPhysics_BoxPointDistance(minX, minY, minZ, maxX, maxY, maxZ, x, y, z) < self->game->constWallDistance) {
									if (blockingBlocktype != NULL) {
										blockingBlocktype->value = Map_GetBlock(self->game->map, ScriptCharacterPhysics_FloatToInt(self, x + xx - 1), ScriptCharacterPhysics_FloatToInt(self, z + zz - 1), ScriptCharacterPhysics_FloatToInt(self, y + yy - 1));
									}
									return FALSE;
								}
							}
						}
					}
				}
			}
		}
	}
	return TRUE;
}

static cibool ScriptCharacterPhysics_IsEmptySpaceForPlayer(ScriptCharacterPhysics const *self, cibool high, float x, float y, float z, IntRef *blockingBlockType)
{
	return ScriptCharacterPhysics_IsEmptyPoint(self, x, y, z, blockingBlockType) && ScriptCharacterPhysics_IsEmptyPoint(self, x, y + 1, z, blockingBlockType) && (!high || ScriptCharacterPhysics_IsEmptyPoint(self, x, y + 2, z, blockingBlockType));
}

cibool ScriptCharacterPhysics_IsTileEmptyForPhysics(ScriptCharacterPhysics const *self, int x, int y, int z)
{
	cibool enableFreemove;
	int block;
	Packet_BlockType const *blocktype;
	if (z >= self->game->map->mapSizeZ) {
		return TRUE;
	}
	enableFreemove = FALSE;
	if (x < 0 || y < 0 || z < 0) {
		return enableFreemove;
	}
	if (x >= self->game->map->mapSizeX || y >= self->game->map->mapSizeY) {
		return enableFreemove;
	}
	block = Map_GetBlockValid(self->game->map, x, y, z);
	if (block == 0) {
		return TRUE;
	}
	blocktype = self->game->blocktypes[block];
	return blocktype->walkableType == 1 || Game_IsEmptyForPhysics(self->game, blocktype) || Game_IsRail(self->game, blocktype);
}

float ScriptCharacterPhysics_MakeCloserToZero(float a, float b)
{
	if (a > 0) {
		float c = a - b;
		if (c < 0) {
			c = 0;
		}
		return c;
	}
	else {
		float c = a + b;
		if (c > 0) {
			c = 0;
		}
		return c;
	}
}

static float ScriptCharacterPhysics_Max3(float a, float b, float c)
{
	return MathCi_MaxFloat(MathCi_MaxFloat(a, b), c);
}

void ScriptCharacterPhysics_OnNewFrameFixed(ScriptCharacterPhysics *self, Game *game_, int entity, float dt)
{
	Controls *move;
	self->game = game_;
	if (self->game->guistate == GuiState_MAP_LOADING) {
		return;
	}
	self->movespeednow = Game_MoveSpeedNow(self->game);
	self->game->controls->movedx = MathCi_ClampFloat(self->game->controls->movedx, -1, 1);
	self->game->controls->movedy = MathCi_ClampFloat(self->game->controls->movedy, -1, 1);
	move = self->game->controls;
	self->jumpstartacceleration = 13.333f * self->constGravity;
	self->jumpstartaccelerationhalf = 9 * self->constGravity;
	Acceleration_SetDefault(self->acceleration);
	self->game->soundnow = BoolRef_New();
	if (Game_FollowId(self->game) != NULL && Game_FollowId(self->game)->value == self->game->localPlayerId) {
		move->movedx = 0;
		move->movedy = 0;
		move->moveup = FALSE;
		move->wantsjump = FALSE;
	}
	ScriptCharacterPhysics_Update(self, self->game->player->position, move, dt, self->game->soundnow, Vector3Ref_Create(self->game->pushX, self->game->pushY, self->game->pushZ), self->game->entities[self->game->localPlayerId]->drawModel->modelHeight);
}

static cibool ScriptCharacterPhysics_StandingOnHalfBlock(ScriptCharacterPhysics const *self, float x, float y, float z)
{
	int under = Map_GetBlock(self->game->map, self->game->platform->vtbl->floatToInt(self->game->platform, x), self->game->platform->vtbl->floatToInt(self->game->platform, z), self->game->platform->vtbl->floatToInt(self->game->platform, y));
	return self->game->blocktypes[under]->drawType == 11;
}

void ScriptCharacterPhysics_Update(ScriptCharacterPhysics *self, EntityPosition_ *stateplayerposition, Controls const *move, float dt, BoolRef *soundnow, Vector3Ref *push, float modelheight)
{
	Vector3Ref *diff1ref;
	Vector3Ref *diff1;
	cibool loaded;
	int cx;
	int cy;
	int cz;
	Vector3Ref *newposition;
	Vector3Ref const *previousposition;
	if (self->game->stopPlayerMove) {
		self->movedz = 0;
		self->game->stopPlayerMove = FALSE;
	}
	if (!self->isplayeronground) {
		self->acceleration->acceleration1 = 0.99f;
		self->acceleration->acceleration2 = 0.2f;
		self->acceleration->acceleration3 = 70;
	}
	{
		int blockunderplayer = Game_BlockUnderPlayer(self->game);
		if (blockunderplayer != -1 && blockunderplayer == GameData_BlockIdTrampoline(self->game->d_Data) && !self->isplayeronground && !self->game->controls->shiftkeydown) {
			self->game->controls->wantsjump = TRUE;
			self->jumpstartacceleration = 20.666f * self->constGravity;
		}
	}
	{
		int blockunderplayer = Game_BlockUnderPlayer(self->game);
		if ((blockunderplayer != -1 && GameData_IsSlipperyWalk(self->game->d_Data)[blockunderplayer]) || Game_SwimmingBody(self->game)) {
			self->acceleration->acceleration1 = 0.99f;
			self->acceleration->acceleration2 = 0.2f;
			self->acceleration->acceleration3 = 70;
		}
	}
	soundnow->value = FALSE;
	diff1ref = Vector3Ref_New();
	VectorTool_ToVectorInFixedSystem(move->movedx * self->movespeednow * dt, 0, move->movedy * self->movespeednow * dt, stateplayerposition->rotx, stateplayerposition->roty, diff1ref);
	diff1 = Vector3Ref_New();
	diff1->x = diff1ref->x;
	diff1->y = diff1ref->y;
	diff1->z = diff1ref->z;
	if (MiscCi_Vec3Length(push->x, push->y, push->z) > 0.01f) {
		Vector3Ref_Normalize(push);
		push->x *= 5;
		push->y *= 5;
		push->z *= 5;
	}
	diff1->x += push->x * dt;
	diff1->y += push->y * dt;
	diff1->z += push->z * dt;
	loaded = FALSE;
	cx = self->game->platform->vtbl->floatToInt(self->game->platform, self->game->player->position->x / 16);
	cy = self->game->platform->vtbl->floatToInt(self->game->platform, self->game->player->position->z / 16);
	cz = self->game->platform->vtbl->floatToInt(self->game->platform, self->game->player->position->y / 16);
	if (Map_IsValidChunkPos(self->game->map, cx, cy, cz)) {
		if (self->game->map->chunks[MapUtilCi_Index3d(cx, cy, cz, self->game->map->mapSizeX / 16, self->game->map->mapSizeY / 16)] != NULL) {
			loaded = TRUE;
		}
	}
	else {
		loaded = TRUE;
	}
	if (!move->freemove && loaded) {
		if (!Game_SwimmingBody(self->game)) {
			self->movedz += -self->constGravity;
		}
		else {
			self->movedz += -self->constGravity * self->constWaterGravityMultiplier;
		}
	}
	self->game->movedz = self->movedz;
	if (self->constEnableAcceleration) {
		self->curspeed->x *= self->acceleration->acceleration1;
		self->curspeed->y *= self->acceleration->acceleration1;
		self->curspeed->z *= self->acceleration->acceleration1;
		self->curspeed->x = ScriptCharacterPhysics_MakeCloserToZero(self->curspeed->x, self->acceleration->acceleration2 * dt);
		self->curspeed->y = ScriptCharacterPhysics_MakeCloserToZero(self->curspeed->y, self->acceleration->acceleration2 * dt);
		self->curspeed->z = ScriptCharacterPhysics_MakeCloserToZero(self->curspeed->z, self->acceleration->acceleration2 * dt);
		diff1->y += move->moveup ? 2 * self->movespeednow * dt : 0;
		diff1->y -= move->movedown ? 2 * self->movespeednow * dt : 0;
		self->curspeed->x += diff1->x * self->acceleration->acceleration3 * dt;
		self->curspeed->y += diff1->y * self->acceleration->acceleration3 * dt;
		self->curspeed->z += diff1->z * self->acceleration->acceleration3 * dt;
		if (Vector3Ref_Length(self->curspeed) > self->movespeednow) {
			Vector3Ref_Normalize(self->curspeed);
			self->curspeed->x *= self->movespeednow;
			self->curspeed->y *= self->movespeednow;
			self->curspeed->z *= self->movespeednow;
		}
	}
	else {
		if (MiscCi_Vec3Length(diff1->x, diff1->y, diff1->z) > 0) {
			Vector3Ref_Normalize(diff1);
		}
		self->curspeed->x = diff1->x * self->movespeednow;
		self->curspeed->y = diff1->y * self->movespeednow;
		self->curspeed->z = diff1->z * self->movespeednow;
	}
	newposition = Vector3Ref_Create(0, 0, 0);
	if (!move->freemove) {
		float diffx;
		float diffy;
		float diffz;
		float difflength;
		newposition->x = stateplayerposition->x + self->curspeed->x;
		newposition->y = stateplayerposition->y + self->curspeed->y;
		newposition->z = stateplayerposition->z + self->curspeed->z;
		if (!Game_SwimmingBody(self->game)) {
			newposition->y = stateplayerposition->y;
		}
		diffx = newposition->x - stateplayerposition->x;
		diffy = newposition->y - stateplayerposition->y;
		diffz = newposition->z - stateplayerposition->z;
		difflength = MiscCi_Vec3Length(diffx, diffy, diffz);
		if (difflength > 0) {
			diffx /= difflength;
			diffy /= difflength;
			diffz /= difflength;
			diffx *= Vector3Ref_Length(self->curspeed);
			diffy *= Vector3Ref_Length(self->curspeed);
			diffz *= Vector3Ref_Length(self->curspeed);
		}
		newposition->x = stateplayerposition->x + diffx * dt;
		newposition->y = stateplayerposition->y + diffy * dt;
		newposition->z = stateplayerposition->z + diffz * dt;
	}
	else {
		newposition->x = stateplayerposition->x + self->curspeed->x * dt;
		newposition->y = stateplayerposition->y + self->curspeed->y * dt;
		newposition->z = stateplayerposition->z + self->curspeed->z * dt;
	}
	newposition->y += self->movedz * dt;
	previousposition = Vector3Ref_Create(stateplayerposition->x, stateplayerposition->y, stateplayerposition->z);
	if (!move->noclip) {
		float const *v = ScriptCharacterPhysics_WallSlide(self, Vec3_FromValues(stateplayerposition->x, stateplayerposition->y, stateplayerposition->z), Vec3_FromValues(newposition->x, newposition->y, newposition->z), modelheight);
		stateplayerposition->x = v[0];
		stateplayerposition->y = v[1];
		stateplayerposition->z = v[2];
	}
	else {
		stateplayerposition->x = newposition->x;
		stateplayerposition->y = newposition->y;
		stateplayerposition->z = newposition->z;
	}
	if (!move->freemove) {
		if (self->isplayeronground || Game_SwimmingBody(self->game)) {
			self->jumpacceleration = 0;
			self->movedz = 0;
		}
		if ((move->wantsjump || move->wantsjumphalf) && ((self->jumpacceleration == 0 && self->isplayeronground) || Game_SwimmingBody(self->game)) && loaded && !Game_SwimmingEyes(self->game)) {
			self->jumpacceleration = move->wantsjumphalf ? self->jumpstartaccelerationhalf : self->jumpstartacceleration;
			soundnow->value = TRUE;
		}
		if (self->jumpacceleration > 0) {
			self->isplayeronground = FALSE;
			self->jumpacceleration = self->jumpacceleration / 2;
		}
		{
			self->movedz += self->jumpacceleration * self->constJump;
		}
	}
	else {
		self->isplayeronground = TRUE;
	}
	self->game->isplayeronground = self->isplayeronground;
}

float const *ScriptCharacterPhysics_WallSlide(ScriptCharacterPhysics *self, float *oldposition, float *newposition, float modelheight)
{
	cibool high = FALSE;
	if (modelheight >= 2) {
		high = TRUE;
	}
	oldposition[1] += self->game->constWallDistance;
	newposition[1] += self->game->constWallDistance;
	self->game->reachedwall = FALSE;
	self->game->reachedwall_1blockhigh = FALSE;
	self->game->reachedHalfBlock = FALSE;
	self->tmpPlayerPosition[0] = oldposition[0];
	self->tmpPlayerPosition[1] = oldposition[1];
	self->tmpPlayerPosition[2] = oldposition[2];
	self->tmpBlockingBlockType->value = 0;
	if (ScriptCharacterPhysics_IsEmptySpaceForPlayer(self, high, newposition[0], self->tmpPlayerPosition[1], self->tmpPlayerPosition[2], self->tmpBlockingBlockType)) {
		self->tmpPlayerPosition[0] = newposition[0];
	}
	else {
		self->game->reachedwall = TRUE;
		if (ScriptCharacterPhysics_IsEmptyPoint(self, newposition[0], self->tmpPlayerPosition[1] + 0.5f, self->tmpPlayerPosition[2], NULL)) {
			self->game->reachedwall_1blockhigh = TRUE;
			if (self->game->blocktypes[self->tmpBlockingBlockType->value]->drawType == 11) {
				self->game->reachedHalfBlock = TRUE;
			}
			if (ScriptCharacterPhysics_StandingOnHalfBlock(self, newposition[0], self->tmpPlayerPosition[1], self->tmpPlayerPosition[2])) {
				self->game->reachedHalfBlock = TRUE;
			}
		}
	}
	if (ScriptCharacterPhysics_IsEmptySpaceForPlayer(self, high, self->tmpPlayerPosition[0], newposition[1], self->tmpPlayerPosition[2], self->tmpBlockingBlockType)) {
		self->tmpPlayerPosition[1] = newposition[1];
	}
	if (ScriptCharacterPhysics_IsEmptySpaceForPlayer(self, high, self->tmpPlayerPosition[0], self->tmpPlayerPosition[1], newposition[2], self->tmpBlockingBlockType)) {
		self->tmpPlayerPosition[2] = newposition[2];
	}
	else {
		self->game->reachedwall = TRUE;
		if (ScriptCharacterPhysics_IsEmptyPoint(self, self->tmpPlayerPosition[0], self->tmpPlayerPosition[1] + 0.5f, newposition[2], NULL)) {
			self->game->reachedwall_1blockhigh = TRUE;
			if (self->game->blocktypes[self->tmpBlockingBlockType->value]->drawType == 11) {
				self->game->reachedHalfBlock = TRUE;
			}
			if (ScriptCharacterPhysics_StandingOnHalfBlock(self, self->tmpPlayerPosition[0], self->tmpPlayerPosition[1], newposition[2])) {
				self->game->reachedHalfBlock = TRUE;
			}
		}
	}
	self->isplayeronground = self->tmpPlayerPosition[1] == oldposition[1] && newposition[1] < oldposition[1];
	self->tmpPlayerPosition[1] -= self->game->constWallDistance;
	return self->tmpPlayerPosition;
}

static void ScriptManager_Construct(ScriptManager *self, const ScriptManagerVtbl *vtbl)
{
	self->vtbl = vtbl;
}

static void SendPacketAction_Construct(SendPacketAction *self, const Action_Vtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_SendPacketAction;
	Action__Construct(&self->base, vtbl);
}

SendPacketAction *SendPacketAction_New(void)
{
	SendPacketAction *self = (SendPacketAction *) malloc(sizeof(SendPacketAction));
	if (self != NULL)
		SendPacketAction_Construct(self, NULL);
	return self;
}

void SendPacketAction_Delete(SendPacketAction *self)
{
	free(self);
}

SendPacketAction const *SendPacketAction_Create(ServerSimple const *server_, int client_, Packet_Server const *packet_)
{
	SendPacketAction *a = SendPacketAction_New();
	a->server = server_;
	a->client = client_;
	a->packet = packet_;
	return a;
}

void SendPacketAction_Run(SendPacketAction const *self)
{
	ServerSimple_SendPacket(self->server, self->client, self->packet);
}

static void ServerCi_Construct(ServerCi *self)
{
	self->one = 1;
	self->mainSocketsCount = 3;
}

ServerCi *ServerCi_New(void)
{
	ServerCi *self = (ServerCi *) malloc(sizeof(ServerCi));
	if (self != NULL)
		ServerCi_Construct(self);
	return self;
}

void ServerCi_Delete(ServerCi *self)
{
	free(self);
}

static void ServerInformation_Construct(ServerInformation *self)
{
	self->serverName = "";
	self->serverMotd = "";
	self->connectdata = ConnectData_New();
	self->serverPing = Ping__New();
}

ServerInformation *ServerInformation_New(void)
{
	ServerInformation *self = (ServerInformation *) malloc(sizeof(ServerInformation));
	if (self != NULL)
		ServerInformation_Construct(self);
	return self;
}

void ServerInformation_Delete(ServerInformation *self)
{
	free(self);
}

ServerOnList *ServerOnList_New(void)
{
	ServerOnList *self = (ServerOnList *) malloc(sizeof(ServerOnList));
	return self;
}

void ServerOnList_Delete(ServerOnList *self)
{
	free(self);
}

static Packet_Server const *ServerPackets_AnswerQuery(Packet_ServerQueryAnswer *answer)
{
	Packet_Server *p = Packet_Server_New();
	p->id = 64;
	p->queryAnswer = answer;
	return p;
}

Packet_Server const *ServerPackets_BlockType(int id, Packet_BlockType *blockType)
{
	Packet_Server *p = Packet_Server_New();
	p->id = 56;
	p->blockType = Packet_ServerBlockType_New();
	p->blockType->id = id;
	p->blockType->blocktype = blockType;
	return p;
}

Packet_Server const *ServerPackets_BlockTypes(void)
{
	Packet_Server *p = Packet_Server_New();
	p->id = 27;
	p->blockTypes = Packet_ServerBlockTypes_New();
	return p;
}

Packet_Server const *ServerPackets_ChunkPart(unsigned char const *compressedChunkPart)
{
	Packet_Server *p = Packet_Server_New();
	p->id = 57;
	p->chunkPart = Packet_ServerChunkPart_New();
	p->chunkPart->compressedChunkPart = compressedChunkPart;
	return p;
}

Packet_Server const *ServerPackets_Chunk_(int x, int y, int z, int chunksize)
{
	Packet_Server *p = Packet_Server_New();
	p->id = 15;
	p->chunk_ = Packet_ServerChunk_New();
	p->chunk_->x = x;
	p->chunk_->y = y;
	p->chunk_->z = z;
	p->chunk_->sizeX = chunksize;
	p->chunk_->sizeY = chunksize;
	p->chunk_->sizeZ = chunksize;
	return p;
}

static Packet_Server const *ServerPackets_DisconnectPlayer(const char *disconnectReason)
{
	Packet_Server *p = Packet_Server_New();
	p->id = 14;
	p->disconnectPlayer = Packet_ServerDisconnectPlayer_New();
	p->disconnectPlayer->disconnectReason = disconnectReason;
	return p;
}

static Packet_Server const *ServerPackets_EntityDespawn(int id)
{
	Packet_Server *p = Packet_Server_New();
	p->id = 68;
	p->entityDespawn = Packet_ServerEntityDespawn_New();
	p->entityDespawn->id = id;
	return p;
}

static Packet_Server const *ServerPackets_EntityPositionAndOrientation(int id, Packet_PositionAndOrientation *positionAndOrientation)
{
	Packet_Server *p = Packet_Server_New();
	p->id = 67;
	p->entityPosition = Packet_ServerEntityPositionAndOrientation_New();
	p->entityPosition->id = id;
	p->entityPosition->positionAndOrientation = positionAndOrientation;
	return p;
}

static Packet_Server const *ServerPackets_EntitySpawn(int id, Packet_ServerEntity *entity)
{
	Packet_Server *p = Packet_Server_New();
	p->id = 66;
	p->entitySpawn = Packet_ServerEntitySpawn_New();
	p->entitySpawn->id = id;
	p->entitySpawn->entity_ = entity;
	return p;
}

Packet_Server const *ServerPackets_Identification(int assignedClientId, int mapSizeX, int mapSizeY, int mapSizeZ, const char *version)
{
	Packet_Server *p = Packet_Server_New();
	p->id = 0;
	p->identification = Packet_ServerIdentification_New();
	p->identification->assignedClientId = assignedClientId;
	p->identification->mapSizeX = mapSizeX;
	p->identification->mapSizeY = mapSizeY;
	p->identification->mapSizeZ = mapSizeZ;
	p->identification->serverName = "Simple";
	p->identification->mdProtocolVersion = version;
	return p;
}

static Packet_Server const *ServerPackets_Inventory(Packet_Inventory *inventory)
{
	Packet_Server *p = Packet_Server_New();
	p->id = 16;
	p->inventory = Packet_ServerInventory_New();
	p->inventory->inventory = inventory;
	return p;
}

Packet_Server const *ServerPackets_LevelFinalize(void)
{
	Packet_Server *p = Packet_Server_New();
	p->id = 4;
	p->levelFinalize = Packet_ServerLevelFinalize_New();
	return p;
}

Packet_Server const *ServerPackets_LevelInitialize(void)
{
	Packet_Server *p = Packet_Server_New();
	p->id = 2;
	p->levelInitialize = Packet_ServerLevelInitialize_New();
	return p;
}

Packet_Server const *ServerPackets_Message(const char *text)
{
	Packet_Server *p = Packet_Server_New();
	p->id = 13;
	p->message = Packet_ServerMessage_New();
	p->message->message = text;
	return p;
}

static Packet_Server const *ServerPackets_Ping(void)
{
	Packet_Server *p = Packet_Server_New();
	p->id = 1;
	p->ping = Packet_ServerPing_New();
	return p;
}

static Packet_Server const *ServerPackets_PlayerStats(int health, int maxHealth, int oxygen, int maxOxygen)
{
	Packet_Server *p = Packet_Server_New();
	p->id = 23;
	p->playerStats = Packet_ServerPlayerStats_New();
	p->playerStats->currentHealth = health;
	p->playerStats->maxHealth = maxHealth;
	p->playerStats->currentOxygen = oxygen;
	p->playerStats->maxOxygen = maxOxygen;
	return p;
}

unsigned char const *ServerPackets_Serialize(Packet_Server const *packet, IntRef *retLength)
{
	CitoMemoryStream const *ms = CitoMemoryStream_New();
	unsigned char const *data;
	Packet_ServerSerializer_Serialize(&ms->base, packet);
	data = CitoMemoryStream_ToArray(ms);
	retLength->value = CitoMemoryStream_Length(ms);
	return data;
}

static Packet_Server const *ServerPackets_SetBlock(int x, int y, int z, int block)
{
	Packet_Server *p = Packet_Server_New();
	p->id = 6;
	p->setBlock = Packet_ServerSetBlock_New();
	p->setBlock->x = x;
	p->setBlock->y = y;
	p->setBlock->z = z;
	p->setBlock->blockType = block;
	return p;
}

static void ServerSimple_Construct(ServerSimple *self)
{
	ModManagerSimple1 *m;
	self->one = 1;
	self->clients = (ClientSimple const **) malloc(256 * sizeof(ClientSimple const *));
	self->clientsCount = 0;
	self->blockTypes = (Packet_BlockType const **) malloc(1024 * sizeof(Packet_BlockType const *));
	self->blockTypesCount = 0;
	self->mods = (ModSimple const **) malloc(128 * sizeof(ModSimple const *));
	m = ModManagerSimple1_New();
	ModManagerSimple1_Start(m, self);
	self->mods[self->modsCount++] = &ModSimpleDefault_New()->base;
	self->mods[self->modsCount++] = &ModSimpleWorldGenerator_New()->base;
	{
		int i;
		for (i = 0; i < self->modsCount; i++) {
			self->mods[i]->vtbl->start(self->mods[i], &m->base);
		}
	}
	self->mapSizeX = 8192;
	self->mapSizeY = 8192;
	self->mapSizeZ = 128;
	self->chunks = (ChunkSimple const *const **) malloc(self->mapSizeX / 32 * self->mapSizeY / 32 * sizeof(ChunkSimple const *const *));
	self->chunkdrawdistance = 4;
	self->actions = QueueAction_New();
	self->mainThreadActions = QueueAction_New();
	self->spawnGlX = self->mapSizeX / 2;
	self->spawnGlY = self->mapSizeZ;
	{
		int i;
		for (i = 0; i < self->modsCount; i++) {
			int spawnHeight = self->mods[i]->vtbl->getHeight(self->mods[i]);
			if (spawnHeight != -1) {
				self->spawnGlY = spawnHeight;
			}
		}
	}
	self->spawnGlZ = self->mapSizeY / 2;
}

ServerSimple *ServerSimple_New(void)
{
	ServerSimple *self = (ServerSimple *) malloc(sizeof(ServerSimple));
	if (self != NULL)
		ServerSimple_Construct(self);
	return self;
}

void ServerSimple_Delete(ServerSimple *self)
{
	free(self);
}

static void ServerSimple_Move(ServerSimple const *self, QueueAction *from, QueueAction *to)
{
	int count;
	self->platform->vtbl->monitorEnter(self->platform, self->mainThreadActionsLock);
	count = from->count;
	{
		int i;
		for (i = 0; i < count; i++) {
			Action_ const *task = QueueAction_Dequeue(from);
			QueueAction_Enqueue(to, task);
		}
	}
	self->platform->vtbl->monitorExit(self->platform, self->mainThreadActionsLock);
}

static void ServerSimple_NotifyInventory(ServerSimple const *self)
{
	{
		int i;
		for (i = 0; i < self->clientsCount; i++) {
			if (self->clients[i] == NULL) {
				continue;
			}
			if (!self->clients[i]->connected) {
				continue;
			}
			if (!self->clients[i]->inventoryDirty) {
				continue;
			}
			ServerSimple_SendPacket(self, i, ServerPackets_Inventory(self->clients[i]->inventory));
			self->clients[i]->inventoryDirty = FALSE;
		}
	}
}

static void ServerSimple_NotifyMap(ServerSimple const *self)
{
	{
		int i;
		for (i = 0; i < self->clientsCount; i++) {
			if (self->clients[i] == NULL) {
				continue;
			}
			if (!self->clients[i]->connected) {
				continue;
			}
			if (self->clients[i]->notifyMapAction == NULL) {
				NotifyMapAction *notify = NotifyMapAction_New();
				notify->server = self;
				notify->clientId = i;
				self->clients[i]->notifyMapAction = &notify->base;
				self->platform->vtbl->queueUserWorkItem(self->platform, &notify->base);
			}
		}
	}
}

static void ServerSimple_NotifyPing(ServerSimple const *self)
{
	{
		int i;
		for (i = 0; i < self->clientsCount; i++) {
			int now;
			if (self->clients[i] == NULL) {
				continue;
			}
			now = self->platform->vtbl->timeMillisecondsFromStart(self->platform);
			if (now - self->clients[i]->pingLastMilliseconds > 1000) {
				ServerSimple_SendPacket(self, i, ServerPackets_Ping());
				self->clients[i]->pingLastMilliseconds = now;
			}
		}
	}
}

static void ServerSimple_ProcessActions(ServerSimple const *self)
{
	ServerSimple_Move(self, self->mainThreadActions, self->actions);
	while (QueueAction_Count(self->actions) > 0) {
		Action_ const *a = QueueAction_Dequeue(self->actions);
		a->vtbl->run(a);
	}
}

static void ServerSimple_ProcessPacket(ServerSimple const *self, int client, Packet_Client const *packet)
{
	switch (Packet_Client_GetId(packet)) {
	case 0:
		{
			if (packet->identification == NULL) {
				return;
			}
			ServerSimple_SendPacket(self, client, ServerPackets_Identification(0, self->mapSizeX, self->mapSizeY, self->mapSizeZ, self->platform->vtbl->getGameVersion(self->platform)));
			self->clients[client]->name = packet->identification->username;
		}
		break;
	case 50:
		{
			ServerSimple_SendPacket(self, client, ServerPackets_LevelInitialize());
			{
				int i;
				for (i = 0; i < self->blockTypesCount; i++) {
					Packet_BlockType *blocktype = self->blockTypes[i];
					if (blocktype == NULL) {
						blocktype = Packet_BlockType_New();
					}
					ServerSimple_SendPacket(self, client, ServerPackets_BlockType(i, blocktype));
				}
			}
			ServerSimple_SendPacket(self, client, ServerPackets_BlockTypes());
			ServerSimple_SendPacket(self, client, ServerPackets_LevelFinalize());
			{
				int i;
				for (i = 0; i < self->clientsCount; i++) {
					Packet_PositionAndOrientation *pos;
					Packet_ServerEntity *e;
					if (self->clients[i] == NULL) {
						continue;
					}
					self->clients[i]->glX = self->spawnGlX;
					self->clients[i]->glY = self->spawnGlY;
					self->clients[i]->glZ = self->spawnGlZ;
					pos = Packet_PositionAndOrientation_New();
					pos->x = self->platform->vtbl->floatToInt(self->platform, 32 * self->clients[i]->glX);
					pos->y = self->platform->vtbl->floatToInt(self->platform, 32 * self->clients[i]->glY);
					pos->z = self->platform->vtbl->floatToInt(self->platform, 32 * self->clients[i]->glZ);
					pos->pitch = 127;
					e = Packet_ServerEntity_New();
					e->drawModel = Packet_ServerEntityAnimatedModel_New();
					e->drawModel->model_ = "player.txt";
					e->drawModel->modelHeight = self->platform->vtbl->floatToInt(self->platform, self->one * 17 / 10 * 32);
					e->drawModel->eyeHeight = self->platform->vtbl->floatToInt(self->platform, self->one * 15 / 10 * 32);
					e->position = pos;
					ServerSimple_SendPacket(self, client, ServerPackets_EntitySpawn(0, e));
					ServerSimple_SendPacket(self, client, ServerPackets_PlayerStats(100, 100, 100, 100));
				}
			}
			{
				int i;
				for (i = 0; i < self->modsCount; i++) {
					self->mods[i]->vtbl->onPlayerJoin(self->mods[i], client);
				}
			}
			self->clients[client]->connected = TRUE;
		}
		break;
	case 13:
		{
			ServerSimple_SendPacketToAll(self, ServerPackets_Message(self->platform->vtbl->stringFormat2(self->platform, "{0}: &f{1}", self->clients[client]->name, packet->message->message)));
		}
		break;
	case 5:
		{
			int x = packet->setBlock->x;
			int y = packet->setBlock->y;
			int z = packet->setBlock->z;
			int block = packet->setBlock->blockType;
			int mode = packet->setBlock->mode;
			if (mode == 1) {
			}
			if (mode == 0) {
				ServerSimple_SendPacketToAll(self, ServerPackets_SetBlock(x, y, z, 0));
			}
			if (mode == 2) {
			}
			if (mode == 3) {
			}
		}
		break;
	case 8:
		{
			self->clients[client]->glX = self->one * packet->positionAndOrientation->x / 32;
			self->clients[client]->glY = self->one * packet->positionAndOrientation->y / 32;
			self->clients[client]->glZ = self->one * packet->positionAndOrientation->z / 32;
		}
		break;
	case 51:
		{
			switch (packet->inventoryAction->action) {
			case 0:
				break;
			}
		}
		break;
	}
}

static void ServerSimple_ProcessPackets(ServerSimple *self)
{
	for (;;) {
		NetIncomingMessage const *msg = self->server->vtbl->readMessage(self->server);
		if (msg == NULL) {
			return;
		}
		switch (msg->type) {
			ClientSimple *c;
			unsigned char *data;
			Packet_Client *packet;
		case NetworkMessageType_CONNECT:
			c = ClientSimple_New();
			c->mainSocket = self->server;
			c->connection = msg->senderConnection;
			c->chunksseen = (cibool const **) malloc(self->mapSizeX / 32 * self->mapSizeY / 32 * sizeof(cibool const *));
			self->clients[0] = c;
			self->clientsCount = 1;
			break;
		case NetworkMessageType_DATA:
			data = msg->message;
			packet = Packet_Client_New();
			Packet_ClientSerializer_DeserializeBuffer(data, msg->messageLength, packet);
			ServerSimple_ProcessPacket(self, 0, packet);
			break;
		case NetworkMessageType_DISCONNECT:
			break;
		}
	}
}

void ServerSimple_QueueMainThreadAction(ServerSimple const *self, Action_ const *action)
{
	self->platform->vtbl->monitorEnter(self->platform, self->mainThreadActionsLock);
	QueueAction_Enqueue(self->mainThreadActions, action);
	self->platform->vtbl->monitorExit(self->platform, self->mainThreadActionsLock);
}

void ServerSimple_SendPacket(ServerSimple const *self, int client, Packet_Server const *packet)
{
	IntRef *length = IntRef_New();
	unsigned char const *data = ServerPackets_Serialize(packet, length);
	INetOutgoingMessage *msg = INetOutgoingMessage_New();
	INetOutgoingMessage_Write(msg, data, length->value);
	self->clients[client]->connection->vtbl->sendMessage(self->clients[client]->connection, msg, MyNetDeliveryMethod_RELIABLE_ORDERED, 0);
}

static void ServerSimple_SendPacketToAll(ServerSimple const *self, Packet_Server const *packet)
{
	{
		int i;
		for (i = 0; i < self->clientsCount; i++) {
			ServerSimple_SendPacket(self, i, packet);
		}
	}
}

void ServerSimple_Start(ServerSimple *self, NetServer const *server_, const char *saveFilename_, GamePlatform const *platform_)
{
	self->server = server_;
	self->saveFilename = saveFilename_;
	self->platform = platform_;
	self->mainThreadActionsLock = self->platform->vtbl->monitorCreate(self->platform);
}

void ServerSimple_Update(ServerSimple *self)
{
	ServerSimple_ProcessPackets(self);
	ServerSimple_NotifyMap(self);
	ServerSimple_NotifyInventory(self);
	ServerSimple_NotifyPing(self);
	ServerSimple_ProcessActions(self);
}

static void Sound__Construct(Sound_ *self)
{
	self->name = NULL;
	self->x = 0;
	self->y = 0;
	self->z = 0;
	self->loop = FALSE;
	self->stop = FALSE;
	self->audio = NULL;
}

Sound_ *Sound__New(void)
{
	Sound_ *self = (Sound_ *) malloc(sizeof(Sound_));
	if (self != NULL)
		Sound__Construct(self);
	return self;
}

void Sound__Delete(Sound_ *self)
{
	free(self);
}

Speculative *Speculative_New(void)
{
	Speculative *self = (Speculative *) malloc(sizeof(Speculative));
	return self;
}

void Speculative_Delete(Speculative *self)
{
	free(self);
}

int *SphereModelData_CalculateElements(float radius, float height, int segments, int rings)
{
	int i = 0;
	int *data = (int *) malloc(segments * rings * 6 * sizeof(int ));
	{
		int y;
		for (y = 0; y < rings - 1; y++) {
			{
				int x;
				for (x = 0; x < segments - 1; x++) {
					data[i++] = (y + 0) * segments + x;
					data[i++] = (y + 1) * segments + x;
					data[i++] = (y + 1) * segments + x + 1;
					data[i++] = (y + 1) * segments + x + 1;
					data[i++] = (y + 0) * segments + x + 1;
					data[i++] = (y + 0) * segments + x;
				}
			}
		}
	}
	return data;
}

static float SphereModelData_GetPi(void)
{
	float a = 3141592;
	return a / 1000000;
}

ModelData const *SphereModelData_GetSphereModelData(float radius, float height, int segments, int rings)
{
	int i = 0;
	float *xyz = (float *) malloc(rings * segments * 3 * sizeof(float ));
	float *uv = (float *) malloc(rings * segments * 2 * sizeof(float ));
	unsigned char *rgba = (unsigned char *) malloc(rings * segments * 4 * sizeof(unsigned char ));
	ModelData *data;
	{
		int y;
		for (y = 0; y < rings; y++) {
			float yFloat = y;
			float phiFloat = yFloat / (rings - 1) * SphereModelData_GetPi();
			{
				int x;
				for (x = 0; x < segments; x++) {
					float xFloat = x;
					float thetaFloat = xFloat / (segments - 1) * 2 * SphereModelData_GetPi();
					float vxFloat = radius * Platform_Sin(phiFloat) * Platform_Cos(thetaFloat);
					float vyFloat = height * Platform_Cos(phiFloat);
					float vzFloat = radius * Platform_Sin(phiFloat) * Platform_Sin(thetaFloat);
					float uFloat = xFloat / (segments - 1);
					float vFloat = yFloat / (rings - 1);
					xyz[i * 3 + 0] = vxFloat;
					xyz[i * 3 + 1] = vyFloat;
					xyz[i * 3 + 2] = vzFloat;
					uv[i * 2 + 0] = uFloat;
					uv[i * 2 + 1] = vFloat;
					rgba[i * 4 + 0] = 255;
					rgba[i * 4 + 1] = 255;
					rgba[i * 4 + 2] = 255;
					rgba[i * 4 + 3] = 255;
					i++;
				}
			}
		}
	}
	data = ModelData_New();
	ModelData_SetVerticesCount(data, segments * rings);
	ModelData_SetIndicesCount(data, segments * rings * 6);
	ModelData_setXyz(data, xyz);
	ModelData_setUv(data, uv);
	ModelData_setRgba(data, rgba);
	ModelData_setIndices(data, SphereModelData_CalculateElements(radius, height, segments, rings));
	return data;
}

static void Sprite_Construct(Sprite *self)
{
	self->size = 40;
}

Sprite *Sprite_New(void)
{
	Sprite *self = (Sprite *) malloc(sizeof(Sprite));
	if (self != NULL)
		Sprite_Construct(self);
	return self;
}

void Sprite_Delete(Sprite *self)
{
	free(self);
}

static void StackMatrix4_Construct(StackMatrix4 *self)
{
	self->values = (float const **) malloc(1024 * sizeof(float const *));
	{
		int i;
		for (i = 0; i < 1024; i++) {
			self->values[i] = Mat4_Create();
		}
	}
}

StackMatrix4 *StackMatrix4_New(void)
{
	StackMatrix4 *self = (StackMatrix4 *) malloc(sizeof(StackMatrix4));
	if (self != NULL)
		StackMatrix4_Construct(self);
	return self;
}

void StackMatrix4_Delete(StackMatrix4 *self)
{
	free(self);
}

static int StackMatrix4_Count(StackMatrix4 const *self)
{
	return self->count_;
}

static float *StackMatrix4_Peek(StackMatrix4 const *self)
{
	return self->values[self->count_ - 1];
}

static float const *StackMatrix4_Pop(StackMatrix4 *self)
{
	float const *ret = self->values[self->count_ - 1];
	self->count_--;
	return ret;
}

static void StackMatrix4_Push(StackMatrix4 *self, float const *p)
{
	Mat4_Copy(self->values[self->count_], p);
	self->count_++;
}

static StringByteArray *StringByteArray_New(void)
{
	StringByteArray *self = (StringByteArray *) malloc(sizeof(StringByteArray));
	return self;
}

const char *StringTools_StringAppend(GamePlatform const *p, const char *a, const char *b)
{
	IntRef const *aLength = IntRef_New();
	int const *aChars = p->vtbl->stringToCharArray(p, a, aLength);
	IntRef const *bLength = IntRef_New();
	int const *bChars = p->vtbl->stringToCharArray(p, b, bLength);
	int *cChars = (int *) malloc((aLength->value + bLength->value) * sizeof(int ));
	{
		int i;
		for (i = 0; i < aLength->value; i++) {
			cChars[i] = aChars[i];
		}
	}
	{
		int i;
		for (i = 0; i < bLength->value; i++) {
			cChars[i + aLength->value] = bChars[i];
		}
	}
	return p->vtbl->charArrayToString(p, cChars, aLength->value + bLength->value);
}

int StringTools_StringLength(GamePlatform const *p, const char *a)
{
	IntRef const *aLength = IntRef_New();
	int const *aChars = p->vtbl->stringToCharArray(p, a, aLength);
	return aLength->value;
}

cibool StringTools_StringStartsWith(GamePlatform const *p, const char *s, const char *b)
{
	return strcmp(StringTools_StringSubstring(p, s, 0, StringTools_StringLength(p, b)), b) == 0;
}

const char *StringTools_StringSubstring(GamePlatform const *p, const char *a, int start, int count)
{
	IntRef const *aLength = IntRef_New();
	int const *aChars = p->vtbl->stringToCharArray(p, a, aLength);
	int *bChars = (int *) malloc(count * sizeof(int ));
	{
		int i;
		for (i = 0; i < count; i++) {
			bChars[i] = aChars[start + i];
		}
	}
	return p->vtbl->charArrayToString(p, bChars, count);
}

const char *StringTools_StringSubstringToEnd(GamePlatform const *p, const char *a, int start)
{
	return StringTools_StringSubstring(p, a, start, StringTools_StringLength(p, a) - start);
}

static void SunMoonRenderer_Construct(SunMoonRenderer *self, const ClientModVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_SunMoonRenderer;
	ClientMod_Construct(&self->base, vtbl);
	self->one = 1;
	self->hour = 6;
	self->t = 0;
	self->suntexture = -1;
	self->moontexture = -1;
	self->imageSize = 96;
	self->day_length_in_seconds = 30;
}

SunMoonRenderer *SunMoonRenderer_New(void)
{
	SunMoonRenderer *self = (SunMoonRenderer *) malloc(sizeof(SunMoonRenderer));
	if (self != NULL)
		SunMoonRenderer_Construct(self, NULL);
	return self;
}

void SunMoonRenderer_Delete(SunMoonRenderer *self)
{
	free(self);
}

int SunMoonRenderer_GetHour(SunMoonRenderer const *self)
{
	return self->hour;
}

void SunMoonRenderer_OnNewFrameDraw3d(SunMoonRenderer *self, Game *game, float dt)
{
	GamePlatform const *platform = game->platform;
	float posX;
	float posY;
	float posZ;
	Game_GLMatrixModeModelView(game);
	if (self->suntexture == -1) {
		self->suntexture = Game_GetTexture(game, "sun.png");
		self->moontexture = Game_GetTexture(game, "moon.png");
	}
	SunMoonRenderer_UpdateSunMoonPosition(self, game, dt);
	if (!game->isNight) {
		posX = game->sunPositionX;
		posY = game->sunPositionY;
		posZ = game->sunPositionZ;
	}
	else {
		posX = game->moonPositionX;
		posY = game->moonPositionY;
		posZ = game->moonPositionZ;
	}
	posX += game->player->position->x;
	posY += game->player->position->y;
	posZ += game->player->position->z;
	Game_GLPushMatrix(game);
	Game_GLTranslate(game, posX, posY, posZ);
	ModDrawSprites_Billboard(game);
	Game_GLScale(game, self->one * 2 / 100, self->one * 2 / 100, self->one * 2 / 100);
	Game_Draw2dTexture(game, game->isNight ? self->moontexture : self->suntexture, 0, 0, self->imageSize, self->imageSize, NULL, 0, Game_ColorFromArgb(255, 255, 255, 255), FALSE);
	Game_GLPopMatrix(game);
}

void SunMoonRenderer_SetHour(SunMoonRenderer *self, int value)
{
	self->hour = value;
	self->t = (self->hour - 6) / (self->one * 24) * 2 * Game_GetPi();
}

static void SunMoonRenderer_UpdateSunMoonPosition(SunMoonRenderer *self, Game *game, float dt)
{
	self->t += dt * 2 * Game_GetPi() / self->day_length_in_seconds;
	game->isNight = (self->t + 2 * Game_GetPi()) % (2 * Game_GetPi()) > Game_GetPi();
	game->sunPositionX = game->platform->vtbl->mathCos(game->platform, self->t) * 20;
	game->sunPositionY = game->platform->vtbl->mathSin(game->platform, self->t) * 20;
	game->sunPositionZ = game->platform->vtbl->mathSin(game->platform, self->t) * 20;
	game->moonPositionX = game->platform->vtbl->mathCos(game->platform, -self->t) * 20;
	game->moonPositionY = game->platform->vtbl->mathSin(game->platform, -self->t) * 20;
	game->moonPositionZ = game->platform->vtbl->mathSin(game->platform, self->t) * 20;
}

static void TableBinding_Construct(TableBinding *self, const TableBindingVtbl *vtbl)
{
	self->vtbl = vtbl;
}

void TableSerializer_Deserialize(TableSerializer const *self, GamePlatform const *p, const char *data, TableBinding const *b)
{
	IntRef const *linesCount = IntRef_New();
	const char *const *lines = p->vtbl->readAllLines(p, data, linesCount);
	const char *const *header = NULL;
	IntRef const *headerLength = IntRef_New();
	const char *current = "";
	int currentI = 0;
	{
		int i;
		for (i = 0; i < linesCount->value; i++) {
			const char *s = p->vtbl->stringTrim(p, lines[i]);
			if (strcmp(s, "") == 0) {
				continue;
			}
			if (p->vtbl->stringStartsWithIgnoreCase(p, s, "//") || p->vtbl->stringStartsWithIgnoreCase(p, s, "#")) {
				continue;
			}
			if (p->vtbl->stringStartsWithIgnoreCase(p, s, "section=")) {
				const char *sHeader;
				current = p->vtbl->stringReplace(p, s, "section=", "");
				sHeader = p->vtbl->stringTrim(p, lines[i + 1]);
				header = p->vtbl->stringSplit(p, sHeader, "\t", headerLength);
				i++;
				currentI = 0;
				continue;
			}
			{
				IntRef const *ssLength;
				const char *const *ss;
				if (header == NULL) {
					continue;
				}
				ssLength = IntRef_New();
				ss = p->vtbl->stringSplit(p, s, "\t", ssLength);
				{
					int k;
					for (k = 0; k < ssLength->value; k++) {
						b->vtbl->set(b, current, currentI, header[k], ss[k]);
					}
				}
				currentI++;
			}
		}
	}
}

static void TaskScheduler_Construct(TaskScheduler *self)
{
	self->actions = NULL;
}

TaskScheduler *TaskScheduler_New(void)
{
	TaskScheduler *self = (TaskScheduler *) malloc(sizeof(TaskScheduler));
	if (self != NULL)
		TaskScheduler_Construct(self);
	return self;
}

void TaskScheduler_Delete(TaskScheduler *self)
{
	free(self);
}

void TaskScheduler_Update(TaskScheduler *self, Game const *game, float dt)
{
	if (self->actions == NULL) {
		self->actions = (BackgroundAction const **) malloc(game->clientmodsCount * sizeof(BackgroundAction const *));
		{
			int i;
			for (i = 0; i < game->clientmodsCount; i++) {
				self->actions[i] = BackgroundAction_New();
			}
		}
	}
	if (game->platform->vtbl->multithreadingAvailable(game->platform)) {
		cibool allDone;
		{
			int i;
			for (i = 0; i < game->clientmodsCount; i++) {
				game->clientmods[i]->vtbl->onReadOnlyMainThread(game->clientmods[i], game, dt);
			}
		}
		allDone = TRUE;
		{
			int i;
			for (i = 0; i < game->clientmodsCount; i++) {
				if (self->actions[i] != NULL && self->actions[i]->active && !self->actions[i]->finished) {
					allDone = FALSE;
				}
			}
		}
		if (allDone) {
			{
				int i;
				for (i = 0; i < game->clientmodsCount; i++) {
					game->clientmods[i]->vtbl->onReadWriteMainThread(game->clientmods[i], game, dt);
				}
			}
			{
				int i;
				for (i = 0; i < game->commitActions->count; i++) {
					game->commitActions->items[i]->vtbl->run(game->commitActions->items[i]);
				}
			}
			ListAction_Clear(game->commitActions);
			{
				int i;
				for (i = 0; i < game->clientmodsCount; i++) {
					BackgroundAction *a = self->actions[i];
					a->game = game;
					a->dt = dt;
					a->i = i;
					a->active = TRUE;
					a->finished = FALSE;
					game->platform->vtbl->queueUserWorkItem(game->platform, &a->base);
				}
			}
		}
	}
	else {
		{
			int i;
			for (i = 0; i < game->clientmodsCount; i++) {
				game->clientmods[i]->vtbl->onReadOnlyMainThread(game->clientmods[i], game, dt);
			}
		}
		{
			int i;
			for (i = 0; i < game->clientmodsCount; i++) {
				game->clientmods[i]->vtbl->onReadOnlyBackgroundThread(game->clientmods[i], game, dt);
			}
		}
		{
			int i;
			for (i = 0; i < game->clientmodsCount; i++) {
				game->clientmods[i]->vtbl->onReadWriteMainThread(game->clientmods[i], game, dt);
			}
		}
		{
			int i;
			for (i = 0; i < game->commitActions->count; i++) {
				game->commitActions->items[i]->vtbl->run(game->commitActions->items[i]);
			}
		}
		ListAction_Clear(game->commitActions);
	}
}

static void TcpNetClient_Construct(TcpNetClient *self, const NetClientVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_TcpNetClient;
	NetClient_Construct(&self->base, vtbl);
	self->incoming = QueueByte_New();
	self->data = (unsigned char *) malloc(1024 * sizeof(unsigned char ));
	self->connected = BoolRef_New();
}

TcpNetClient *TcpNetClient_New(void)
{
	TcpNetClient *self = (TcpNetClient *) malloc(sizeof(TcpNetClient));
	if (self != NULL)
		TcpNetClient_Construct(self, NULL);
	return self;
}

void TcpNetClient_Delete(TcpNetClient *self)
{
	free(self);
}

NetConnection const *TcpNetClient_Connect(TcpNetClient const *self, const char *ip, int port)
{
	self->platform->vtbl->tcpConnect(self->platform, ip, port, self->connected);
	return NULL;
}

static void TcpNetClient_DoSendPacket(TcpNetClient const *self, INetOutgoingMessage const *msg)
{
	unsigned char *packet = (unsigned char *) malloc((msg->messageLength + 4) * sizeof(unsigned char ));
	TcpNetClient_WriteInt(self, packet, 0, msg->messageLength);
	{
		int i;
		for (i = 0; i < msg->messageLength; i++) {
			packet[i + 4] = msg->message[i];
		}
	}
	self->platform->vtbl->tcpSend(self->platform, packet, msg->messageLength + 4);
}

static NetIncomingMessage const *TcpNetClient_GetMessage(TcpNetClient const *self)
{
	if (self->incoming->count >= 4) {
		unsigned char *length = (unsigned char *) malloc(4 * sizeof(unsigned char ));
		int messageLength;
		QueueByte_PeekRange(self->incoming, length, 4);
		messageLength = TcpNetClient_ReadInt(self, length, 0);
		if (self->incoming->count >= 4 + messageLength) {
			NetIncomingMessage *msg;
			QueueByte_DequeueRange(self->incoming, (unsigned char *) malloc(4 * sizeof(unsigned char )), 4);
			msg = NetIncomingMessage_New();
			msg->message = (unsigned char *) malloc(messageLength * sizeof(unsigned char ));
			msg->messageLength = messageLength;
			QueueByte_DequeueRange(self->incoming, msg->message, msg->messageLength);
			return msg;
		}
	}
	return NULL;
}

static int TcpNetClient_ReadInt(TcpNetClient const *self, unsigned char const *readBuf, int readPos)
{
	int n = readBuf[readPos] << 24;
	n |= readBuf[readPos + 1] << 16;
	n |= readBuf[readPos + 2] << 8;
	n |= readBuf[readPos + 3];
	return n;
}

NetIncomingMessage const *TcpNetClient_ReadMessage(TcpNetClient const *self)
{
	NetIncomingMessage const *message;
	if (self->connected->value) {
		while (QueueINetOutgoingMessage_Count(self->tosend) > 0) {
			INetOutgoingMessage const *msg = QueueINetOutgoingMessage_Dequeue(self->tosend);
			TcpNetClient_DoSendPacket(self, msg);
		}
	}
	message = TcpNetClient_GetMessage(self);
	if (message != NULL) {
		return message;
	}
	{
		int k;
		for (k = 0; k < 1; k++) {
			int received = self->platform->vtbl->tcpReceive(self->platform, self->data, 1024);
			if (received <= 0) {
				break;
			}
			{
				int i;
				for (i = 0; i < received; i++) {
					QueueByte_Enqueue(self->incoming, self->data[i]);
				}
			}
		}
	}
	message = TcpNetClient_GetMessage(self);
	if (message != NULL) {
		return message;
	}
	return NULL;
}

void TcpNetClient_SendMessage(TcpNetClient const *self, INetOutgoingMessage const *message, MyNetDeliveryMethod method)
{
	INetOutgoingMessage const *msg = message;
	if (!self->connected->value) {
		QueueINetOutgoingMessage_Enqueue(self->tosend, msg);
		return;
	}
	TcpNetClient_DoSendPacket(self, msg);
}

void TcpNetClient_SetPlatform(TcpNetClient *self, GamePlatform const *platform_)
{
	self->platform = platform_;
}

void TcpNetClient_Start(TcpNetClient *self)
{
	self->tosend = QueueINetOutgoingMessage_New();
}

static void TcpNetClient_WriteInt(TcpNetClient const *self, unsigned char *writeBuf, int writePos, int n)
{
	int a = (n >> 24) & 255;
	int b = (n >> 16) & 255;
	int c = (n >> 8) & 255;
	int d = n & 255;
	writeBuf[writePos] = Game_IntToByte(a);
	writeBuf[writePos + 1] = Game_IntToByte(b);
	writeBuf[writePos + 2] = Game_IntToByte(c);
	writeBuf[writePos + 3] = Game_IntToByte(d);
}

static void TerrainChunkTesselatorCi_Construct(TerrainChunkTesselatorCi *self)
{
	self->enableSmoothLight = TRUE;
	self->eNABLE_TEXTURE_TILING = TRUE;
	self->_colorWhite = Game_ColorFromArgb(255, 255, 255, 255);
	self->blockShadow = 0.6f;
	self->option_DarkenBlockSides = TRUE;
	self->option_DoNotDrawEdges = TRUE;
	self->occ = 0.7f;
	self->halfocc = 0.4f;
	self->tmpnPos = (int *) malloc(7 * sizeof(int ));
	self->tmpshadowration = (int *) malloc(9 * sizeof(int ));
	self->tmpoccupied = (cibool *) malloc(9 * sizeof(cibool ));
	self->tmpfShadowRation = (float *) malloc(4 * sizeof(float ));
	self->tmpv = VecCito3i_New();
	self->ref_blockCornerHeight = (float *) malloc(4 * sizeof(float ));
	self->c_OcclusionNeighbors = (VecCito3i const *const **) malloc(6 * sizeof(VecCito3i const *const *));
	{
		int i;
		for (i = 0; i < 6; i++) {
			self->c_OcclusionNeighbors[i] = (VecCito3i const **) malloc(9 * sizeof(VecCito3i const *));
		}
	}
	self->c_OcclusionNeighbors[0][8] = VecCito3i_CitoCtr(0, 0, 1);
	self->c_OcclusionNeighbors[0][0] = VecCito3i_CitoCtr(0, -1, 1);
	self->c_OcclusionNeighbors[0][1] = VecCito3i_CitoCtr(0, 1, 1);
	self->c_OcclusionNeighbors[0][2] = VecCito3i_CitoCtr(-1, 0, 1);
	self->c_OcclusionNeighbors[0][3] = VecCito3i_CitoCtr(1, 0, 1);
	self->c_OcclusionNeighbors[0][4] = VecCito3i_CitoCtr(-1, -1, 1);
	self->c_OcclusionNeighbors[0][5] = VecCito3i_CitoCtr(1, -1, 1);
	self->c_OcclusionNeighbors[0][6] = VecCito3i_CitoCtr(-1, 1, 1);
	self->c_OcclusionNeighbors[0][7] = VecCito3i_CitoCtr(1, 1, 1);
	self->c_OcclusionNeighbors[2][8] = VecCito3i_CitoCtr(-1, 0, 0);
	self->c_OcclusionNeighbors[2][0] = VecCito3i_CitoCtr(-1, 0, 1);
	self->c_OcclusionNeighbors[2][1] = VecCito3i_CitoCtr(-1, 0, -1);
	self->c_OcclusionNeighbors[2][2] = VecCito3i_CitoCtr(-1, -1, 0);
	self->c_OcclusionNeighbors[2][3] = VecCito3i_CitoCtr(-1, 1, 0);
	self->c_OcclusionNeighbors[2][4] = VecCito3i_CitoCtr(-1, -1, 1);
	self->c_OcclusionNeighbors[2][5] = VecCito3i_CitoCtr(-1, 1, 1);
	self->c_OcclusionNeighbors[2][6] = VecCito3i_CitoCtr(-1, -1, -1);
	self->c_OcclusionNeighbors[2][7] = VecCito3i_CitoCtr(-1, 1, -1);
	self->c_OcclusionNeighbors[1][8] = VecCito3i_CitoCtr(0, 0, -1);
	self->c_OcclusionNeighbors[1][0] = VecCito3i_CitoCtr(0, 1, -1);
	self->c_OcclusionNeighbors[1][1] = VecCito3i_CitoCtr(0, -1, -1);
	self->c_OcclusionNeighbors[1][2] = VecCito3i_CitoCtr(-1, 0, -1);
	self->c_OcclusionNeighbors[1][3] = VecCito3i_CitoCtr(1, 0, -1);
	self->c_OcclusionNeighbors[1][4] = VecCito3i_CitoCtr(-1, 1, -1);
	self->c_OcclusionNeighbors[1][5] = VecCito3i_CitoCtr(1, 1, -1);
	self->c_OcclusionNeighbors[1][6] = VecCito3i_CitoCtr(-1, -1, -1);
	self->c_OcclusionNeighbors[1][7] = VecCito3i_CitoCtr(1, -1, -1);
	self->c_OcclusionNeighbors[3][8] = VecCito3i_CitoCtr(1, 0, 0);
	self->c_OcclusionNeighbors[3][0] = VecCito3i_CitoCtr(1, 0, 1);
	self->c_OcclusionNeighbors[3][1] = VecCito3i_CitoCtr(1, 0, -1);
	self->c_OcclusionNeighbors[3][2] = VecCito3i_CitoCtr(1, 1, 0);
	self->c_OcclusionNeighbors[3][3] = VecCito3i_CitoCtr(1, -1, 0);
	self->c_OcclusionNeighbors[3][4] = VecCito3i_CitoCtr(1, 1, 1);
	self->c_OcclusionNeighbors[3][5] = VecCito3i_CitoCtr(1, -1, 1);
	self->c_OcclusionNeighbors[3][6] = VecCito3i_CitoCtr(1, 1, -1);
	self->c_OcclusionNeighbors[3][7] = VecCito3i_CitoCtr(1, -1, -1);
	self->c_OcclusionNeighbors[4][8] = VecCito3i_CitoCtr(0, -1, 0);
	self->c_OcclusionNeighbors[4][0] = VecCito3i_CitoCtr(0, -1, 1);
	self->c_OcclusionNeighbors[4][1] = VecCito3i_CitoCtr(0, -1, -1);
	self->c_OcclusionNeighbors[4][2] = VecCito3i_CitoCtr(1, -1, 0);
	self->c_OcclusionNeighbors[4][3] = VecCito3i_CitoCtr(-1, -1, 0);
	self->c_OcclusionNeighbors[4][4] = VecCito3i_CitoCtr(1, -1, 1);
	self->c_OcclusionNeighbors[4][5] = VecCito3i_CitoCtr(-1, -1, 1);
	self->c_OcclusionNeighbors[4][6] = VecCito3i_CitoCtr(1, -1, -1);
	self->c_OcclusionNeighbors[4][7] = VecCito3i_CitoCtr(-1, -1, -1);
	self->c_OcclusionNeighbors[5][8] = VecCito3i_CitoCtr(0, 1, 0);
	self->c_OcclusionNeighbors[5][0] = VecCito3i_CitoCtr(0, 1, 1);
	self->c_OcclusionNeighbors[5][1] = VecCito3i_CitoCtr(0, 1, -1);
	self->c_OcclusionNeighbors[5][2] = VecCito3i_CitoCtr(-1, 1, 0);
	self->c_OcclusionNeighbors[5][3] = VecCito3i_CitoCtr(1, 1, 0);
	self->c_OcclusionNeighbors[5][4] = VecCito3i_CitoCtr(-1, 1, 1);
	self->c_OcclusionNeighbors[5][5] = VecCito3i_CitoCtr(1, 1, 1);
	self->c_OcclusionNeighbors[5][6] = VecCito3i_CitoCtr(-1, 1, -1);
	self->c_OcclusionNeighbors[5][7] = VecCito3i_CitoCtr(1, 1, -1);
}

TerrainChunkTesselatorCi *TerrainChunkTesselatorCi_New(void)
{
	TerrainChunkTesselatorCi *self = (TerrainChunkTesselatorCi *) malloc(sizeof(TerrainChunkTesselatorCi));
	if (self != NULL)
		TerrainChunkTesselatorCi_Construct(self);
	return self;
}

void TerrainChunkTesselatorCi_Delete(TerrainChunkTesselatorCi *self)
{
	free(self);
}

void TerrainChunkTesselatorCi_AddTorch(TerrainChunkTesselatorCi const *self, int x, int y, int z, int type, int tt)
{
	TerrainChunkTesselatorCi const *d_TerainRenderer = self;
	int curcolor = self->_colorWhite;
	float torchsizexy = 0.16f;
	float topx = 0.5f - torchsizexy / 2;
	float topy = 0.5f - torchsizexy / 2;
	float bottomx = 0.5f - torchsizexy / 2;
	float bottomy = 0.5f - torchsizexy / 2;
	Vector3Ref *top00;
	Vector3Ref *top01;
	Vector3Ref *top10;
	Vector3Ref *top11;
	Vector3Ref const *bottom00;
	Vector3Ref const *bottom01;
	Vector3Ref const *bottom10;
	Vector3Ref const *bottom11;
	topx += x;
	topy += y;
	bottomx += x;
	bottomy += y;
	if (type == 3) {
		bottomx = x - torchsizexy;
	}
	if (type == 4) {
		bottomx = x + 1;
	}
	if (type == 1) {
		bottomy = y - torchsizexy;
	}
	if (type == 2) {
		bottomy = y + 1;
	}
	top00 = Vector3Ref_Create(topx, z + 0.9f, topy);
	top01 = Vector3Ref_Create(topx, z + 0.9f, topy + torchsizexy);
	top10 = Vector3Ref_Create(topx + torchsizexy, z + 0.9f, topy);
	top11 = Vector3Ref_Create(topx + torchsizexy, z + 0.9f, topy + torchsizexy);
	if (type == 1) {
		top01->y += -0.1f;
		top11->y += -0.1f;
	}
	if (type == 2) {
		top10->y += -0.1f;
		top00->y += -0.1f;
	}
	if (type == 3) {
		top10->y += -0.1f;
		top11->y += -0.1f;
	}
	if (type == 4) {
		top01->y += -0.1f;
		top00->y += -0.1f;
	}
	bottom00 = Vector3Ref_Create(bottomx, z + 0, bottomy);
	bottom01 = Vector3Ref_Create(bottomx, z + 0, bottomy + torchsizexy);
	bottom10 = Vector3Ref_Create(bottomx + torchsizexy, z + 0, bottomy);
	bottom11 = Vector3Ref_Create(bottomx + torchsizexy, z + 0, bottomy + torchsizexy);
	{
		int sidetexture = self->torchTopTexture;
		float texrecTop = self->terrainTexturesPerAtlasInverse * sidetexture % self->terrainTexturesPerAtlas;
		float texrecBottom = texrecTop + self->_texrecHeight;
		ModelData *toreturn = TerrainChunkTesselatorCi_GetModelData(self, tt, sidetexture);
		int lastelement = toreturn->verticesCount;
		ModelDataTool_AddVertex(toreturn, top00->x, top00->y, top00->z, self->_texrecLeft, texrecTop, curcolor);
		ModelDataTool_AddVertex(toreturn, top01->x, top01->y, top01->z, self->_texrecLeft, texrecBottom, curcolor);
		ModelDataTool_AddVertex(toreturn, top10->x, top10->y, top10->z, self->_texrecRight, texrecTop, curcolor);
		ModelDataTool_AddVertex(toreturn, top11->x, top11->y, top11->z, self->_texrecRight, texrecBottom, curcolor);
		ModelDataTool_AddIndex(toreturn, lastelement + 0);
		ModelDataTool_AddIndex(toreturn, lastelement + 1);
		ModelDataTool_AddIndex(toreturn, lastelement + 2);
		ModelDataTool_AddIndex(toreturn, lastelement + 1);
		ModelDataTool_AddIndex(toreturn, lastelement + 3);
		ModelDataTool_AddIndex(toreturn, lastelement + 2);
	}
	{
		int sidetexture = self->torchSideTexture;
		float texrecTop = self->terrainTexturesPerAtlasInverse * sidetexture % self->terrainTexturesPerAtlas;
		float texrecBottom = texrecTop + self->_texrecHeight;
		ModelData *toreturn = TerrainChunkTesselatorCi_GetModelData(self, tt, sidetexture);
		int lastelement = toreturn->verticesCount;
		ModelDataTool_AddVertex(toreturn, bottom00->x, bottom00->y, bottom00->z, self->_texrecLeft, texrecTop, curcolor);
		ModelDataTool_AddVertex(toreturn, bottom01->x, bottom01->y, bottom01->z, self->_texrecLeft, texrecBottom, curcolor);
		ModelDataTool_AddVertex(toreturn, bottom10->x, bottom10->y, bottom10->z, self->_texrecRight, texrecTop, curcolor);
		ModelDataTool_AddVertex(toreturn, bottom11->x, bottom11->y, bottom11->z, self->_texrecRight, texrecBottom, curcolor);
		ModelDataTool_AddIndex(toreturn, lastelement + 1);
		ModelDataTool_AddIndex(toreturn, lastelement + 0);
		ModelDataTool_AddIndex(toreturn, lastelement + 2);
		ModelDataTool_AddIndex(toreturn, lastelement + 3);
		ModelDataTool_AddIndex(toreturn, lastelement + 1);
		ModelDataTool_AddIndex(toreturn, lastelement + 2);
	}
	{
		int sidetexture = self->torchSideTexture;
		float texrecTop = self->terrainTexturesPerAtlasInverse * sidetexture % self->terrainTexturesPerAtlas;
		float texrecBottom = texrecTop + self->_texrecHeight;
		ModelData *toreturn = TerrainChunkTesselatorCi_GetModelData(self, tt, sidetexture);
		int lastelement = toreturn->verticesCount;
		ModelDataTool_AddVertex(toreturn, bottom00->x, bottom00->y, bottom00->z, self->_texrecLeft, texrecBottom, curcolor);
		ModelDataTool_AddVertex(toreturn, bottom01->x, bottom01->y, bottom01->z, self->_texrecRight, texrecBottom, curcolor);
		ModelDataTool_AddVertex(toreturn, top00->x, top00->y, top00->z, self->_texrecLeft, texrecTop, curcolor);
		ModelDataTool_AddVertex(toreturn, top01->x, top01->y, top01->z, self->_texrecRight, texrecTop, curcolor);
		ModelDataTool_AddIndex(toreturn, lastelement + 0);
		ModelDataTool_AddIndex(toreturn, lastelement + 1);
		ModelDataTool_AddIndex(toreturn, lastelement + 2);
		ModelDataTool_AddIndex(toreturn, lastelement + 1);
		ModelDataTool_AddIndex(toreturn, lastelement + 3);
		ModelDataTool_AddIndex(toreturn, lastelement + 2);
	}
	{
		int sidetexture = self->torchSideTexture;
		float texrecTop = self->terrainTexturesPerAtlasInverse * sidetexture % self->terrainTexturesPerAtlas;
		float texrecBottom = texrecTop + self->_texrecHeight;
		ModelData *toreturn = TerrainChunkTesselatorCi_GetModelData(self, tt, sidetexture);
		int lastelement = toreturn->verticesCount;
		ModelDataTool_AddVertex(toreturn, bottom10->x, bottom10->y, bottom10->z, self->_texrecRight, texrecBottom, curcolor);
		ModelDataTool_AddVertex(toreturn, bottom11->x, bottom11->y, bottom11->z, self->_texrecLeft, texrecBottom, curcolor);
		ModelDataTool_AddVertex(toreturn, top10->x, top10->y, top10->z, self->_texrecRight, texrecTop, curcolor);
		ModelDataTool_AddVertex(toreturn, top11->x, top11->y, top11->z, self->_texrecLeft, texrecTop, curcolor);
		ModelDataTool_AddIndex(toreturn, lastelement + 1);
		ModelDataTool_AddIndex(toreturn, lastelement + 0);
		ModelDataTool_AddIndex(toreturn, lastelement + 2);
		ModelDataTool_AddIndex(toreturn, lastelement + 3);
		ModelDataTool_AddIndex(toreturn, lastelement + 1);
		ModelDataTool_AddIndex(toreturn, lastelement + 2);
	}
	{
		int sidetexture = self->torchSideTexture;
		float texrecTop = self->terrainTexturesPerAtlasInverse * sidetexture % self->terrainTexturesPerAtlas;
		float texrecBottom = texrecTop + self->_texrecHeight;
		ModelData *toreturn = TerrainChunkTesselatorCi_GetModelData(self, tt, sidetexture);
		int lastelement = toreturn->verticesCount;
		ModelDataTool_AddVertex(toreturn, bottom00->x, bottom00->y, bottom00->z, self->_texrecRight, texrecBottom, curcolor);
		ModelDataTool_AddVertex(toreturn, top00->x, top00->y, top00->z, self->_texrecRight, texrecTop, curcolor);
		ModelDataTool_AddVertex(toreturn, bottom10->x, bottom10->y, bottom10->z, self->_texrecLeft, texrecBottom, curcolor);
		ModelDataTool_AddVertex(toreturn, top10->x, top10->y, top10->z, self->_texrecLeft, texrecTop, curcolor);
		ModelDataTool_AddIndex(toreturn, lastelement + 0);
		ModelDataTool_AddIndex(toreturn, lastelement + 1);
		ModelDataTool_AddIndex(toreturn, lastelement + 2);
		ModelDataTool_AddIndex(toreturn, lastelement + 1);
		ModelDataTool_AddIndex(toreturn, lastelement + 3);
		ModelDataTool_AddIndex(toreturn, lastelement + 2);
	}
	{
		int sidetexture = self->torchSideTexture;
		float texrecTop = self->terrainTexturesPerAtlasInverse * sidetexture % self->terrainTexturesPerAtlas;
		float texrecBottom = texrecTop + self->_texrecHeight;
		ModelData *toreturn = TerrainChunkTesselatorCi_GetModelData(self, tt, sidetexture);
		int lastelement = toreturn->verticesCount;
		ModelDataTool_AddVertex(toreturn, bottom01->x, bottom01->y, bottom01->z, self->_texrecLeft, texrecBottom, curcolor);
		ModelDataTool_AddVertex(toreturn, top01->x, top01->y, top01->z, self->_texrecLeft, texrecTop, curcolor);
		ModelDataTool_AddVertex(toreturn, bottom11->x, bottom11->y, bottom11->z, self->_texrecRight, texrecBottom, curcolor);
		ModelDataTool_AddVertex(toreturn, top11->x, top11->y, top11->z, self->_texrecRight, texrecTop, curcolor);
		ModelDataTool_AddIndex(toreturn, lastelement + 1);
		ModelDataTool_AddIndex(toreturn, lastelement + 0);
		ModelDataTool_AddIndex(toreturn, lastelement + 2);
		ModelDataTool_AddIndex(toreturn, lastelement + 3);
		ModelDataTool_AddIndex(toreturn, lastelement + 1);
		ModelDataTool_AddIndex(toreturn, lastelement + 2);
	}
}

void TerrainChunkTesselatorCi_AddVertex(TerrainChunkTesselatorCi const *self, ModelData *model, float x, float y, float z, float u, float v, int color)
{
	model->xyz[ModelData_GetXyzCount(model) + 0] = x;
	model->xyz[ModelData_GetXyzCount(model) + 1] = y;
	model->xyz[ModelData_GetXyzCount(model) + 2] = z;
	model->uv[ModelData_GetUvCount(model) + 0] = u;
	model->uv[ModelData_GetUvCount(model) + 1] = v;
	model->rgba[ModelData_GetRgbaCount(model) + 0] = Game_IntToByte(Game_ColorR(color));
	model->rgba[ModelData_GetRgbaCount(model) + 1] = Game_IntToByte(Game_ColorG(color));
	model->rgba[ModelData_GetRgbaCount(model) + 2] = Game_IntToByte(Game_ColorB(color));
	model->rgba[ModelData_GetRgbaCount(model) + 3] = Game_IntToByte(Game_ColorA(color));
	model->verticesCount++;
}

static void TerrainChunkTesselatorCi_BuildBlockFace(TerrainChunkTesselatorCi const *self, int x, int y, int z, int tileType, float vOffsetX, float vOffsetY, float vOffsetZ, float vScaleX, float vScaleY, float vScaleZ, int const *currentChunk, int tileSide)
{
	int xx = x % 16 + 1;
	int yy = y % 16 + 1;
	int zz = z % 16 + 1;
	VecCito3i const *const *vNeighbors = self->c_OcclusionNeighbors[tileSide];
	int *shadowration = self->tmpshadowration;
	cibool *occupied = self->tmpoccupied;
	int shadowratio = TerrainChunkTesselatorCi_GetShadowRatio(self, vNeighbors[8]->x + xx, vNeighbors[8]->y + yy, vNeighbors[8]->z + zz);
	float *fShadowRation = self->tmpfShadowRation;
	float shadowratiomain = self->lightlevels[shadowratio];
	fShadowRation[0] = shadowratiomain;
	fShadowRation[1] = shadowratiomain;
	fShadowRation[2] = shadowratiomain;
	fShadowRation[3] = shadowratiomain;
	if (self->enableSmoothLight) {
		{
			int i;
			for (i = 0; i < 9; i++) {
				int vPosX = vNeighbors[i]->x + xx;
				int vPosY = vNeighbors[i]->y + yy;
				int vPosZ = vNeighbors[i]->z + zz;
				int nBlockType = currentChunk[(vPosZ * 18 + vPosY) * 18 + vPosX];
				if (nBlockType != 0) {
					occupied[i] = !TerrainChunkTesselatorCi_IsTransparentForLight(self, nBlockType);
					shadowration[i] = shadowratio;
				}
				else {
					occupied[i] = FALSE;
					shadowration[i] = TerrainChunkTesselatorCi_GetShadowRatio(self, vPosX, vPosY, vPosZ);
				}
			}
		}
		TerrainChunkTesselatorCi_CalcShadowRation(self, 0, 2, 4, 0, fShadowRation, occupied, shadowration);
		TerrainChunkTesselatorCi_CalcShadowRation(self, 0, 3, 5, 1, fShadowRation, occupied, shadowration);
		TerrainChunkTesselatorCi_CalcShadowRation(self, 1, 2, 6, 2, fShadowRation, occupied, shadowration);
		TerrainChunkTesselatorCi_CalcShadowRation(self, 1, 3, 7, 3, fShadowRation, occupied, shadowration);
	}
	else {
	}
	TerrainChunkTesselatorCi_DrawBlockFace(self, x, y, z, tileType, tileSide, vOffsetX, vOffsetY, vOffsetZ, vScaleX, vScaleY, vScaleZ, vNeighbors, fShadowRation);
}

void TerrainChunkTesselatorCi_BuildBlockPolygons(TerrainChunkTesselatorCi *self, int x, int y, int z)
{
	{
		int xx;
		for (xx = 0; xx < 16; xx++) {
			{
				int yy;
				for (yy = 0; yy < 16; yy++) {
					{
						int zz;
						for (zz = 0; zz < 16; zz++) {
							if (self->currentChunkDraw16[(zz * 16 + yy) * 16 + xx] != 0) {
								int xxx = x * 16 + xx;
								int yyy = y * 16 + yy;
								int zzz = z * 16 + zz;
								TerrainChunkTesselatorCi_BuildSingleBlockPolygon(self, xxx, yyy, zzz, self->currentChunk18);
							}
						}
					}
				}
			}
		}
	}
}

void TerrainChunkTesselatorCi_BuildSingleBlockPolygon(TerrainChunkTesselatorCi *self, int x, int y, int z, int const *currentChunk)
{
	int xx;
	int yy;
	int zz;
	int nToDraw;
	int tiletype;
	float vOffsetX;
	float vOffsetY;
	float vOffsetZ;
	float vScaleX;
	float vScaleY;
	float vScaleZ;
	{
		int i;
		for (i = 0; i < 4; i++) {
			self->ref_blockCornerHeight[i] = 0;
		}
	}
	xx = x % 16 + 1;
	yy = y % 16 + 1;
	zz = z % 16 + 1;
	nToDraw = TerrainChunkTesselatorCi_GetToDrawFlags(self, xx, yy, zz);
	tiletype = currentChunk[(zz * 18 + yy) * 18 + xx];
	vOffsetX = 0;
	vOffsetY = 0;
	vOffsetZ = 0;
	vScaleX = 1;
	vScaleY = 1;
	vScaleZ = 1;
	if (!TerrainChunkTesselatorCi_isvalid(self, tiletype)) {
		return;
	}
	if (nToDraw == 0) {
		return;
	}
	if (self->option_DoNotDrawEdges) {
		if (z == 0) {
			nToDraw &= ~2;
		}
		if (x == 0) {
			nToDraw &= ~16;
		}
		if (x == self->mapsizex - 1) {
			nToDraw &= ~32;
		}
		if (y == 0) {
			nToDraw &= ~8;
		}
		if (y == self->mapsizey - 1) {
			nToDraw &= ~4;
		}
	}
	if (TerrainChunkTesselatorCi_IsFlower(self, tiletype)) {
		nToDraw = 20;
		vScaleX = 0.9f;
		vScaleY = 0.9f;
		vScaleZ = 1f;
		TerrainChunkTesselatorCi_BuildBlockFace(self, x, y, z, tiletype, 0.5f, 0.05f, 0f, vScaleX, vScaleY, vScaleZ, currentChunk, 2);
		TerrainChunkTesselatorCi_BuildBlockFace(self, x, y, z, tiletype, 0.05f, 0.5f, 0f, vScaleX, vScaleY, vScaleZ, currentChunk, 4);
		return;
	}
	else if (self->game->blocktypes[tiletype]->drawType == 13) {
		float fScale = 0.875f;
		float fOffset = (1f - fScale) / 2f;
		float vLROffsetX = fOffset;
		float vLROffsetY = 0;
		float vLROffsetZ = 0;
		float vLRScaleX = fScale;
		float vLRScaleY = 1f;
		float vLRScaleZ = 1f;
		float vFBOffsetX = 0;
		float vFBOffsetY = fOffset;
		float vFBOffsetZ = 0;
		float vFBScaleX = 1f;
		float vFBScaleY = fScale;
		float vFBScaleZ = 1f;
		TerrainChunkTesselatorCi_BuildBlockFace(self, x, y, z, tiletype, vLROffsetX, vLROffsetY, vLROffsetZ, vLRScaleX, vLRScaleY, vLRScaleZ, currentChunk, 2);
		TerrainChunkTesselatorCi_BuildBlockFace(self, x, y, z, tiletype, vLROffsetX, vLROffsetY, vLROffsetZ, vLRScaleX, vLRScaleY, vLRScaleZ, currentChunk, 3);
		TerrainChunkTesselatorCi_BuildBlockFace(self, x, y, z, tiletype, vFBOffsetX, vFBOffsetY, vFBOffsetZ, vFBScaleX, vFBScaleY, vFBScaleZ, currentChunk, 5);
		TerrainChunkTesselatorCi_BuildBlockFace(self, x, y, z, tiletype, vFBOffsetX, vFBOffsetY, vFBOffsetZ, vFBScaleX, vFBScaleY, vFBScaleZ, currentChunk, 4);
		nToDraw = nToDraw & 3;
	}
	else if (self->game->blocktypes[tiletype]->drawType == 6 || self->game->blocktypes[tiletype]->drawType == 7) {
		cibool blnDrawn = FALSE;
		float fOffset = 0.025f;
		if (currentChunk[(zz * 18 + yy) * 18 + xx - 1] == 0 && currentChunk[(zz * 18 + yy) * 18 + xx + 1] == 0) {
			nToDraw = 8;
			vOffsetX = 0;
			vOffsetY = fOffset;
			vOffsetZ = 0;
			blnDrawn = TRUE;
		}
		if (!blnDrawn || (currentChunk[(zz * 18 + yy - 1) * 18 + xx] == 0 && currentChunk[(zz * 18 + yy + 1) * 18 + xx] == 0)) {
			vOffsetX = fOffset;
			vOffsetY = 0;
			vOffsetZ = 0;
			nToDraw = 16;
		}
	}
	else if (self->game->blocktypes[tiletype]->drawType == 10 || self->game->blocktypes[tiletype]->drawType == 8) {
		cibool blnSideDrawn = FALSE;
		if (currentChunk[(zz * 18 + yy) * 18 + xx - 1] != 0 || currentChunk[(zz * 18 + yy) * 18 + xx + 1] != 0) {
			TerrainChunkTesselatorCi_BuildBlockFace(self, x, y, z, tiletype, 0, -0.5f, 0, vScaleX, vScaleY, vScaleZ, currentChunk, 5);
			blnSideDrawn = TRUE;
		}
		if (!blnSideDrawn || currentChunk[(zz * 18 + yy - 1) * 18 + xx] != 0 || currentChunk[(zz * 18 + yy + 1) * 18 + xx] != 0) {
			TerrainChunkTesselatorCi_BuildBlockFace(self, x, y, z, tiletype, 0.5f, 0, 0, vScaleX, vScaleY, vScaleZ, currentChunk, 2);
		}
		return;
	}
	else if (self->game->blocktypes[tiletype]->drawType == 9) {
		int ladderAtPositionMatchWall;
		vOffsetX = 0.025f;
		vOffsetY = 0.025f;
		vOffsetZ = 0;
		vScaleX = 0.95f;
		vScaleY = 0.95f;
		vScaleZ = 1f;
		nToDraw = 0;
		ladderAtPositionMatchWall = TerrainChunkTesselatorCi_getBestLadderWall(self, xx, yy, zz, currentChunk);
		if (ladderAtPositionMatchWall < 0) {
			int ladderbelow = TerrainChunkTesselatorCi_getBestLadderInDirection(self, xx, yy, zz, currentChunk, -1);
			int ladderabove = TerrainChunkTesselatorCi_getBestLadderInDirection(self, xx, yy, zz, currentChunk, 1);
			if (ladderbelow != 0) {
				ladderAtPositionMatchWall = TerrainChunkTesselatorCi_getBestLadderWall(self, xx, yy, zz + ladderbelow, currentChunk);
			}
			else if (ladderabove != 0) {
				ladderAtPositionMatchWall = TerrainChunkTesselatorCi_getBestLadderWall(self, xx, yy, zz + ladderabove, currentChunk);
			}
		}
		switch (ladderAtPositionMatchWall) {
		case 1:
			nToDraw |= 4;
			break;
		case 2:
			nToDraw |= 16;
			break;
		case 3:
			nToDraw |= 32;
			break;
		default:
			nToDraw |= 8;
			break;
		}
	}
	else if (self->game->blocktypes[tiletype]->drawType == 11) {
		vScaleX = 1;
		vScaleY = 1;
		vScaleZ = 0.5f;
	}
	else if (self->game->blocktypes[tiletype]->drawType == 12) {
		vScaleX = 1;
		vScaleY = 1;
		vScaleZ = 0.05f;
	}
	else if (self->game->blocktypes[tiletype]->drawType == 4) {
		int type = 0;
		if (TerrainChunkTesselatorCi_CanSupportTorch(self, currentChunk[(zz * 18 + yy) * 18 + xx - 1])) {
			type = 3;
		}
		if (TerrainChunkTesselatorCi_CanSupportTorch(self, currentChunk[(zz * 18 + yy) * 18 + xx + 1])) {
			type = 4;
		}
		if (TerrainChunkTesselatorCi_CanSupportTorch(self, currentChunk[(zz * 18 + yy - 1) * 18 + xx])) {
			type = 1;
		}
		if (TerrainChunkTesselatorCi_CanSupportTorch(self, currentChunk[(zz * 18 + yy + 1) * 18 + xx])) {
			type = 2;
		}
		self->torchSideTexture = TerrainChunkTesselatorCi_TextureId(self, tiletype, 2);
		self->torchTopTexture = TerrainChunkTesselatorCi_TextureId(self, tiletype, 0);
		TerrainChunkTesselatorCi_AddTorch(self, x, y, z, type, tiletype);
		return;
	}
	else if (tiletype == 8) {
		if (currentChunk[((zz - 1) * 18 + yy) * 18 + xx] == 8) {
			vOffsetX = 0;
			vOffsetY = 0;
			vOffsetZ = -0.1f;
		}
		else {
			vScaleX = 1;
			vScaleY = 1;
			vScaleZ = 0.9f;
		}
	}
	else {
		int rail = TerrainChunkTesselatorCi_Rail(self, tiletype);
		if (rail != 0) {
			int slope = TerrainChunkTesselatorCi_GetRailSlope(self, xx, yy, zz);
			float fSlopeMod = 1f;
			vScaleX = 1f;
			vScaleY = 1f;
			vScaleZ = 0.3f;
			if (slope == 2) {
				self->ref_blockCornerHeight[1] = fSlopeMod;
				self->ref_blockCornerHeight[3] = fSlopeMod;
			}
			else if (slope == 1) {
				self->ref_blockCornerHeight[0] = fSlopeMod;
				self->ref_blockCornerHeight[2] = fSlopeMod;
			}
			else if (slope == 3) {
				self->ref_blockCornerHeight[0] = fSlopeMod;
				self->ref_blockCornerHeight[1] = fSlopeMod;
			}
			else if (slope == 4) {
				self->ref_blockCornerHeight[2] = fSlopeMod;
				self->ref_blockCornerHeight[3] = fSlopeMod;
			}
		}
	}
	{
		int i;
		for (i = 0; i < 6; i++) {
			if ((nToDraw & TileSideEnum_ToFlags(i)) != 0) {
				TerrainChunkTesselatorCi_BuildBlockFace(self, x, y, z, tiletype, vOffsetX, vOffsetY, vOffsetZ, vScaleX, vScaleY, vScaleZ, currentChunk, i);
			}
		}
	}
}

static void TerrainChunkTesselatorCi_CalcShadowRation(TerrainChunkTesselatorCi const *self, int nDir1, int nDir2, int nDirBetween, int nCorner, float *fShadowRation, cibool const *occupied, int const *shadowRationInt)
{
	if (occupied[nDir1] && occupied[nDir2]) {
		fShadowRation[nCorner] *= self->halfocc;
	}
	else {
		unsigned char facesconsidered = 1;
		if (!occupied[nDir1]) {
			fShadowRation[nCorner] += self->lightlevels[shadowRationInt[nDir1]];
			facesconsidered++;
		}
		if (!occupied[nDir2]) {
			fShadowRation[nCorner] += self->lightlevels[shadowRationInt[nDir2]];
			facesconsidered++;
		}
		if (!occupied[nDirBetween]) {
			fShadowRation[nCorner] += self->lightlevels[shadowRationInt[nDirBetween]];
			facesconsidered++;
		}
		fShadowRation[nCorner] /= facesconsidered;
		if (occupied[nDir1] || occupied[nDir2] || occupied[nDirBetween]) {
			fShadowRation[nCorner] *= self->occ;
		}
	}
}

void TerrainChunkTesselatorCi_CalculateTilingCount(TerrainChunkTesselatorCi const *self, int const *currentChunk, int startx, int starty, int startz)
{
	{
		int i;
		for (i = 0; i < 4096; i++) {
			if (self->currentChunkDrawCount16[i] == NULL) {
				self->currentChunkDrawCount16[i] = (unsigned char *) malloc(6 * sizeof(unsigned char ));
			}
			self->currentChunkDrawCount16[i][0] = 0;
			self->currentChunkDrawCount16[i][1] = 0;
			self->currentChunkDrawCount16[i][2] = 0;
			self->currentChunkDrawCount16[i][3] = 0;
			self->currentChunkDrawCount16[i][4] = 0;
			self->currentChunkDrawCount16[i][5] = 0;
		}
	}
	{
		int const *currentChunk_ = currentChunk;
		{
			int zz;
			for (zz = 1; zz < 17; zz++) {
				{
					int yy;
					for (yy = 1; yy < 17; yy++) {
						int pos = (zz * 18 + yy) * 18 + 0;
						{
							int xx;
							for (xx = 1; xx < 17; xx++) {
								int tt = currentChunk_[pos + xx];
								int x;
								int y;
								int z;
								int draw;
								if (tt == 0) {
									continue;
								}
								x = startx + xx - 1;
								y = starty + yy - 1;
								z = startz + zz - 1;
								draw = self->currentChunkDraw16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1];
								if (draw == 0) {
									continue;
								}
								if ((draw & 1) != 0) {
									int shadowratioTop = TerrainChunkTesselatorCi_GetShadowRatio(self, xx, yy, zz + 1);
									self->currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1][0] = 1;
								}
								if ((draw & 2) != 0) {
									int shadowratioTop = TerrainChunkTesselatorCi_GetShadowRatio(self, xx, yy, zz - 1);
									self->currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1][1] = 1;
								}
								if ((draw & 4) != 0) {
									int shadowratioTop = TerrainChunkTesselatorCi_GetShadowRatio(self, xx - 1, yy, zz);
									self->currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1][2] = 1;
								}
								if ((draw & 8) != 0) {
									int shadowratioTop = TerrainChunkTesselatorCi_GetShadowRatio(self, xx + 1, yy, zz);
									self->currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1][3] = 1;
								}
								if ((draw & 16) != 0) {
									int shadowratioTop = TerrainChunkTesselatorCi_GetShadowRatio(self, xx, yy - 1, zz);
									self->currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1][4] = 1;
								}
								if ((draw & 32) != 0) {
									int shadowratioTop = TerrainChunkTesselatorCi_GetShadowRatio(self, xx, yy + 1, zz);
									self->currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1][5] = 1;
								}
							}
						}
					}
				}
			}
		}
	}
}

void TerrainChunkTesselatorCi_CalculateVisibleFaces(TerrainChunkTesselatorCi const *self, int const *currentChunk)
{
	int movez = 324;
	{
		int zz;
		for (zz = 1; zz < 17; zz++) {
			{
				int yy;
				for (yy = 1; yy < 17; yy++) {
					int posstart = (zz * 18 + yy) * 18 + 0;
					{
						int xx;
						for (xx = 1; xx < 17; xx++) {
							int pos = posstart + xx;
							int tt = currentChunk[pos];
							int draw;
							int *nPos;
							cibool blnIsFluid;
							cibool blnIsLowered;
							if (tt == 0) {
								continue;
							}
							draw = 0;
							nPos = self->tmpnPos;
							nPos[0] = pos + movez;
							nPos[1] = pos - movez;
							nPos[5] = pos + 18;
							nPos[4] = pos - 18;
							nPos[2] = pos - 1;
							nPos[3] = pos + 1;
							blnIsFluid = self->isFluid[tt];
							blnIsLowered = self->isLowered[tt];
							draw |= TerrainChunkTesselatorCi_GetFaceVisibility(self, 0, currentChunk, nPos, blnIsFluid, blnIsLowered);
							draw |= TerrainChunkTesselatorCi_GetFaceVisibility(self, 1, currentChunk, nPos, blnIsFluid, blnIsLowered);
							draw |= TerrainChunkTesselatorCi_GetFaceVisibility(self, 2, currentChunk, nPos, blnIsFluid, blnIsLowered);
							draw |= TerrainChunkTesselatorCi_GetFaceVisibility(self, 3, currentChunk, nPos, blnIsFluid, blnIsLowered);
							draw |= TerrainChunkTesselatorCi_GetFaceVisibility(self, 4, currentChunk, nPos, blnIsFluid, blnIsLowered);
							draw |= TerrainChunkTesselatorCi_GetFaceVisibility(self, 5, currentChunk, nPos, blnIsFluid, blnIsLowered);
							if (blnIsLowered && draw > 0) {
								int nRail;
								if (!TileSideFlagsEnum_HasFlag(draw, 1)) {
									if (TileSideFlagsEnum_HasFlag(draw, 60)) {
										draw |= 1;
									}
								}
								nRail = TerrainChunkTesselatorCi_Rail(self, tt);
								if (nRail > 0) {
									int nSlope = TerrainChunkTesselatorCi_GetRailSlope(self, xx, yy, zz);
									switch (nSlope) {
									case 4:
										draw |= 52;
										break;
									case 3:
										draw |= 56;
										break;
									case 1:
										draw |= 28;
										break;
									case 2:
										draw |= 44;
										break;
									}
								}
							}
							self->currentChunkDraw16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1] = Game_IntToByte(draw);
						}
					}
				}
			}
		}
	}
}

cibool TerrainChunkTesselatorCi_CanSupportTorch(TerrainChunkTesselatorCi const *self, int blocktype)
{
	return blocktype != 0 && self->game->blocktypes[blocktype]->drawType != 4;
}

static int TerrainChunkTesselatorCi_ColorMultiply(TerrainChunkTesselatorCi const *self, int color, float fValue)
{
	return Game_ColorFromArgb(Game_ColorA(color), self->game->platform->vtbl->floatToInt(self->game->platform, Game_ColorR(color) * fValue), self->game->platform->vtbl->floatToInt(self->game->platform, Game_ColorG(color) * fValue), self->game->platform->vtbl->floatToInt(self->game->platform, Game_ColorB(color) * fValue));
}

static void TerrainChunkTesselatorCi_DrawBlockFace(TerrainChunkTesselatorCi const *self, int x, int y, int z, int tileType, int tileSide, float vOffsetX, float vOffsetY, float vOffsetZ, float vScaleX, float vScaleY, float vScaleZ, VecCito3i const *const *vNeighbors, float const *fShadowRation)
{
	int color = self->_colorWhite;
	int sidetexture;
	ModelData *toreturn;
	float texrecTop;
	float texrecBottom;
	int lastelement;
	VecCito3i *v;
	float fSlopeModifier;
	float xPos;
	float zPos;
	float yPos;
	if (self->option_DarkenBlockSides) {
		switch (tileSide) {
		case 1:
		case 2:
		case 3:
			color = TerrainChunkTesselatorCi_ColorMultiply(self, color, self->blockShadow);
			break;
		}
	}
	sidetexture = TerrainChunkTesselatorCi_TextureId(self, tileType, tileSide);
	toreturn = TerrainChunkTesselatorCi_GetModelData(self, tileType, sidetexture);
	texrecTop = self->terrainTexturesPerAtlasInverse * sidetexture % self->terrainTexturesPerAtlas + self->atiArtifactFix * self->terrainTexturesPerAtlasInverse;
	texrecBottom = texrecTop + self->_texrecHeight;
	lastelement = toreturn->verticesCount;
	v = self->tmpv;
	fSlopeModifier = 0f;
	VecCito3i_Add(vNeighbors[5], 1, 1, 1, v);
	fSlopeModifier = TerrainChunkTesselatorCi_GetCornerHeightModifier(self, tileSide, 1);
	xPos = x + vOffsetX + v->x * 0.5f * vScaleX;
	zPos = z + vOffsetZ + v->z * 0.5f * vScaleZ + fSlopeModifier;
	yPos = y + vOffsetY + v->y * 0.5f * vScaleY;
	ModelDataTool_AddVertex(toreturn, xPos, zPos, yPos, self->_texrecRight, texrecTop, TerrainChunkTesselatorCi_ColorMultiply(self, color, fShadowRation[1]));
	VecCito3i_Add(vNeighbors[4], 1, 1, 1, v);
	fSlopeModifier = TerrainChunkTesselatorCi_GetCornerHeightModifier(self, tileSide, 0);
	xPos = x + vOffsetX + v->x * 0.5f * vScaleX;
	zPos = z + vOffsetZ + v->z * 0.5f * vScaleZ + fSlopeModifier;
	yPos = y + vOffsetY + v->y * 0.5f * vScaleY;
	ModelDataTool_AddVertex(toreturn, xPos, zPos, yPos, self->_texrecLeft, texrecTop, TerrainChunkTesselatorCi_ColorMultiply(self, color, fShadowRation[0]));
	VecCito3i_Add(vNeighbors[7], 1, 1, 1, v);
	fSlopeModifier = TerrainChunkTesselatorCi_GetCornerHeightModifier(self, tileSide, 3);
	xPos = x + vOffsetX + v->x * 0.5f * vScaleX;
	zPos = z + vOffsetZ + v->z * 0.5f * vScaleZ + fSlopeModifier;
	yPos = y + vOffsetY + v->y * 0.5f * vScaleY;
	ModelDataTool_AddVertex(toreturn, xPos, zPos, yPos, self->_texrecRight, texrecBottom, TerrainChunkTesselatorCi_ColorMultiply(self, color, fShadowRation[3]));
	VecCito3i_Add(vNeighbors[6], 1, 1, 1, v);
	fSlopeModifier = TerrainChunkTesselatorCi_GetCornerHeightModifier(self, tileSide, 2);
	xPos = x + vOffsetX + v->x * 0.5f * vScaleX;
	zPos = z + vOffsetZ + v->z * 0.5f * vScaleZ + fSlopeModifier;
	yPos = y + vOffsetY + v->y * 0.5f * vScaleY;
	ModelDataTool_AddVertex(toreturn, xPos, zPos, yPos, self->_texrecLeft, texrecBottom, TerrainChunkTesselatorCi_ColorMultiply(self, color, fShadowRation[2]));
	{
		ModelDataTool_AddIndex(toreturn, lastelement + 0);
		ModelDataTool_AddIndex(toreturn, lastelement + 1);
		ModelDataTool_AddIndex(toreturn, lastelement + 2);
		ModelDataTool_AddIndex(toreturn, lastelement + 1);
		ModelDataTool_AddIndex(toreturn, lastelement + 3);
		ModelDataTool_AddIndex(toreturn, lastelement + 2);
	}
}

static float TerrainChunkTesselatorCi_GetCornerHeightModifier(TerrainChunkTesselatorCi const *self, int side, int corner)
{
	int nIndex = -1;
	switch (side) {
	case 1:
		{
			nIndex = -1;
			break;
		}
	case 3:
		switch (corner) {
		case 1:
			nIndex = 1;
			break;
		case 0:
			nIndex = 3;
			break;
		}
		break;
	case 2:
		switch (corner) {
		case 0:
			nIndex = 0;
			break;
		case 1:
			nIndex = 2;
			break;
		}
		break;
	case 5:
		switch (corner) {
		case 0:
			nIndex = 2;
			break;
		case 1:
			nIndex = 3;
			break;
		}
		break;
	case 4:
		switch (corner) {
		case 0:
			nIndex = 1;
			break;
		case 1:
			nIndex = 0;
			break;
		}
		break;
	case 0:
		nIndex = corner;
		break;
	}
	if (nIndex != -1) {
		return self->ref_blockCornerHeight[nIndex];
	}
	else {
		return 0f;
	}
}

static int TerrainChunkTesselatorCi_GetFaceVisibility(TerrainChunkTesselatorCi const *self, int nSide, int const *currentChunk, int const *nPos, cibool blnIsFluid, cibool blnIsLowered)
{
	int nReturn = 0;
	int nIndex = nPos[nSide];
	int tt2 = currentChunk[nIndex];
	if (tt2 == 0 || (self->istransparent[tt2] && !self->isLowered[tt2]) || (self->isFluid[tt2] && !blnIsFluid)) {
		nReturn |= TileSideEnum_ToFlags(nSide);
	}
	else if (blnIsFluid && nSide != 1) {
		if (self->isFluid[currentChunk[nPos[1]]]) {
			if (!self->isFluid[tt2]) {
				int movez = 324;
				int nPos2 = nPos[nSide] - movez;
				if (nPos2 > 0 && self->isFluid[currentChunk[nPos2]]) {
					nReturn |= TileSideEnum_ToFlags(nSide);
				}
			}
		}
		else {
		}
	}
	if (self->isLowered[tt2] && nSide != 0) {
		if (!blnIsLowered) {
			nReturn |= TileSideEnum_ToFlags(nSide);
		}
		else if (nSide == 1) {
			nReturn |= 2;
		}
		else {
			nReturn |= 1;
		}
	}
	return nReturn;
}

VerticesIndicesToLoad const *const *TerrainChunkTesselatorCi_GetFinalVerticesIndices(TerrainChunkTesselatorCi const *self, int x, int y, int z, IntRef *retCount)
{
	VerticesIndicesToLoad const **ret = (VerticesIndicesToLoad const **) malloc((self->toreturnatlas1dLength + self->toreturnatlas1dLength) * sizeof(VerticesIndicesToLoad const *));
	retCount->value = 0;
	{
		int i;
		for (i = 0; i < self->toreturnatlas1dLength; i++) {
			if (self->toreturnatlas1d[i]->indicesCount > 0) {
				ret[retCount->value++] = TerrainChunkTesselatorCi_GetVerticesIndices(self, self->toreturnatlas1d[i], x, y, z, ITerrainTextures_terrainTextures1d(self->game->d_TerrainTextures)[i % ITerrainTextures_terrainTexturesPerAtlas(self->game->d_TerrainTextures)], FALSE);
			}
		}
	}
	{
		int i;
		for (i = 0; i < self->toreturnatlas1dLength; i++) {
			if (self->toreturnatlas1dtransparent[i]->indicesCount > 0) {
				ret[retCount->value++] = TerrainChunkTesselatorCi_GetVerticesIndices(self, self->toreturnatlas1dtransparent[i], x, y, z, ITerrainTextures_terrainTextures1d(self->game->d_TerrainTextures)[i % ITerrainTextures_terrainTexturesPerAtlas(self->game->d_TerrainTextures)], TRUE);
			}
		}
	}
	return ret;
}

ModelData *TerrainChunkTesselatorCi_GetModelData(TerrainChunkTesselatorCi const *self, int tiletype, int textureid)
{
	if (self->isFluid[tiletype] || (self->istransparent[tiletype] && !self->isLowered[tiletype])) {
		return self->toreturnatlas1dtransparent[textureid / self->game->terrainTexturesPerAtlas];
	}
	else {
		return self->toreturnatlas1d[textureid / self->game->terrainTexturesPerAtlas];
	}
}

int TerrainChunkTesselatorCi_GetRailSlope(TerrainChunkTesselatorCi const *self, int xx, int yy, int zz)
{
	int tiletype = self->currentChunk18[(zz * 18 + yy) * 18 + xx];
	int rail = TerrainChunkTesselatorCi_Rail(self, tiletype);
	int blocknear;
	{
		blocknear = self->currentChunk18[(zz * 18 + yy) * 18 + xx + 1];
		if (rail == 1 && blocknear != 0 && TerrainChunkTesselatorCi_Rail(self, blocknear) == 0) {
			return 2;
		}
	}
	{
		blocknear = self->currentChunk18[(zz * 18 + yy) * 18 + xx - 1];
		if (rail == 1 && blocknear != 0 && TerrainChunkTesselatorCi_Rail(self, blocknear) == 0) {
			return 1;
		}
	}
	{
		blocknear = self->currentChunk18[(zz * 18 + yy - 1) * 18 + xx];
		if (rail == 2 && blocknear != 0 && TerrainChunkTesselatorCi_Rail(self, blocknear) == 0) {
			return 3;
		}
	}
	{
		blocknear = self->currentChunk18[(zz * 18 + yy + 1) * 18 + xx];
		if (rail == 2 && blocknear != 0 && TerrainChunkTesselatorCi_Rail(self, blocknear) == 0) {
			return 4;
		}
	}
	return 0;
}

int TerrainChunkTesselatorCi_GetShadowRatio(TerrainChunkTesselatorCi const *self, int xx, int yy, int zz)
{
	return self->currentChunkShadows18[(zz * 18 + yy) * 18 + xx];
}

int TerrainChunkTesselatorCi_GetShadowRatioOld(TerrainChunkTesselatorCi const *self, int xx, int yy, int zz, int globalx, int globaly, int globalz)
{
	return TerrainChunkTesselatorCi_GetShadowRatio(self, xx, yy, zz);
}

int TerrainChunkTesselatorCi_GetShadowRatioVec(TerrainChunkTesselatorCi const *self, VecCito3i const *v)
{
	return TerrainChunkTesselatorCi_GetShadowRatio(self, v->x, v->y, v->z);
}

int TerrainChunkTesselatorCi_GetTilingCount(TerrainChunkTesselatorCi const *self, int const *currentChunk, int xx, int yy, int zz, int tt, int x, int y, int z, int shadowratio, int dir, int dirflags)
{
	if (!self->eNABLE_TEXTURE_TILING) {
		return 1;
	}
	if (self->istransparent[currentChunk[(zz * 18 + yy) * 18 + xx]] && !TerrainChunkTesselatorCi_IsTransparentFully(self, currentChunk[(zz * 18 + yy) * 18 + xx])) {
		return 1;
	}
	if (dir == 0 || dir == 1) {
		int shadowz = dir == 0 ? 1 : -1;
		int newxx = xx + 1;
		for (;;) {
			int shadowratio2;
			if (newxx >= 17) {
				break;
			}
			if (currentChunk[(zz * 18 + yy) * 18 + newxx] != tt) {
				break;
			}
			shadowratio2 = TerrainChunkTesselatorCi_GetShadowRatioOld(self, newxx, yy, zz + shadowz, x + newxx - xx, y, z + shadowz);
			if (shadowratio != shadowratio2) {
				break;
			}
			if ((self->currentChunkDraw16[((zz - 1) * 16 + yy - 1) * 16 + newxx - 1] & dirflags) == 0) {
				break;
			}
			self->currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + newxx - 1][dir] = 0;
			self->currentChunkDraw16[((zz - 1) * 16 + yy - 1) * 16 + newxx - 1] &= Game_IntToByte(~dirflags);
			newxx++;
		}
		return newxx - xx;
	}
	else if (dir == 5 || dir == 4) {
		int shadowx = dir == 5 ? -1 : 1;
		int newyy = yy + 1;
		for (;;) {
			int shadowratio2;
			if (newyy >= 17) {
				break;
			}
			if (currentChunk[(zz * 18 + newyy) * 18 + xx] != tt) {
				break;
			}
			shadowratio2 = TerrainChunkTesselatorCi_GetShadowRatioOld(self, xx + shadowx, newyy, zz, x + shadowx, y + newyy - yy, z);
			if (shadowratio != shadowratio2) {
				break;
			}
			if ((self->currentChunkDraw16[((zz - 1) * 16 + newyy - 1) * 16 + xx - 1] & dirflags) == 0) {
				break;
			}
			self->currentChunkDrawCount16[((zz - 1) * 16 + newyy - 1) * 16 + xx - 1][dir] = 0;
			self->currentChunkDraw16[((zz - 1) * 16 + newyy - 1) * 16 + xx - 1] &= Game_IntToByte(~dirflags);
			newyy++;
		}
		return newyy - yy;
	}
	else {
		int shadowy = dir == 2 ? -1 : 1;
		int newxx = xx + 1;
		for (;;) {
			int shadowratio2;
			if (newxx >= 17) {
				break;
			}
			if (currentChunk[(zz * 18 + yy) * 18 + newxx] != tt) {
				break;
			}
			shadowratio2 = TerrainChunkTesselatorCi_GetShadowRatioOld(self, newxx, yy + shadowy, zz, x + newxx - xx, y + shadowy, z);
			if (shadowratio != shadowratio2) {
				break;
			}
			if ((self->currentChunkDraw16[((zz - 1) * 16 + yy - 1) * 16 + newxx - 1] & dirflags) == 0) {
				break;
			}
			self->currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + newxx - 1][dir] = 0;
			self->currentChunkDraw16[((zz - 1) * 16 + yy - 1) * 16 + newxx - 1] &= Game_IntToByte(~dirflags);
			newxx++;
		}
		return newxx - xx;
	}
}

static int TerrainChunkTesselatorCi_GetToDrawFlags(TerrainChunkTesselatorCi const *self, int xx, int yy, int zz)
{
	int nToDraw = 0;
	unsigned char const *drawFlags = self->currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1];
	nToDraw = TerrainChunkTesselatorCi_SetVisibleFlag(self, drawFlags, 0, nToDraw, 1);
	nToDraw = TerrainChunkTesselatorCi_SetVisibleFlag(self, drawFlags, 1, nToDraw, 2);
	nToDraw = TerrainChunkTesselatorCi_SetVisibleFlag(self, drawFlags, 2, nToDraw, 4);
	nToDraw = TerrainChunkTesselatorCi_SetVisibleFlag(self, drawFlags, 3, nToDraw, 8);
	nToDraw = TerrainChunkTesselatorCi_SetVisibleFlag(self, drawFlags, 4, nToDraw, 16);
	nToDraw = TerrainChunkTesselatorCi_SetVisibleFlag(self, drawFlags, 5, nToDraw, 32);
	return nToDraw;
}

VerticesIndicesToLoad const *TerrainChunkTesselatorCi_GetVerticesIndices(TerrainChunkTesselatorCi const *self, ModelData const *m, int x, int y, int z, int texture, cibool transparent)
{
	VerticesIndicesToLoad *v = VerticesIndicesToLoad_New();
	v->modelData = m;
	v->positionX = x * 16;
	v->positionY = y * 16;
	v->positionZ = z * 16;
	v->texture = texture;
	v->transparent = transparent;
	return v;
}

cibool TerrainChunkTesselatorCi_IsFlower(TerrainChunkTesselatorCi const *self, int tiletype)
{
	return self->game->blocktypes[tiletype]->drawType == 5;
}

cibool TerrainChunkTesselatorCi_IsTransparentForLight(TerrainChunkTesselatorCi const *self, int block)
{
	Packet_BlockType const *b = self->game->blocktypes[block];
	return b->drawType != 1 && b->drawType != 8;
}

cibool TerrainChunkTesselatorCi_IsTransparentFully(TerrainChunkTesselatorCi const *self, int p)
{
	Packet_BlockType const *b = self->game->blocktypes[p];
	return b->drawType != 1 && b->drawType != 5 && b->drawType != 6 && b->drawType != 7 && b->drawType != 8;
}

VerticesIndicesToLoad const *const *TerrainChunkTesselatorCi_MakeChunk(TerrainChunkTesselatorCi *self, int x, int y, int z, int const *chunk18, unsigned char const *shadows18, float const *lightlevels_, IntRef *retCount)
{
	VerticesIndicesToLoad const *const *ret;
	self->currentChunk18 = chunk18;
	self->currentChunkShadows18 = shadows18;
	self->lightlevels = lightlevels_;
	{
		int i;
		for (i = 0; i < 1024; i++) {
			Packet_BlockType const *b = self->game->blocktypes[i];
			if (b == NULL) {
				continue;
			}
			self->istransparent[i] = b->drawType != 1 && b->drawType != 3;
			if (b->drawType == 11 || b->drawType == 12 || Packet_BlockType_GetRail(b) != 0) {
				self->isLowered[i] = TRUE;
			}
			self->isFluid[i] = b->drawType == 3;
		}
	}
	if (x < 0 || y < 0 || z < 0) {
		retCount->value = 0;
		return (VerticesIndicesToLoad const **) malloc(0 * sizeof(VerticesIndicesToLoad const *));
	}
	if (!self->started) {
		self->game->platform->vtbl->throwException(self->game->platform, "not started");
	}
	if (x >= self->mapsizex / 16 || y >= self->mapsizey / 16 || z >= self->mapsizez / 16) {
		retCount->value = 0;
		return (VerticesIndicesToLoad const **) malloc(0 * sizeof(VerticesIndicesToLoad const *));
	}
	{
		int i;
		for (i = 0; i < self->toreturnatlas1dLength; i++) {
			self->toreturnatlas1d[i]->verticesCount = 0;
			self->toreturnatlas1d[i]->indicesCount = 0;
			self->toreturnatlas1dtransparent[i]->verticesCount = 0;
			self->toreturnatlas1dtransparent[i]->indicesCount = 0;
		}
	}
	TerrainChunkTesselatorCi_CalculateVisibleFaces(self, self->currentChunk18);
	TerrainChunkTesselatorCi_CalculateTilingCount(self, self->currentChunk18, x * 16, y * 16, z * 16);
	TerrainChunkTesselatorCi_BuildBlockPolygons(self, x, y, z);
	ret = TerrainChunkTesselatorCi_GetFinalVerticesIndices(self, x, y, z, retCount);
	return ret;
}

static int TerrainChunkTesselatorCi_Max(TerrainChunkTesselatorCi const *self, int a, int b)
{
	if (a > b) {
		return a;
	}
	else {
		return b;
	}
}

int TerrainChunkTesselatorCi_Rail(TerrainChunkTesselatorCi const *self, int tiletype)
{
	return self->game->blocktypes[tiletype]->rail;
}

static int TerrainChunkTesselatorCi_SetVisibleFlag(TerrainChunkTesselatorCi const *self, unsigned char const *drawFlags, int tileSideIndex, int nCurrentFlags, int nFlagToSet)
{
	if (drawFlags[tileSideIndex] > 0) {
		return nCurrentFlags | nFlagToSet;
	}
	else {
		return nCurrentFlags;
	}
}

void TerrainChunkTesselatorCi_Start(TerrainChunkTesselatorCi *self)
{
	self->currentChunk18 = (int *) malloc(5832 * sizeof(int ));
	self->currentChunkShadows18 = (unsigned char *) malloc(5832 * sizeof(unsigned char ));
	self->currentChunkDraw16 = (unsigned char *) malloc(4096 * sizeof(unsigned char ));
	self->currentChunkDrawCount16 = (unsigned char const **) malloc(4096 * sizeof(unsigned char const *));
	self->mapsizex = self->game->map->mapSizeX;
	self->mapsizey = self->game->map->mapSizeY;
	self->mapsizez = self->game->map->mapSizeZ;
	self->started = TRUE;
	self->istransparent = (cibool *) malloc(1024 * sizeof(cibool ));
	{
		int i;
		for (i = 0; i < 1024; i++) {
			self->istransparent[i] = FALSE;
		}
	}
	self->isLowered = (cibool *) malloc(1024 * sizeof(cibool ));
	{
		int i;
		for (i = 0; i < 1024; i++) {
			self->isLowered[i] = FALSE;
		}
	}
	self->isFluid = (cibool *) malloc(1024 * sizeof(cibool ));
	{
		int i;
		for (i = 0; i < 1024; i++) {
			self->isFluid[i] = FALSE;
		}
	}
	self->maxlightInverse = 1f / 15;
	self->terrainTexturesPerAtlas = self->game->terrainTexturesPerAtlas;
	self->terrainTexturesPerAtlasInverse = 1f / self->game->terrainTexturesPerAtlas;
	if (self->game->platform->vtbl->isFastSystem(self->game->platform)) {
		self->atiArtifactFix = 1 / 32f * 0.25f;
	}
	else {
		self->atiArtifactFix = 1 / 32f * 1.5f;
	}
	self->_texrecWidth = 1 - self->atiArtifactFix * 2;
	self->_texrecHeight = self->terrainTexturesPerAtlasInverse * (1 - self->atiArtifactFix * 2);
	self->_texrecLeft = self->atiArtifactFix;
	self->_texrecRight = self->_texrecLeft + self->_texrecWidth;
	self->toreturnatlas1dLength = TerrainChunkTesselatorCi_Max(self, 1, 1024 / self->game->terrainTexturesPerAtlas);
	self->toreturnatlas1d = (ModelData const **) malloc(self->toreturnatlas1dLength * sizeof(ModelData const *));
	self->toreturnatlas1dtransparent = (ModelData const **) malloc(self->toreturnatlas1dLength * sizeof(ModelData const *));
	{
		int i;
		for (i = 0; i < self->toreturnatlas1dLength; i++) {
			int max;
			self->toreturnatlas1d[i] = ModelData_New();
			max = 1024;
			self->toreturnatlas1d[i]->xyz = (float *) malloc(max * 3 * sizeof(float ));
			self->toreturnatlas1d[i]->uv = (float *) malloc(max * 2 * sizeof(float ));
			self->toreturnatlas1d[i]->rgba = (unsigned char *) malloc(max * 4 * sizeof(unsigned char ));
			self->toreturnatlas1d[i]->indices = (int *) malloc(max * sizeof(int ));
			self->toreturnatlas1d[i]->verticesMax = max;
			self->toreturnatlas1d[i]->indicesMax = max;
			self->toreturnatlas1dtransparent[i] = ModelData_New();
			self->toreturnatlas1dtransparent[i]->xyz = (float *) malloc(max * 3 * sizeof(float ));
			self->toreturnatlas1dtransparent[i]->uv = (float *) malloc(max * 2 * sizeof(float ));
			self->toreturnatlas1dtransparent[i]->rgba = (unsigned char *) malloc(max * 4 * sizeof(unsigned char ));
			self->toreturnatlas1dtransparent[i]->indices = (int *) malloc(max * sizeof(int ));
			self->toreturnatlas1dtransparent[i]->verticesMax = max;
			self->toreturnatlas1dtransparent[i]->indicesMax = max;
		}
	}
}

int TerrainChunkTesselatorCi_TextureId(TerrainChunkTesselatorCi const *self, int tiletype, int side)
{
	return self->game->textureId[tiletype][side];
}

int TerrainChunkTesselatorCi_getBestLadderInDirection(TerrainChunkTesselatorCi const *self, int x, int y, int z, int const *currentChunk, int dir)
{
	int dz = dir;
	int result = 0;
	{
		while (((z + dz) * 18 + y) * 18 + x >= 0 && ((z + dz) * 18 + y) * 18 + x < 5832 && currentChunk[((z + dz) * 18 + y) * 18 + x] == 152) {
			result = dz;
			if (TerrainChunkTesselatorCi_getBestLadderWall(self, x, y, z + dz, currentChunk) != -1)
				return result;
			dz += dir;
		}
	}
	return 0;
}

int TerrainChunkTesselatorCi_getBestLadderWall(TerrainChunkTesselatorCi const *self, int x, int y, int z, int const *currentChunk)
{
	cibool front = FALSE;
	cibool back = FALSE;
	cibool left = FALSE;
	int wallscount = 0;
	int c;
	if (currentChunk[(z * 18 + y - 1) * 18 + x] != 0) {
		front = TRUE;
		wallscount++;
	}
	if (currentChunk[(z * 18 + y + 1) * 18 + x] != 0) {
		back = TRUE;
		wallscount++;
	}
	c = currentChunk[(z * 18 + y) * 18 + x - 1];
	if (c != 0) {
		left = TRUE;
		wallscount++;
	}
	if (currentChunk[(z * 18 + y) * 18 + x + 1] != 0) {
		wallscount++;
	}
	if (wallscount != 1) {
		return -1;
	}
	else {
		if (front) {
			return 0;
		}
		else if (back) {
			return 1;
		}
		else if (left) {
			return 2;
		}
		else {
			return 3;
		}
	}
}

cibool TerrainChunkTesselatorCi_isvalid(TerrainChunkTesselatorCi const *self, int tt)
{
	return self->game->blocktypes[tt]->name != NULL;
}

static void TerrainRendererCommit_Construct(TerrainRendererCommit *self, const Action_Vtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_TerrainRendererCommit;
	Action__Construct(&self->base, vtbl);
}

TerrainRendererCommit *TerrainRendererCommit_New(void)
{
	TerrainRendererCommit *self = (TerrainRendererCommit *) malloc(sizeof(TerrainRendererCommit));
	if (self != NULL)
		TerrainRendererCommit_Construct(self, NULL);
	return self;
}

void TerrainRendererCommit_Delete(TerrainRendererCommit *self)
{
	free(self);
}

TerrainRendererCommit const *TerrainRendererCommit_Create(ModDrawTerrain *renderer)
{
	TerrainRendererCommit *c = TerrainRendererCommit_New();
	c->renderer = renderer;
	return c;
}

void TerrainRendererCommit_Run(TerrainRendererCommit const *self)
{
	ModDrawTerrain_MainThreadCommit(self->renderer);
}

TerrainRendererRedraw *TerrainRendererRedraw_New(void)
{
	TerrainRendererRedraw *self = (TerrainRendererRedraw *) malloc(sizeof(TerrainRendererRedraw));
	return self;
}

void TerrainRendererRedraw_Delete(TerrainRendererRedraw *self)
{
	free(self);
}

TextColorRenderer *TextColorRenderer_New(void)
{
	TextColorRenderer *self = (TextColorRenderer *) malloc(sizeof(TextColorRenderer));
	return self;
}

void TextColorRenderer_Delete(TextColorRenderer *self)
{
	free(self);
}

static BitmapCi const *TextColorRenderer_CreateTextTexture(TextColorRenderer const *self, Text_ const *t)
{
	IntRef *partsCount = IntRef_New();
	TextPart const *const *parts = TextColorRenderer_DecodeColors(self, t->text, t->color, partsCount);
	float totalwidth = 0;
	float totalheight = 0;
	int *sizesX = (int *) malloc(partsCount->value * sizeof(int ));
	int *sizesY = (int *) malloc(partsCount->value * sizeof(int ));
	int size2X;
	int size2Y;
	BitmapCi const *bmp2;
	int *bmp2Pixels;
	float currentwidth;
	{
		int i;
		for (i = 0; i < partsCount->value; i++) {
			IntRef const *outWidth = IntRef_New();
			IntRef const *outHeight = IntRef_New();
			self->platform->vtbl->textSize(self->platform, parts[i]->text, t->fontsize, outWidth, outHeight);
			sizesX[i] = outWidth->value;
			sizesY[i] = outHeight->value;
			totalwidth += outWidth->value;
			totalheight = MathCi_MaxFloat(totalheight, outHeight->value);
		}
	}
	size2X = TextColorRenderer_NextPowerOfTwo(self, self->platform->vtbl->floatToInt(self->platform, totalwidth) + 1);
	size2Y = TextColorRenderer_NextPowerOfTwo(self, self->platform->vtbl->floatToInt(self->platform, totalheight) + 1);
	bmp2 = self->platform->vtbl->bitmapCreate(self->platform, size2X, size2Y);
	bmp2Pixels = (int *) malloc(size2X * size2Y * sizeof(int ));
	currentwidth = 0;
	{
		int i;
		for (i = 0; i < partsCount->value; i++) {
			int sizeiX = sizesX[i];
			int sizeiY = sizesY[i];
			Text_ *partText;
			BitmapCi const *partBmp;
			int partWidth;
			int partHeight;
			int const *partBmpPixels;
			if (sizeiX == 0 || sizeiY == 0) {
				continue;
			}
			partText = Text__New();
			partText->text = parts[i]->text;
			partText->color = parts[i]->color;
			partText->fontsize = t->fontsize;
			partText->fontstyle = t->fontstyle;
			partText->fontfamily = t->fontfamily;
			partBmp = self->platform->vtbl->createTextTexture(self->platform, partText);
			partWidth = self->platform->vtbl->floatToInt(self->platform, self->platform->vtbl->bitmapGetWidth(self->platform, partBmp));
			partHeight = self->platform->vtbl->floatToInt(self->platform, self->platform->vtbl->bitmapGetHeight(self->platform, partBmp));
			partBmpPixels = (int *) malloc(partWidth * partHeight * sizeof(int ));
			self->platform->vtbl->bitmapGetPixelsArgb(self->platform, partBmp, partBmpPixels);
			{
				int x;
				for (x = 0; x < partWidth; x++) {
					{
						int y;
						for (y = 0; y < partHeight; y++) {
							int c;
							if (x + currentwidth >= size2X) {
								continue;
							}
							if (y >= size2Y) {
								continue;
							}
							c = partBmpPixels[MapUtilCi_Index2d(x, y, partWidth)];
							if (Game_ColorA(c) > 0) {
								bmp2Pixels[MapUtilCi_Index2d(self->platform->vtbl->floatToInt(self->platform, currentwidth) + x, y, size2X)] = c;
							}
						}
					}
				}
			}
			currentwidth += sizeiX;
		}
	}
	self->platform->vtbl->bitmapSetPixelsArgb(self->platform, bmp2, bmp2Pixels);
	return bmp2;
}

TextPart const *const *TextColorRenderer_DecodeColors(TextColorRenderer const *self, const char *s, int defaultcolor, IntRef *retLength)
{
	TextPart const **parts = (TextPart const **) malloc(256 * sizeof(TextPart const *));
	int partsCount = 0;
	int currentcolor = defaultcolor;
	int *currenttext = (int *) malloc(256 * sizeof(int ));
	int currenttextLength = 0;
	IntRef const *sLength = IntRef_New();
	int const *sChars = self->platform->vtbl->stringToCharArray(self->platform, s, sLength);
	{
		int i;
		for (i = 0; i < sLength->value; i++) {
			if (sChars[i] == 38) {
				if (i + 1 < sLength->value) {
					int color = TextColorRenderer_HexToInt(self, sChars[i + 1]);
					if (color != -1) {
						if (currenttextLength != 0) {
							TextPart *part = TextPart_New();
							part->text = self->platform->vtbl->charArrayToString(self->platform, currenttext, currenttextLength);
							part->color = currentcolor;
							parts[partsCount++] = part;
						}
						{
							int k;
							for (k = 0; k < currenttextLength; k++) {
								currenttext[k] = 0;
							}
						}
						currenttextLength = 0;
						currentcolor = TextColorRenderer_GetColor(self, color);
						i++;
					}
					else {
						currenttext[currenttextLength++] = sChars[i];
					}
				}
				else {
					currenttext[currenttextLength++] = sChars[i];
				}
			}
			else {
				currenttext[currenttextLength++] = s[i];
			}
		}
	}
	if (currenttextLength != 0) {
		TextPart *part = TextPart_New();
		part->text = self->platform->vtbl->charArrayToString(self->platform, currenttext, currenttextLength);
		part->color = currentcolor;
		parts[partsCount++] = part;
	}
	retLength->value = partsCount;
	return parts;
}

static int TextColorRenderer_GetColor(TextColorRenderer const *self, int currentcolor)
{
	switch (currentcolor) {
	case 0:
		{
			return Game_ColorFromArgb(255, 0, 0, 0);
		}
	case 1:
		{
			return Game_ColorFromArgb(255, 0, 0, 191);
		}
	case 2:
		{
			return Game_ColorFromArgb(255, 0, 191, 0);
		}
	case 3:
		{
			return Game_ColorFromArgb(255, 0, 191, 191);
		}
	case 4:
		{
			return Game_ColorFromArgb(255, 191, 0, 0);
		}
	case 5:
		{
			return Game_ColorFromArgb(255, 191, 0, 191);
		}
	case 6:
		{
			return Game_ColorFromArgb(255, 191, 191, 0);
		}
	case 7:
		{
			return Game_ColorFromArgb(255, 191, 191, 191);
		}
	case 8:
		{
			return Game_ColorFromArgb(255, 40, 40, 40);
		}
	case 9:
		{
			return Game_ColorFromArgb(255, 64, 64, 255);
		}
	case 10:
		{
			return Game_ColorFromArgb(255, 64, 255, 64);
		}
	case 11:
		{
			return Game_ColorFromArgb(255, 64, 255, 255);
		}
	case 12:
		{
			return Game_ColorFromArgb(255, 255, 64, 64);
		}
	case 13:
		{
			return Game_ColorFromArgb(255, 255, 64, 255);
		}
	case 14:
		{
			return Game_ColorFromArgb(255, 255, 255, 64);
		}
	case 15:
		{
			return Game_ColorFromArgb(255, 255, 255, 255);
		}
	default:
		return Game_ColorFromArgb(255, 255, 255, 255);
	}
}

static int TextColorRenderer_HexToInt(TextColorRenderer const *self, int c)
{
	if (c == 48) {
		return 0;
	}
	if (c == 49) {
		return 1;
	}
	if (c == 50) {
		return 2;
	}
	if (c == 51) {
		return 3;
	}
	if (c == 52) {
		return 4;
	}
	if (c == 53) {
		return 5;
	}
	if (c == 54) {
		return 6;
	}
	if (c == 55) {
		return 7;
	}
	if (c == 56) {
		return 8;
	}
	if (c == 57) {
		return 9;
	}
	if (c == 97) {
		return 10;
	}
	if (c == 98) {
		return 11;
	}
	if (c == 99) {
		return 12;
	}
	if (c == 100) {
		return 13;
	}
	if (c == 101) {
		return 14;
	}
	if (c == 102) {
		return 15;
	}
	return -1;
}

static int TextColorRenderer_NextPowerOfTwo(TextColorRenderer const *self, int x)
{
	x--;
	x |= x >> 1;
	x |= x >> 2;
	x |= x >> 4;
	x |= x >> 8;
	x++;
	return x;
}

TextPart *TextPart_New(void)
{
	TextPart *self = (TextPart *) malloc(sizeof(TextPart));
	return self;
}

void TextPart_Delete(TextPart *self)
{
	free(self);
}

TextTexture *TextTexture_New(void)
{
	TextTexture *self = (TextTexture *) malloc(sizeof(TextTexture));
	return self;
}

void TextTexture_Delete(TextTexture *self)
{
	free(self);
}

Text_ *Text__New(void)
{
	Text_ *self = (Text_ *) malloc(sizeof(Text_));
	return self;
}

void Text__Delete(Text_ *self)
{
	free(self);
}

static cibool Text__Equals_(Text_ const *self, Text_ const *t)
{
	return strcmp(self->text, t->text) == 0 && self->fontsize == t->fontsize && self->color == t->color && strcmp(self->fontfamily, t->fontfamily) == 0 && self->fontstyle == t->fontstyle;
}

int Text__GetColor(Text_ const *self)
{
	return self->color;
}

const char *Text__GetFontFamily(Text_ const *self)
{
	return self->fontfamily;
}

float Text__GetFontSize(Text_ const *self)
{
	return self->fontsize;
}

int Text__GetFontStyle(Text_ const *self)
{
	return self->fontstyle;
}

const char *Text__GetText(Text_ const *self)
{
	return self->text;
}

void Text__SetColor(Text_ *self, int value)
{
	self->color = value;
}

void Text__SetFontFamily(Text_ *self, const char *value)
{
	self->fontfamily = value;
}

void Text__SetFontSize(Text_ *self, float value)
{
	self->fontsize = value;
}

void Text__SetFontStyle(Text_ *self, int value)
{
	self->fontstyle = value;
}

void Text__SetText(Text_ *self, const char *value)
{
	self->text = value;
}

RectFRef const *TextureAtlas_TextureCoords2d(int textureId, int texturesPacked)
{
	float one = 1;
	RectFRef *r = RectFRef_New();
	r->y = one / texturesPacked * textureId / texturesPacked;
	r->x = one / texturesPacked * textureId % texturesPacked;
	r->w = one / texturesPacked;
	r->h = one / texturesPacked;
	return r;
}

void TextureAtlasCi_TextureCoords2d(int textureId, int texturesPacked, RectFRef *r)
{
	float one = 1;
	r->y = one / texturesPacked * textureId / texturesPacked;
	r->x = one / texturesPacked * textureId % texturesPacked;
	r->w = one / texturesPacked;
	r->h = one / texturesPacked;
}

BitmapCi const *const *TextureAtlasConverter_Atlas2dInto1d(TextureAtlasConverter const *self, GamePlatform const *p, BitmapCi const *atlas2d_, int tiles, int atlassizezlimit, IntRef *retCount)
{
	BitmapData_ const *orig = BitmapData__CreateFromBitmap(p, atlas2d_);
	int tilesize = orig->width / tiles;
	int atlasescount = MathCi_MaxInt(1, tiles * tiles * tilesize / atlassizezlimit);
	BitmapCi const **atlases = (BitmapCi const **) malloc(128 * sizeof(BitmapCi const *));
	int atlasesCount = 0;
	BitmapData_ const *atlas1d = NULL;
	{
		int i;
		for (i = 0; i < tiles * tiles; i++) {
			int x = i % tiles;
			int y = i / tiles;
			int tilesinatlas = tiles * tiles / atlasescount;
			if (i % tilesinatlas == 0) {
				if (atlas1d != NULL) {
					atlases[atlasesCount++] = BitmapData__ToBitmap(atlas1d, p);
				}
				atlas1d = BitmapData__Create(tilesize, atlassizezlimit);
			}
			{
				int xx;
				for (xx = 0; xx < tilesize; xx++) {
					{
						int yy;
						for (yy = 0; yy < tilesize; yy++) {
							int c = BitmapData__GetPixel(orig, x * tilesize + xx, y * tilesize + yy);
							BitmapData__SetPixel(atlas1d, xx, i % tilesinatlas * tilesize + yy, c);
						}
					}
				}
			}
		}
	}
	atlases[atlasesCount++] = BitmapData__ToBitmap(atlas1d, p);
	retCount->value = atlasescount;
	return atlases;
}

ThumbnailResponseCi *ThumbnailResponseCi_New(void)
{
	ThumbnailResponseCi *self = (ThumbnailResponseCi *) malloc(sizeof(ThumbnailResponseCi));
	return self;
}

void ThumbnailResponseCi_Delete(ThumbnailResponseCi *self)
{
	free(self);
}

TileEnterData *TileEnterData_New(void)
{
	TileEnterData *self = (TileEnterData *) malloc(sizeof(TileEnterData));
	return self;
}

void TileEnterData_Delete(TileEnterData *self)
{
	free(self);
}

int TileSideEnum_ToFlags(int nValue)
{
	switch (nValue) {
	case 0:
		return 1;
	case 1:
		return 2;
	case 2:
		return 16;
	case 3:
		return 32;
	case 4:
		return 8;
	case 5:
		return 4;
	default:
		return 0;
	}
}

cibool TileSideFlagsEnum_HasFlag(int nFlagA, int nFlagB)
{
	return (nFlagA & nFlagB) != 0;
}

static void TimerCi_Construct(TimerCi *self)
{
	self->interval = 1;
	self->maxDeltaTime = -1;
}

TimerCi *TimerCi_New(void)
{
	TimerCi *self = (TimerCi *) malloc(sizeof(TimerCi));
	if (self != NULL)
		TimerCi_Construct(self);
	return self;
}

void TimerCi_Delete(TimerCi *self)
{
	free(self);
}

static TimerCi *TimerCi_Create(int interval_, int maxDeltaTime_)
{
	TimerCi *timer = TimerCi_New();
	timer->interval = interval_;
	timer->maxDeltaTime = maxDeltaTime_;
	return timer;
}

void TimerCi_Reset(TimerCi *self)
{
	self->accumulator = 0;
}

int TimerCi_Update(TimerCi *self, float dt)
{
	float constDt;
	int updates;
	self->accumulator += dt;
	constDt = self->interval;
	if (self->maxDeltaTime != -1 && self->accumulator > self->maxDeltaTime) {
		self->accumulator = self->maxDeltaTime;
	}
	updates = 0;
	while (self->accumulator >= constDt) {
		updates++;
		self->accumulator -= constDt;
	}
	return updates;
}

ToCall *ToCall_New(void)
{
	ToCall *self = (ToCall *) malloc(sizeof(ToCall));
	return self;
}

void ToCall_Delete(ToCall *self)
{
	free(self);
}

TouchEventArgs *TouchEventArgs_New(void)
{
	TouchEventArgs *self = (TouchEventArgs *) malloc(sizeof(TouchEventArgs));
	return self;
}

void TouchEventArgs_Delete(TouchEventArgs *self)
{
	free(self);
}

cibool TouchEventArgs_GetHandled(TouchEventArgs const *self)
{
	return self->handled;
}

int TouchEventArgs_GetId(TouchEventArgs const *self)
{
	return self->id;
}

int TouchEventArgs_GetX(TouchEventArgs const *self)
{
	return self->x;
}

int TouchEventArgs_GetY(TouchEventArgs const *self)
{
	return self->y;
}

void TouchEventArgs_SetHandled(TouchEventArgs *self, cibool value)
{
	self->handled = value;
}

void TouchEventArgs_SetId(TouchEventArgs *self, int value)
{
	self->id = value;
}

void TouchEventArgs_SetX(TouchEventArgs *self, int value)
{
	self->x = value;
}

void TouchEventArgs_SetY(TouchEventArgs *self, int value)
{
	self->y = value;
}

static void TouchEventHandler_Construct(TouchEventHandler *self, const TouchEventHandlerVtbl *vtbl)
{
	self->vtbl = vtbl;
}

TranslatedString *TranslatedString_New(void)
{
	TranslatedString *self = (TranslatedString *) malloc(sizeof(TranslatedString));
	return self;
}

void TranslatedString_Delete(TranslatedString *self)
{
	free(self);
}

static void UnloadRendererChunksCommit_Construct(UnloadRendererChunksCommit *self, const Action_Vtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_UnloadRendererChunksCommit;
	Action__Construct(&self->base, vtbl);
}

UnloadRendererChunksCommit *UnloadRendererChunksCommit_New(void)
{
	UnloadRendererChunksCommit *self = (UnloadRendererChunksCommit *) malloc(sizeof(UnloadRendererChunksCommit));
	if (self != NULL)
		UnloadRendererChunksCommit_Construct(self, NULL);
	return self;
}

void UnloadRendererChunksCommit_Delete(UnloadRendererChunksCommit *self)
{
	free(self);
}

void UnloadRendererChunksCommit_Run(UnloadRendererChunksCommit *self)
{
	if (self->unloadChunkPos != -1) {
		Chunk const *c = self->game->map->chunks[self->unloadChunkPos];
		{
			int k;
			for (k = 0; k < c->rendered->idsCount; k++) {
				int loadedSubmesh = c->rendered->ids[k];
				MeshBatcher_Remove(self->game->d_Batcher, loadedSubmesh);
			}
		}
		c->rendered->ids = NULL;
		c->rendered->dirty = TRUE;
		c->rendered->light = NULL;
		self->unloadChunkPos = -1;
	}
}

static void Unproject_Construct(Unproject *self)
{
	self->finalMatrix = Mat4_Create();
	self->inp = (float *) malloc(4 * sizeof(float ));
	self->out_ = (float *) malloc(4 * sizeof(float ));
}

Unproject *Unproject_New(void)
{
	Unproject *self = (Unproject *) malloc(sizeof(Unproject));
	if (self != NULL)
		Unproject_Construct(self);
	return self;
}

void Unproject_Delete(Unproject *self)
{
	free(self);
}

static void Unproject_MultMatrixVec(Unproject const *self, float const *matrix, float const *inp__, float *out__)
{
	{
		int i;
		for (i = 0; i < 4; i = i + 1) {
			out__[i] = inp__[0] * matrix[0 + i] + inp__[1] * matrix[4 + i] + inp__[2] * matrix[8 + i] + inp__[3] * matrix[12 + i];
		}
	}
}

cibool Unproject_UnProject(Unproject const *self, int winX, int winY, int winZ, float const *model, float const *proj, float const *view, float *objPos)
{
	self->inp[0] = winX;
	self->inp[1] = winY;
	self->inp[2] = winZ;
	self->inp[3] = 1;
	Mat4_Multiply(self->finalMatrix, proj, model);
	Mat4_Invert(self->finalMatrix, self->finalMatrix);
	self->inp[0] = (self->inp[0] - view[0]) / view[2];
	self->inp[1] = (self->inp[1] - view[1]) / view[3];
	self->inp[0] = self->inp[0] * 2 - 1;
	self->inp[1] = self->inp[1] * 2 - 1;
	self->inp[2] = self->inp[2] * 2 - 1;
	Unproject_MultMatrixVec(self, self->finalMatrix, self->inp, self->out_);
	if (self->out_[3] == 0) {
		return FALSE;
	}
	self->out_[0] /= self->out_[3];
	self->out_[1] /= self->out_[3];
	self->out_[2] /= self->out_[3];
	objPos[0] = self->out_[0];
	objPos[1] = self->out_[1];
	objPos[2] = self->out_[2];
	return TRUE;
}

UriCi *UriCi_New(void)
{
	UriCi *self = (UriCi *) malloc(sizeof(UriCi));
	return self;
}

void UriCi_Delete(UriCi *self)
{
	free(self);
}

DictionaryStringString const *UriCi_GetGet(UriCi const *self)
{
	return self->get;
}

const char *UriCi_GetIp(UriCi const *self)
{
	return self->ip;
}

int UriCi_GetPort(UriCi const *self)
{
	return self->port;
}

const char *UriCi_GetUrl(UriCi const *self)
{
	return self->url;
}

float const *Vec2_Add(float *output, float const *a, float const *b)
{
	output[0] = a[0] + b[0];
	output[1] = a[1] + b[1];
	return output;
}

float const *Vec2_CloneIt(float const *a)
{
	float *output = (float *) malloc(2 * sizeof(float ));
	output[0] = a[0];
	output[1] = a[1];
	return output;
}

float const *Vec2_Copy(float *output, float const *a)
{
	output[0] = a[0];
	output[1] = a[1];
	return output;
}

float const *Vec2_Create(void)
{
	float *output = (float *) malloc(2 * sizeof(float ));
	output[0] = 0;
	output[1] = 0;
	return output;
}

float const *Vec2_Cross(float *output, float const *a, float const *b)
{
	float z = a[0] * b[1] - a[1] * b[0];
	output[0] = output[1] = 0;
	output[2] = z;
	return output;
}

float Vec2_Dist(float const *a, float const *b)
{
	return Vec2_Distance(a, b);
}

float Vec2_Distance(float const *a, float const *b)
{
	float x = b[0] - a[0];
	float y = b[1] - a[1];
	return Platform_Sqrt(x * x + y * y);
}

float const *Vec2_Div(float *output, float const *a, float const *b)
{
	return Vec2_Divide(output, a, b);
}

float const *Vec2_Divide(float *output, float const *a, float const *b)
{
	output[0] = a[0] / b[0];
	output[1] = a[1] / b[1];
	return output;
}

float Vec2_Dot(float const *a, float const *b)
{
	return a[0] * b[0] + a[1] * b[1];
}

float const *Vec2_FromValues(float x, float y)
{
	float *output = (float *) malloc(2 * sizeof(float ));
	output[0] = x;
	output[1] = y;
	return output;
}

float Vec2_Len(float const *a)
{
	return Vec2_Length_(a);
}

float Vec2_Length_(float const *a)
{
	float x = a[0];
	float y = a[1];
	return Platform_Sqrt(x * x + y * y);
}

float const *Vec2_Lerp(float *output, float const *a, float const *b, float t)
{
	float ax = a[0];
	float ay = a[1];
	output[0] = ax + t * (b[0] - ax);
	output[1] = ay + t * (b[1] - ay);
	return output;
}

float const *Vec2_Max(float *output, float const *a, float const *b)
{
	output[0] = GlMatrixMath_max(a[0], b[0]);
	output[1] = GlMatrixMath_max(a[1], b[1]);
	return output;
}

float const *Vec2_Min(float *output, float const *a, float const *b)
{
	output[0] = GlMatrixMath_min(a[0], b[0]);
	output[1] = GlMatrixMath_min(a[1], b[1]);
	return output;
}

float const *Vec2_Mul(float *output, float const *a, float const *b)
{
	return Vec2_Multiply(output, a, b);
}

float const *Vec2_Multiply(float *output, float const *a, float const *b)
{
	output[0] = a[0] * b[0];
	output[1] = a[1] * b[1];
	return output;
}

float const *Vec2_Negate(float *output, float const *a)
{
	output[0] = -a[0];
	output[1] = -a[1];
	return output;
}

float const *Vec2_Normalize(float *output, float const *a)
{
	float x = a[0];
	float y = a[1];
	float len = x * x + y * y;
	if (len > 0) {
		len = 1 / Platform_Sqrt(len);
		output[0] = a[0] * len;
		output[1] = a[1] * len;
	}
	return output;
}

float const *Vec2_Scale(float *output, float const *a, float b)
{
	output[0] = a[0] * b;
	output[1] = a[1] * b;
	return output;
}

float const *Vec2_ScaleAndAdd(float *output, float const *a, float const *b, float scale)
{
	output[0] = a[0] + b[0] * scale;
	output[1] = a[1] + b[1] * scale;
	return output;
}

float const *Vec2_Set(float *output, float x, float y)
{
	output[0] = x;
	output[1] = y;
	return output;
}

float Vec2_SqrDist(float const *a, float const *b)
{
	return Vec2_SquaredDistance(a, b);
}

float Vec2_SqrLen(float const *a)
{
	return Vec2_SquaredLength(a);
}

float Vec2_SquaredDistance(float const *a, float const *b)
{
	float x = b[0] - a[0];
	float y = b[1] - a[1];
	return x * x + y * y;
}

float Vec2_SquaredLength(float const *a)
{
	float x = a[0];
	float y = a[1];
	return x * x + y * y;
}

float const *Vec2_Sub(float *output, float const *a, float const *b)
{
	return Vec2_Subtract(output, a, b);
}

float const *Vec2_Subtract(float *output, float const *a, float const *b)
{
	output[0] = a[0] - b[0];
	output[1] = a[1] - b[1];
	return output;
}

float const *Vec2_TransformMat2(float *output, float const *a, float const *m)
{
	float x = a[0];
	float y = a[1];
	output[0] = m[0] * x + m[2] * y;
	output[1] = m[1] * x + m[3] * y;
	return output;
}

float const *Vec2_TransformMat2d(float *output, float const *a, float const *m)
{
	float x = a[0];
	float y = a[1];
	output[0] = m[0] * x + m[2] * y + m[4];
	output[1] = m[1] * x + m[3] * y + m[5];
	return output;
}

float const *Vec2_TransformMat3(float *output, float const *a, float const *m)
{
	float x = a[0];
	float y = a[1];
	output[0] = m[0] * x + m[3] * y + m[6];
	output[1] = m[1] * x + m[4] * y + m[7];
	return output;
}

float const *Vec2_TransformMat4(float *output, float const *a, float const *m)
{
	float x = a[0];
	float y = a[1];
	output[0] = m[0] * x + m[4] * y + m[12];
	output[1] = m[1] * x + m[5] * y + m[13];
	return output;
}

float const *Vec3_Add(float *output, float const *a, float const *b)
{
	output[0] = a[0] + b[0];
	output[1] = a[1] + b[1];
	output[2] = a[2] + b[2];
	return output;
}

float *Vec3_CloneIt(float const *a)
{
	float *output = (float *) malloc(3 * sizeof(float ));
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	return output;
}

float const *Vec3_Copy(float *output, float const *a)
{
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	return output;
}

float *Vec3_Create(void)
{
	float *output = (float *) malloc(3 * sizeof(float ));
	output[0] = 0;
	output[1] = 0;
	output[2] = 0;
	return output;
}

float const *Vec3_Cross(float *output, float const *a, float const *b)
{
	float ax = a[0];
	float ay = a[1];
	float az = a[2];
	float bx = b[0];
	float by = b[1];
	float bz = b[2];
	output[0] = ay * bz - az * by;
	output[1] = az * bx - ax * bz;
	output[2] = ax * by - ay * bx;
	return output;
}

float Vec3_Dist(float const *a, float const *b)
{
	return Vec3_Distance(a, b);
}

float Vec3_Distance(float const *a, float const *b)
{
	float x = b[0] - a[0];
	float y = b[1] - a[1];
	float z = b[2] - a[2];
	return Platform_Sqrt(x * x + y * y + z * z);
}

float const *Vec3_Div(float *output, float const *a, float const *b)
{
	return Vec3_Divide(output, a, b);
}

float const *Vec3_Divide(float *output, float const *a, float const *b)
{
	output[0] = a[0] / b[0];
	output[1] = a[1] / b[1];
	output[2] = a[2] / b[2];
	return output;
}

float Vec3_Dot(float const *a, float const *b)
{
	return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

float *Vec3_FromValues(float x, float y, float z)
{
	float *output = (float *) malloc(3 * sizeof(float ));
	output[0] = x;
	output[1] = y;
	output[2] = z;
	return output;
}

float Vec3_Len(float const *a)
{
	return Vec3_Length_(a);
}

float Vec3_Length_(float const *a)
{
	float x = a[0];
	float y = a[1];
	float z = a[2];
	return Platform_Sqrt(x * x + y * y + z * z);
}

float const *Vec3_Lerp(float *output, float const *a, float const *b, float t)
{
	float ax = a[0];
	float ay = a[1];
	float az = a[2];
	output[0] = ax + t * (b[0] - ax);
	output[1] = ay + t * (b[1] - ay);
	output[2] = az + t * (b[2] - az);
	return output;
}

float const *Vec3_Max(float *output, float const *a, float const *b)
{
	output[0] = GlMatrixMath_max(a[0], b[0]);
	output[1] = GlMatrixMath_max(a[1], b[1]);
	output[2] = GlMatrixMath_max(a[2], b[2]);
	return output;
}

float const *Vec3_Min(float *output, float const *a, float const *b)
{
	output[0] = GlMatrixMath_min(a[0], b[0]);
	output[1] = GlMatrixMath_min(a[1], b[1]);
	output[2] = GlMatrixMath_min(a[2], b[2]);
	return output;
}

float const *Vec3_Mul(float *output, float const *a, float const *b)
{
	return Vec3_Multiply(output, a, b);
}

float const *Vec3_Multiply(float *output, float const *a, float const *b)
{
	output[0] = a[0] * b[0];
	output[1] = a[1] * b[1];
	output[2] = a[2] * b[2];
	return output;
}

float const *Vec3_Negate(float *output, float const *a)
{
	output[0] = 0 - a[0];
	output[1] = 0 - a[1];
	output[2] = 0 - a[2];
	return output;
}

float const *Vec3_Normalize(float *output, float const *a)
{
	float x = a[0];
	float y = a[1];
	float z = a[2];
	float len = x * x + y * y + z * z;
	if (len > 0) {
		float one = 1;
		len = one / Platform_Sqrt(len);
		output[0] = a[0] * len;
		output[1] = a[1] * len;
		output[2] = a[2] * len;
	}
	return output;
}

float const *Vec3_Scale(float *output, float const *a, float b)
{
	output[0] = a[0] * b;
	output[1] = a[1] * b;
	output[2] = a[2] * b;
	return output;
}

float const *Vec3_ScaleAndAdd(float *output, float const *a, float const *b, float scale)
{
	output[0] = a[0] + b[0] * scale;
	output[1] = a[1] + b[1] * scale;
	output[2] = a[2] + b[2] * scale;
	return output;
}

float const *Vec3_Set(float *output, float x, float y, float z)
{
	output[0] = x;
	output[1] = y;
	output[2] = z;
	return output;
}

float Vec3_SqrDist(float const *a, float const *b)
{
	return Vec3_SquaredDistance(a, b);
}

float Vec3_SqrLen(float const *a)
{
	return Vec3_SquaredLength(a);
}

float Vec3_SquaredDistance(float const *a, float const *b)
{
	float x = b[0] - a[0];
	float y = b[1] - a[1];
	float z = b[2] - a[2];
	return x * x + y * y + z * z;
}

float Vec3_SquaredLength(float const *a)
{
	float x = a[0];
	float y = a[1];
	float z = a[2];
	return x * x + y * y + z * z;
}

float const *Vec3_Sub(float *output, float const *a, float const *b)
{
	return Vec3_Substract(output, a, b);
}

float const *Vec3_Substract(float *output, float const *a, float const *b)
{
	output[0] = a[0] - b[0];
	output[1] = a[1] - b[1];
	output[2] = a[2] - b[2];
	return output;
}

float const *Vec3_TransformMat3(float *output, float const *a, float const *m)
{
	float x = a[0];
	float y = a[1];
	float z = a[2];
	output[0] = x * m[0] + y * m[3] + z * m[6];
	output[1] = x * m[1] + y * m[4] + z * m[7];
	output[2] = x * m[2] + y * m[5] + z * m[8];
	return output;
}

float const *Vec3_TransformMat4(float *output, float const *a, float const *m)
{
	float x = a[0];
	float y = a[1];
	float z = a[2];
	output[0] = m[0] * x + m[4] * y + m[8] * z + m[12];
	output[1] = m[1] * x + m[5] * y + m[9] * z + m[13];
	output[2] = m[2] * x + m[6] * y + m[10] * z + m[14];
	return output;
}

float const *Vec3_TransformQuat(float *output, float const *a, float const *q)
{
	float x = a[0];
	float y = a[1];
	float z = a[2];
	float qx = q[0];
	float qy = q[1];
	float qz = q[2];
	float qw = q[3];
	float ix = qw * x + qy * z - qz * y;
	float iy = qw * y + qz * x - qx * z;
	float iz = qw * z + qx * y - qy * x;
	float iw = (0 - qx) * x - qy * y - qz * z;
	output[0] = ix * qw + iw * (0 - qx) + iy * (0 - qz) - iz * (0 - qy);
	output[1] = iy * qw + iw * (0 - qy) + iz * (0 - qx) - ix * (0 - qz);
	output[2] = iz * qw + iw * (0 - qz) + ix * (0 - qy) - iy * (0 - qx);
	return output;
}

const char *Vec3_str(float const *a)
{
	return "";
}

float const *Vec4_Add(float *output, float const *a, float const *b)
{
	output[0] = a[0] + b[0];
	output[1] = a[1] + b[1];
	output[2] = a[2] + b[2];
	output[3] = a[3] + b[3];
	return output;
}

float const *Vec4_CloneIt(float const *a)
{
	float *output = (float *) malloc(4 * sizeof(float ));
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	output[3] = a[3];
	return output;
}

float const *Vec4_Copy(float *output, float const *a)
{
	output[0] = a[0];
	output[1] = a[1];
	output[2] = a[2];
	output[3] = a[3];
	return output;
}

float const *Vec4_Create(void)
{
	float *output = (float *) malloc(4 * sizeof(float ));
	output[0] = 0;
	output[1] = 0;
	output[2] = 0;
	output[3] = 0;
	return output;
}

float Vec4_Dist(float const *a, float const *b)
{
	return Vec4_Distance(a, b);
}

float Vec4_Distance(float const *a, float const *b)
{
	float x = b[0] - a[0];
	float y = b[1] - a[1];
	float z = b[2] - a[2];
	float w = b[3] - a[3];
	return Platform_Sqrt(x * x + y * y + z * z + w * w);
}

float const *Vec4_Div(float *output, float const *a, float const *b)
{
	return Vec4_Divide(output, a, b);
}

float const *Vec4_Divide(float *output, float const *a, float const *b)
{
	output[0] = a[0] / b[0];
	output[1] = a[1] / b[1];
	output[2] = a[2] / b[2];
	output[3] = a[3] / b[3];
	return output;
}

float Vec4_Dot(float const *a, float const *b)
{
	return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}

float const *Vec4_FromValues(float x, float y, float z, float w)
{
	float *output = (float *) malloc(4 * sizeof(float ));
	output[0] = x;
	output[1] = y;
	output[2] = z;
	output[3] = w;
	return output;
}

float Vec4_Len(float const *a)
{
	return Vec4_Length_(a);
}

float Vec4_Length_(float const *a)
{
	float x = a[0];
	float y = a[1];
	float z = a[2];
	float w = a[3];
	return Platform_Sqrt(x * x + y * y + z * z + w * w);
}

float const *Vec4_Lerp(float *output, float const *a, float const *b, float t)
{
	float ax = a[0];
	float ay = a[1];
	float az = a[2];
	float aw = a[3];
	output[0] = ax + t * (b[0] - ax);
	output[1] = ay + t * (b[1] - ay);
	output[2] = az + t * (b[2] - az);
	output[3] = aw + t * (b[3] - aw);
	return output;
}

float const *Vec4_Max(float *output, float const *a, float const *b)
{
	output[0] = GlMatrixMath_max(a[0], b[0]);
	output[1] = GlMatrixMath_max(a[1], b[1]);
	output[2] = GlMatrixMath_max(a[2], b[2]);
	output[3] = GlMatrixMath_max(a[3], b[3]);
	return output;
}

float const *Vec4_Min(float *output, float const *a, float const *b)
{
	output[0] = GlMatrixMath_min(a[0], b[0]);
	output[1] = GlMatrixMath_min(a[1], b[1]);
	output[2] = GlMatrixMath_min(a[2], b[2]);
	output[3] = GlMatrixMath_min(a[3], b[3]);
	return output;
}

float const *Vec4_Mul(float *output, float const *a, float const *b)
{
	return Vec4_Multiply(output, a, b);
}

float const *Vec4_Multiply(float *output, float const *a, float const *b)
{
	output[0] = a[0] * b[0];
	output[1] = a[1] * b[1];
	output[2] = a[2] * b[2];
	output[3] = a[3] * b[3];
	return output;
}

float const *Vec4_Negate(float *output, float const *a)
{
	output[0] = -a[0];
	output[1] = -a[1];
	output[2] = -a[2];
	output[3] = -a[3];
	return output;
}

float const *Vec4_Normalize(float *output, float const *a)
{
	float x = a[0];
	float y = a[1];
	float z = a[2];
	float w = a[3];
	float len = x * x + y * y + z * z + w * w;
	if (len > 0) {
		float one = 1;
		len = one / Platform_Sqrt(len);
		output[0] = a[0] * len;
		output[1] = a[1] * len;
		output[2] = a[2] * len;
		output[3] = a[3] * len;
	}
	return output;
}

float const *Vec4_Scale(float *output, float const *a, float b)
{
	output[0] = a[0] * b;
	output[1] = a[1] * b;
	output[2] = a[2] * b;
	output[3] = a[3] * b;
	return output;
}

float const *Vec4_ScaleAndAdd(float *output, float const *a, float const *b, float scale)
{
	output[0] = a[0] + b[0] * scale;
	output[1] = a[1] + b[1] * scale;
	output[2] = a[2] + b[2] * scale;
	output[3] = a[3] + b[3] * scale;
	return output;
}

float const *Vec4_Set(float *output, float x, float y, float z, float w)
{
	output[0] = x;
	output[1] = y;
	output[2] = z;
	output[3] = w;
	return output;
}

float Vec4_SqrDist(float const *a, float const *b)
{
	return Vec4_SquaredDistance(a, b);
}

float Vec4_SqrLen(float const *a)
{
	return Vec4_SquaredLength(a);
}

float Vec4_SquaredDistance(float const *a, float const *b)
{
	float x = b[0] - a[0];
	float y = b[1] - a[1];
	float z = b[2] - a[2];
	float w = b[3] - a[3];
	return x * x + y * y + z * z + w * w;
}

float Vec4_SquaredLength(float const *a)
{
	float x = a[0];
	float y = a[1];
	float z = a[2];
	float w = a[3];
	return x * x + y * y + z * z + w * w;
}

float const *Vec4_Sub(float *output, float const *a, float const *b)
{
	return Vec4_Subtract(output, a, b);
}

float const *Vec4_Subtract(float *output, float const *a, float const *b)
{
	output[0] = a[0] - b[0];
	output[1] = a[1] - b[1];
	output[2] = a[2] - b[2];
	output[3] = a[3] - b[3];
	return output;
}

float const *Vec4_TransformMat4(float *output, float const *a, float const *m)
{
	float x = a[0];
	float y = a[1];
	float z = a[2];
	float w = a[3];
	output[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
	output[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
	output[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
	output[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
	return output;
}

float const *Vec4_transformQuat(float *output, float const *a, float const *q)
{
	float x = a[0];
	float y = a[1];
	float z = a[2];
	float qx = q[0];
	float qy = q[1];
	float qz = q[2];
	float qw = q[3];
	float ix = qw * x + qy * z - qz * y;
	float iy = qw * y + qz * x - qx * z;
	float iz = qw * z + qx * y - qy * x;
	float iw = -qx * x - qy * y - qz * z;
	output[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	output[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	output[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
	return output;
}

VecCito3i *VecCito3i_New(void)
{
	VecCito3i *self = (VecCito3i *) malloc(sizeof(VecCito3i));
	return self;
}

void VecCito3i_Delete(VecCito3i *self)
{
	free(self);
}

void VecCito3i_Add(VecCito3i const *self, int _x, int _y, int _z, VecCito3i *result)
{
	result->x = self->x + _x;
	result->y = self->y + _y;
	result->z = self->z + _z;
}

VecCito3i const *VecCito3i_CitoCtr(int _x, int _y, int _z)
{
	VecCito3i *v = VecCito3i_New();
	v->x = _x;
	v->y = _y;
	v->z = _z;
	return v;
}

Vector3Float *Vector3Float_New(void)
{
	Vector3Float *self = (Vector3Float *) malloc(sizeof(Vector3Float));
	return self;
}

void Vector3Float_Delete(Vector3Float *self)
{
	free(self);
}

Vector3IntRef *Vector3IntRef_New(void)
{
	Vector3IntRef *self = (Vector3IntRef *) malloc(sizeof(Vector3IntRef));
	return self;
}

void Vector3IntRef_Delete(Vector3IntRef *self)
{
	free(self);
}

static Vector3IntRef const *Vector3IntRef_Create(int x, int y, int z)
{
	Vector3IntRef *v = Vector3IntRef_New();
	v->x = x;
	v->y = y;
	v->z = z;
	return v;
}

Vector3Ref *Vector3Ref_New(void)
{
	Vector3Ref *self = (Vector3Ref *) malloc(sizeof(Vector3Ref));
	return self;
}

void Vector3Ref_Delete(Vector3Ref *self)
{
	free(self);
}

static Vector3Ref *Vector3Ref_Create(float x, float y, float z)
{
	Vector3Ref *v = Vector3Ref_New();
	v->x = x;
	v->y = y;
	v->z = z;
	return v;
}

float Vector3Ref_GetX(Vector3Ref const *self)
{
	return self->x;
}

float Vector3Ref_GetY(Vector3Ref const *self)
{
	return self->y;
}

float Vector3Ref_GetZ(Vector3Ref const *self)
{
	return self->z;
}

static float Vector3Ref_Length(Vector3Ref const *self)
{
	return Platform_Sqrt(self->x * self->x + self->y * self->y + self->z * self->z);
}

static void Vector3Ref_Normalize(Vector3Ref *self)
{
	float length = Vector3Ref_Length(self);
	self->x = self->x / length;
	self->y = self->y / length;
	self->z = self->z / length;
}

void VectorTool_ToVectorInFixedSystem(float dx, float dy, float dz, float orientationx, float orientationy, Vector3Ref *output)
{
	float xRot;
	float yRot;
	float x;
	float y;
	float z;
	if (dx == 0 && dy == 0 && dz == 0) {
		output->x = 0;
		output->y = 0;
		output->z = 0;
		return;
	}
	xRot = orientationx;
	yRot = orientationy;
	x = dx * Platform_Cos(yRot) + dy * Platform_Sin(xRot) * Platform_Sin(yRot) - dz * Platform_Cos(xRot) * Platform_Sin(yRot);
	y = dy * Platform_Cos(xRot) + dz * Platform_Sin(xRot);
	z = dx * Platform_Sin(yRot) - dy * Platform_Sin(xRot) * Platform_Cos(yRot) + dz * Platform_Cos(xRot) * Platform_Cos(yRot);
	output->x = x;
	output->y = y;
	output->z = z;
}

VerticesIndicesToLoad *VerticesIndicesToLoad_New(void)
{
	VerticesIndicesToLoad *self = (VerticesIndicesToLoad *) malloc(sizeof(VerticesIndicesToLoad));
	return self;
}

void VerticesIndicesToLoad_Delete(VerticesIndicesToLoad *self)
{
	free(self);
}

VisibleDialog *VisibleDialog_New(void)
{
	VisibleDialog *self = (VisibleDialog *) malloc(sizeof(VisibleDialog));
	return self;
}

void VisibleDialog_Delete(VisibleDialog *self)
{
	free(self);
}

static void WebSocketClient_Construct(WebSocketClient *self, const NetClientVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_WebSocketClient;
	NetClient_Construct(&self->base, vtbl);
	self->incomingData = (unsigned char *) malloc(16384 * sizeof(unsigned char ));
}

WebSocketClient *WebSocketClient_New(void)
{
	WebSocketClient *self = (WebSocketClient *) malloc(sizeof(WebSocketClient));
	if (self != NULL)
		WebSocketClient_Construct(self, NULL);
	return self;
}

void WebSocketClient_Delete(WebSocketClient *self)
{
	free(self);
}

NetConnection const *WebSocketClient_Connect(WebSocketClient const *self, const char *ip, int port)
{
	self->p->vtbl->webSocketConnect(self->p, ip, port);
	self->c->address = self->p->vtbl->stringFormat2(self->p, "{0}:{1}", ip, self->p->vtbl->intToString(self->p, port));
	self->c->platform = self->p;
	return &self->c->base;
}

NetIncomingMessage const *WebSocketClient_ReadMessage(WebSocketClient const *self)
{
	int received = self->p->vtbl->webSocketReceive(self->p, self->incomingData, 16384);
	if (received == -1) {
		return NULL;
	}
	else {
		NetIncomingMessage *msg = NetIncomingMessage_New();
		msg->message = self->incomingData;
		msg->messageLength = received;
		msg->senderConnection = &self->c->base;
		return msg;
	}
}

void WebSocketClient_SendMessage(WebSocketClient const *self, INetOutgoingMessage const *message, MyNetDeliveryMethod method)
{
	self->c->base.vtbl->sendMessage(&self->c->base, message, method, 0);
}

static void WebSocketClient_SetPlatform(WebSocketClient *self, GamePlatform const *platform)
{
	self->p = platform;
}

void WebSocketClient_Start(WebSocketClient *self)
{
	self->c = WebSocketClientConnection_New();
}

static void WebSocketClientConnection_Construct(WebSocketClientConnection *self, const NetConnectionVtbl *vtbl)
{
	if (vtbl == NULL)
		vtbl = &CiVtbl_WebSocketClientConnection;
	NetConnection_Construct(&self->base, vtbl);
}

WebSocketClientConnection *WebSocketClientConnection_New(void)
{
	WebSocketClientConnection *self = (WebSocketClientConnection *) malloc(sizeof(WebSocketClientConnection));
	if (self != NULL)
		WebSocketClientConnection_Construct(self, NULL);
	return self;
}

void WebSocketClientConnection_Delete(WebSocketClientConnection *self)
{
	free(self);
}

cibool WebSocketClientConnection_EqualsConnection(WebSocketClientConnection const *self, NetConnection const *connection)
{
	return TRUE;
}

IPEndPointCi const *WebSocketClientConnection_RemoteEndPoint(WebSocketClientConnection const *self)
{
	return &IPEndPointCiDefault_Create(self->address)->base;
}

void WebSocketClientConnection_SendMessage(WebSocketClientConnection const *self, INetOutgoingMessage const *msg, MyNetDeliveryMethod method, int sequenceChannel)
{
	self->platform->vtbl->webSocketSend(self->platform, msg->message, msg->messageLength);
}

void WebSocketClientConnection_Update(WebSocketClientConnection const *self)
{
}

static void WireframeCube_AddVertex(ModelData *model, float x, float y, float z, float u, float v, int color)
{
	model->xyz[ModelData_GetXyzCount(model) + 0] = x;
	model->xyz[ModelData_GetXyzCount(model) + 1] = y;
	model->xyz[ModelData_GetXyzCount(model) + 2] = z;
	model->uv[ModelData_GetUvCount(model) + 0] = u;
	model->uv[ModelData_GetUvCount(model) + 1] = v;
	model->rgba[ModelData_GetRgbaCount(model) + 0] = Game_IntToByte(Game_ColorR(color));
	model->rgba[ModelData_GetRgbaCount(model) + 1] = Game_IntToByte(Game_ColorG(color));
	model->rgba[ModelData_GetRgbaCount(model) + 2] = Game_IntToByte(Game_ColorB(color));
	model->rgba[ModelData_GetRgbaCount(model) + 3] = Game_IntToByte(Game_ColorA(color));
	model->verticesCount++;
}

static void WireframeCube_DrawLineLoop(ModelData *m, Vector3Ref const *p0, Vector3Ref const *p1, Vector3Ref const *p2, Vector3Ref const *p3)
{
	int startVertex = ModelData_GetVerticesCount(m);
	WireframeCube_AddVertex(m, p0->x, p0->y, p0->z, 0, 0, Game_ColorFromArgb(255, 255, 255, 255));
	WireframeCube_AddVertex(m, p1->x, p1->y, p1->z, 0, 0, Game_ColorFromArgb(255, 255, 255, 255));
	WireframeCube_AddVertex(m, p2->x, p2->y, p2->z, 0, 0, Game_ColorFromArgb(255, 255, 255, 255));
	WireframeCube_AddVertex(m, p3->x, p3->y, p3->z, 0, 0, Game_ColorFromArgb(255, 255, 255, 255));
	m->indices[m->indicesCount++] = startVertex + 0;
	m->indices[m->indicesCount++] = startVertex + 1;
	m->indices[m->indicesCount++] = startVertex + 1;
	m->indices[m->indicesCount++] = startVertex + 2;
	m->indices[m->indicesCount++] = startVertex + 2;
	m->indices[m->indicesCount++] = startVertex + 3;
	m->indices[m->indicesCount++] = startVertex + 3;
	m->indices[m->indicesCount++] = startVertex + 0;
}

ModelData const *WireframeCube_Get(void)
{
	ModelData *m = ModelData_New();
	ModelData_setMode(m, 1);
	m->xyz = (float *) malloc(72 * sizeof(float ));
	m->uv = (float *) malloc(48 * sizeof(float ));
	m->rgba = (unsigned char *) malloc(96 * sizeof(unsigned char ));
	m->indices = (int *) malloc(48 * sizeof(int ));
	WireframeCube_DrawLineLoop(m, Vector3Ref_Create(-1, -1, -1), Vector3Ref_Create(-1, 1, -1), Vector3Ref_Create(1, 1, -1), Vector3Ref_Create(1, -1, -1));
	WireframeCube_DrawLineLoop(m, Vector3Ref_Create(-1, -1, -1), Vector3Ref_Create(1, -1, -1), Vector3Ref_Create(1, -1, 1), Vector3Ref_Create(-1, -1, 1));
	WireframeCube_DrawLineLoop(m, Vector3Ref_Create(-1, -1, -1), Vector3Ref_Create(-1, -1, 1), Vector3Ref_Create(-1, 1, 1), Vector3Ref_Create(-1, 1, -1));
	WireframeCube_DrawLineLoop(m, Vector3Ref_Create(-1, -1, 1), Vector3Ref_Create(1, -1, 1), Vector3Ref_Create(1, 1, 1), Vector3Ref_Create(-1, 1, 1));
	WireframeCube_DrawLineLoop(m, Vector3Ref_Create(-1, 1, -1), Vector3Ref_Create(-1, 1, 1), Vector3Ref_Create(1, 1, 1), Vector3Ref_Create(1, 1, -1));
	WireframeCube_DrawLineLoop(m, Vector3Ref_Create(1, -1, -1), Vector3Ref_Create(1, 1, -1), Vector3Ref_Create(1, 1, 1), Vector3Ref_Create(1, -1, 1));
	return m;
}
