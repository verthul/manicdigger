// Generated automatically with "cito". Do not edit.

public class Acceleration
{
	public Acceleration()
	{
		this.SetDefault();
	}

	public void SetDefault()
	{
		this.acceleration1 = 0.9f;
		this.acceleration2 = 2;
		this.acceleration3 = 700;
	}
	internal float acceleration1;
	internal float acceleration2;
	internal float acceleration3;
}

public abstract class Action_
{

	public abstract void Run();
}

public class AngleInterpolation
{

	public static int InterpolateAngle256(GamePlatform platform, int a, int b, float progress)
	{
		if (progress != 0 && b != a) {
			int diff = AngleInterpolation.NormalizeAngle256(b - a);
			if (diff >= 128) {
				diff -= 256;
			}
			a += platform.FloatToInt(progress * diff);
		}
		return AngleInterpolation.NormalizeAngle256(a);
	}

	public static float InterpolateAngle360(GamePlatform platform, float a, float b, float progress)
	{
		if (progress != 0 && b != a) {
			float diff = AngleInterpolation.NormalizeAngle360(platform, b - a);
			if (diff >= 180) {
				diff -= 360;
			}
			a += progress * diff;
		}
		return AngleInterpolation.NormalizeAngle360(platform, a);
	}

	static int NormalizeAngle256(int v)
	{
		return (v + 16383) % 256;
	}

	static float NormalizeAngle360(GamePlatform platform, float v)
	{
		return platform.FloatModulo(v + 16200, 360);
	}
}

public class AnimatedModel
{
	public AnimatedModel()
	{
		this.global = new AnimationGlobal();
	}
	internal Animation[] animations;
	internal int animationsCount;
	internal AnimationGlobal global;
	internal Keyframe[] keyframes;
	internal int keyframesCount;
	internal Node[] nodes;
	internal int nodesCount;
}

public class AnimatedModelBinding : TableBinding
{

	float FloatParse(string s)
	{
		FloatRef ret = new FloatRef();
		this.p.FloatTryParse(s, ret);
		return ret.value;
	}

	public override void Get(string table, int index, DictionaryStringString items)
	{
		if (table == "nodes") {
			Node k = this.m.nodes[index];
			items.Set("name", k.name);
			items.Set("paren", k.parentName);
			items.Set("x", this.p.FloatToString(k.posx));
			items.Set("y", this.p.FloatToString(k.posy));
			items.Set("z", this.p.FloatToString(k.posz));
			items.Set("rotx", this.p.FloatToString(k.rotatex));
			items.Set("roty", this.p.FloatToString(k.rotatey));
			items.Set("rotz", this.p.FloatToString(k.rotatez));
			items.Set("sizex", this.p.FloatToString(k.sizex));
			items.Set("sizey", this.p.FloatToString(k.sizey));
			items.Set("sizez", this.p.FloatToString(k.sizez));
			items.Set("u", this.p.FloatToString(k.u));
			items.Set("v", this.p.FloatToString(k.v));
			items.Set("pivx", this.p.FloatToString(k.pivotx));
			items.Set("pivy", this.p.FloatToString(k.pivoty));
			items.Set("pivz", this.p.FloatToString(k.pivotz));
			items.Set("scalx", this.p.FloatToString(k.scalex));
			items.Set("scaly", this.p.FloatToString(k.scaley));
			items.Set("scalz", this.p.FloatToString(k.scalez));
			items.Set("head", this.p.FloatToString(k.head));
		}
		if (table == "keyframes") {
			Keyframe k = this.m.keyframes[index];
			items.Set("anim", k.animationName);
			items.Set("node", k.nodeName);
			items.Set("frame", this.p.FloatToString(k.frame));
			items.Set("type", KeyframeType.GetName(k.frame));
			items.Set("x", this.p.FloatToString(k.x));
			items.Set("y", this.p.FloatToString(k.y));
			items.Set("z", this.p.FloatToString(k.z));
		}
		if (table == "animations") {
			Animation k = this.m.animations[index];
			items.Set("name", k.name);
			items.Set("len", this.p.FloatToString(k.length));
		}
		if (table == "global") {
			AnimationGlobal global = this.m.global;
			items.Set("texw", this.p.FloatToString(global.texw));
			items.Set("texh", this.p.FloatToString(global.texh));
		}
	}

	public void GetTables(string[] name, int[] count)
	{
		name[0] = "nodes";
		count[0] = this.m.nodesCount;
		name[1] = "keyframes";
		count[1] = this.m.keyframesCount;
		name[2] = "animations";
		count[2] = this.m.animationsCount;
		name[3] = "global";
		count[3] = 1;
	}

	int IntParse(string s)
	{
		return this.p.FloatToInt(this.FloatParse(s));
	}

	public override void Set(string table, int index, string column, string value)
	{
		if (table == "nodes") {
			if (index >= this.m.nodesCount) {
				this.m.nodesCount = index + 1;
			}
			if (this.m.nodes[index] == null) {
				this.m.nodes[index] = new Node();
			}
			Node k = this.m.nodes[index];
			if (column == "name") {
				k.name = value;
			}
			if (column == "paren") {
				k.parentName = value;
			}
			if (column == "x") {
				k.posx = this.FloatParse(value);
			}
			if (column == "y") {
				k.posy = this.FloatParse(value);
			}
			if (column == "z") {
				k.posz = this.FloatParse(value);
			}
			if (column == "rotx") {
				k.rotatex = this.FloatParse(value);
			}
			if (column == "roty") {
				k.rotatey = this.FloatParse(value);
			}
			if (column == "rotz") {
				k.rotatez = this.FloatParse(value);
			}
			if (column == "sizex") {
				k.sizex = this.FloatParse(value);
			}
			if (column == "sizey") {
				k.sizey = this.FloatParse(value);
			}
			if (column == "sizez") {
				k.sizez = this.FloatParse(value);
			}
			if (column == "u") {
				k.u = this.FloatParse(value);
			}
			if (column == "v") {
				k.v = this.FloatParse(value);
			}
			if (column == "pivx") {
				k.pivotx = this.FloatParse(value);
			}
			if (column == "pivy") {
				k.pivoty = this.FloatParse(value);
			}
			if (column == "pivz") {
				k.pivotz = this.FloatParse(value);
			}
			if (column == "scalx") {
				k.scalex = this.FloatParse(value);
			}
			if (column == "scaly") {
				k.scaley = this.FloatParse(value);
			}
			if (column == "scalz") {
				k.scalez = this.FloatParse(value);
			}
			if (column == "head") {
				k.head = this.FloatParse(value);
			}
		}
		if (table == "keyframes") {
			if (index >= this.m.keyframesCount) {
				this.m.keyframesCount = index + 1;
			}
			if (this.m.keyframes[index] == null) {
				this.m.keyframes[index] = new Keyframe();
			}
			Keyframe k = this.m.keyframes[index];
			if (column == "anim") {
				k.animationName = value;
			}
			if (column == "node") {
				k.nodeName = value;
			}
			if (column == "frame") {
				k.frame = this.IntParse(value);
			}
			if (column == "type") {
				k.keyframeType = KeyframeType.GetValue(value);
			}
			if (column == "x") {
				k.x = this.FloatParse(value);
			}
			if (column == "y") {
				k.y = this.FloatParse(value);
			}
			if (column == "z") {
				k.z = this.FloatParse(value);
			}
		}
		if (table == "animations") {
			if (index >= this.m.animationsCount) {
				this.m.animationsCount = index + 1;
			}
			if (this.m.animations[index] == null) {
				this.m.animations[index] = new Animation();
			}
			Animation k = this.m.animations[index];
			if (column == "name") {
				k.name = value;
			}
			if (column == "len") {
				k.length = this.IntParse(value);
			}
		}
		if (table == "global") {
			AnimationGlobal global = this.m.global;
			if (column == "texw") {
				global.texw = this.IntParse(value);
			}
			if (column == "texh") {
				global.texh = this.IntParse(value);
			}
		}
	}
	internal AnimatedModel m;
	internal GamePlatform p;
}

public class AnimatedModelRenderer
{
	public AnimatedModelRenderer()
	{
		this.one = 1;
		this.tempframes = new Keyframe[256];
		this.tempframesCount = new IntRef();
		this.tempVec3 = new float[3];
	}

	void DrawNode(string parent, float headDeg, float light)
	{
		for (int i = 0; i < this.m.nodesCount; i++) {
			Node n = this.m.nodes[i];
			if (n == null) {
				continue;
			}
			if (n.parentName != parent) {
				continue;
			}
			this.game.GLPushMatrix();
			RectangleFloat[] r = new RectangleFloat[6];
			r = CuboidRenderer.CuboidNet(n.sizex, n.sizey, n.sizez, n.u, n.v);
			CuboidRenderer.CuboidNetNormalize(r, this.m.global.texw, this.m.global.texh);
			this.GetAnimation(n, this.tempVec3, 5);
			if (this.tempVec3[0] != 0 && this.tempVec3[1] != 0 && this.tempVec3[2] != 0) {
				this.game.GLScale(this.tempVec3[0], this.tempVec3[1], this.tempVec3[2]);
			}
			this.GetAnimation(n, this.tempVec3, 1);
			this.tempVec3[0] /= 16;
			this.tempVec3[1] /= 16;
			this.tempVec3[2] /= 16;
			if (!this.IsZero(this.tempVec3)) {
				this.game.GLTranslate(this.tempVec3[0], this.tempVec3[1], this.tempVec3[2]);
			}
			this.GetAnimation(n, this.tempVec3, 2);
			if (this.tempVec3[0] != 0) {
				this.game.GLRotate(this.tempVec3[0], 1, 0, 0);
			}
			if (this.tempVec3[1] != 0) {
				this.game.GLRotate(this.tempVec3[1], 0, 1, 0);
			}
			if (this.tempVec3[2] != 0) {
				this.game.GLRotate(this.tempVec3[2], 0, 0, 1);
			}
			if (n.head == 1) {
				this.game.GLRotate(headDeg, 1, 0, 0);
			}
			this.GetAnimation(n, this.tempVec3, 4);
			this.tempVec3[0] /= 16;
			this.tempVec3[1] /= 16;
			this.tempVec3[2] /= 16;
			this.game.GLTranslate(this.tempVec3[0], this.tempVec3[1], this.tempVec3[2]);
			this.GetAnimation(n, this.tempVec3, 3);
			this.tempVec3[0] /= 16;
			this.tempVec3[1] /= 16;
			this.tempVec3[2] /= 16;
			CuboidRenderer.DrawCuboid2(this.game, 0 - this.tempVec3[0] / 2, 0 - this.tempVec3[1] / 2, 0 - this.tempVec3[2] / 2, this.tempVec3[0], this.tempVec3[1], this.tempVec3[2], r, light);
			this.DrawNode(n.name, headDeg, light);
			this.game.GLPopMatrix();
		}
	}

	void GetAnimation(Node node, float[] ret, int type)
	{
		this.GetFrames(node.name, type, this.tempframes, this.tempframesCount);
		int currentI = this.GetFrameCurrent(this.tempframes, this.tempframesCount.value);
		if (currentI == -1) {
			this.GetDefaultFrame(node, type, ret);
			return;
		}
		int nextI = (currentI + 1) % this.tempframesCount.value;
		Keyframe current = this.tempframes[currentI];
		Keyframe next = this.tempframes[nextI];
		float t;
		float length = this.m.animations[this.anim].length;
		if (next.frame == current.frame) {
			t = 0;
		}
		else if (next.frame > current.frame) {
			t = (this.frame - current.frame) / (next.frame - current.frame);
		}
		else {
			float end = 0;
			float begin = 0;
			if (this.frame >= current.frame) {
				end = this.frame - current.frame;
			}
			else {
				end = length - current.frame;
				begin = this.frame;
			}
			t = (end + begin) / (length - current.frame + next.frame);
		}
		ret[0] = this.Lerp(current.x, next.x, t);
		ret[1] = this.Lerp(current.y, next.y, t);
		ret[2] = this.Lerp(current.z, next.z, t);
	}

	void GetDefaultFrame(Node node, int type, float[] ret)
	{
		switch (type) {
		case 1:
			{
				ret[0] = node.posx;
				ret[1] = node.posy;
				ret[2] = node.posz;
			}
			break;
		case 2:
			{
				ret[0] = node.rotatex;
				ret[1] = node.rotatey;
				ret[2] = node.rotatez;
			}
			break;
		case 3:
			{
				ret[0] = node.sizex;
				ret[1] = node.sizey;
				ret[2] = node.sizez;
			}
			break;
		case 4:
			{
				ret[0] = node.pivotx;
				ret[1] = node.pivoty;
				ret[2] = node.pivotz;
			}
			break;
		case 5:
			{
				ret[0] = node.scalex;
				ret[1] = node.scaley;
				ret[2] = node.scalez;
			}
			break;
		}
	}

	int GetFrameCurrent(Keyframe[] frames, int framesCount)
	{
		string animName = this.m.animations[this.anim].name;
		int current = -1;
		for (int i = 0; i < framesCount; i++) {
			Keyframe k = frames[i];
			if (k.frame <= this.frame) {
				if (current == -1) {
					current = i;
				}
				else {
					if (k.frame > frames[current].frame) {
						current = i;
					}
				}
			}
		}
		if (current == -1) {
			for (int i = 0; i < framesCount; i++) {
				Keyframe k = frames[i];
				if (current == -1 || k.frame > frames[current].frame) {
					current = i;
				}
			}
		}
		return current;
	}

	void GetFrames(string nodeName, int type, Keyframe[] frames, IntRef count)
	{
		count.value = 0;
		string animName = this.m.animations[this.anim].name;
		for (int i = 0; i < this.m.keyframesCount; i++) {
			Keyframe k = this.m.keyframes[i];
			if (k == null) {
				continue;
			}
			if (k.nodeName != nodeName) {
				continue;
			}
			if (k.animationName != animName) {
				continue;
			}
			if (k.keyframeType != type) {
				continue;
			}
			frames[count.value++] = k;
		}
	}

	bool IsZero(float[] vec)
	{
		return vec[0] == 0 && vec[1] == 0 && vec[2] == 0;
	}

	float Lerp(float v0, float v1, float t)
	{
		return v0 + (v1 - v0) * t;
	}

	public void Render(float dt, float headDeg, bool walkAnimation, bool moves, float light)
	{
		if (this.m == null) {
			return;
		}
		if (this.m.animations == null) {
			return;
		}
		if (this.m.animations[this.anim] == null) {
			return;
		}
		float length = this.m.animations[this.anim].length;
		if (moves) {
			this.frame += dt * 60;
			this.frame = this.frame % length;
		}
		if (walkAnimation) {
			if (!moves) {
				if (this.frame != 0 && this.frame != length / 2 && this.frame != length) {
					if (this.frame < length / 2) {
						this.frame += dt * 60;
						if (this.frame > length / 2) {
							this.frame = length / 2;
						}
					}
					else {
						this.frame += dt * 60;
						if (this.frame > length) {
							this.frame = length;
						}
					}
				}
			}
		}
		this.DrawNode("root", headDeg, light);
	}

	public void Start(Game game_, AnimatedModel model_)
	{
		this.game = game_;
		this.m = model_;
	}
	int anim;
	float frame;
	internal Game game;
	AnimatedModel m;
	float one;
	float[] tempVec3;
	Keyframe[] tempframes;
	IntRef tempframesCount;
}

public class AnimatedModelSerializer
{

	public static AnimatedModel Deserialize(GamePlatform p, string data)
	{
		AnimatedModel model = new AnimatedModel();
		model.nodes = new Node[256];
		model.keyframes = new Keyframe[1024];
		model.animations = new Animation[128];
		AnimatedModelBinding b = new AnimatedModelBinding();
		b.p = p;
		b.m = model;
		TableSerializer s = new TableSerializer();
		s.Deserialize(p, data, b);
		return model;
	}

	public static string Serialize(GamePlatform p, AnimatedModel m)
	{
		return null;
	}
}

public class Animation
{
	internal int length;
	internal string name;
}

public class AnimationGlobal
{
	internal int texh;
	internal int texw;
}

public class AnimationHint
{
	internal float DrawFixX;
	internal float DrawFixY;
	internal float DrawFixZ;
	internal bool InVehicle;
	internal bool leanleft;
	internal bool leanright;
}

public class AnimationState
{
	public AnimationState()
	{
		this.bodyrotation = -1;
		this.light = 1;
	}

	public float GetInterp()
	{
		return this.interp;
	}
	internal float bodyrotation;
	internal bool fullbodyrotate;
	internal float headbodydelta;
	internal float interp;
	internal float lastheading;
	internal float light;
	internal float speed;
}

public class Asset
{

	public byte[] GetData()
	{
		return this.data;
	}

	public int GetDataLength()
	{
		return this.dataLength;
	}

	public string GetMd5()
	{
		return this.md5;
	}

	public string GetName()
	{
		return this.name;
	}

	public void SetData(byte[] value)
	{
		this.data = value;
	}

	public void SetDataLength(int value)
	{
		this.dataLength = value;
	}

	public void SetMd5(string value)
	{
		this.md5 = value;
	}

	public void SetName(string value)
	{
		this.name = value;
	}
	internal byte[] data;
	internal int dataLength;
	internal string md5;
	internal string name;
}

public class AssetList
{

	public int GetCount()
	{
		return this.count;
	}

	public Asset[] GetItems()
	{
		return this.items;
	}

	public void SetCount(int value)
	{
		this.count = value;
	}

	public void SetItems(Asset[] value)
	{
		this.items = value;
	}
	internal int count;
	internal Asset[] items;
}

public abstract class AudioCi
{
}

public class AudioControl
{
	public AudioControl()
	{
		this.soundsCount = 0;
		this.sounds = new Sound_[64];
		for (int i = 0; i < 64; i++) {
			this.sounds[i] = null;
		}
	}

	public void Add(Sound_ s)
	{
		for (int i = 0; i < this.soundsCount; i++) {
			if (this.sounds[i] == null) {
				this.sounds[i] = s;
				return;
			}
		}
		if (this.soundsCount < 64) {
			this.sounds[this.soundsCount++] = s;
		}
	}

	public void Clear()
	{
		for (int i = 0; i < this.soundsCount; i++) {
			this.sounds[i] = null;
		}
		this.soundsCount = 0;
	}

	public void StopAll()
	{
		for (int i = 0; i < this.soundsCount; i++) {
			if (this.sounds[i] == null) {
				continue;
			}
			this.sounds[i].stop = true;
		}
	}
	internal Sound_[] sounds;
	internal int soundsCount;
}

public abstract class AudioData
{
}

public class AudioSampleCi
{
}

public abstract class AviWriterCi
{

	public abstract void AddFrame(BitmapCi bitmap);

	public abstract void Close();

	public abstract void Open(string filename, int framerate, int width, int height);
}

public class BackgroundAction : Action_
{
	public BackgroundAction()
	{
		this.game = null;
		this.i = -1;
		this.dt = 1;
		this.active = false;
		this.finished = false;
	}

	public override void Run()
	{
		this.game.clientmods[this.i].OnReadOnlyBackgroundThread(this.game, this.dt);
		this.finished = true;
	}
	internal bool active;
	internal float dt;
	internal bool finished;
	internal Game game;
	internal int i;
}

public class BitTools
{

	public static bool IsPowerOfTwo(int x)
	{
		return x == 1 || x == 2 || x == 4 || x == 8 || x == 16 || x == 32 || x == 64 || x == 128 || x == 256 || x == 512 || x == 1024 || x == 2048 || x == 4096 || x == 8192 || x == 16384 || x == 32768 || x == 65536 || x == 131072 || x == 262144 || x == 524288 || x == 1048576 || x == 2097152 || x == 4194304 || x == 8388608 || x == 16777216 || x == 33554432 || x == 67108864 || x == 134217728 || x == 268435456 || x == 536870912 || x == 1073741824;
	}

	public static int NextPowerOfTwo(int x)
	{
		x--;
		x |= x >> 1;
		x |= x >> 2;
		x |= x >> 4;
		x |= x >> 8;
		x |= x >> 16;
		x++;
		return x;
	}
}

public class BitmapCi
{

	public virtual void Dispose()
	{
	}
}

public class BitmapData_
{

	public static BitmapData_ Create(int width, int height)
	{
		BitmapData_ b = new BitmapData_();
		b.width = width;
		b.height = height;
		b.argb = new int[width * height];
		return b;
	}

	public static BitmapData_ CreateFromBitmap(GamePlatform p, BitmapCi atlas2d_)
	{
		BitmapData_ b = new BitmapData_();
		b.width = p.FloatToInt(p.BitmapGetWidth(atlas2d_));
		b.height = p.FloatToInt(p.BitmapGetHeight(atlas2d_));
		b.argb = new int[b.width * b.height];
		p.BitmapGetPixelsArgb(atlas2d_, b.argb);
		return b;
	}

	public int GetPixel(int x, int y)
	{
		return this.argb[x + y * this.width];
	}

	public void SetPixel(int x, int y, int color)
	{
		this.argb[x + y * this.width] = color;
	}

	public BitmapCi ToBitmap(GamePlatform p)
	{
		BitmapCi bmp = p.BitmapCreate(this.width, this.height);
		p.BitmapSetPixelsArgb(bmp, this.argb);
		return bmp;
	}
	internal int[] argb;
	internal int height;
	internal int width;
}

public class BlockOctreeSearcher
{
	public BlockOctreeSearcher()
	{
		this.intersection = new Intersection();
		this.pool = new Box3D[10000];
		for (int i = 0; i < 10000; i++) {
			this.pool[i] = new Box3D();
		}
		this.listpool = new ListBox3d[50];
		for (int i = 0; i < 50; i++) {
			this.listpool[i] = new ListBox3d();
			this.listpool[i].arr = new Box3D[1000];
		}
		this.l = new BlockPosSide[1024];
		this.lCount = 0;
		this.currentHit = new float[3];
	}

	public bool BoxHit(Box3D box)
	{
		this.currentHit[0] = 0;
		this.currentHit[1] = 0;
		this.currentHit[2] = 0;
		return Intersection.CheckLineBox(box, this.currentLine, this.currentHit);
	}

	ListBox3d Children(Box3D box)
	{
		ListBox3d l = this.newListBox3d();
		l.count = 8;
		Box3D[] c = l.arr;
		for (int i = 0; i < 8; i++) {
			c[i] = this.newBox3d();
		}
		float x = box.MinEdge[0];
		float y = box.MinEdge[1];
		float z = box.MinEdge[2];
		float size = box.LengthX() / 2;
		c[0].Set(x, y, z, size);
		c[1].Set(x + size, y, z, size);
		c[2].Set(x, y, z + size, size);
		c[3].Set(x + size, y, z + size, size);
		c[4].Set(x, y + size, z, size);
		c[5].Set(x + size, y + size, z, size);
		c[6].Set(x, y + size, z + size, size);
		c[7].Set(x + size, y + size, z + size, size);
		return l;
	}

	public BlockPosSide[] LineIntersection(DelegateIsBlockEmpty isEmpty, DelegateGetBlockHeight getBlockHeight, Line3D line, IntRef retCount)
	{
		this.lCount = 0;
		this.currentLine = line;
		this.currentHit[0] = 0;
		this.currentHit[1] = 0;
		this.currentHit[2] = 0;
		ListBox3d l1 = this.Search(PredicateBox3DHit.Create(this));
		for (int i = 0; i < l1.count; i++) {
			Box3D node = l1.arr[i];
			float[] hit = this.currentHit;
			float x = node.MinEdge[0];
			float y = node.MinEdge[2];
			float z = node.MinEdge[1];
			if (!isEmpty.IsBlockEmpty(this.platform.FloatToInt(x), this.platform.FloatToInt(y), this.platform.FloatToInt(z))) {
				Box3D node2 = new Box3D();
				node2.MinEdge = Vec3.CloneIt(node.MinEdge);
				node2.MaxEdge = Vec3.CloneIt(node.MaxEdge);
				node2.MaxEdge[1] = node2.MinEdge[1] + getBlockHeight.GetBlockHeight(this.platform.FloatToInt(x), this.platform.FloatToInt(y), this.platform.FloatToInt(z));
				BlockPosSide b = new BlockPosSide();
				float[] hit2 = new float[3];
				float[] dir = new float[3];
				dir[0] = line.End[0] - line.Start[0];
				dir[1] = line.End[1] - line.Start[1];
				dir[2] = line.End[2] - line.Start[2];
				bool ishit = Intersection.HitBoundingBox(node2.MinEdge, node2.MaxEdge, line.Start, dir, hit2);
				if (ishit) {
					b.blockPos = Vec3.FromValues(this.platform.FloatToInt(x), this.platform.FloatToInt(z), this.platform.FloatToInt(y));
					b.collisionPos = hit2;
					this.l[this.lCount++] = b;
				}
			}
		}
		BlockPosSide[] ll = new BlockPosSide[this.lCount];
		for (int i = 0; i < this.lCount; i++) {
			ll[i] = this.l[i];
		}
		retCount.value = this.lCount;
		return ll;
	}

	ListBox3d Search(PredicateBox3D query)
	{
		this.pool_i = 0;
		this.listpool_i = 0;
		if (this.StartBox.LengthX() == 0 && this.StartBox.LengthY() == 0 && this.StartBox.LengthZ() == 0) {
			return new ListBox3d();
		}
		return this.SearchPrivate(query, this.StartBox);
	}

	ListBox3d SearchPrivate(PredicateBox3D query, Box3D box)
	{
		if (box.LengthX() == 1) {
			ListBox3d l1 = this.newListBox3d();
			l1.count = 1;
			l1.arr[0] = box;
			return l1;
		}
		ListBox3d l = this.newListBox3d();
		l.count = 0;
		ListBox3d children = this.Children(box);
		for (int k = 0; k < children.count; k++) {
			Box3D child = children.arr[k];
			if (query.Hit(child)) {
				ListBox3d l2 = this.SearchPrivate(query, child);
				for (int i = 0; i < l2.count; i++) {
					Box3D n = l2.arr[i];
					l.arr[l.count++] = n;
				}
				this.recycleListBox3d(l2);
			}
		}
		this.recycleListBox3d(children);
		return l;
	}
	internal Box3D StartBox;
	float[] currentHit;
	Line3D currentLine;
	Intersection intersection;
	BlockPosSide[] l;
	int lCount;
	ListBox3d[] listpool;
	int listpool_i;

	Box3D newBox3d()
	{
		return this.pool[this.pool_i++];
	}

	ListBox3d newListBox3d()
	{
		ListBox3d l = this.listpool[this.listpool_i++];
		l.count = 0;
		return l;
	}
	internal GamePlatform platform;
	Box3D[] pool;
	int pool_i;

	void recycleBox3d(Box3D l)
	{
		this.pool_i--;
		this.pool[this.pool_i] = l;
	}

	void recycleListBox3d(ListBox3d l)
	{
		this.listpool_i--;
		this.listpool[this.listpool_i] = l;
	}
}

public class BlockPosSide
{
	public BlockPosSide()
	{
	}

	public static BlockPosSide Create(int x, int y, int z)
	{
		BlockPosSide p = new BlockPosSide();
		p.blockPos = Vec3.FromValues(x, y, z);
		return p;
	}

	public float[] Current()
	{
		return this.blockPos;
	}

	public float[] Translated()
	{
		float[] translated = new float[3];
		translated[0] = this.blockPos[0];
		translated[1] = this.blockPos[1];
		translated[2] = this.blockPos[2];
		if (this.collisionPos == null) {
			return translated;
		}
		if (this.collisionPos[0] == this.blockPos[0]) {
			translated[0] = translated[0] - 1;
		}
		if (this.collisionPos[1] == this.blockPos[1]) {
			translated[1] = translated[1] - 1;
		}
		if (this.collisionPos[2] == this.blockPos[2]) {
			translated[2] = translated[2] - 1;
		}
		if (this.collisionPos[0] == this.blockPos[0] + 1) {
			translated[0] = translated[0] + 1;
		}
		if (this.collisionPos[1] == this.blockPos[1] + 1) {
			translated[1] = translated[1] + 1;
		}
		if (this.collisionPos[2] == this.blockPos[2] + 1) {
			translated[2] = translated[2] + 1;
		}
		return translated;
	}
	internal float[] blockPos;
	internal float[] collisionPos;
}

public class BlockRendererTorch
{

	public void AddTorch(GameData d_Data, Game d_TerainRenderer, ModelData m, int x, int y, int z, TorchType type)
	{
		float one = 1;
		int curcolor = Game.ColorFromArgb(255, 255, 255, 255);
		float torchsizexy = one * 16 / 100;
		float topx = one / 2 - torchsizexy / 2;
		float topy = one / 2 - torchsizexy / 2;
		float bottomx = one / 2 - torchsizexy / 2;
		float bottomy = one / 2 - torchsizexy / 2;
		topx += x;
		topy += y;
		bottomx += x;
		bottomy += y;
		if (type == TorchType.Front) {
			bottomx = x - torchsizexy;
		}
		if (type == TorchType.Back) {
			bottomx = x + 1;
		}
		if (type == TorchType.Left) {
			bottomy = y - torchsizexy;
		}
		if (type == TorchType.Right) {
			bottomy = y + 1;
		}
		Vector3Ref top00 = Vector3Ref.Create(topx, z + one * 9 / 10, topy);
		Vector3Ref top01 = Vector3Ref.Create(topx, z + one * 9 / 10, topy + torchsizexy);
		Vector3Ref top10 = Vector3Ref.Create(topx + torchsizexy, z + one * 9 / 10, topy);
		Vector3Ref top11 = Vector3Ref.Create(topx + torchsizexy, z + one * 9 / 10, topy + torchsizexy);
		if (type == TorchType.Left) {
			top01.Y += -(one * 1 / 10);
			top11.Y += -(one * 1 / 10);
		}
		if (type == TorchType.Right) {
			top10.Y += -(one * 1 / 10);
			top00.Y += -(one * 1 / 10);
		}
		if (type == TorchType.Front) {
			top10.Y += -(one * 1 / 10);
			top11.Y += -(one * 1 / 10);
		}
		if (type == TorchType.Back) {
			top01.Y += -(one * 1 / 10);
			top00.Y += -(one * 1 / 10);
		}
		Vector3Ref bottom00 = Vector3Ref.Create(bottomx, z + 0, bottomy);
		Vector3Ref bottom01 = Vector3Ref.Create(bottomx, z + 0, bottomy + torchsizexy);
		Vector3Ref bottom10 = Vector3Ref.Create(bottomx + torchsizexy, z + 0, bottomy);
		Vector3Ref bottom11 = Vector3Ref.Create(bottomx + torchsizexy, z + 0, bottomy + torchsizexy);
		{
			int sidetexture = this.TopTexture;
			RectFRef texrec = TextureAtlas.TextureCoords2d(sidetexture, d_TerainRenderer.texturesPacked());
			int lastelement = m.GetVerticesCount();
			this.AddVertex(m, top00.X, top00.Y, top00.Z, texrec.Left(), texrec.Top(), curcolor);
			this.AddVertex(m, top01.X, top01.Y, top01.Z, texrec.Left(), texrec.Bottom(), curcolor);
			this.AddVertex(m, top10.X, top10.Y, top10.Z, texrec.Right(), texrec.Top(), curcolor);
			this.AddVertex(m, top11.X, top11.Y, top11.Z, texrec.Right(), texrec.Bottom(), curcolor);
			m.indices[m.indicesCount++] = lastelement + 0;
			m.indices[m.indicesCount++] = lastelement + 1;
			m.indices[m.indicesCount++] = lastelement + 2;
			m.indices[m.indicesCount++] = lastelement + 1;
			m.indices[m.indicesCount++] = lastelement + 3;
			m.indices[m.indicesCount++] = lastelement + 2;
		}
		{
			int sidetexture = this.SideTexture;
			RectFRef texrec = TextureAtlas.TextureCoords2d(sidetexture, d_TerainRenderer.texturesPacked());
			int lastelement = m.GetVerticesCount();
			this.AddVertex(m, bottom00.X, bottom00.Y, bottom00.Z, texrec.Left(), texrec.Top(), curcolor);
			this.AddVertex(m, bottom01.X, bottom01.Y, bottom01.Z, texrec.Left(), texrec.Bottom(), curcolor);
			this.AddVertex(m, bottom10.X, bottom10.Y, bottom10.Z, texrec.Right(), texrec.Top(), curcolor);
			this.AddVertex(m, bottom11.X, bottom11.Y, bottom11.Z, texrec.Right(), texrec.Bottom(), curcolor);
			m.indices[m.indicesCount++] = lastelement + 1;
			m.indices[m.indicesCount++] = lastelement + 0;
			m.indices[m.indicesCount++] = lastelement + 2;
			m.indices[m.indicesCount++] = lastelement + 3;
			m.indices[m.indicesCount++] = lastelement + 1;
			m.indices[m.indicesCount++] = lastelement + 2;
		}
		{
			int sidetexture = this.SideTexture;
			RectFRef texrec = TextureAtlas.TextureCoords2d(sidetexture, d_TerainRenderer.texturesPacked());
			int lastelement = m.GetVerticesCount();
			this.AddVertex(m, bottom00.X, bottom00.Y, bottom00.Z, texrec.Left(), texrec.Bottom(), curcolor);
			this.AddVertex(m, bottom01.X, bottom01.Y, bottom01.Z, texrec.Right(), texrec.Bottom(), curcolor);
			this.AddVertex(m, top00.X, top00.Y, top00.Z, texrec.Left(), texrec.Top(), curcolor);
			this.AddVertex(m, top01.X, top01.Y, top01.Z, texrec.Right(), texrec.Top(), curcolor);
			m.indices[m.indicesCount++] = lastelement + 0;
			m.indices[m.indicesCount++] = lastelement + 1;
			m.indices[m.indicesCount++] = lastelement + 2;
			m.indices[m.indicesCount++] = lastelement + 1;
			m.indices[m.indicesCount++] = lastelement + 3;
			m.indices[m.indicesCount++] = lastelement + 2;
		}
		{
			int sidetexture = this.SideTexture;
			RectFRef texrec = TextureAtlas.TextureCoords2d(sidetexture, d_TerainRenderer.texturesPacked());
			int lastelement = m.GetVerticesCount();
			this.AddVertex(m, bottom10.X, bottom10.Y, bottom10.Z, texrec.Right(), texrec.Bottom(), curcolor);
			this.AddVertex(m, bottom11.X, bottom11.Y, bottom11.Z, texrec.Left(), texrec.Bottom(), curcolor);
			this.AddVertex(m, top10.X, top10.Y, top10.Z, texrec.Right(), texrec.Top(), curcolor);
			this.AddVertex(m, top11.X, top11.Y, top11.Z, texrec.Left(), texrec.Top(), curcolor);
			m.indices[m.indicesCount++] = lastelement + 1;
			m.indices[m.indicesCount++] = lastelement + 0;
			m.indices[m.indicesCount++] = lastelement + 2;
			m.indices[m.indicesCount++] = lastelement + 3;
			m.indices[m.indicesCount++] = lastelement + 1;
			m.indices[m.indicesCount++] = lastelement + 2;
		}
		{
			int sidetexture = this.SideTexture;
			RectFRef texrec = TextureAtlas.TextureCoords2d(sidetexture, d_TerainRenderer.texturesPacked());
			int lastelement = m.GetVerticesCount();
			this.AddVertex(m, bottom00.X, bottom00.Y, bottom00.Z, texrec.Right(), texrec.Bottom(), curcolor);
			this.AddVertex(m, top00.X, top00.Y, top00.Z, texrec.Right(), texrec.Top(), curcolor);
			this.AddVertex(m, bottom10.X, bottom10.Y, bottom10.Z, texrec.Left(), texrec.Bottom(), curcolor);
			this.AddVertex(m, top10.X, top10.Y, top10.Z, texrec.Left(), texrec.Top(), curcolor);
			m.indices[m.indicesCount++] = lastelement + 0;
			m.indices[m.indicesCount++] = lastelement + 1;
			m.indices[m.indicesCount++] = lastelement + 2;
			m.indices[m.indicesCount++] = lastelement + 1;
			m.indices[m.indicesCount++] = lastelement + 3;
			m.indices[m.indicesCount++] = lastelement + 2;
		}
		{
			int sidetexture = this.SideTexture;
			RectFRef texrec = TextureAtlas.TextureCoords2d(sidetexture, d_TerainRenderer.texturesPacked());
			int lastelement = m.GetVerticesCount();
			this.AddVertex(m, bottom01.X, bottom01.Y, bottom01.Z, texrec.Left(), texrec.Bottom(), curcolor);
			this.AddVertex(m, top01.X, top01.Y, top01.Z, texrec.Left(), texrec.Top(), curcolor);
			this.AddVertex(m, bottom11.X, bottom11.Y, bottom11.Z, texrec.Right(), texrec.Bottom(), curcolor);
			this.AddVertex(m, top11.X, top11.Y, top11.Z, texrec.Right(), texrec.Top(), curcolor);
			m.indices[m.indicesCount++] = lastelement + 1;
			m.indices[m.indicesCount++] = lastelement + 0;
			m.indices[m.indicesCount++] = lastelement + 2;
			m.indices[m.indicesCount++] = lastelement + 3;
			m.indices[m.indicesCount++] = lastelement + 1;
			m.indices[m.indicesCount++] = lastelement + 2;
		}
	}

	public void AddVertex(ModelData model, float x, float y, float z, float u, float v, int color)
	{
		model.xyz[model.GetXyzCount() + 0] = x;
		model.xyz[model.GetXyzCount() + 1] = y;
		model.xyz[model.GetXyzCount() + 2] = z;
		model.uv[model.GetUvCount() + 0] = u;
		model.uv[model.GetUvCount() + 1] = v;
		model.rgba[model.GetRgbaCount() + 0] = Game.IntToByte(Game.ColorR(color));
		model.rgba[model.GetRgbaCount() + 1] = Game.IntToByte(Game.ColorG(color));
		model.rgba[model.GetRgbaCount() + 2] = Game.IntToByte(Game.ColorB(color));
		model.rgba[model.GetRgbaCount() + 3] = Game.IntToByte(Game.ColorA(color));
		model.verticesCount++;
	}
	internal int SideTexture;
	internal int TopTexture;
}

public enum BlockSetMode
{
	Destroy,
	Create,
	Use,
	UseWithTool
}

public class BlockTypeSimple
{
	public BlockTypeSimple()
	{
		this.block = new Packet_BlockType();
	}

	public void SetAllTextures(string texture)
	{
		this.block.TextureIdTop = texture;
		this.block.TextureIdBottom = texture;
		this.block.TextureIdFront = texture;
		this.block.TextureIdBack = texture;
		this.block.TextureIdLeft = texture;
		this.block.TextureIdRight = texture;
		this.block.TextureIdForInventory = texture;
	}

	public void SetDrawType(int p)
	{
		this.block.DrawType = p;
	}

	public void SetName(string name)
	{
		this.block.Name = name;
	}

	public void SetTextureBack(string p)
	{
		this.block.TextureIdBack = p;
	}

	public void SetTextureBottom(string p)
	{
		this.block.TextureIdBottom = p;
	}

	public void SetTextureFront(string p)
	{
		this.block.TextureIdFront = p;
	}

	public void SetTextureLeft(string p)
	{
		this.block.TextureIdLeft = p;
	}

	public void SetTextureRight(string p)
	{
		this.block.TextureIdRight = p;
	}

	public void SetTextureTop(string p)
	{
		this.block.TextureIdTop = p;
	}

	public void SetWalkableType(int p)
	{
		this.block.WalkableType = p;
	}
	internal Packet_BlockType block;
}

public class BoolRef
{

	public bool GetValue()
	{
		return this.value;
	}

	public void SetValue(bool value_)
	{
		this.value = value_;
	}
	internal bool value;
}

public class Box3D
{

	public void AddPoint(float x, float y, float z)
	{
		if (this.MinEdge == null || this.MaxEdge == null || this.MinEdge[0] == 0 && this.MinEdge[1] == 0 && this.MinEdge[2] == 0 && this.MaxEdge[0] == 0 && this.MaxEdge[1] == 0 && this.MaxEdge[2] == 0) {
			this.MinEdge = Vec3.FromValues(x, y, z);
			this.MaxEdge = Vec3.FromValues(x, y, z);
		}
		this.MinEdge[0] = MathCi.MinFloat(this.MinEdge[0], x);
		this.MinEdge[1] = MathCi.MinFloat(this.MinEdge[1], y);
		this.MinEdge[2] = MathCi.MinFloat(this.MinEdge[2], z);
		this.MaxEdge[0] = MathCi.MaxFloat(this.MaxEdge[0], x);
		this.MaxEdge[1] = MathCi.MaxFloat(this.MaxEdge[1], y);
		this.MaxEdge[2] = MathCi.MaxFloat(this.MaxEdge[2], z);
	}

	public float[] Center()
	{
		return null;
	}

	internal static Box3D Create(int x, int y, int z, int size)
	{
		Box3D b = new Box3D();
		b.Set(x, y, z, size);
		return b;
	}

	public float LengthX()
	{
		return this.MaxEdge[0] - this.MinEdge[0];
	}

	public float LengthY()
	{
		return this.MaxEdge[1] - this.MinEdge[1];
	}

	public float LengthZ()
	{
		return this.MaxEdge[2] - this.MinEdge[2];
	}
	internal float[] MaxEdge;
	internal float[] MinEdge;

	public void Set(float x, float y, float z, float size)
	{
		if (this.MinEdge == null) {
			this.MinEdge = new float[3];
			this.MaxEdge = new float[3];
		}
		this.MinEdge[0] = x;
		this.MinEdge[1] = y;
		this.MinEdge[2] = z;
		this.MaxEdge[0] = x + size;
		this.MaxEdge[1] = y + size;
		this.MaxEdge[2] = z + size;
	}
}

public class Bullet_
{
	internal float fromX;
	internal float fromY;
	internal float fromZ;
	internal float progress;
	internal float speed;
	internal float toX;
	internal float toY;
	internal float toZ;
}

public class Button
{
	public Button()
	{
		this.fontcolor = Game.ColorFromArgb(255, 255, 255, 255);
		this.fontcolorselected = Game.ColorFromArgb(255, 255, 0, 0);
		this.fontsize = 20;
	}
	internal string Text;
	internal int fontcolor;
	internal int fontcolorselected;
	internal int fontsize;
	internal int height;
	internal bool selected;
	internal int width;
	internal int x;
	internal int y;
}

public enum ButtonStyle
{
	Button,
	Text,
	ServerEntry
}

public class ByteArray
{
	internal byte[] data;
	internal int length;
}

public class CachedTextTexture
{
	internal Text_ text;
	internal CachedTexture texture;
}

public class CachedTexture
{
	internal int lastuseMilliseconds;
	internal float sizeX;
	internal float sizeY;
	internal int textureId;
}

public class CameraMove
{
	internal bool AngleDown;
	internal bool AngleUp;
	internal float Distance;
	internal bool DistanceDown;
	internal bool DistanceUp;
	internal int MoveX;
	internal int MoveY;
	internal bool TurnLeft;
	internal bool TurnRight;
}

public class CameraPoint
{
	internal float orientationGlX;
	internal float orientationGlY;
	internal float orientationGlZ;
	internal float positionGlX;
	internal float positionGlY;
	internal float positionGlZ;
}

public enum CameraType
{
	Fpp,
	Tpp,
	Overhead
}

public class Chatline
{

	internal static Chatline Create(string text_, int timeMilliseconds_)
	{
		Chatline c = new Chatline();
		c.text = text_;
		c.timeMilliseconds = timeMilliseconds_;
		c.clickable = false;
		return c;
	}

	internal static Chatline CreateClickable(string text_, int timeMilliseconds_, string linkTarget_)
	{
		Chatline c = new Chatline();
		c.text = text_;
		c.timeMilliseconds = timeMilliseconds_;
		c.clickable = true;
		c.linkTarget = linkTarget_;
		return c;
	}
	internal bool clickable;
	internal string linkTarget;
	internal string text;
	internal int timeMilliseconds;
}

public class Chunk
{
	public Chunk()
	{
		this.baseLightDirty = true;
	}

	public bool ChunkHasData()
	{
		return this.data != null || this.dataInt != null;
	}

	public int GetBlockInChunk(int pos)
	{
		if (this.dataInt != null) {
			return this.dataInt[pos];
		}
		else {
			return this.data[pos];
		}
	}

	public void SetBlockInChunk(int pos, int block)
	{
		if (this.dataInt == null) {
			if (block < 255) {
				this.data[pos] = Game.IntToByte(block);
			}
			else {
				int n = 4096;
				this.dataInt = new int[n];
				for (int i = 0; i < n; i++) {
					this.dataInt[i] = this.data[i];
				}
				this.data = null;
				this.dataInt[pos] = block;
			}
		}
		else {
			this.dataInt[pos] = block;
		}
	}
	internal byte[] baseLight;
	internal bool baseLightDirty;
	internal byte[] data;
	internal int[] dataInt;
	internal RenderedChunk rendered;
}

public class ChunkEntityClient
{
}

public class ChunkSimple
{
	int[] data;
}

public class CitoMemoryStream : CitoStream
{
	public CitoMemoryStream()
	{
		this.buffer_ = new byte[1];
		this.count_ = 0;
		this.bufferlength = 1;
		this.position_ = 0;
	}

	public override bool CanSeek()
	{
		return false;
	}

	public static CitoMemoryStream Create(byte[] buffer, int length)
	{
		CitoMemoryStream m = new CitoMemoryStream();
		m.buffer_ = buffer;
		m.count_ = length;
		m.bufferlength = length;
		m.position_ = 0;
		return m;
	}

	public byte[] GetBuffer()
	{
		return this.buffer_;
	}

	public int Length()
	{
		return this.count_;
	}

	public override int Position()
	{
		return this.position_;
	}

	public override int Read(byte[] buffer, int offset, int count)
	{
		for (int i = 0; i < count; i++) {
			if (this.position_ + i >= this.count_) {
				this.position_ += i;
				return i;
			}
			buffer[offset + i] = this.buffer_[this.position_ + i];
		}
		this.position_ += count;
		return count;
	}

	public override int ReadByte()
	{
		if (this.position_ >= this.count_) {
			return -1;
		}
		return this.buffer_[this.position_++];
	}

	public override void Seek(int length, CitoSeekOrigin seekOrigin)
	{
		switch (seekOrigin) {
		case CitoSeekOrigin.Current:
			this.position_ += length;
			break;
		}
	}

	public override void Seek_(int p, CitoSeekOrigin seekOrigin)
	{
	}

	public byte[] ToArray()
	{
		return this.buffer_;
	}

	public override void Write(byte[] buffer, int offset, int count)
	{
		for (int i = 0; i < count; i++) {
			this.WriteByte(buffer[offset + i]);
		}
	}

	public override void WriteByte(byte p)
	{
		if (this.position_ >= this.bufferlength) {
			byte[] buffer2 = new byte[this.bufferlength * 2];
			for (int i = 0; i < this.bufferlength; i++) {
				buffer2[i] = this.buffer_[i];
			}
			this.buffer_ = buffer2;
			this.bufferlength = this.bufferlength * 2;
		}
		this.buffer_[this.position_] = p;
		if (this.position_ == this.count_) {
			this.count_++;
		}
		this.position_++;
	}
	byte[] buffer_;
	int bufferlength;
	int count_;
	int position_;
}

public enum CitoSeekOrigin
{
	Current
}

public abstract class CitoStream
{

	public abstract bool CanSeek();

	public abstract int Position();

	public abstract int Read(byte[] buffer, int read, int p);

	public abstract int ReadByte();

	public abstract void Seek(int length, CitoSeekOrigin seekOrigin);

	public abstract void Seek_(int p, CitoSeekOrigin seekOrigin);

	public abstract void Write(byte[] val, int p, int p_3);

	public abstract void WriteByte(byte p);
}

public class ClientCommandArgs
{
	internal string arguments;
	internal string command;
}

public class ClientInventoryController : IInventoryController
{

	public static ClientInventoryController Create(Game game)
	{
		ClientInventoryController c = new ClientInventoryController();
		c.g = game;
		return c;
	}

	public override void InventoryClick(Packet_InventoryPosition pos)
	{
		this.g.InventoryClick(pos);
	}

	public override void MoveToInventory(Packet_InventoryPosition from)
	{
		this.g.MoveToInventory(from);
	}

	public override void WearItem(Packet_InventoryPosition from, Packet_InventoryPosition to)
	{
		this.g.WearItem(from, to);
	}
	Game g;
}

public abstract class ClientMod
{

	public virtual void Dispose(Game game)
	{
	}

	public virtual void OnBeforeNewFrameDraw3d(Game game, float deltaTime)
	{
	}

	public virtual bool OnClientCommand(Game game, ClientCommandArgs args)
	{
		return false;
	}

	public virtual void OnHitEntity(Game game, OnUseEntityArgs e)
	{
	}

	public virtual void OnKeyDown(Game game, KeyEventArgs args)
	{
	}

	public virtual void OnKeyPress(Game game, KeyPressEventArgs args)
	{
	}

	public virtual void OnKeyUp(Game game, KeyEventArgs args)
	{
	}

	public virtual void OnMouseDown(Game game, MouseEventArgs args)
	{
	}

	public virtual void OnMouseMove(Game game, MouseEventArgs args)
	{
	}

	public virtual void OnMouseUp(Game game, MouseEventArgs args)
	{
	}

	public virtual void OnMouseWheelChanged(Game game, MouseWheelEventArgs args)
	{
	}

	public virtual void OnNewFrame(Game game, NewFrameEventArgs args)
	{
	}

	public virtual void OnNewFrameDraw2d(Game game, float deltaTime)
	{
	}

	public virtual void OnNewFrameDraw3d(Game game, float deltaTime)
	{
	}

	public virtual void OnNewFrameFixed(Game game, NewFrameEventArgs args)
	{
	}

	public virtual void OnNewFrameReadOnlyMainThread(Game game, float deltaTime)
	{
	}

	public virtual void OnReadOnlyBackgroundThread(Game game, float dt)
	{
	}

	public virtual void OnReadOnlyMainThread(Game game, float dt)
	{
	}

	public virtual void OnReadWriteMainThread(Game game, float dt)
	{
	}

	public virtual void OnTouchEnd(Game game, TouchEventArgs e)
	{
	}

	public virtual void OnTouchMove(Game game, TouchEventArgs e)
	{
	}

	public virtual void OnTouchStart(Game game, TouchEventArgs e)
	{
	}

	public virtual void OnUseEntity(Game game, OnUseEntityArgs e)
	{
	}

	public virtual void Start(ClientModManager modmanager)
	{
	}
}

public abstract class ClientModManager
{

	public abstract AviWriterCi AviWriterCreate();

	public abstract void DisplayNotification(string message);

	public abstract void Draw2dText(string text, float x, float y, float fontsize);

	public abstract void Draw2dTexture(int textureid, float x1, float y1, float width, float height, IntRef inAtlasId, int color);

	public abstract void Draw2dTextures(Draw2dData[] todraw, int todrawLength, int textureId);

	public abstract void EnableCameraControl(bool enable);

	public abstract int GetFreemove();

	public abstract float GetLocalOrientationX();

	public abstract float GetLocalOrientationY();

	public abstract float GetLocalOrientationZ();

	public abstract float GetLocalPositionX();

	public abstract float GetLocalPositionY();

	public abstract float GetLocalPositionZ();

	public abstract DictionaryStringString GetPerformanceInfo();

	public abstract GamePlatform GetPlatform();

	public abstract int GetWindowHeight();

	public abstract int GetWindowWidth();

	public abstract BitmapCi GrabScreenshot();

	public abstract bool IsFreemoveAllowed();

	public abstract void MakeScreenshot();

	public abstract void OrthoMode();

	public abstract void PerspectiveMode();

	public abstract void SendChatMessage(string message);

	public abstract void SetFreemove(int level);

	public abstract void SetLocalOrientation(float glx, float gly, float glz);

	public abstract void SetLocalPosition(float glx, float gly, float glz);

	public abstract void ShowGui(int level);

	public abstract int WhiteTexture();
}

public class ClientModManager1 : ClientModManager
{

	public override AviWriterCi AviWriterCreate()
	{
		return this.game.platform.AviWriterCreate();
	}

	public override void DisplayNotification(string message)
	{
		this.game.AddChatline(message);
	}

	public override void Draw2dText(string text, float x, float y, float fontsize)
	{
		FontCi font = new FontCi();
		font.family = "Arial";
		font.size = fontsize;
		this.game.Draw2dText(text, font, x, y, null, false);
	}

	public override void Draw2dTexture(int textureid, float x1, float y1, float width, float height, IntRef inAtlasId, int color)
	{
		int a = Game.ColorA(color);
		int r = Game.ColorR(color);
		int g = Game.ColorG(color);
		int b = Game.ColorB(color);
		this.game.Draw2dTexture(textureid, this.game.platform.FloatToInt(x1), this.game.platform.FloatToInt(y1), this.game.platform.FloatToInt(width), this.game.platform.FloatToInt(height), inAtlasId, 0, Game.ColorFromArgb(a, r, g, b), false);
	}

	public override void Draw2dTextures(Draw2dData[] todraw, int todrawLength, int textureId)
	{
		this.game.Draw2dTextures(todraw, todrawLength, textureId);
	}

	public override void EnableCameraControl(bool enable)
	{
		this.game.enableCameraControl = enable;
	}

	public override int GetFreemove()
	{
		return this.game.controls.GetFreemove();
	}

	public override float GetLocalOrientationX()
	{
		return this.game.player.position.rotx;
	}

	public override float GetLocalOrientationY()
	{
		return this.game.player.position.roty;
	}

	public override float GetLocalOrientationZ()
	{
		return this.game.player.position.rotz;
	}

	public override float GetLocalPositionX()
	{
		return this.game.player.position.x;
	}

	public override float GetLocalPositionY()
	{
		return this.game.player.position.y;
	}

	public override float GetLocalPositionZ()
	{
		return this.game.player.position.z;
	}

	public override DictionaryStringString GetPerformanceInfo()
	{
		return this.game.performanceinfo;
	}

	public override GamePlatform GetPlatform()
	{
		return this.game.platform;
	}

	public override int GetWindowHeight()
	{
		return this.game.platform.GetCanvasHeight();
	}

	public override int GetWindowWidth()
	{
		return this.game.platform.GetCanvasWidth();
	}

	public override BitmapCi GrabScreenshot()
	{
		return this.game.platform.GrabScreenshot();
	}

	public override bool IsFreemoveAllowed()
	{
		return this.game.AllowFreemove;
	}

	public override void MakeScreenshot()
	{
		this.game.platform.SaveScreenshot();
	}

	public override void OrthoMode()
	{
		this.game.OrthoMode(this.GetWindowWidth(), this.GetWindowHeight());
	}

	public override void PerspectiveMode()
	{
		this.game.PerspectiveMode();
	}

	public override void SendChatMessage(string message)
	{
		this.game.SendChat(message);
	}

	public override void SetFreemove(int level)
	{
		this.game.controls.SetFreemove(level);
	}

	public override void SetLocalOrientation(float glx, float gly, float glz)
	{
		this.game.player.position.rotx = glx;
		this.game.player.position.roty = gly;
		this.game.player.position.rotz = glz;
	}

	public override void SetLocalPosition(float glx, float gly, float glz)
	{
		this.game.player.position.x = glx;
		this.game.player.position.y = gly;
		this.game.player.position.z = glz;
	}

	public override void ShowGui(int level)
	{
		if (level == 0) {
			this.game.ENABLE_DRAW2D = false;
		}
		else {
			this.game.ENABLE_DRAW2D = true;
		}
	}

	public override int WhiteTexture()
	{
		return this.game.WhiteTexture();
	}
	internal Game game;
}

public abstract class ClientPacketHandler
{
	public ClientPacketHandler()
	{
		this.one = 1;
	}

	public abstract void Handle(Game game, Packet_Server packet);
	internal float one;
}

public class ClientPacketHandlerDialog : ClientPacketHandler
{

	GameScreen ConvertDialog(Game game, Packet_Dialog p)
	{
		DialogScreen s = new DialogScreen();
		s.widgets = new MenuWidget[p.WidgetsCount];
		s.WidgetCount = p.WidgetsCount;
		for (int i = 0; i < p.WidgetsCount; i++) {
			Packet_Widget a = p.Widgets[i];
			MenuWidget b = new MenuWidget();
			if (a.Type == 1) {
				b.type = WidgetType.Label;
			}
			if (a.Type == 0) {
				b.type = WidgetType.Button;
			}
			if (a.Type == 2) {
				b.type = WidgetType.Textbox;
			}
			b.x = a.X;
			b.y = a.Y;
			b.sizex = a.Width;
			b.sizey = a.Height_;
			b.text = a.Text;
			if (b.text != null) {
				b.text = game.platform.StringReplace(b.text, "!SERVER_IP!", game.ServerInfo.connectdata.Ip);
			}
			if (b.text != null) {
				b.text = game.platform.StringReplace(b.text, "!SERVER_PORT!", game.platform.IntToString(game.ServerInfo.connectdata.Port));
			}
			b.color = a.Color;
			if (a.Font != null) {
				b.font = new FontCi();
				b.font.family = game.ValidFont(a.Font.FamilyName);
				b.font.size = game.DeserializeFloat(a.Font.SizeFloat);
				b.font.style = a.Font.FontStyle;
			}
			b.id = a.Id;
			b.isbutton = a.ClickKey != 0;
			if (a.Image == "Solid") {
				b.image = null;
			}
			else if (a.Image != null) {
				b.image = StringTools.StringAppend(game.platform, a.Image, ".png");
			}
			s.widgets[i] = b;
		}
		for (int i = 0; i < s.WidgetCount; i++) {
			if (s.widgets[i] == null) {
				continue;
			}
			if (s.widgets[i].type == WidgetType.Textbox) {
				s.widgets[i].editing = true;
				break;
			}
		}
		return s;
	}

	public override void Handle(Game game, Packet_Server packet)
	{
		Packet_ServerDialog d = packet.Dialog;
		if (d.Dialog == null) {
			if (game.GetDialogId(d.DialogId) != -1 && game.dialogs[game.GetDialogId(d.DialogId)].value.IsModal != 0) {
				game.GuiStateBackToGame();
			}
			if (game.GetDialogId(d.DialogId) != -1) {
				game.dialogs[game.GetDialogId(d.DialogId)] = null;
			}
			if (game.DialogsCount_() == 0) {
				game.SetFreeMouse(false);
			}
		}
		else {
			VisibleDialog d2 = new VisibleDialog();
			d2.key = d.DialogId;
			d2.value = d.Dialog;
			d2.screen = this.ConvertDialog(game, d2.value);
			d2.screen.game = game;
			if (game.GetDialogId(d.DialogId) == -1) {
				for (int i = 0; i < game.dialogsCount; i++) {
					if (game.dialogs[i] == null) {
						game.dialogs[i] = d2;
						break;
					}
				}
			}
			else {
				game.dialogs[game.GetDialogId(d.DialogId)] = d2;
			}
			if (d.Dialog.IsModal != 0) {
				game.guistate = GuiState.ModalDialog;
				game.SetFreeMouse(true);
			}
		}
	}
}

public class ClientPacketHandlerEntityDespawn : ClientPacketHandler
{

	public override void Handle(Game game, Packet_Server packet)
	{
		if (game.entities[packet.EntityDespawn.Id] != null) {
			if (game.entities[packet.EntityDespawn.Id].drawModel != null && game.entities[packet.EntityDespawn.Id].drawModel.DownloadSkin) {
				int currentTex = game.entities[packet.EntityDespawn.Id].drawModel.CurrentTexture;
				if (currentTex > 0 && currentTex != game.GetTexture("mineplayer.png")) {
					game.entities[packet.EntityDespawn.Id].drawModel.CurrentTexture = -1;
					game.DeleteTexture(game.entities[packet.EntityDespawn.Id].drawName.Name);
				}
			}
		}
		game.entities[packet.EntityDespawn.Id] = null;
	}
}

public class ClientPacketHandlerEntityPosition : ClientPacketHandler
{

	public override void Handle(Game game, Packet_Server packet)
	{
		Entity entity = game.entities[packet.EntityPosition.Id];
		EntityPosition_ pos = ClientPacketHandlerEntitySpawn.ToClientEntityPosition(packet.EntityPosition.PositionAndOrientation);
		entity.networkPosition = pos;
		entity.networkPosition.PositionLoaded = true;
		entity.networkPosition.LastUpdateMilliseconds = game.platform.TimeMillisecondsFromStart();
		if (packet.EntityPosition.Id == game.LocalPlayerId) {
			game.player.position.x = pos.x;
			game.player.position.y = pos.y;
			game.player.position.z = pos.z;
			game.player.position.rotx = pos.rotx;
			game.player.position.roty = pos.roty;
			game.player.position.rotz = pos.rotz;
			entity.networkPosition = null;
		}
		else if (entity.push != null) {
			entity.push.XFloat = packet.EntityPosition.PositionAndOrientation.X;
			entity.push.YFloat = packet.EntityPosition.PositionAndOrientation.Z;
			entity.push.ZFloat = packet.EntityPosition.PositionAndOrientation.Y;
		}
	}
}

public class ClientPacketHandlerEntitySpawn : ClientPacketHandler
{

	public override void Handle(Game game, Packet_Server packet)
	{
		Entity entity = game.entities[packet.EntitySpawn.Id];
		if (entity == null) {
			entity = new Entity();
		}
		ClientPacketHandlerEntitySpawn.ToClientEntity(game, packet.EntitySpawn.Entity_, entity, packet.EntitySpawn.Id != game.LocalPlayerId);
		game.entities[packet.EntitySpawn.Id] = entity;
		if (packet.EntitySpawn.Id == game.LocalPlayerId) {
			entity.networkPosition = null;
			game.player = entity;
			if (!game.spawned) {
				entity.scripts[entity.scriptsCount++] = new ScriptCharacterPhysics();
				game.MapLoaded();
				game.spawned = true;
			}
		}
	}

	public static Entity ToClientEntity(Game game, Packet_ServerEntity entity, Entity old, bool updatePosition)
	{
		if (entity.Position != null) {
			if (old.position == null || updatePosition) {
				old.networkPosition = ClientPacketHandlerEntitySpawn.ToClientEntityPosition(entity.Position);
				old.networkPosition.PositionLoaded = true;
				old.networkPosition.LastUpdateMilliseconds = game.platform.TimeMillisecondsFromStart();
				old.position = ClientPacketHandlerEntitySpawn.ToClientEntityPosition(entity.Position);
			}
		}
		if (entity.DrawModel != null) {
			old.drawModel = new EntityDrawModel();
			old.drawModel.eyeHeight = game.DeserializeFloat(entity.DrawModel.EyeHeight);
			old.drawModel.ModelHeight = game.DeserializeFloat(entity.DrawModel.ModelHeight);
			old.drawModel.Texture_ = entity.DrawModel.Texture_;
			old.drawModel.Model_ = entity.DrawModel.Model_;
			if (old.drawModel.Model_ == null) {
				old.drawModel.Model_ = "player.txt";
			}
			old.drawModel.DownloadSkin = entity.DrawModel.DownloadSkin != 0;
		}
		if (entity.DrawName_ != null) {
			old.drawName = new DrawName();
			if (entity.DrawName_.Color != null) {
				old.drawName.Name = game.platform.StringFormat2("{0}{1}", entity.DrawName_.Color, entity.DrawName_.Name);
			}
			else {
				old.drawName.Name = entity.DrawName_.Name;
			}
			if (!game.platform.StringStartsWithIgnoreCase(old.drawName.Name, "&")) {
				old.drawName.Name = game.platform.StringFormat("&f{0}", old.drawName.Name);
			}
			old.drawName.OnlyWhenSelected = entity.DrawName_.OnlyWhenSelected;
			old.drawName.ClientAutoComplete = entity.DrawName_.ClientAutoComplete;
		}
		if (entity.DrawText != null) {
			old.drawText = new EntityDrawText();
			old.drawText.text = entity.DrawText.Text;
			float one_ = 1;
			old.drawText.dx = one_ * entity.DrawText.Dx / 32;
			old.drawText.dy = one_ * entity.DrawText.Dy / 32;
			old.drawText.dz = one_ * entity.DrawText.Dz / 32;
		}
		else {
			old.drawText = null;
		}
		if (entity.DrawBlock != null) {
		}
		if (entity.Push != null) {
			old.push = new Packet_ServerExplosion();
			old.push.RangeFloat = entity.Push.RangeFloat;
		}
		else {
			old.push = null;
		}
		old.usable = entity.Usable;
		if (entity.DrawArea != null) {
			old.drawArea = new EntityDrawArea();
			old.drawArea.x = entity.DrawArea.X;
			old.drawArea.y = entity.DrawArea.Y;
			old.drawArea.z = entity.DrawArea.Z;
			old.drawArea.sizex = entity.DrawArea.Sizex;
			old.drawArea.sizey = entity.DrawArea.Sizey;
			old.drawArea.sizez = entity.DrawArea.Sizez;
		}
		else {
			old.drawArea = null;
		}
		return old;
	}

	public static EntityPosition_ ToClientEntityPosition(Packet_PositionAndOrientation pos)
	{
		float one = 1;
		EntityPosition_ p = new EntityPosition_();
		p.x = one * pos.X / 32;
		p.y = one * pos.Y / 32;
		p.z = one * pos.Z / 32;
		p.rotx = Game.Angle256ToRad(pos.Pitch);
		p.roty = Game.Angle256ToRad(pos.Heading);
		return p;
	}
}

public class ClientPackets
{

	public static Packet_Client ActiveMaterialSlot(int ActiveMaterial)
	{
		Packet_Client p = new Packet_Client();
		{
			p.Id = 56;
			p.ActiveMaterialSlot = new Packet_ClientActiveMaterialSlot();
			p.ActiveMaterialSlot.ActiveMaterialSlot = ActiveMaterial;
		}
		return p;
	}

	public static Packet_Client Chat(string s, int isTeamchat)
	{
		Packet_ClientMessage p = new Packet_ClientMessage();
		p.Message = s;
		p.IsTeamchat = isTeamchat;
		Packet_Client pp = new Packet_Client();
		pp.Id = 13;
		pp.Message = p;
		return pp;
	}

	public static Packet_Client Craft(int x, int y, int z, int recipeId)
	{
		Packet_ClientCraft cmd = new Packet_ClientCraft();
		cmd.X = x;
		cmd.Y = y;
		cmd.Z = z;
		cmd.RecipeId = recipeId;
		Packet_Client p = new Packet_Client();
		p.Id = 9;
		p.Craft = cmd;
		return p;
	}

	public static Packet_Client CreateLoginPacket(GamePlatform platform, string username, string verificationKey)
	{
		Packet_ClientIdentification p = new Packet_ClientIdentification();
		{
			p.Username = username;
			p.MdProtocolVersion = platform.GetGameVersion();
			p.VerificationKey = verificationKey;
		}
		Packet_Client pp = new Packet_Client();
		pp.Id = 0;
		pp.Identification = p;
		return pp;
	}

	public static Packet_Client CreateLoginPacket_(GamePlatform platform, string username, string verificationKey, string serverPassword)
	{
		Packet_ClientIdentification p = new Packet_ClientIdentification();
		{
			p.Username = username;
			p.MdProtocolVersion = platform.GetGameVersion();
			p.VerificationKey = verificationKey;
			p.ServerPassword = serverPassword;
		}
		Packet_Client pp = new Packet_Client();
		pp.Id = 0;
		pp.Identification = p;
		return pp;
	}

	public static Packet_Client Death(int reason, int sourcePlayer)
	{
		Packet_Client p = new Packet_Client();
		p.Id = 60;
		p.Death = new Packet_ClientDeath();
		{
			p.Death.Reason = reason;
			p.Death.SourcePlayer = sourcePlayer;
		}
		return p;
	}

	public static Packet_Client DialogClick(string widgetId, string[] textValues, int textValuesCount)
	{
		Packet_Client p = new Packet_Client();
		p.Id = 14;
		p.DialogClick_ = new Packet_ClientDialogClick();
		p.DialogClick_.WidgetId = widgetId;
		p.DialogClick_.SetTextBoxValue(textValues, textValuesCount, textValuesCount);
		return p;
	}

	public static Packet_Client FillArea(int startx, int starty, int startz, int endx, int endy, int endz, int blockType, int ActiveMaterial)
	{
		Packet_ClientFillArea p = new Packet_ClientFillArea();
		{
			p.X1 = startx;
			p.Y1 = starty;
			p.Z1 = startz;
			p.X2 = endx;
			p.Y2 = endy;
			p.Z2 = endz;
			p.BlockType = blockType;
			p.MaterialSlot = ActiveMaterial;
		}
		Packet_Client pp = new Packet_Client();
		pp.Id = 510;
		pp.FillArea = p;
		return pp;
	}

	public static Packet_Client GameResolution(int width, int height)
	{
		Packet_ClientGameResolution p = new Packet_ClientGameResolution();
		p.Width = width;
		p.Height = height;
		Packet_Client pp = new Packet_Client();
		pp.Id = 10;
		pp.GameResolution = p;
		return pp;
	}

	public static Packet_Client Health(int currentHealth)
	{
		Packet_Client p = new Packet_Client();
		{
			p.Id = 52;
			p.Health = new Packet_ClientHealth();
			p.Health.CurrentHealth = currentHealth;
		}
		return p;
	}

	internal static Packet_Client HitEntity(int entityId)
	{
		Packet_Client p = new Packet_Client();
		p.Id = 61;
		p.EntityInteraction = new Packet_ClientEntityInteraction();
		p.EntityInteraction.EntityId = entityId;
		p.EntityInteraction.InteractionType = 1;
		return p;
	}

	public static Packet_Client InventoryClick(Packet_InventoryPosition pos)
	{
		Packet_ClientInventoryAction p = new Packet_ClientInventoryAction();
		p.A = pos;
		p.Action = 0;
		Packet_Client pp = new Packet_Client();
		pp.Id = 51;
		pp.InventoryAction = p;
		return pp;
	}

	public static Packet_Client Leave(int reason)
	{
		Packet_Client p = new Packet_Client();
		p.Id = 57;
		p.Leave = new Packet_ClientLeave();
		p.Leave.Reason = reason;
		return p;
	}

	public static Packet_Client MonsterHit(int damage)
	{
		Packet_ClientHealth p = new Packet_ClientHealth();
		p.CurrentHealth = damage;
		Packet_Client packet = new Packet_Client();
		packet.Id = 53;
		packet.Health = p;
		return packet;
	}

	public static Packet_Client MoveToInventory(Packet_InventoryPosition from)
	{
		Packet_ClientInventoryAction p = new Packet_ClientInventoryAction();
		p.A = from;
		p.Action = 2;
		Packet_Client pp = new Packet_Client();
		pp.Id = 51;
		pp.InventoryAction = p;
		return pp;
	}

	public static Packet_Client Oxygen(int currentOxygen)
	{
		Packet_Client packet = new Packet_Client();
		packet.Id = 59;
		packet.Oxygen = new Packet_ClientOxygen();
		packet.Oxygen.CurrentOxygen = currentOxygen;
		return packet;
	}

	public static Packet_Client PingReply()
	{
		Packet_ClientPingReply p = new Packet_ClientPingReply();
		Packet_Client pp = new Packet_Client();
		pp.Id = 1;
		pp.PingReply = p;
		return pp;
	}

	public static Packet_Client PositionAndOrientation(Game game, int playerId, float positionX, float positionY, float positionZ, float orientationX, float orientationY, float orientationZ, byte stance)
	{
		Packet_ClientPositionAndOrientation p = new Packet_ClientPositionAndOrientation();
		{
			p.PlayerId = playerId;
			p.X = game.platform.FloatToInt(positionX * 32);
			p.Y = game.platform.FloatToInt(positionY * 32);
			p.Z = game.platform.FloatToInt(positionZ * 32);
			p.Heading = game.platform.FloatToInt(Game.RadToAngle256(orientationY));
			p.Pitch = game.platform.FloatToInt(Game.RadToAngle256(orientationX));
			p.Stance = stance;
		}
		Packet_Client pp = new Packet_Client();
		pp.Id = 8;
		pp.PositionAndOrientation = p;
		return pp;
	}

	public static Packet_Client Reload()
	{
		Packet_Client p = new Packet_Client();
		p.Id = 58;
		p.Reload = new Packet_ClientReload();
		return p;
	}

	public static Packet_Client RequestBlob(Game game, string[] required, int requiredCount)
	{
		Packet_ClientRequestBlob p = new Packet_ClientRequestBlob();
		if (GameVersionHelper.ServerVersionAtLeast(game.platform, game.serverGameVersion, 2014, 4, 13)) {
			p.RequestedMd5 = new Packet_StringList();
			p.RequestedMd5.SetItems(required, requiredCount, requiredCount);
		}
		Packet_Client pp = new Packet_Client();
		pp.Id = 50;
		pp.RequestBlob = p;
		return pp;
	}

	public static Packet_Client ServerQuery()
	{
		Packet_ClientServerQuery p1 = new Packet_ClientServerQuery();
		Packet_Client pp = new Packet_Client();
		pp.Id = 64;
		pp.Query = p1;
		return pp;
	}

	public static Packet_Client SetBlock(int x, int y, int z, int mode, int type, int materialslot)
	{
		Packet_ClientSetBlock p = new Packet_ClientSetBlock();
		{
			p.X = x;
			p.Y = y;
			p.Z = z;
			p.Mode = mode;
			p.BlockType = type;
			p.MaterialSlot = materialslot;
		}
		Packet_Client pp = new Packet_Client();
		pp.Id = 5;
		pp.SetBlock = p;
		return pp;
	}

	public static Packet_Client SpecialKeyRespawn()
	{
		Packet_Client p = new Packet_Client();
		{
			p.Id = 55;
			p.SpecialKey_ = new Packet_ClientSpecialKey();
			p.SpecialKey_.Key_ = 0;
		}
		return p;
	}

	public static Packet_Client SpecialKeySelectTeam()
	{
		Packet_Client p = new Packet_Client();
		{
			p.Id = 55;
			p.SpecialKey_ = new Packet_ClientSpecialKey();
			p.SpecialKey_.Key_ = 3;
		}
		return p;
	}

	public static Packet_Client SpecialKeySetSpawn()
	{
		Packet_Client p = new Packet_Client();
		{
			p.Id = 55;
			p.SpecialKey_ = new Packet_ClientSpecialKey();
			p.SpecialKey_.Key_ = 1;
		}
		return p;
	}

	public static Packet_Client SpecialKeyTabPlayerList()
	{
		Packet_Client p = new Packet_Client();
		p.Id = 55;
		p.SpecialKey_ = new Packet_ClientSpecialKey();
		p.SpecialKey_.Key_ = 2;
		return p;
	}

	internal static Packet_Client UseEntity(int entityId)
	{
		Packet_Client p = new Packet_Client();
		p.Id = 61;
		p.EntityInteraction = new Packet_ClientEntityInteraction();
		p.EntityInteraction.EntityId = entityId;
		p.EntityInteraction.InteractionType = 0;
		return p;
	}

	public static Packet_Client WearItem(Packet_InventoryPosition from, Packet_InventoryPosition to)
	{
		Packet_ClientInventoryAction p = new Packet_ClientInventoryAction();
		p.A = from;
		p.B = to;
		p.Action = 1;
		Packet_Client pp = new Packet_Client();
		pp.Id = 51;
		pp.InventoryAction = p;
		return pp;
	}
}

public class ClientSimple
{
	public ClientSimple()
	{
		this.inventory = new Packet_Inventory();
		this.inventory.SetRightHand(new Packet_Item[10], 10, 10);
		for (int i = 0; i < 10; i++) {
			this.inventory.RightHand[i] = new Packet_Item();
		}
	}
	internal NetConnection Connection;
	internal NetServer MainSocket;
	internal string Name;
	internal bool[][] chunksseen;
	internal bool connected;
	internal float glX;
	internal float glY;
	internal float glZ;
	internal Packet_Inventory inventory;
	internal bool inventoryDirty;
	internal Action_ notifyMapAction;
	internal int pingLastMilliseconds;
}

public class ClientStateOnServer
{
	public const int Connecting = 0;
	public const int LoadingGenerating = 1;
	public const int LoadingSending = 2;
	public const int Playing = 3;
}

public class Config3d
{
	public Config3d()
	{
		this.ENABLE_BACKFACECULLING = true;
		this.ENABLE_TRANSPARENCY = true;
		this.ENABLE_MIPMAPS = true;
		this.ENABLE_VISIBILITY_CULLING = false;
		this.viewdistance = 128;
	}
	internal bool ENABLE_BACKFACECULLING;
	internal bool ENABLE_MIPMAPS;
	internal bool ENABLE_TRANSPARENCY;
	internal bool ENABLE_VISIBILITY_CULLING;

	public bool GetEnableMipmaps()
	{
		return this.ENABLE_MIPMAPS;
	}

	public bool GetEnableTransparency()
	{
		return this.ENABLE_TRANSPARENCY;
	}

	public float GetViewDistance()
	{
		return this.viewdistance;
	}

	public void SetEnableMipmaps(bool value)
	{
		this.ENABLE_MIPMAPS = value;
	}

	public void SetEnableTransparency(bool value)
	{
		this.ENABLE_TRANSPARENCY = value;
	}

	public void SetViewDistance(float value)
	{
		this.viewdistance = value;
	}
	internal float viewdistance;
}

public class ConnectData
{
	internal string Auth;

	public static ConnectData FromUri(UriCi uri)
	{
		ConnectData c = new ConnectData();
		c = new ConnectData();
		c.Ip = uri.GetIp();
		c.Port = 25565;
		c.Username = "gamer";
		if (uri.GetPort() != -1) {
			c.Port = uri.GetPort();
		}
		if (uri.GetGet().ContainsKey("user")) {
			c.Username = uri.GetGet().Get("user");
		}
		if (uri.GetGet().ContainsKey("auth")) {
			c.Auth = uri.GetGet().Get("auth");
		}
		if (uri.GetGet().ContainsKey("serverPassword")) {
			c.IsServePasswordProtected = MiscCi.ReadBool(uri.GetGet().Get("serverPassword"));
		}
		return c;
	}

	public bool GetIsServePasswordProtected()
	{
		return this.IsServePasswordProtected;
	}
	internal string Ip;
	internal bool IsServePasswordProtected;
	internal int Port;
	internal string ServerPassword;

	public void SetIp(string value)
	{
		this.Ip = value;
	}

	public void SetIsServePasswordProtected(bool value)
	{
		this.IsServePasswordProtected = value;
	}

	public void SetPort(int value)
	{
		this.Port = value;
	}

	public void SetServerPassword(string value)
	{
		this.ServerPassword = value;
	}

	public void SetUsername(string value)
	{
		this.Username = value;
	}
	internal string Username;
}

public class ConnectedPlayer
{
	internal int id;
	internal string name;
	internal int ping;
}

public class Controls
{

	/// <summary>&lt;summary&gt;
	/// Get the current player freemove mode
	/// &lt;/summary&gt;
	/// &lt;returns&gt;Freemove mode as defined in FreemoveLevelEnum&lt;/returns&gt;</summary>
	public int GetFreemove()
	{
		if (!this.freemove) {
			return 0;
		}
		if (this.noclip) {
			return 2;
		}
		else {
			return 1;
		}
	}

	/// <summary>&lt;summary&gt;
	/// Set player freemove mode to the given value
	/// &lt;/summary&gt;
	/// &lt;param name="level"&gt;Freemove mode as defined in FreemoveLevelEnum&lt;/param&gt;</summary>
	public void SetFreemove(int level)
	{
		if (level == 0) {
			this.freemove = false;
			this.noclip = false;
		}
		if (level == 1) {
			this.freemove = true;
			this.noclip = false;
		}
		if (level == 2) {
			this.freemove = true;
			this.noclip = true;
		}
	}
	internal bool freemove;
	internal bool movedown;
	internal float movedx;
	internal float movedy;
	internal bool moveup;
	internal bool noclip;
	internal bool shiftkeydown;
	internal bool wantsjump;
	internal bool wantsjumphalf;
}

public class CornerEnum
{
	public const int BottomLeft = 2;
	public const int BottomRight = 3;
	public const int None = -1;
	public const int TopLeft = 0;
	public const int TopRight = 1;
}

public class CraftingTableTool
{

	public int[] GetOnTable(Vector3IntRef[] table, int tableCount, IntRef retCount)
	{
		int[] ontable = new int[2048];
		int ontableCount = 0;
		for (int i = 0; i < tableCount; i++) {
			Vector3IntRef v = table[i];
			int t = this.d_Map.GetBlock(v.X, v.Y, v.Z + 1);
			ontable[ontableCount++] = t;
		}
		retCount.value = ontableCount;
		return ontable;
	}

	public Vector3IntRef[] GetTable(int posx, int posy, int posz, IntRef retCount)
	{
		Vector3IntRef[] l = new Vector3IntRef[2048];
		int lCount = 0;
		Vector3IntRef[] todo = new Vector3IntRef[2048];
		int todoCount = 0;
		todo[todoCount++] = Vector3IntRef.Create(posx, posy, posz);
		for (;;) {
			if (todoCount == 0 || lCount >= 2000) {
				break;
			}
			Vector3IntRef p = todo[todoCount - 1];
			todoCount--;
			if (this.Vector3IntRefArrayContains(l, lCount, p)) {
				continue;
			}
			l[lCount++] = p;
			Vector3IntRef a = Vector3IntRef.Create(p.X + 1, p.Y, p.Z);
			if (this.d_Map.GetBlock(a.X, a.Y, a.Z) == this.d_Data.BlockIdCraftingTable()) {
				todo[todoCount++] = a;
			}
			Vector3IntRef b = Vector3IntRef.Create(p.X - 1, p.Y, p.Z);
			if (this.d_Map.GetBlock(b.X, b.Y, b.Z) == this.d_Data.BlockIdCraftingTable()) {
				todo[todoCount++] = b;
			}
			Vector3IntRef c = Vector3IntRef.Create(p.X, p.Y + 1, p.Z);
			if (this.d_Map.GetBlock(c.X, c.Y, c.Z) == this.d_Data.BlockIdCraftingTable()) {
				todo[todoCount++] = c;
			}
			Vector3IntRef d = Vector3IntRef.Create(p.X, p.Y - 1, p.Z);
			if (this.d_Map.GetBlock(d.X, d.Y, d.Z) == this.d_Data.BlockIdCraftingTable()) {
				todo[todoCount++] = d;
			}
		}
		retCount.value = lCount;
		return l;
	}

	bool Vector3IntRefArrayContains(Vector3IntRef[] l, int lCount, Vector3IntRef p)
	{
		for (int i = 0; i < lCount; i++) {
			if (l[i].X == p.X && l[i].Y == p.Y && l[i].Z == p.Z) {
				return true;
			}
		}
		return false;
	}
	internal GameData d_Data;
	internal IMapStorage2 d_Map;
}

public class CubeModelData
{

	public static ModelData GetCubeModelData()
	{
		ModelData m = new ModelData();
		float[] xyz = new float[72];
		for (int i = 0; i < 72; i++) {
			xyz[i] = CiConstArray_1[i];
		}
		m.setXyz(xyz);
		float[] uv = new float[48];
		for (int i = 0; i < 48; i++) {
			uv[i] = CiConstArray_2[i];
		}
		m.setUv(uv);
		m.SetVerticesCount(24);
		m.setIndices(CiConstArray_3);
		m.SetIndicesCount(36);
		return m;
	}
	static readonly int[] CiConstArray_1 = { -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1,
		1, -1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1,
		1, 1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1,
		1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1, -1, -1,
		-1, 1, -1, 1, 1, -1, 1, -1 };
	static readonly int[] CiConstArray_2 = { 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0,
		0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0,
		1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1 };
	static readonly int[] CiConstArray_3 = { 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8,
		10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21,
		22, 20, 22, 23 };
}

public class CuboidRenderer
{

	public static void AddVertex(ModelData model, float x, float y, float z, float u, float v, int color)
	{
		model.xyz[model.GetXyzCount() + 0] = x;
		model.xyz[model.GetXyzCount() + 1] = y;
		model.xyz[model.GetXyzCount() + 2] = z;
		model.uv[model.GetUvCount() + 0] = u;
		model.uv[model.GetUvCount() + 1] = v;
		model.rgba[model.GetRgbaCount() + 0] = Game.IntToByte(Game.ColorR(color));
		model.rgba[model.GetRgbaCount() + 1] = Game.IntToByte(Game.ColorG(color));
		model.rgba[model.GetRgbaCount() + 2] = Game.IntToByte(Game.ColorB(color));
		model.rgba[model.GetRgbaCount() + 3] = Game.IntToByte(Game.ColorA(color));
		model.verticesCount++;
	}

	public static RectangleFloat[] CuboidNet(float tsizex, float tsizey, float tsizez, float tstartx, float tstarty)
	{
		RectangleFloat[] coords = new RectangleFloat[6];
		{
			coords[0] = RectangleFloat.Create(tsizez + tstartx, tsizez + tstarty, tsizex, tsizey);
			coords[1] = RectangleFloat.Create(2 * tsizez + tsizex + tstartx, tsizez + tstarty, tsizex, tsizey);
			coords[2] = RectangleFloat.Create(tstartx, tsizez + tstarty, tsizez, tsizey);
			coords[3] = RectangleFloat.Create(tsizez + tsizex + tstartx, tsizez + tstarty, tsizez, tsizey);
			coords[4] = RectangleFloat.Create(tsizez + tstartx, tstarty, tsizex, tsizez);
			coords[5] = RectangleFloat.Create(tsizez + tsizex + tstartx, tstarty, tsizex, tsizez);
		}
		return coords;
	}

	public static void CuboidNetNormalize(RectangleFloat[] coords, float texturewidth, float textureheight)
	{
		float AtiArtifactFix = 0.15f;
		for (int i = 0; i < 6; i++) {
			float x = (coords[i].X + AtiArtifactFix) / texturewidth;
			float y = (coords[i].Y + AtiArtifactFix) / textureheight;
			float w = (coords[i].X + coords[i].Width - AtiArtifactFix) / texturewidth - x;
			float h = (coords[i].Y + coords[i].Height - AtiArtifactFix) / textureheight - y;
			coords[i] = RectangleFloat.Create(x, y, w, h);
		}
	}

	public static void DrawCuboid(Game game, float posX, float posY, float posZ, float sizeX, float sizeY, float sizeZ, RectangleFloat[] texturecoords, float light)
	{
		ModelData data = new ModelData();
		data.xyz = new float[72];
		data.uv = new float[48];
		data.rgba = new byte[96];
		int light255 = game.platform.FloatToInt(light * 255);
		int color = Game.ColorFromArgb(255, light255, light255, light255);
		RectangleFloat rect;
		rect = texturecoords[0];
		CuboidRenderer.AddVertex(data, posX, posY, posZ, rect.X, rect.Bottom(), color);
		CuboidRenderer.AddVertex(data, posX, posY, posZ + sizeZ, rect.X + rect.Width, rect.Bottom(), color);
		CuboidRenderer.AddVertex(data, posX, posY + sizeY, posZ + sizeZ, rect.X + rect.Width, rect.Y, color);
		CuboidRenderer.AddVertex(data, posX, posY + sizeY, posZ, rect.X, rect.Y, color);
		rect = texturecoords[1];
		CuboidRenderer.AddVertex(data, posX + sizeX, posY, posZ, rect.X, rect.Bottom(), color);
		CuboidRenderer.AddVertex(data, posX + sizeX, posY, posZ + sizeZ, rect.X + rect.Width, rect.Bottom(), color);
		CuboidRenderer.AddVertex(data, posX + sizeX, posY + sizeY, posZ + sizeZ, rect.X + rect.Width, rect.Y, color);
		CuboidRenderer.AddVertex(data, posX + sizeX, posY + sizeY, posZ, rect.X, rect.Y, color);
		rect = texturecoords[2];
		CuboidRenderer.AddVertex(data, posX + sizeX, posY, posZ, rect.X, rect.Bottom(), color);
		CuboidRenderer.AddVertex(data, posX, posY, posZ, rect.X + rect.Width, rect.Bottom(), color);
		CuboidRenderer.AddVertex(data, posX, posY + sizeY, posZ, rect.X + rect.Width, rect.Y, color);
		CuboidRenderer.AddVertex(data, posX + sizeX, posY + sizeY, posZ, rect.X, rect.Y, color);
		rect = texturecoords[3];
		CuboidRenderer.AddVertex(data, posX + sizeX, posY, posZ + sizeZ, rect.X + rect.Width, rect.Bottom(), color);
		CuboidRenderer.AddVertex(data, posX, posY, posZ + sizeZ, rect.X, rect.Bottom(), color);
		CuboidRenderer.AddVertex(data, posX, posY + sizeY, posZ + sizeZ, rect.X, rect.Y, color);
		CuboidRenderer.AddVertex(data, posX + sizeX, posY + sizeY, posZ + sizeZ, rect.X + rect.Width, rect.Y, color);
		rect = texturecoords[4];
		CuboidRenderer.AddVertex(data, posX, posY + sizeY, posZ, rect.X, rect.Bottom(), color);
		CuboidRenderer.AddVertex(data, posX, posY + sizeY, posZ + sizeZ, rect.X + rect.Width, rect.Bottom(), color);
		CuboidRenderer.AddVertex(data, posX + sizeX, posY + sizeY, posZ + sizeZ, rect.X + rect.Width, rect.Y, color);
		CuboidRenderer.AddVertex(data, posX + sizeX, posY + sizeY, posZ, rect.X, rect.Y, color);
		rect = texturecoords[5];
		CuboidRenderer.AddVertex(data, posX, posY, posZ, rect.X, rect.Bottom(), color);
		CuboidRenderer.AddVertex(data, posX, posY, posZ + sizeZ, rect.X + rect.Width, rect.Bottom(), color);
		CuboidRenderer.AddVertex(data, posX + sizeX, posY, posZ + sizeZ, rect.X + rect.Width, rect.Y, color);
		CuboidRenderer.AddVertex(data, posX + sizeX, posY, posZ, rect.X, rect.Y, color);
		data.indices = new int[36];
		for (int i = 0; i < 6; i++) {
			data.indices[i * 6 + 0] = i * 4 + 3;
			data.indices[i * 6 + 1] = i * 4 + 2;
			data.indices[i * 6 + 2] = i * 4 + 0;
			data.indices[i * 6 + 3] = i * 4 + 2;
			data.indices[i * 6 + 4] = i * 4 + 1;
			data.indices[i * 6 + 5] = i * 4 + 0;
		}
		data.indicesCount = 36;
		game.platform.GlDisableCullFace();
		game.DrawModelData(data);
		game.platform.GlEnableCullFace();
	}

	public static void DrawCuboid2(Game game, float posX, float posY, float posZ, float sizeX, float sizeY, float sizeZ, RectangleFloat[] texturecoords, float light)
	{
		ModelData data = new ModelData();
		data.xyz = new float[72];
		data.uv = new float[48];
		data.rgba = new byte[96];
		int light255 = game.platform.FloatToInt(light * 255);
		int color = Game.ColorFromArgb(255, light255, light255, light255);
		RectangleFloat rect;
		rect = texturecoords[2];
		CuboidRenderer.AddVertex(data, posX, posY, posZ, rect.X, rect.Bottom(), color);
		CuboidRenderer.AddVertex(data, posX, posY, posZ + sizeZ, rect.X + rect.Width, rect.Bottom(), color);
		CuboidRenderer.AddVertex(data, posX, posY + sizeY, posZ + sizeZ, rect.X + rect.Width, rect.Y, color);
		CuboidRenderer.AddVertex(data, posX, posY + sizeY, posZ, rect.X, rect.Y, color);
		rect = texturecoords[3];
		CuboidRenderer.AddVertex(data, posX + sizeX, posY, posZ + sizeZ, rect.X, rect.Bottom(), color);
		CuboidRenderer.AddVertex(data, posX + sizeX, posY, posZ, rect.X + rect.Width, rect.Bottom(), color);
		CuboidRenderer.AddVertex(data, posX + sizeX, posY + sizeY, posZ, rect.X + rect.Width, rect.Y, color);
		CuboidRenderer.AddVertex(data, posX + sizeX, posY + sizeY, posZ + sizeZ, rect.X, rect.Y, color);
		rect = texturecoords[1];
		CuboidRenderer.AddVertex(data, posX + sizeX, posY, posZ, rect.X, rect.Bottom(), color);
		CuboidRenderer.AddVertex(data, posX, posY, posZ, rect.X + rect.Width, rect.Bottom(), color);
		CuboidRenderer.AddVertex(data, posX, posY + sizeY, posZ, rect.X + rect.Width, rect.Y, color);
		CuboidRenderer.AddVertex(data, posX + sizeX, posY + sizeY, posZ, rect.X, rect.Y, color);
		rect = texturecoords[0];
		CuboidRenderer.AddVertex(data, posX + sizeX, posY, posZ + sizeZ, rect.X + rect.Width, rect.Bottom(), color);
		CuboidRenderer.AddVertex(data, posX, posY, posZ + sizeZ, rect.X, rect.Bottom(), color);
		CuboidRenderer.AddVertex(data, posX, posY + sizeY, posZ + sizeZ, rect.X, rect.Y, color);
		CuboidRenderer.AddVertex(data, posX + sizeX, posY + sizeY, posZ + sizeZ, rect.X + rect.Width, rect.Y, color);
		rect = texturecoords[4];
		CuboidRenderer.AddVertex(data, posX, posY + sizeY, posZ, rect.X, rect.Y, color);
		CuboidRenderer.AddVertex(data, posX, posY + sizeY, posZ + sizeZ, rect.X, rect.Bottom(), color);
		CuboidRenderer.AddVertex(data, posX + sizeX, posY + sizeY, posZ + sizeZ, rect.X + rect.Width, rect.Bottom(), color);
		CuboidRenderer.AddVertex(data, posX + sizeX, posY + sizeY, posZ, rect.X + rect.Width, rect.Y, color);
		rect = texturecoords[5];
		CuboidRenderer.AddVertex(data, posX, posY, posZ, rect.X, rect.Y, color);
		CuboidRenderer.AddVertex(data, posX, posY, posZ + sizeZ, rect.X, rect.Bottom(), color);
		CuboidRenderer.AddVertex(data, posX + sizeX, posY, posZ + sizeZ, rect.X + rect.Width, rect.Bottom(), color);
		CuboidRenderer.AddVertex(data, posX + sizeX, posY, posZ, rect.X + rect.Width, rect.Y, color);
		data.indices = new int[36];
		for (int i = 0; i < 6; i++) {
			data.indices[i * 6 + 0] = i * 4 + 3;
			data.indices[i * 6 + 1] = i * 4 + 2;
			data.indices[i * 6 + 2] = i * 4 + 0;
			data.indices[i * 6 + 3] = i * 4 + 2;
			data.indices[i * 6 + 4] = i * 4 + 1;
			data.indices[i * 6 + 5] = i * 4 + 0;
		}
		data.indicesCount = 36;
		game.platform.GlDisableCullFace();
		game.DrawModelData(data);
		game.platform.GlEnableCullFace();
	}
}

public abstract class DelegateGetBlockHeight
{

	public abstract float GetBlockHeight(int x, int y, int z);
}

public abstract class DelegateIsBlockEmpty
{

	public abstract bool IsBlockEmpty(int x, int y, int z);
}

public class DialogScreen : GameScreen
{

	public override void OnButton(MenuWidget w)
	{
		if (w.isbutton) {
			string[] textValues = new string[this.WidgetCount];
			for (int i = 0; i < this.WidgetCount; i++) {
				string s = this.widgets[i].text;
				if (s == null) {
					s = "";
				}
				textValues[i] = s;
			}
			this.game.SendPacketClient(ClientPackets.DialogClick(w.id, textValues, this.WidgetCount));
		}
	}
}

public class DictionaryStringAudioData
{
	public DictionaryStringAudioData()
	{
		this.keys = new string[1024];
		for (int i = 0; i < 1024; i++) {
			this.keys[i] = null;
		}
		this.values = new AudioData[1024];
		for (int i = 0; i < 1024; i++) {
			this.values[i] = null;
		}
	}

	internal bool Contains(string key)
	{
		int id = this.GetId(key);
		return id != -1;
	}

	internal AudioData GetById(int id)
	{
		return this.values[id];
	}

	internal int GetId(string key)
	{
		for (int i = 0; i < 1024; i++) {
			if (this.keys[i] == key) {
				return i;
			}
		}
		return -1;
	}

	internal int Set(string key, AudioData bmp)
	{
		int id = this.GetId(key);
		if (id != -1) {
			this.values[id] = bmp;
			return id;
		}
		for (int i = 0; i < 1024; i++) {
			if (this.keys[i] == null) {
				this.keys[i] = key;
				this.values[i] = bmp;
				return i;
			}
		}
		return -1;
	}
	internal string[] keys;
	internal AudioData[] values;
}

public class DictionaryStringAudioSample
{
	public DictionaryStringAudioSample()
	{
		this.max = 1024;
		this.count = 0;
		this.keys = new string[this.max];
		this.values = new AudioSampleCi[this.max];
	}

	public bool Contains(string key)
	{
		int index = this.GetIndex(key);
		return index != -1;
	}

	public AudioSampleCi Get(string key)
	{
		int index = this.GetIndex(key);
		return this.values[index];
	}

	public int GetIndex(string key)
	{
		for (int i = 0; i < this.count; i++) {
			if (this.keys[i] == key) {
				return i;
			}
		}
		return -1;
	}

	public void Set(string key, AudioSampleCi value)
	{
		int index = this.GetIndex(key);
		if (index != -1) {
			this.values[index] = value;
			return;
		}
		this.keys[this.count] = key;
		this.values[this.count] = value;
		this.count++;
	}
	int count;
	string[] keys;
	int max;
	AudioSampleCi[] values;
}

internal class DictionaryStringByteArray
{
	public DictionaryStringByteArray()
	{
		this.items = new StringByteArray[1024];
		this.itemsCount = 1024;
	}

	internal byte[] Get(string name)
	{
		for (int i = 0; i < this.itemsCount; i++) {
			if (this.items[i] == null) {
				continue;
			}
			if (Game.StringEquals(this.items[i].name, name)) {
				return this.items[i].data;
			}
		}
		return null;
	}

	internal void Set(string name, byte[] value)
	{
		for (int i = 0; i < this.itemsCount; i++) {
			if (this.items[i] == null) {
				continue;
			}
			if (Game.StringEquals(this.items[i].name, name)) {
				this.items[i].data = value;
				return;
			}
		}
		for (int i = 0; i < this.itemsCount; i++) {
			if (this.items[i] == null) {
				this.items[i] = new StringByteArray();
				this.items[i].name = name;
				this.items[i].data = value;
				return;
			}
		}
	}
	internal StringByteArray[] items;
	internal int itemsCount;
}

public class DictionaryStringInt1024
{
	public DictionaryStringInt1024()
	{
		this.items = new KeyValueStringInt[1024];
		this.count = 0;
	}

	/// <summary>&lt;summary&gt;
	/// Check if the dictionary contains the specified key.</summary>
	/// <remarks>This method is case-sensitive.
	/// &lt;/summary&gt;
	/// &lt;param name="key"&gt;Key&lt;/param&gt;
	/// &lt;returns&gt;&lt;b&gt;true&lt;/b&gt; if key is found&lt;/returns&gt;</remarks>
	internal bool Contains(string key)
	{
		for (int i = 0; i < this.count; i++) {
			if (this.items[i] == null) {
				continue;
			}
			if (Game.StringEquals(this.items[i].key, key)) {
				return true;
			}
		}
		return false;
	}

	/// <summary>&lt;summary&gt;
	/// Get the specified key.</summary>
	/// <remarks>This method is case-sensitive.
	/// &lt;/summary&gt;
	/// &lt;param name="key"&gt;Key&lt;/param&gt;
	/// &lt;returns&gt;&lt;b&gt;Stored value&lt;/b&gt; when key is found in collection, &lt;b&gt;-1&lt;/b&gt; otherwise.&lt;/returns&gt;</remarks>
	internal int Get(string key)
	{
		for (int i = 0; i < this.count; i++) {
			if (this.items[i] == null) {
				continue;
			}
			if (Game.StringEquals(this.items[i].key, key)) {
				return this.items[i].value;
			}
		}
		return -1;
	}

	/// <summary>&lt;summary&gt;
	/// Remove the specified key.</summary>
	/// <remarks>This method is case-sensitive.
	/// &lt;/summary&gt;
	/// &lt;param name="key"&gt;Key&lt;/param&gt;
	/// &lt;returns&gt;&lt;b&gt;true&lt;/b&gt; if key is found in collection, &lt;b&gt;false&lt;/b&gt; otherwise.&lt;/returns&gt;</remarks>
	public bool Remove(string key)
	{
		for (int i = 0; i < this.count; i++) {
			if (this.items[i] == null) {
				continue;
			}
			if (Game.StringEquals(this.items[i].key, key)) {
				this.items[i] = null;
				return true;
			}
		}
		return false;
	}

	/// <summary>&lt;summary&gt;
	/// Set the specified key to the specified value.</summary>
	/// <remarks>&lt;/summary&gt;
	/// &lt;param name="key"&gt;Key&lt;/param&gt;
	/// &lt;param name="value"&gt;Value to set&lt;/param&gt;</remarks>
	public void Set(string key, int value)
	{
		for (int i = 0; i < this.count; i++) {
			if (this.items[i] == null) {
				continue;
			}
			if (this.items[i].key == key) {
				this.items[i].value = value;
				return;
			}
		}
		for (int i = 0; i < this.count; i++) {
			if (this.items[i] == null) {
				this.items[i] = new KeyValueStringInt();
				this.items[i].key = key;
				this.items[i].value = value;
				return;
			}
		}
		KeyValueStringInt k = new KeyValueStringInt();
		k.key = key;
		k.value = value;
		this.items[this.count++] = k;
	}
	internal int count;
	internal KeyValueStringInt[] items;
}

public class DictionaryStringString
{
	public DictionaryStringString()
	{
		this.Start(64);
	}

	internal bool ContainsKey(string key)
	{
		for (int i = 0; i < this.count; i++) {
			if (this.items[i] == null) {
				continue;
			}
			if (Game.StringEquals(this.items[i].key, key)) {
				return true;
			}
		}
		return false;
	}

	internal string Get(string key)
	{
		for (int i = 0; i < this.count; i++) {
			if (this.items[i] == null) {
				continue;
			}
			if (Game.StringEquals(this.items[i].key, key)) {
				return this.items[i].value;
			}
		}
		return null;
	}

	internal void Remove(string key)
	{
		for (int i = 0; i < this.count; i++) {
			if (this.items[i] == null) {
				continue;
			}
			if (Game.StringEquals(this.items[i].key, key)) {
				this.items[i] = null;
			}
		}
	}

	public void Set(string key, string value)
	{
		for (int i = 0; i < this.count; i++) {
			if (this.items[i] == null) {
				continue;
			}
			if (Game.StringEquals(this.items[i].key, key)) {
				this.items[i].value = value;
				return;
			}
		}
		for (int i = 0; i < this.count; i++) {
			if (this.items[i] == null) {
				this.items[i] = new KeyValueStringString();
				this.items[i].key = key;
				this.items[i].value = value;
				return;
			}
		}
	}

	public void Start(int count_)
	{
		this.items = new KeyValueStringString[count_];
		this.count = count_;
	}
	internal int count;
	internal KeyValueStringString[] items;
}

public class DictionaryVector3Float
{
	public DictionaryVector3Float()
	{
		this.itemsCount = 16384;
		this.items = new Vector3Float[this.itemsCount];
	}

	internal void Clear()
	{
		for (int i = 0; i < this.itemsCount; i++) {
			this.items[i] = null;
		}
	}

	internal bool ContainsKey(int x, int y, int z)
	{
		return this.ItemIndex(x, y, z) != -1;
	}

	internal int Count()
	{
		int count = 0;
		for (int i = 0; i < this.itemsCount; i++) {
			if (this.items[i] != null) {
				count++;
			}
		}
		return count;
	}

	internal float Get(int x, int y, int z)
	{
		return this.items[this.ItemIndex(x, y, z)].value;
	}

	int ItemIndex(int x, int y, int z)
	{
		for (int i = 0; i < this.itemsCount; i++) {
			if (this.items[i] == null) {
				continue;
			}
			Vector3Float item = this.items[i];
			if (item.x == x && item.y == y && item.z == z) {
				return i;
			}
		}
		return -1;
	}

	internal void Remove(int x, int y, int z)
	{
		if (this.ItemIndex(x, y, z) == -1) {
			return;
		}
		this.items[this.ItemIndex(x, y, z)] = null;
	}

	internal void Set(int x, int y, int z, float value)
	{
		int index = this.ItemIndex(x, y, z);
		if (index != -1) {
			this.items[index].value = value;
		}
		else {
			for (int i = 0; i < this.itemsCount; i++) {
				if (this.items[i] == null) {
					Vector3Float item = new Vector3Float();
					item.x = x;
					item.y = y;
					item.z = z;
					item.value = value;
					this.items[i] = item;
					return;
				}
			}
		}
	}
	internal Vector3Float[] items;
	internal int itemsCount;
}

public class DirectionUtils
{

	/// <summary>&lt;summary&gt;
	/// Enter at TileEnterDirection.Left -&gt; yields VehicleDirection12.UpLeftUp,
	/// VehicleDirection12.HorizontalRight,
	/// VehicleDirection12.DownLeftDown
	/// &lt;/summary&gt;
	/// &lt;param name="enter_at"&gt;&lt;/param&gt;
	/// &lt;returns&gt;&lt;/returns&gt;</summary>
	public static VehicleDirection12[] PossibleNewRails3(TileEnterDirection enter_at)
	{
		VehicleDirection12[] ret = new VehicleDirection12[3];
		switch (enter_at) {
		case TileEnterDirection.Left:
			ret[0] = VehicleDirection12.UpLeftUp;
			ret[1] = VehicleDirection12.HorizontalRight;
			ret[2] = VehicleDirection12.DownLeftDown;
			break;
		case TileEnterDirection.Down:
			ret[0] = VehicleDirection12.DownLeftLeft;
			ret[1] = VehicleDirection12.VerticalUp;
			ret[2] = VehicleDirection12.DownRightRight;
			break;
		case TileEnterDirection.Up:
			ret[0] = VehicleDirection12.UpLeftLeft;
			ret[1] = VehicleDirection12.VerticalDown;
			ret[2] = VehicleDirection12.UpRightRight;
			break;
		case TileEnterDirection.Right:
			ret[0] = VehicleDirection12.UpRightUp;
			ret[1] = VehicleDirection12.HorizontalLeft;
			ret[2] = VehicleDirection12.DownRightDown;
			break;
		default:
			return null;
		}
		return ret;
	}

	public static int RailDirectionFlagsCount(int railDirectionFlags)
	{
		int count = 0;
		if ((railDirectionFlags & DirectionUtils.ToRailDirectionFlags(RailDirection.DownLeft)) != 0) {
			count++;
		}
		if ((railDirectionFlags & DirectionUtils.ToRailDirectionFlags(RailDirection.DownRight)) != 0) {
			count++;
		}
		if ((railDirectionFlags & DirectionUtils.ToRailDirectionFlags(RailDirection.Horizontal)) != 0) {
			count++;
		}
		if ((railDirectionFlags & DirectionUtils.ToRailDirectionFlags(RailDirection.UpLeft)) != 0) {
			count++;
		}
		if ((railDirectionFlags & DirectionUtils.ToRailDirectionFlags(RailDirection.UpRight)) != 0) {
			count++;
		}
		if ((railDirectionFlags & DirectionUtils.ToRailDirectionFlags(RailDirection.Vertical)) != 0) {
			count++;
		}
		return count;
	}

	public static TileEnterDirection ResultEnter(TileExitDirection direction)
	{
		switch (direction) {
		case TileExitDirection.Up:
			return TileEnterDirection.Down;
		case TileExitDirection.Down:
			return TileEnterDirection.Up;
		case TileExitDirection.Left:
			return TileEnterDirection.Right;
		case TileExitDirection.Right:
			return TileEnterDirection.Left;
		default:
			return TileEnterDirection.Down;
		}
	}

	/// <summary>&lt;summary&gt;
	/// VehicleDirection12.UpRightRight -&gt; returns Direction4.Right
	/// &lt;/summary&gt;
	/// &lt;param name="direction"&gt;&lt;/param&gt;
	/// &lt;returns&gt;&lt;/returns&gt;</summary>
	public static TileExitDirection ResultExit(VehicleDirection12 direction)
	{
		switch (direction) {
		case VehicleDirection12.HorizontalLeft:
			return TileExitDirection.Left;
		case VehicleDirection12.HorizontalRight:
			return TileExitDirection.Right;
		case VehicleDirection12.VerticalUp:
			return TileExitDirection.Up;
		case VehicleDirection12.VerticalDown:
			return TileExitDirection.Down;
		case VehicleDirection12.UpLeftUp:
			return TileExitDirection.Up;
		case VehicleDirection12.UpLeftLeft:
			return TileExitDirection.Left;
		case VehicleDirection12.UpRightUp:
			return TileExitDirection.Up;
		case VehicleDirection12.UpRightRight:
			return TileExitDirection.Right;
		case VehicleDirection12.DownLeftDown:
			return TileExitDirection.Down;
		case VehicleDirection12.DownLeftLeft:
			return TileExitDirection.Left;
		case VehicleDirection12.DownRightDown:
			return TileExitDirection.Down;
		case VehicleDirection12.DownRightRight:
			return TileExitDirection.Right;
		default:
			return TileExitDirection.Down;
		}
	}

	public static VehicleDirection12 Reverse(VehicleDirection12 direction)
	{
		switch (direction) {
		case VehicleDirection12.HorizontalLeft:
			return VehicleDirection12.HorizontalRight;
		case VehicleDirection12.HorizontalRight:
			return VehicleDirection12.HorizontalLeft;
		case VehicleDirection12.VerticalUp:
			return VehicleDirection12.VerticalDown;
		case VehicleDirection12.VerticalDown:
			return VehicleDirection12.VerticalUp;
		case VehicleDirection12.UpLeftUp:
			return VehicleDirection12.UpLeftLeft;
		case VehicleDirection12.UpLeftLeft:
			return VehicleDirection12.UpLeftUp;
		case VehicleDirection12.UpRightUp:
			return VehicleDirection12.UpRightRight;
		case VehicleDirection12.UpRightRight:
			return VehicleDirection12.UpRightUp;
		case VehicleDirection12.DownLeftDown:
			return VehicleDirection12.DownLeftLeft;
		case VehicleDirection12.DownLeftLeft:
			return VehicleDirection12.DownLeftDown;
		case VehicleDirection12.DownRightDown:
			return VehicleDirection12.DownRightRight;
		case VehicleDirection12.DownRightRight:
			return VehicleDirection12.DownRightDown;
		default:
			return VehicleDirection12.DownLeftDown;
		}
	}

	public static RailDirection ToRailDirection(VehicleDirection12 direction)
	{
		switch (direction) {
		case VehicleDirection12.HorizontalLeft:
			return RailDirection.Horizontal;
		case VehicleDirection12.HorizontalRight:
			return RailDirection.Horizontal;
		case VehicleDirection12.VerticalUp:
			return RailDirection.Vertical;
		case VehicleDirection12.VerticalDown:
			return RailDirection.Vertical;
		case VehicleDirection12.UpLeftUp:
			return RailDirection.UpLeft;
		case VehicleDirection12.UpLeftLeft:
			return RailDirection.UpLeft;
		case VehicleDirection12.UpRightUp:
			return RailDirection.UpRight;
		case VehicleDirection12.UpRightRight:
			return RailDirection.UpRight;
		case VehicleDirection12.DownLeftDown:
			return RailDirection.DownLeft;
		case VehicleDirection12.DownLeftLeft:
			return RailDirection.DownLeft;
		case VehicleDirection12.DownRightDown:
			return RailDirection.DownRight;
		case VehicleDirection12.DownRightRight:
			return RailDirection.DownRight;
		default:
			return RailDirection.DownLeft;
		}
	}

	public static int ToRailDirectionFlags(RailDirection direction)
	{
		switch (direction) {
		case RailDirection.DownLeft:
			return 16;
		case RailDirection.DownRight:
			return 32;
		case RailDirection.Horizontal:
			return 1;
		case RailDirection.UpLeft:
			return 4;
		case RailDirection.UpRight:
			return 8;
		case RailDirection.Vertical:
			return 2;
		default:
			return 0;
		}
	}

	public static int ToVehicleDirection12Flags(VehicleDirection12 direction)
	{
		switch (direction) {
		case VehicleDirection12.HorizontalLeft:
			return 1;
		case VehicleDirection12.HorizontalRight:
			return 2;
		case VehicleDirection12.VerticalUp:
			return 4;
		case VehicleDirection12.VerticalDown:
			return 8;
		case VehicleDirection12.UpLeftUp:
			return 16;
		case VehicleDirection12.UpLeftLeft:
			return 32;
		case VehicleDirection12.UpRightUp:
			return 64;
		case VehicleDirection12.UpRightRight:
			return 128;
		case VehicleDirection12.DownLeftDown:
			return 256;
		case VehicleDirection12.DownLeftLeft:
			return 512;
		case VehicleDirection12.DownRightDown:
			return 1024;
		case VehicleDirection12.DownRightRight:
			return 2048;
		default:
			return 0;
		}
	}

	public static int ToVehicleDirection12Flags_(VehicleDirection12[] directions, int directionsCount)
	{
		int flags = 0;
		for (int i = 0; i < directionsCount; i++) {
			VehicleDirection12 d = directions[i];
			flags = flags | DirectionUtils.ToVehicleDirection12Flags(d);
		}
		return flags;
	}
}

public class DisplayResolutionCi
{
	internal int BitsPerPixel;

	public int GetBitsPerPixel()
	{
		return this.BitsPerPixel;
	}

	public int GetHeight()
	{
		return this.Height;
	}

	public float GetRefreshRate()
	{
		return this.RefreshRate;
	}

	public int GetWidth()
	{
		return this.Width;
	}
	internal int Height;
	internal float RefreshRate;

	public void SetBitsPerPixel(int value)
	{
		this.BitsPerPixel = value;
	}

	public void SetHeight(int value)
	{
		this.Height = value;
	}

	public void SetRefreshRate(float value)
	{
		this.RefreshRate = value;
	}

	public void SetWidth(int value)
	{
		this.Width = value;
	}
	internal int Width;
}

public class Draw2dData
{
	internal int color;
	internal float height;
	internal IntRef inAtlasId;
	internal float width;
	internal float x1;
	internal float y1;
}

public class DrawModeEnum
{
	public const int Lines = 1;
	public const int Triangles = 0;
}

public class DrawName
{
	internal bool ClientAutoComplete;
	internal bool DrawHealth;
	internal float Health;
	internal string Name;
	internal bool OnlyWhenSelected;
	internal float TextX;
	internal float TextY;
	internal float TextZ;
}

public class DrawWireframeCube
{
	public DrawWireframeCube()
	{
		this.one = 1;
	}

	public void DrawWireframeCube_(Game game, float posx, float posy, float posz, float scalex, float scaley, float scalez)
	{
		game.platform.GLLineWidth(2);
		game.platform.BindTexture2d(0);
		if (this.wireframeCube == null) {
			ModelData data = WireframeCube.Get();
			this.wireframeCube = game.platform.CreateModel(data);
		}
		game.GLPushMatrix();
		game.GLTranslate(posx, posy, posz);
		float half = this.one / 2;
		game.GLScale(scalex * half, scaley * half, scalez * half);
		game.DrawModel(this.wireframeCube);
		game.GLPopMatrix();
	}
	float one;
	Model wireframeCube;
}

public class DummyIpEndPoint : IPEndPointCi
{

	public override string AddressToString()
	{
		return "127.0.0.1";
	}
}

public class DummyNetClient : NetClient
{

	public override NetConnection Connect(string ip, int port)
	{
		return new DummyNetConnection();
	}

	public override NetIncomingMessage ReadMessage()
	{
		NetIncomingMessage msg = null;
		this.platform.MonitorEnter(this.network.ClientReceiveBufferLock);
		{
			if (this.network.ClientReceiveBuffer.Count() > 0) {
				msg = new NetIncomingMessage();
				ByteArray b = this.network.ClientReceiveBuffer.Dequeue();
				msg.message = b.data;
				msg.messageLength = b.length;
			}
		}
		this.platform.MonitorExit(this.network.ClientReceiveBufferLock);
		return msg;
	}

	public override void SendMessage(INetOutgoingMessage message, MyNetDeliveryMethod method)
	{
		this.platform.MonitorEnter(this.network.ServerReceiveBufferLock);
		{
			INetOutgoingMessage msg = message;
			ByteArray b = new ByteArray();
			b.data = msg.message;
			b.length = msg.messageLength;
			this.network.ServerReceiveBuffer.Enqueue(b);
		}
		this.platform.MonitorExit(this.network.ServerReceiveBufferLock);
	}

	public void SetNetwork(DummyNetwork network_)
	{
		this.network = network_;
	}

	public void SetPlatform(GamePlatform gamePlatform)
	{
		this.platform = gamePlatform;
	}

	public override void Start()
	{
	}
	internal DummyNetwork network;
	internal GamePlatform platform;
}

public class DummyNetConnection : NetConnection
{

	public override bool EqualsConnection(NetConnection connection)
	{
		return true;
	}

	public override IPEndPointCi RemoteEndPoint()
	{
		return new DummyIpEndPoint();
	}

	public override void SendMessage(INetOutgoingMessage msg, MyNetDeliveryMethod method, int sequenceChannel)
	{
		this.platform.MonitorEnter(this.network.ClientReceiveBufferLock);
		{
			INetOutgoingMessage msg2 = msg;
			ByteArray b = new ByteArray();
			b.data = msg2.message;
			b.length = msg2.messageLength;
			this.network.ClientReceiveBuffer.Enqueue(b);
		}
		this.platform.MonitorExit(this.network.ClientReceiveBufferLock);
	}

	public override void Update()
	{
	}
	internal DummyNetwork network;
	internal GamePlatform platform;
}

public class DummyNetOutgoingMessage : INetOutgoingMessage
{
}

public class DummyNetServer : NetServer
{
	public DummyNetServer()
	{
		this.connectedClient = new DummyNetConnection();
	}

	public override NetIncomingMessage ReadMessage()
	{
		this.connectedClient.network = this.network;
		this.connectedClient.platform = this.platform;
		NetIncomingMessage msg = null;
		this.platform.MonitorEnter(this.network.ServerReceiveBufferLock);
		{
			if (this.network.ServerReceiveBuffer.Count() > 0) {
				if (!this.receivedAnyMessage) {
					this.receivedAnyMessage = true;
					msg = new NetIncomingMessage();
					msg.Type = NetworkMessageType.Connect;
					msg.SenderConnection = this.connectedClient;
				}
				else {
					msg = new NetIncomingMessage();
					ByteArray b = this.network.ServerReceiveBuffer.Dequeue();
					msg.message = b.data;
					msg.messageLength = b.length;
					msg.SenderConnection = this.connectedClient;
				}
			}
		}
		this.platform.MonitorExit(this.network.ServerReceiveBufferLock);
		return msg;
	}

	public void SetNetwork(DummyNetwork dummyNetwork)
	{
		this.network = dummyNetwork;
	}

	public void SetPlatform(GamePlatform gamePlatform)
	{
		this.platform = gamePlatform;
	}

	public override void SetPort(int port)
	{
	}

	public override void Start()
	{
	}
	DummyNetConnection connectedClient;
	internal DummyNetwork network;
	internal GamePlatform platform;
	bool receivedAnyMessage;
}

public class DummyNetwork
{
	public DummyNetwork()
	{
		this.Clear();
	}

	public void Clear()
	{
		this.ServerReceiveBuffer = new QueueByteArray();
		this.ClientReceiveBuffer = new QueueByteArray();
	}
	internal QueueByteArray ClientReceiveBuffer;
	internal MonitorObject ClientReceiveBufferLock;
	internal QueueByteArray ServerReceiveBuffer;
	internal MonitorObject ServerReceiveBufferLock;

	public void Start(MonitorObject lock1, MonitorObject lock2)
	{
		this.ServerReceiveBufferLock = lock1;
		this.ClientReceiveBufferLock = lock2;
	}
}

public abstract class EnetEvent
{

	public abstract EnetPacket Packet();

	public abstract EnetPeer Peer();

	public abstract EnetEventType Type();
}

public class EnetEventRef
{
	internal EnetEvent e;
}

public enum EnetEventType
{
	None,
	Connect,
	Disconnect,
	Receive
}

public class EnetHost
{
}

public class EnetNetClient : NetClient
{

	public override NetConnection Connect(string ip, int port)
	{
		this.peer = this.platform.EnetHostConnect(this.host, ip, port, 1234, 200);
		this.connected = true;
		return null;
	}

	void DoSendPacket(INetOutgoingMessage msg)
	{
		INetOutgoingMessage msg1 = msg;
		this.platform.EnetPeerSend(this.peer, 0, msg1.message, msg1.messageLength, 1);
	}

	public override NetIncomingMessage ReadMessage()
	{
		if (!this.connected) {
			return null;
		}
		if (this.messages.Count() > 0) {
			return this.messages.Dequeue();
		}
		if (this.connected2) {
			while (this.tosend.Count() > 0) {
				INetOutgoingMessage msg = this.tosend.Dequeue();
				this.DoSendPacket(msg);
			}
		}
		EnetEventRef event_ = new EnetEventRef();
		if (this.platform.EnetHostService(this.host, 0, event_)) {
			do {
				switch (event_.e.Type()) {
				case EnetEventType.Connect:
					this.connected2 = true;
					break;
				case EnetEventType.Receive:
					byte[] data = event_.e.Packet().GetBytes();
					int dataLength = event_.e.Packet().GetBytesCount();
					event_.e.Packet().Dispose();
					NetIncomingMessage msg = new NetIncomingMessage();
					msg.message = data;
					msg.messageLength = dataLength;
					this.messages.Enqueue(msg);
					break;
				}
			}
			while (this.platform.EnetHostCheckEvents(this.host, event_));
		}
		if (this.messages.Count() > 0) {
			return this.messages.Dequeue();
		}
		return null;
	}

	public override void SendMessage(INetOutgoingMessage message, MyNetDeliveryMethod method)
	{
		INetOutgoingMessage msg = message;
		if (!this.connected2) {
			this.tosend.Enqueue(msg);
			return;
		}
		this.DoSendPacket(msg);
	}

	public void SetPlatform(GamePlatform platform_)
	{
		this.platform = platform_;
	}

	public override void Start()
	{
		this.host = this.platform.EnetCreateHost();
		this.platform.EnetHostInitialize(this.host, null, 1, 0, 0, 0);
		this.tosend = new QueueINetOutgoingMessage();
		this.messages = new QueueNetIncomingMessage();
	}
	bool connected;
	bool connected2;
	EnetHost host;
	QueueNetIncomingMessage messages;
	EnetPeer peer;
	internal GamePlatform platform;
	QueueINetOutgoingMessage tosend;
}

public class EnetNetConnection : NetConnection
{

	public override bool EqualsConnection(NetConnection connection)
	{
		return this.peer.UserData() == this.platform.CastToEnetNetConnection(connection).peer.UserData();
	}

	public override IPEndPointCi RemoteEndPoint()
	{
		return IPEndPointCiDefault.Create(this.peer.GetRemoteAddress().AddressToString());
	}

	public override void SendMessage(INetOutgoingMessage msg, MyNetDeliveryMethod method, int sequenceChannel)
	{
		INetOutgoingMessage msg1 = msg;
		this.platform.EnetPeerSend(this.peer, 0, msg1.message, msg1.messageLength, 1);
	}

	public override void Update()
	{
	}
	internal EnetPeer peer;
	internal GamePlatform platform;
}

public class EnetNetServer : NetServer
{
	public EnetNetServer()
	{
		this.event_ = new EnetEventRef();
		this.messages = new QueueNetIncomingMessage();
	}
	int Port;

	public override NetIncomingMessage ReadMessage()
	{
		if (this.messages.Count() > 0) {
			return this.messages.Dequeue();
		}
		if (this.platform.EnetHostService(this.host, 0, this.event_)) {
			do {
				switch (this.event_.e.Type()) {
				case EnetEventType.Connect:
					{
						EnetPeer peer = this.event_.e.Peer();
						peer.SetUserData(this.clientid++);
						EnetNetConnection senderConnectionConnect = new EnetNetConnection();
						senderConnectionConnect.platform = this.platform;
						senderConnectionConnect.peer = this.event_.e.Peer();
						NetIncomingMessage message = new NetIncomingMessage();
						message.SenderConnection = senderConnectionConnect;
						message.Type = NetworkMessageType.Connect;
						this.messages.Enqueue(message);
					}
					break;
				case EnetEventType.Receive:
					{
						byte[] data = this.event_.e.Packet().GetBytes();
						this.event_.e.Packet().Dispose();
						EnetNetConnection senderConnectionReceive = new EnetNetConnection();
						senderConnectionReceive.platform = this.platform;
						senderConnectionReceive.peer = this.event_.e.Peer();
						NetIncomingMessage message = new NetIncomingMessage();
						message.SenderConnection = senderConnectionReceive;
						message.message = data;
						message.Type = NetworkMessageType.Data;
						this.messages.Enqueue(message);
					}
					break;
				case EnetEventType.Disconnect:
					{
						EnetNetConnection senderConnectionDisconnect = new EnetNetConnection();
						senderConnectionDisconnect.platform = this.platform;
						senderConnectionDisconnect.peer = this.event_.e.Peer();
						NetIncomingMessage message = new NetIncomingMessage();
						message.SenderConnection = senderConnectionDisconnect;
						message.Type = NetworkMessageType.Disconnect;
						this.messages.Enqueue(message);
					}
					break;
				}
			}
			while (this.platform.EnetHostCheckEvents(this.host, this.event_));
		}
		if (this.messages.Count() > 0) {
			return this.messages.Dequeue();
		}
		return null;
	}

	public override void SetPort(int port)
	{
		this.Port = port;
	}

	public override void Start()
	{
		this.host = this.platform.EnetCreateHost();
		this.platform.EnetHostInitializeServer(this.host, this.Port, 256);
	}
	int clientid;
	EnetEventRef event_;
	EnetHost host;
	QueueNetIncomingMessage messages;
	internal GamePlatform platform;
}

public abstract class EnetPacket
{

	public abstract void Dispose();

	public abstract byte[] GetBytes();

	public abstract int GetBytesCount();
}

public class EnetPacketFlags
{
	public const int NoAllocate = 4;
	public const int None = 0;
	public const int Reliable = 1;
	public const int UnreliableFragment = 8;
	public const int Unsequenced = 2;
}

public abstract class EnetPeer
{

	public abstract IPEndPointCi GetRemoteAddress();

	public abstract void SetUserData(int value);

	public abstract int UserData();
}

public class Entity
{
	public Entity()
	{
		this.scripts = new EntityScript[8];
		this.scriptsCount = 0;
	}
	internal Bullet_ bullet;
	internal EntityDrawArea drawArea;
	internal EntityDrawModel drawModel;
	internal DrawName drawName;
	internal EntityDrawText drawText;
	internal Expires expires;
	internal Grenade_ grenade;
	internal Minecart minecart;
	internal EntityPosition_ networkPosition;
	internal PlayerDrawInfo playerDrawInfo;
	internal Packet_ServerPlayerStats playerStats;
	internal EntityPosition_ position;
	internal Packet_ServerExplosion push;
	internal EntityScript[] scripts;
	internal int scriptsCount;
	internal Sprite sprite;
	internal bool usable;
}

public class EntityDrawArea
{
	internal int sizex;
	internal int sizey;
	internal int sizez;
	internal bool visible;
	internal int x;
	internal int y;
	internal int z;
}

public class EntityDrawModel
{
	public EntityDrawModel()
	{
		this.CurrentTexture = -1;
	}
	internal int CurrentTexture;
	internal bool DownloadSkin;
	internal float ModelHeight;
	internal string Model_;
	internal HttpResponseCi SkinDownloadResponse;
	internal string Texture_;
	internal float eyeHeight;
	internal AnimatedModelRenderer renderer;
}

public class EntityDrawText
{
	internal float dx;
	internal float dy;
	internal float dz;
	internal float rotx;
	internal float roty;
	internal float rotz;
	internal string text;
}

public class EntityPosition_
{
	internal int LastUpdateMilliseconds;
	internal bool PositionLoaded;
	internal float rotx;
	internal float roty;
	internal float rotz;
	internal float x;
	internal float y;
	internal float z;
}

public abstract class EntityScript
{

	public virtual void OnNewFrameFixed(Game game, int entity, float dt)
	{
	}
}

public enum EscapeMenuState
{
	Main,
	Options,
	Graphics,
	Keys,
	Other
}

public class Expires
{

	internal static Expires Create(float p)
	{
		Expires expires = new Expires();
		expires.totalTime = p;
		expires.timeLeft = p;
		return expires;
	}
	internal float timeLeft;
	internal float totalTime;
}

public class FastQueueInt
{

	public void Clear()
	{
		this.Count = 0;
	}
	internal int Count;

	public void Initialize(int maxCount)
	{
		this.maxCount = maxCount;
		this.values = new int[maxCount];
		this.Count = 0;
		this.start = 0;
		this.end = 0;
	}

	public int Pop()
	{
		int value = this.values[this.start];
		this.Count--;
		this.start++;
		if (this.start >= this.maxCount) {
			this.start = 0;
		}
		return value;
	}

	public void Push(int value)
	{
		this.values[this.end] = value;
		this.Count++;
		this.end++;
		if (this.end >= this.maxCount) {
			this.end = 0;
		}
	}
	int end;
	int maxCount;
	int start;
	int[] values;
}

public class FastStackInt
{

	public void Clear()
	{
		this.count = 0;
	}

	internal int Count_()
	{
		return this.count;
	}

	public void Initialize(int maxCount)
	{
		this.valuesLength = maxCount;
		this.values = new int[maxCount];
	}

	public int Pop()
	{
		this.count--;
		return this.values[this.count];
	}

	public void Push(int value)
	{
		while (this.count >= this.valuesLength) {
			int[] values2 = new int[this.valuesLength * 2];
			for (int i = 0; i < this.valuesLength; i++) {
				values2[i] = this.values[i];
			}
			this.values = values2;
			this.valuesLength = this.valuesLength * 2;
		}
		this.values[this.count] = value;
		this.count++;
	}
	internal int count;
	int[] values;
	int valuesLength;
}

public class FloatRef
{

	public static FloatRef Create(float value_)
	{
		FloatRef f = new FloatRef();
		f.value = value_;
		return f;
	}

	public float GetValue()
	{
		return this.value;
	}

	public void SetValue(float value_)
	{
		this.value = value_;
	}
	internal float value;
}

public class FontCi
{

	internal static FontCi Create(string family_, float size_, int style_)
	{
		FontCi f = new FontCi();
		f.family = family_;
		f.size = size_;
		f.style = style_;
		return f;
	}
	internal string family;
	internal float size;
	internal int style;
}

public enum FontType
{
	Nice,
	Simple,
	BlackBackground,
	Default
}

public class FreemoveLevelEnum
{
	public const int Freemove = 1;
	public const int Noclip = 2;
	public const int None = 0;
}

public class FrustumCulling
{

	/// <summary>&lt;summary&gt;
	/// Calculating the frustum planes.</summary>
	/// <remarks>&lt;/summary&gt;
	/// &lt;remarks&gt;
	/// From the current OpenGL modelview and projection matrices,
	/// calculate the frustum plane equations (Ax+By+Cz+D=0, n=(A,B,C))
	/// The equations can then be used to see on which side points are.
	/// &lt;/remarks&gt;</remarks>
	public void CalcFrustumEquations()
	{
		float t;
		float[] matModelView = this.d_GetCameraMatrix.GetModelViewMatrix();
		float[] matProjection = this.d_GetCameraMatrix.GetProjectionMatrix();
		float[] matFrustum = Mat4.Create();
		Mat4.Multiply(matFrustum, matProjection, matModelView);
		{
			float[] clip1 = matFrustum;
			{
				this.frustum00 = clip1[3] - clip1[0];
				this.frustum01 = clip1[7] - clip1[4];
				this.frustum02 = clip1[11] - clip1[8];
				this.frustum03 = clip1[15] - clip1[12];
				t = this.platform.MathSqrt(this.frustum00 * this.frustum00 + this.frustum01 * this.frustum01 + this.frustum02 * this.frustum02);
				this.frustum00 /= t;
				this.frustum01 /= t;
				this.frustum02 /= t;
				this.frustum03 /= t;
				this.frustum10 = clip1[3] + clip1[0];
				this.frustum11 = clip1[7] + clip1[4];
				this.frustum12 = clip1[11] + clip1[8];
				this.frustum13 = clip1[15] + clip1[12];
				t = this.platform.MathSqrt(this.frustum10 * this.frustum10 + this.frustum11 * this.frustum11 + this.frustum12 * this.frustum12);
				this.frustum10 /= t;
				this.frustum11 /= t;
				this.frustum12 /= t;
				this.frustum13 /= t;
				this.frustum20 = clip1[3] + clip1[1];
				this.frustum21 = clip1[7] + clip1[5];
				this.frustum22 = clip1[11] + clip1[9];
				this.frustum23 = clip1[15] + clip1[13];
				t = this.platform.MathSqrt(this.frustum20 * this.frustum20 + this.frustum21 * this.frustum21 + this.frustum22 * this.frustum22);
				this.frustum20 /= t;
				this.frustum21 /= t;
				this.frustum22 /= t;
				this.frustum23 /= t;
				this.frustum30 = clip1[3] - clip1[1];
				this.frustum31 = clip1[7] - clip1[5];
				this.frustum32 = clip1[11] - clip1[9];
				this.frustum33 = clip1[15] - clip1[13];
				t = this.platform.MathSqrt(this.frustum30 * this.frustum30 + this.frustum31 * this.frustum31 + this.frustum32 * this.frustum32);
				this.frustum30 /= t;
				this.frustum31 /= t;
				this.frustum32 /= t;
				this.frustum33 /= t;
				this.frustum40 = clip1[3] - clip1[2];
				this.frustum41 = clip1[7] - clip1[6];
				this.frustum42 = clip1[11] - clip1[10];
				this.frustum43 = clip1[15] - clip1[14];
				t = this.platform.MathSqrt(this.frustum40 * this.frustum40 + this.frustum41 * this.frustum41 + this.frustum42 * this.frustum42);
				this.frustum40 /= t;
				this.frustum41 /= t;
				this.frustum42 /= t;
				this.frustum43 /= t;
				this.frustum50 = clip1[3] + clip1[2];
				this.frustum51 = clip1[7] + clip1[6];
				this.frustum52 = clip1[11] + clip1[10];
				this.frustum53 = clip1[15] + clip1[14];
				t = this.platform.MathSqrt(this.frustum50 * this.frustum50 + this.frustum51 * this.frustum51 + this.frustum52 * this.frustum52);
				this.frustum50 /= t;
				this.frustum51 /= t;
				this.frustum52 /= t;
				this.frustum53 /= t;
			}
		}
	}

	public bool SphereInFrustum(float x, float y, float z, float radius)
	{
		float d = 0;
		d = this.frustum00 * x + this.frustum01 * y + this.frustum02 * z + this.frustum03;
		if (d <= -radius)
			return false;
		d = this.frustum10 * x + this.frustum11 * y + this.frustum12 * z + this.frustum13;
		if (d <= -radius)
			return false;
		d = this.frustum20 * x + this.frustum21 * y + this.frustum22 * z + this.frustum23;
		if (d <= -radius)
			return false;
		d = this.frustum30 * x + this.frustum31 * y + this.frustum32 * z + this.frustum33;
		if (d <= -radius)
			return false;
		d = this.frustum40 * x + this.frustum41 * y + this.frustum42 * z + this.frustum43;
		if (d <= -radius)
			return false;
		d = this.frustum50 * x + this.frustum51 * y + this.frustum52 * z + this.frustum53;
		if (d <= -radius)
			return false;
		return true;
	}
	internal IGetCameraMatrix d_GetCameraMatrix;
	float frustum00;
	float frustum01;
	float frustum02;
	float frustum03;
	float frustum10;
	float frustum11;
	float frustum12;
	float frustum13;
	float frustum20;
	float frustum21;
	float frustum22;
	float frustum23;
	float frustum30;
	float frustum31;
	float frustum32;
	float frustum33;
	float frustum40;
	float frustum41;
	float frustum42;
	float frustum43;
	float frustum50;
	float frustum51;
	float frustum52;
	float frustum53;
	internal GamePlatform platform;
}

public class Game
{
	public Game()
	{
		this.one = 1;
		this.map = new Map();
		this.performanceinfo = new DictionaryStringString();
		this.AudioEnabled = true;
		this.AutoJumpEnabled = false;
		this.playerPositionSpawnX = 15 + this.one / 2;
		this.playerPositionSpawnY = 64;
		this.playerPositionSpawnZ = 15 + this.one / 2;
		this.TextureId = new int[1024][];
		for (int i = 0; i < 1024; i++) {
			this.TextureId[i] = new int[6];
		}
		this.TextureIdForInventory = new int[1024];
		this.language = new Language();
		this.lastplacedblockX = -1;
		this.lastplacedblockY = -1;
		this.lastplacedblockZ = -1;
		this.mLightLevels = new float[16];
		this.sunlight_ = 15;
		this.mvMatrix = new StackMatrix4();
		this.pMatrix = new StackMatrix4();
		this.mvMatrix.Push(Mat4.Create());
		this.pMatrix.Push(Mat4.Create());
		this.whitetexture = -1;
		this.cachedTextTexturesMax = 1024;
		this.cachedTextTextures = new CachedTextTexture[this.cachedTextTexturesMax];
		for (int i = 0; i < this.cachedTextTexturesMax; i++) {
			this.cachedTextTextures[i] = null;
		}
		this.packetLen = new IntRef();
		this.ENABLE_DRAW2D = true;
		this.AllowFreemove = true;
		this.enableCameraControl = true;
		this.textures = new DictionaryStringInt1024();
		this.ServerInfo = new ServerInformation();
		this.menustate = new MenuState();
		this.mouseleftclick = false;
		this.mouseleftdeclick = false;
		this.wasmouseleft = false;
		this.mouserightclick = false;
		this.mouserightdeclick = false;
		this.wasmouseright = false;
		this.ENABLE_LAG = 0;
		this.znear = this.one / 10;
		this.CameraMatrix = new GetCameraMatrix();
		this.ENABLE_ZFAR = true;
		this.TotalAmmo = new int[1024];
		this.LoadedAmmo = new int[1024];
		this.AllowedFontsCount = 1;
		this.AllowedFonts = new string[this.AllowedFontsCount];
		this.AllowedFonts[0] = "Verdana";
		this.fov = Game.GetPi() / 3;
		this.cameratype = CameraType.Fpp;
		this.ENABLE_TPP_VIEW = false;
		this.basemovespeed = 5;
		this.movespeed = 5;
		this.RadiusWhenMoving = this.one * 3 / 10;
		this.playervelocity = new Vector3Ref();
		this.LocalPlayerId = -1;
		this.dialogs = new VisibleDialog[512];
		this.dialogsCount = 512;
		this.blockHealth = new DictionaryVector3Float();
		this.playertexturedefault = -1;
		this.a = new AnimationState();
		this.constRotationSpeed = this.one * 180 / 20;
		this.modmanager = new ClientModManager1();
		this.particleEffectBlockBreak = new ModDrawParticleEffectBlockBreak();
		this.PICK_DISTANCE = 4.1f;
		this.selectedmodelid = -1;
		this.grenadetime = 3;
		this.rotationspeed = this.one * 15 / 100;
		this.entities = new Entity[4096];
		for (int i = 0; i < 4096; i++) {
			this.entities[i] = null;
		}
		this.entitiesCount = 512;
		this.PlayerPushDistance = 2;
		this.keyboardState = new bool[256];
		for (int i = 0; i < 256; i++) {
			this.keyboardState[i] = false;
		}
		this.keyboardStateRaw = new bool[256];
		for (int i = 0; i < 256; i++) {
			this.keyboardStateRaw[i] = false;
		}
		this.overheadcameradistance = 10;
		this.tppcameradistance = 3;
		this.TPP_CAMERA_DISTANCE_MIN = 1;
		this.TPP_CAMERA_DISTANCE_MAX = 10;
		this.options = new OptionsCi();
		this.overheadcameraK = new Kamera();
		this.fillAreaLimit = 200;
		this.speculativeCount = 0;
		this.speculative = new Speculative[8192];
		this.typinglog = new string[16384];
		this.typinglogCount = 0;
		this.NewBlockTypes = new Packet_BlockType[1024];
		this.localplayeranim = new AnimationState();
		this.localplayeranimationhint = new AnimationHint();
		this.enable_move = true;
		this.handTexture = -1;
		this.modelViewInverted = new float[16];
		this.GLScaleTempVec3 = Vec3.Create();
		this.GLRotateTempVec3 = Vec3.Create();
		this.GLTranslateTempVec3 = Vec3.Create();
		this.identityMatrix = Mat4.Identity_(Mat4.Create());
		this.Set3dProjectionTempMat4 = Mat4.Create();
		this.getAsset = new string[2048];
		this.PlayerStats = new Packet_ServerPlayerStats();
		this.mLightLevels = new float[16];
		for (int i = 0; i < 16; i++) {
			this.mLightLevels[i] = this.one * i / 15;
		}
		this.soundnow = new BoolRef();
		this.camera = Mat4.Create();
		this.packetHandlers = new ClientPacketHandler[256];
		this.player = new Entity();
		this.player.position = new EntityPosition_();
		this.currentlyAttackedEntity = -1;
		this.ChatLinesMax = 1;
		this.ChatLines = new Chatline[this.ChatLinesMax];
		this.ChatLineLength = 64;
		this.audio = new AudioControl();
		this.CameraEyeX = -1;
		this.CameraEyeY = -1;
		this.CameraEyeZ = -1;
		this.controls = new Controls();
		this.movedz = 0;
		this.taskScheduler = new TaskScheduler();
		this.commitActions = ListAction.Create(16384);
		this.constWallDistance = 0.3f;
		this.mouseSmoothing = true;
	}
	internal int ActiveMaterial;

	public void AddChatline(string s)
	{
		Game game = this;
		if (game.platform.StringEmpty(s)) {
			return;
		}
		bool containsLink = false;
		string linkTarget = "";
		if (game.platform.StringContains(s, "http://")) {
			containsLink = true;
			IntRef r = new IntRef();
			string[] temp = game.platform.StringSplit(s, " ", r);
			for (int i = 0; i < r.value; i++) {
				if (game.platform.StringIndexOf(temp[i], "http://") != -1) {
					linkTarget = temp[i];
					break;
				}
			}
		}
		if (game.platform.StringContains(s, "https://")) {
			containsLink = true;
			IntRef r = new IntRef();
			string[] temp = game.platform.StringSplit(s, " ", r);
			for (int i = 0; i < r.value; i++) {
				if (game.platform.StringIndexOf(temp[i], "https://") != -1) {
					linkTarget = temp[i];
					break;
				}
			}
		}
		int now = game.platform.TimeMillisecondsFromStart();
		if (s.Length > this.ChatLineLength) {
			for (int i = 0; i <= s.Length / this.ChatLineLength; i++) {
				int displayLength = this.ChatLineLength;
				if (s.Length - i * this.ChatLineLength < this.ChatLineLength) {
					displayLength = s.Length - i * this.ChatLineLength;
				}
				if (containsLink)
					this.ChatLinesAdd(Chatline.CreateClickable(StringTools.StringSubstring(game.platform, s, i * this.ChatLineLength, displayLength), now, linkTarget));
				else
					this.ChatLinesAdd(Chatline.Create(StringTools.StringSubstring(game.platform, s, i * this.ChatLineLength, displayLength), now));
			}
		}
		else {
			if (containsLink)
				this.ChatLinesAdd(Chatline.CreateClickable(s, now, linkTarget));
			else
				this.ChatLinesAdd(Chatline.Create(s, now));
		}
	}

	public void AddMod(ClientMod mod)
	{
		this.clientmods[this.clientmodsCount++] = mod;
		mod.Start(this.modmanager);
	}

	void AddSpeculative(Speculative s_)
	{
		for (int i = 0; i < this.speculativeCount; i++) {
			if (this.speculative[i] == null) {
				this.speculative[i] = s_;
				return;
			}
		}
		this.speculative[this.speculativeCount++] = s_;
	}
	internal bool AllowFreemove;
	string[] AllowedFonts;
	int AllowedFontsCount;

	internal static float Angle256ToRad(int value)
	{
		float one_ = 1;
		return one_ * value / 255 * Game.GetPi() * 2;
	}

	internal void ApplyDamageToPlayer(int damage, int damageSource, int sourceId)
	{
		this.PlayerStats.CurrentHealth -= damage;
		if (this.PlayerStats.CurrentHealth <= 0) {
			this.PlayerStats.CurrentHealth = 0;
			this.AudioPlay("death.wav");
			this.SendPacketClient(ClientPackets.Death(damageSource, sourceId));
		}
		else {
			this.AudioPlay(this.rnd.Next() % 2 == 0 ? "grunt1.wav" : "grunt2.wav");
		}
		this.SendPacketClient(ClientPackets.Health(this.PlayerStats.CurrentHealth));
	}
	internal bool AudioEnabled;

	public void AudioPlay(string file)
	{
		if (!this.AudioEnabled) {
			return;
		}
		this.AudioPlayAt(file, this.EyesPosX(), this.EyesPosY(), this.EyesPosZ());
	}

	public void AudioPlayAt(string file, float x, float y, float z)
	{
		if (file == null) {
			return;
		}
		if (!this.AudioEnabled) {
			return;
		}
		if (this.assetsLoadProgress.value != 1) {
			return;
		}
		string file_ = this.platform.StringReplace(file, ".wav", ".ogg");
		if (this.GetFileLength(file_) == 0) {
			this.platform.ConsoleWriteLine(this.platform.StringFormat("File not found: {0}", file));
			return;
		}
		Sound_ s = new Sound_();
		s.name = file_;
		s.x = x;
		s.y = y;
		s.z = z;
		this.audio.Add(s);
	}

	public void AudioPlayLoop(string file, bool play, bool restart)
	{
		if (!this.AudioEnabled && play) {
			return;
		}
		if (this.assetsLoadProgress.value != 1) {
			return;
		}
		string file_ = this.platform.StringReplace(file, ".wav", ".ogg");
		if (this.GetFileLength(file_) == 0) {
			this.platform.ConsoleWriteLine(this.platform.StringFormat("File not found: {0}", file));
			return;
		}
		if (play) {
			Sound_ s = null;
			bool alreadyPlaying = false;
			for (int i = 0; i < this.audio.soundsCount; i++) {
				if (this.audio.sounds[i] == null) {
					continue;
				}
				if (this.audio.sounds[i].name == file_) {
					alreadyPlaying = true;
					s = this.audio.sounds[i];
				}
			}
			if (!alreadyPlaying) {
				s = new Sound_();
				s.name = file_;
				s.loop = true;
				this.audio.Add(s);
			}
			s.x = this.EyesPosX();
			s.y = this.EyesPosY();
			s.z = this.EyesPosZ();
		}
		else {
			for (int i = 0; i < this.audio.soundsCount; i++) {
				if (this.audio.sounds[i] == null) {
					continue;
				}
				if (this.audio.sounds[i].name == file_) {
					this.audio.sounds[i].stop = true;
				}
			}
		}
	}
	internal bool AutoJumpEnabled;

	internal IntRef BlockInHand()
	{
		Packet_Item item = this.d_Inventory.RightHand[this.ActiveMaterial];
		if (item != null && item.ItemClass == 0) {
			return IntRef.Create(item.BlockId);
		}
		return null;
	}

	internal int BlockUnderPlayer()
	{
		if (!this.map.IsValidPos(this.platform.FloatToInt(this.player.position.x), this.platform.FloatToInt(this.player.position.z), this.platform.FloatToInt(this.player.position.y) - 1)) {
			return -1;
		}
		int blockunderplayer = this.map.GetBlock(this.platform.FloatToInt(this.player.position.x), this.platform.FloatToInt(this.player.position.z), this.platform.FloatToInt(this.player.position.y) - 1);
		return blockunderplayer;
	}

	public bool BoolCommandArgument(string arguments)
	{
		arguments = this.platform.StringTrim(arguments);
		return arguments == "" || arguments == "1" || arguments == "on" || arguments == "yes";
	}

	public static int[] ByteArrayToUshortArray(byte[] input, int inputLength)
	{
		int outputLength = inputLength / 2;
		int[] output = new int[outputLength];
		for (int i = 0; i < outputLength; i++) {
			output[i] = (input[i * 2 + 1] << 8) + input[i * 2];
		}
		return output;
	}

	void CacheAsset(Asset asset)
	{
		if (asset.md5 == null) {
			return;
		}
		if (!this.platform.IsChecksum(asset.md5)) {
			return;
		}
		if (!this.platform.IsCached(asset.md5)) {
			this.platform.SaveAssetToCache(asset);
		}
	}

	public void CameraChange()
	{
		if (this.Follow != null) {
			return;
		}
		if (this.cameratype == CameraType.Fpp) {
			this.cameratype = CameraType.Tpp;
			this.ENABLE_TPP_VIEW = true;
		}
		else if (this.cameratype == CameraType.Tpp) {
			this.cameratype = CameraType.Overhead;
			this.overheadcamera = true;
			this.SetFreeMouse(true);
			this.ENABLE_TPP_VIEW = true;
			this.playerdestination = Vector3Ref.Create(this.player.position.x, this.player.position.y, this.player.position.z);
		}
		else if (this.cameratype == CameraType.Overhead) {
			this.cameratype = CameraType.Fpp;
			this.SetFreeMouse(false);
			this.ENABLE_TPP_VIEW = false;
			this.overheadcamera = false;
		}
		else {
			this.platform.ThrowException("");
		}
	}
	internal float CameraEyeX;
	internal float CameraEyeY;
	internal float CameraEyeZ;
	internal GetCameraMatrix CameraMatrix;

	public string CharToString(int c)
	{
		int[] arr = new int[1];
		arr[0] = c;
		return this.platform.CharArrayToString(arr, 1);
	}
	public const int ChatFontSize = 11;
	internal int ChatLineLength;
	internal Chatline[] ChatLines;

	void ChatLinesAdd(Chatline chatline)
	{
		if (this.ChatLinesCount >= this.ChatLinesMax) {
			Chatline[] lines2 = new Chatline[this.ChatLinesMax * 2];
			for (int i = 0; i < this.ChatLinesMax; i++) {
				lines2[i] = this.ChatLines[i];
			}
			this.ChatLines = lines2;
			this.ChatLinesMax *= 2;
		}
		this.ChatLines[this.ChatLinesCount++] = chatline;
	}
	internal int ChatLinesCount;
	internal int ChatLinesMax;

	internal void ChatLog(string p)
	{
		if (!this.platform.ChatLog(this.ServerInfo.ServerName, p)) {
			this.platform.ConsoleWriteLine(this.platform.StringFormat(this.language.CannotWriteChatLog(), this.ServerInfo.ServerName));
		}
	}

	public void Circle3i(float x, float y, float radius)
	{
		float angle;
		this.GLPushMatrix();
		this.GLLoadIdentity();
		int n = 32;
		if (this.circleModelData == null) {
			this.circleModelData = new ModelData();
			this.circleModelData.setMode(1);
			this.circleModelData.indices = new int[n * 2];
			this.circleModelData.xyz = new float[3 * n];
			this.circleModelData.rgba = new byte[4 * n];
			this.circleModelData.uv = new float[2 * n];
			this.circleModelData.indicesCount = n * 2;
			this.circleModelData.verticesCount = n;
		}
		for (int i = 0; i < n; i++) {
			this.circleModelData.indices[i * 2] = i;
			this.circleModelData.indices[i * 2 + 1] = (i + 1) % n;
		}
		for (int i = 0; i < n; i++) {
			angle = i * 2 * Game.GetPi() / n;
			this.circleModelData.xyz[i * 3 + 0] = x + this.platform.MathCos(angle) * radius;
			this.circleModelData.xyz[i * 3 + 1] = y + this.platform.MathSin(angle) * radius;
			this.circleModelData.xyz[i * 3 + 2] = 0;
		}
		for (int i = 0; i < 4 * n; i++) {
			this.circleModelData.rgba[i] = 255;
		}
		for (int i = 0; i < 2 * n; i++) {
			this.circleModelData.uv[i] = 0;
		}
		this.DrawModelData(this.circleModelData);
		this.GLPopMatrix();
	}

	internal void ClientCommand(string s_)
	{
		if (s_ == "") {
			return;
		}
		IntRef ssCount = new IntRef();
		string[] ss = this.platform.StringSplit(s_, " ", ssCount);
		if (StringTools.StringStartsWith(this.platform, s_, ".")) {
			string strFreemoveNotAllowed = this.language.FreemoveNotAllowed();
			string cmd = StringTools.StringSubstringToEnd(this.platform, ss[0], 1);
			string arguments;
			if (this.platform.StringIndexOf(s_, " ") == -1) {
				arguments = "";
			}
			else {
				arguments = StringTools.StringSubstringToEnd(this.platform, s_, this.platform.StringIndexOf(s_, " "));
			}
			arguments = this.platform.StringTrim(arguments);
			if (cmd == "clients") {
				this.Log("Clients:");
				for (int i = 0; i < this.entitiesCount; i++) {
					Entity entity = this.entities[i];
					if (entity == null) {
						continue;
					}
					if (entity.drawName == null) {
						continue;
					}
					if (!entity.drawName.ClientAutoComplete) {
						continue;
					}
					this.Log(this.platform.StringFormat2("{0} {1}", this.platform.IntToString(i), this.entities[i].drawName.Name));
				}
			}
			else if (cmd == "reconnect") {
				this.Reconnect();
			}
			else if (cmd == "m") {
				this.mouseSmoothing = !this.mouseSmoothing;
				if (this.mouseSmoothing) {
					this.Log("Mouse smoothing enabled.");
				}
				else {
					this.Log("Mouse smoothing disabled.");
				}
			}
			else if (cmd == "pos") {
				this.ENABLE_DRAWPOSITION = this.BoolCommandArgument(arguments);
			}
			else if (cmd == "noclip") {
				if (this.AllowFreemove) {
					this.stopPlayerMove = true;
					if (this.BoolCommandArgument(arguments)) {
						this.controls.SetFreemove(2);
					}
					else {
						this.controls.SetFreemove(0);
					}
				}
				else {
					this.Log(strFreemoveNotAllowed);
					return;
				}
			}
			else if (cmd == "freemove") {
				if (this.AllowFreemove) {
					this.stopPlayerMove = true;
					if (this.BoolCommandArgument(arguments)) {
						this.controls.SetFreemove(1);
					}
					else {
						this.controls.SetFreemove(0);
					}
				}
				else {
					this.Log(strFreemoveNotAllowed);
					return;
				}
			}
			else if (cmd == "gui") {
				this.ENABLE_DRAW2D = this.BoolCommandArgument(arguments);
			}
			else if (arguments != "") {
				if (cmd == "fog") {
					int foglevel;
					foglevel = this.platform.IntParse(arguments);
					{
						int foglevel2 = foglevel;
						if (foglevel2 > 1024) {
							foglevel2 = 1024;
						}
						if (foglevel2 % 2 == 0) {
							foglevel2--;
						}
						this.d_Config3d.viewdistance = foglevel2;
					}
					this.OnResize();
				}
				else if (cmd == "fov") {
					int arg = this.platform.IntParse(arguments);
					int minfov = 1;
					int maxfov = 179;
					if (!this.issingleplayer) {
						minfov = 60;
					}
					if (arg < minfov || arg > maxfov) {
						this.Log(this.platform.StringFormat2("Valid field of view: {0}-{1}", this.platform.IntToString(minfov), this.platform.IntToString(maxfov)));
					}
					else {
						float fov_ = 2 * Game.GetPi() * this.one * arg / 360;
						this.fov = fov_;
						this.OnResize();
					}
				}
				else if (cmd == "movespeed") {
					if (this.AllowFreemove) {
						if (this.platform.FloatParse(arguments) <= 500) {
							this.movespeed = this.basemovespeed * this.platform.FloatParse(arguments);
							this.AddChatline(this.platform.StringFormat("Movespeed: {0}x", arguments));
						}
						else {
							this.AddChatline("Entered movespeed to high! max. 500x");
						}
					}
					else {
						this.Log(strFreemoveNotAllowed);
						return;
					}
				}
				else if (cmd == "serverinfo") {
					IntRef splitCount = new IntRef();
					string[] split = this.platform.StringSplit(arguments, ":", splitCount);
					if (splitCount.value == 2) {
						QueryClient qClient = new QueryClient();
						qClient.SetPlatform(this.platform);
						qClient.PerformQuery(split[0], this.platform.IntParse(split[1]));
						if (qClient.querySuccess) {
							QueryResult r = qClient.GetResult();
							this.AddChatline(r.GameMode);
							this.AddChatline(this.platform.IntToString(r.MapSizeX));
							this.AddChatline(this.platform.IntToString(r.MapSizeY));
							this.AddChatline(this.platform.IntToString(r.MapSizeZ));
							this.AddChatline(this.platform.IntToString(r.MaxPlayers));
							this.AddChatline(r.MOTD);
							this.AddChatline(r.Name);
							this.AddChatline(this.platform.IntToString(r.PlayerCount));
							this.AddChatline(r.PlayerList);
							this.AddChatline(this.platform.IntToString(r.Port));
							this.AddChatline(r.PublicHash);
							this.AddChatline(r.ServerVersion);
						}
						this.AddChatline(qClient.GetServerMessage());
					}
				}
			}
			else {
				string chatline = StringTools.StringSubstring(this.platform, this.GuiTypingBuffer, 0, MathCi.MinInt(this.GuiTypingBuffer.Length, 256));
				this.SendChat(chatline);
			}
			for (int i = 0; i < this.clientmodsCount; i++) {
				ClientCommandArgs args = new ClientCommandArgs();
				args.arguments = arguments;
				args.command = cmd;
				this.clientmods[i].OnClientCommand(this, args);
			}
		}
		else {
			string chatline = StringTools.StringSubstring(this.platform, this.GuiTypingBuffer, 0, MathCi.MinInt(StringTools.StringLength(this.platform, this.GuiTypingBuffer), 4096));
			this.SendChat(chatline);
		}
	}

	public static int ColorA(int color)
	{
		byte a = Game.IntToByte(color >> 24);
		return a;
	}

	public static int ColorB(int color)
	{
		byte b = Game.IntToByte(color);
		return b;
	}

	public static int ColorFromArgb(int a, int r, int g, int b)
	{
		int iCol = a << 24 | r << 16 | g << 8 | b;
		return iCol;
	}

	public static int ColorG(int color)
	{
		byte g = Game.IntToByte(color >> 8);
		return g;
	}

	public static int ColorR(int color)
	{
		byte r = Game.IntToByte(color >> 16);
		return r;
	}

	public ModelData CombineModelData(ModelData[] modelDatas, int count)
	{
		ModelData ret = new ModelData();
		int totalIndices = 0;
		int totalVertices = 0;
		for (int i = 0; i < count; i++) {
			ModelData m = modelDatas[i];
			totalIndices += m.indicesCount;
			totalVertices += m.verticesCount;
		}
		ret.indices = new int[totalIndices];
		ret.xyz = new float[totalVertices * 3];
		ret.uv = new float[totalVertices * 2];
		ret.rgba = new byte[totalVertices * 4];
		for (int i = 0; i < count; i++) {
			ModelData m = modelDatas[i];
			int retVerticesCount = ret.verticesCount;
			int retIndicesCount = ret.indicesCount;
			for (int k = 0; k < m.indicesCount; k++) {
				ret.indices[ret.indicesCount++] = m.indices[k] + retVerticesCount;
			}
			for (int k = 0; k < m.verticesCount * 3; k++) {
				ret.xyz[retVerticesCount * 3 + k] = m.xyz[k];
			}
			for (int k = 0; k < m.verticesCount * 2; k++) {
				ret.uv[retVerticesCount * 2 + k] = m.uv[k];
			}
			for (int k = 0; k < m.verticesCount * 4; k++) {
				ret.rgba[retVerticesCount * 4 + k] = m.rgba[k];
			}
			ret.verticesCount += m.verticesCount;
		}
		return ret;
	}

	internal void Connect(string serverAddress, int port, string username, string auth)
	{
		this.main.Start();
		this.main.Connect(serverAddress, port);
		this.SendPacketClient(ClientPackets.CreateLoginPacket(this.platform, username, auth));
	}

	internal void Connect_(string serverAddress, int port, string username, string auth, string serverPassword)
	{
		this.main.Start();
		this.main.Connect(serverAddress, port);
		this.SendPacketClient(ClientPackets.CreateLoginPacket_(this.platform, username, auth, serverPassword));
	}

	internal void Connect__()
	{
		if (this.connectdata.ServerPassword == null || this.connectdata.ServerPassword == "") {
			this.Connect(this.connectdata.Ip, this.connectdata.Port, this.connectdata.Username, this.connectdata.Auth);
		}
		else {
			this.Connect_(this.connectdata.Ip, this.connectdata.Port, this.connectdata.Username, this.connectdata.Auth, this.connectdata.ServerPassword);
		}
		this.MapLoadingStart();
	}

	internal Entity CreateBulletEntity(float fromX, float fromY, float fromZ, float toX, float toY, float toZ, float speed)
	{
		Entity entity = new Entity();
		Bullet_ bullet = new Bullet_();
		bullet.fromX = fromX;
		bullet.fromY = fromY;
		bullet.fromZ = fromZ;
		bullet.toX = toX;
		bullet.toY = toY;
		bullet.toZ = toZ;
		bullet.speed = speed;
		entity.bullet = bullet;
		entity.sprite = new Sprite();
		entity.sprite.image = "Sponge.png";
		entity.sprite.size = 4;
		entity.sprite.animationcount = 0;
		return entity;
	}

	internal float CurrentAimRadius()
	{
		Packet_Item item = this.d_Inventory.RightHand[this.ActiveMaterial];
		if (item == null || item.ItemClass != 0) {
			return 0;
		}
		float radius = this.DeserializeFloat(this.blocktypes[item.BlockId].AimRadiusFloat) / 800 * this.Width();
		if (this.IronSights) {
			radius = this.DeserializeFloat(this.blocktypes[item.BlockId].IronSightsAimRadiusFloat) / 800 * this.Width();
		}
		return radius + this.RadiusWhenMoving * radius * MathCi.MinFloat(this.playervelocity.Length() / this.movespeed, 1);
	}

	internal float CurrentRecoil()
	{
		Packet_Item item = this.d_Inventory.RightHand[this.ActiveMaterial];
		if (item == null || item.ItemClass != 0) {
			return 0;
		}
		return this.DeserializeFloat(this.blocktypes[item.BlockId].RecoilFloat);
	}
	public const int DISCONNECTED_ICON_AFTER_SECONDS = 10;

	internal bool DeleteTexture(string name)
	{
		if (name != null && this.textures.Contains(name)) {
			int id = this.textures.Get(name);
			this.textures.Remove(name);
			this.platform.GLDeleteTexture(id);
			return true;
		}
		return false;
	}

	public void DeleteUnusedCachedTextTextures()
	{
		int now = this.platform.TimeMillisecondsFromStart();
		for (int i = 0; i < this.cachedTextTexturesMax; i++) {
			CachedTextTexture t = this.cachedTextTextures[i];
			if (t == null) {
				continue;
			}
			if (this.one * (now - t.texture.lastuseMilliseconds) / 1000 > 1) {
				this.platform.GLDeleteTexture(t.texture.textureId);
				this.cachedTextTextures[i] = null;
			}
		}
	}

	internal float DeserializeFloat(int value)
	{
		return this.one * value / 32;
	}

	internal int DialogsCount_()
	{
		int count = 0;
		for (int i = 0; i < this.dialogsCount; i++) {
			if (this.dialogs[i] != null) {
				count++;
			}
		}
		return count;
	}

	public void Dispose()
	{
		for (int i = 0; i < this.clientmodsCount; i++) {
			if (this.clientmods[i] == null) {
				continue;
			}
			this.clientmods[i].Dispose(this);
		}
		for (int i = 0; i < this.textures.count; i++) {
			if (this.textures.items[i] == null) {
				continue;
			}
			this.platform.GLDeleteTexture(this.textures.items[i].value);
		}
		for (int i = 0; i < this.cachedTextTexturesMax; i++) {
			if (this.cachedTextTextures[i] == null) {
				continue;
			}
			if (this.cachedTextTextures[i].texture == null) {
				continue;
			}
			this.platform.GLDeleteTexture(this.cachedTextTextures[i].texture.textureId);
		}
	}

	public float Dist(float x1, float y1, float z1, float x2, float y2, float z2)
	{
		float dx = x2 - x1;
		float dy = y2 - y1;
		float dz = z2 - z1;
		return this.platform.MathSqrt(dx * dx + dy * dy + dz * dz);
	}

	internal void Draw2d(float dt)
	{
		if (!this.ENABLE_DRAW2D) {
			return;
		}
		this.OrthoMode(this.Width(), this.Height());
		for (int i = 0; i < this.clientmodsCount; i++) {
			if (this.clientmods[i] == null) {
				continue;
			}
			this.clientmods[i].OnNewFrameDraw2d(this, dt);
		}
		this.PerspectiveMode();
	}

	public void Draw2dBitmapFile(string filename, float x, float y, float w, float h)
	{
		this.Draw2dTexture(this.GetTexture(filename), x, y, w, h, null, 0, Game.ColorFromArgb(255, 255, 255, 255), false);
	}

	public void Draw2dText(string text, FontCi font, float x, float y, IntRef color, bool enabledepthtest)
	{
		if (text == null || this.platform.StringTrim(text) == "") {
			return;
		}
		if (color == null) {
			color = IntRef.Create(Game.ColorFromArgb(255, 255, 255, 255));
		}
		Text_ t = new Text_();
		t.text = text;
		t.color = color.value;
		t.fontsize = font.size;
		t.fontfamily = font.family;
		t.fontstyle = font.style;
		CachedTexture ct;
		if (this.GetCachedTextTexture(t) == null) {
			ct = this.MakeTextTexture(t);
			if (ct == null) {
				return;
			}
			for (int i = 0; i < this.cachedTextTexturesMax; i++) {
				if (this.cachedTextTextures[i] == null) {
					CachedTextTexture ct1 = new CachedTextTexture();
					ct1.text = t;
					ct1.texture = ct;
					this.cachedTextTextures[i] = ct1;
					break;
				}
			}
		}
		ct = this.GetCachedTextTexture(t);
		ct.lastuseMilliseconds = this.platform.TimeMillisecondsFromStart();
		this.platform.GLDisableAlphaTest();
		this.Draw2dTexture(ct.textureId, x, y, ct.sizeX, ct.sizeY, null, 0, Game.ColorFromArgb(255, 255, 255, 255), enabledepthtest);
		this.platform.GLEnableAlphaTest();
		this.DeleteUnusedCachedTextTextures();
	}

	internal void Draw2dText1(string text, int x, int y, int fontsize, IntRef color, bool enabledepthtest)
	{
		FontCi font = new FontCi();
		font.family = "Arial";
		font.size = fontsize;
		this.Draw2dText(text, font, x, y, color, enabledepthtest);
	}

	public void Draw2dTexture(int textureid, float x1, float y1, float width, float height, IntRef inAtlasId, int atlastextures, int color, bool enabledepthtest)
	{
		if (color == Game.ColorFromArgb(255, 255, 255, 255) && inAtlasId == null) {
			this.Draw2dTextureSimple(textureid, x1, y1, width, height, enabledepthtest);
		}
		else {
			this.Draw2dTextureInAtlas(textureid, x1, y1, width, height, inAtlasId, atlastextures, color, enabledepthtest);
		}
	}

	void Draw2dTextureInAtlas(int textureid, float x1, float y1, float width, float height, IntRef inAtlasId, int atlastextures, int color, bool enabledepthtest)
	{
		RectFRef rect = RectFRef.Create(0, 0, 1, 1);
		if (inAtlasId != null) {
			TextureAtlasCi.TextureCoords2d(inAtlasId.value, atlastextures, rect);
		}
		this.platform.GlDisableCullFace();
		this.platform.GlEnableTexture2d();
		this.platform.BindTexture2d(textureid);
		if (!enabledepthtest) {
			this.platform.GlDisableDepthTest();
		}
		ModelData data = QuadModelData.GetQuadModelData2(rect.x, rect.y, rect.w, rect.h, x1, y1, width, height, Game.IntToByte(Game.ColorR(color)), Game.IntToByte(Game.ColorG(color)), Game.IntToByte(Game.ColorB(color)), Game.IntToByte(Game.ColorA(color)));
		this.DrawModelData(data);
		if (!enabledepthtest) {
			this.platform.GlEnableDepthTest();
		}
		this.platform.GlEnableCullFace();
		this.platform.GlEnableTexture2d();
	}

	public void Draw2dTexturePart(int textureid, float srcwidth, float srcheight, float dstx, float dsty, float dstwidth, float dstheight, int color, bool enabledepthtest)
	{
		RectFRef rect = RectFRef.Create(0, 0, srcwidth, srcheight);
		this.platform.GlDisableCullFace();
		this.platform.GlEnableTexture2d();
		this.platform.BindTexture2d(textureid);
		if (!enabledepthtest) {
			this.platform.GlDisableDepthTest();
		}
		ModelData data = QuadModelData.GetQuadModelData2(rect.x, rect.y, rect.w, rect.h, dstx, dsty, dstwidth, dstheight, Game.IntToByte(Game.ColorR(color)), Game.IntToByte(Game.ColorG(color)), Game.IntToByte(Game.ColorB(color)), Game.IntToByte(Game.ColorA(color)));
		this.DrawModelData(data);
		if (!enabledepthtest) {
			this.platform.GlEnableDepthTest();
		}
		this.platform.GlEnableCullFace();
		this.platform.GlEnableTexture2d();
	}

	void Draw2dTextureSimple(int textureid, float x1, float y1, float width, float height, bool enabledepthtest)
	{
		RectFRef rect = RectFRef.Create(0, 0, 1, 1);
		this.platform.GlDisableCullFace();
		this.platform.GlEnableTexture2d();
		this.platform.BindTexture2d(textureid);
		if (!enabledepthtest) {
			this.platform.GlDisableDepthTest();
		}
		if (this.quadModel == null) {
			this.quadModel = this.platform.CreateModel(QuadModelData.GetQuadModelData());
		}
		this.GLPushMatrix();
		this.GLTranslate(x1, y1, 0);
		this.GLScale(width, height, 0);
		this.GLScale(this.one / 2, this.one / 2, 0);
		this.GLTranslate(this.one, this.one, 0);
		this.DrawModel(this.quadModel);
		this.GLPopMatrix();
		if (!enabledepthtest) {
			this.platform.GlEnableDepthTest();
		}
		this.platform.GlEnableCullFace();
		this.platform.GlEnableTexture2d();
	}

	public void Draw2dTextures(Draw2dData[] todraw, int todrawLength, int textureid)
	{
		ModelData[] modelDatas = new ModelData[512];
		int modelDatasCount = 0;
		for (int i = 0; i < todrawLength; i++) {
			Draw2dData d = todraw[i];
			float x1 = d.x1;
			float y1 = d.y1;
			float width = d.width;
			float height = d.height;
			IntRef inAtlasId = d.inAtlasId;
			int textureId = textureid;
			int color = d.color;
			RectFRef rect = RectFRef.Create(0, 0, 1, 1);
			if (inAtlasId != null) {
				TextureAtlasCi.TextureCoords2d(inAtlasId.value, this.texturesPacked(), rect);
			}
			ModelData modelData = QuadModelData.GetQuadModelData2(rect.x, rect.y, rect.w, rect.h, x1, y1, width, height, Game.IntToByte(Game.ColorR(color)), Game.IntToByte(Game.ColorG(color)), Game.IntToByte(Game.ColorB(color)), Game.IntToByte(Game.ColorA(color)));
			modelDatas[modelDatasCount++] = modelData;
		}
		ModelData combined = this.CombineModelData(modelDatas, modelDatasCount);
		this.platform.GlDisableCullFace();
		this.platform.GlEnableTexture2d();
		this.platform.BindTexture2d(textureid);
		this.platform.GlDisableDepthTest();
		this.DrawModelData(combined);
		this.platform.GlEnableDepthTest();
		this.platform.GlDisableCullFace();
		this.platform.GlEnableTexture2d();
	}

	public void DrawModel(Model model)
	{
		this.SetMatrixUniformModelView();
		this.platform.DrawModel(model);
	}

	public void DrawModelData(ModelData data)
	{
		this.SetMatrixUniformModelView();
		this.platform.DrawModelData(data);
	}

	public void DrawModels(Model[] model, int count)
	{
		this.SetMatrixUniformModelView();
		this.platform.DrawModels(model, count);
	}
	internal bool ENABLE_DRAW2D;
	internal bool ENABLE_DRAWPOSITION;
	internal bool ENABLE_DRAW_TEST_CHARACTER;
	internal int ENABLE_LAG;
	internal bool ENABLE_TPP_VIEW;
	internal bool ENABLE_ZFAR;

	internal bool EnablePlayerUpdatePosition(int kKey)
	{
		return true;
	}

	internal bool EnablePlayerUpdatePositionContainsKey(int kKey)
	{
		return false;
	}

	internal void EntityAddLocal(Entity entity)
	{
		for (int i = 256; i < this.entitiesCount; i++) {
			if (this.entities[i] == null) {
				this.entities[i] = entity;
				return;
			}
		}
		this.entities[this.entitiesCount++] = entity;
	}

	public void EscapeMenuStart()
	{
		this.guistate = GuiState.EscapeMenu;
		this.menustate = new MenuState();
		this.platform.ExitMousePointerLock();
		this.escapeMenuRestart = true;
	}

	internal void ExitAndSwitchServer(Packet_ServerRedirect newServer)
	{
		if (this.issingleplayer) {
			this.platform.SinglePlayerServerExit();
		}
		this.redirectTo = newServer;
		this.exitToMainMenu = true;
	}

	internal void ExitToMainMenu_()
	{
		if (this.issingleplayer) {
			this.platform.SinglePlayerServerExit();
		}
		this.redirectTo = null;
		this.exitToMainMenu = true;
	}

	public float EyesPosX()
	{
		return this.player.position.x;
	}

	public float EyesPosY()
	{
		return this.player.position.y + this.GetCharacterEyesHeight();
	}

	public float EyesPosZ()
	{
		return this.player.position.z;
	}

	internal float FloorFloat(float a)
	{
		if (a >= 0) {
			return this.platform.FloatToInt(a);
		}
		else {
			return this.platform.FloatToInt(a) - 1;
		}
	}
	internal string Follow;

	internal IntRef FollowId()
	{
		if (this.Follow == null) {
			return null;
		}
		for (int i = 0; i < this.entitiesCount; i++) {
			if (this.entities[i] == null) {
				continue;
			}
			if (this.entities[i].drawName == null) {
				continue;
			}
			DrawName p = this.entities[i].drawName;
			if (p.Name == this.Follow) {
				return IntRef.Create(i);
			}
		}
		return null;
	}
	internal int Font;

	internal void FrameTick(float dt)
	{
		NewFrameEventArgs args_ = new NewFrameEventArgs();
		args_.SetDt(dt);
		for (int i = 0; i < this.clientmodsCount; i++) {
			this.clientmods[i].OnNewFrameFixed(this, args_);
		}
		for (int i = 0; i < this.entitiesCount; i++) {
			Entity e = this.entities[i];
			if (e == null) {
				continue;
			}
			for (int k = 0; k < e.scriptsCount; k++) {
				e.scripts[k].OnNewFrameFixed(this, i, dt);
			}
		}
		this.RevertSpeculative(dt);
		if (this.guistate == GuiState.MapLoading) {
			return;
		}
		float orientationX = this.platform.MathSin(this.player.position.roty);
		float orientationY = 0;
		float orientationZ = -this.platform.MathCos(this.player.position.roty);
		this.platform.AudioUpdateListener(this.EyesPosX(), this.EyesPosY(), this.EyesPosZ(), orientationX, orientationY, orientationZ);
		this.playervelocity.X = this.player.position.x - this.lastplayerpositionX;
		this.playervelocity.Y = this.player.position.y - this.lastplayerpositionY;
		this.playervelocity.Z = this.player.position.z - this.lastplayerpositionZ;
		this.playervelocity.X *= 75;
		this.playervelocity.Y *= 75;
		this.playervelocity.Z *= 75;
		this.lastplayerpositionX = this.player.position.x;
		this.lastplayerpositionY = this.player.position.y;
		this.lastplayerpositionZ = this.player.position.z;
	}

	public void GLLoadIdentity()
	{
		if (this.currentMatrixModeProjection) {
			if (this.pMatrix.Count() > 0) {
				this.pMatrix.Pop();
			}
			this.pMatrix.Push(this.identityMatrix);
		}
		else {
			if (this.mvMatrix.Count() > 0) {
				this.mvMatrix.Pop();
			}
			this.mvMatrix.Push(this.identityMatrix);
		}
	}

	public void GLLoadMatrix(float[] m)
	{
		if (this.currentMatrixModeProjection) {
			if (this.pMatrix.Count() > 0) {
				this.pMatrix.Pop();
			}
			this.pMatrix.Push(m);
		}
		else {
			if (this.mvMatrix.Count() > 0) {
				this.mvMatrix.Pop();
			}
			this.mvMatrix.Push(m);
		}
	}

	public void GLMatrixModeModelView()
	{
		this.currentMatrixModeProjection = false;
	}

	public void GLMatrixModeProjection()
	{
		this.currentMatrixModeProjection = true;
	}

	public void GLOrtho(float left, float right, float bottom, float top, float zNear, float zFar)
	{
		if (this.currentMatrixModeProjection) {
			float[] m = this.pMatrix.Peek();
			Mat4.Ortho(m, left, right, bottom, top, zNear, zFar);
		}
		else {
			this.platform.ThrowException("GLOrtho");
		}
	}

	public void GLPopMatrix()
	{
		if (this.currentMatrixModeProjection) {
			if (this.pMatrix.Count() > 1) {
				this.pMatrix.Pop();
			}
		}
		else {
			if (this.mvMatrix.Count() > 1) {
				this.mvMatrix.Pop();
			}
		}
	}

	public void GLPushMatrix()
	{
		if (this.currentMatrixModeProjection) {
			this.pMatrix.Push(this.pMatrix.Peek());
		}
		else {
			this.mvMatrix.Push(this.mvMatrix.Peek());
		}
	}

	public void GLRotate(float angle, float x, float y, float z)
	{
		angle /= 360;
		angle *= 2 * Game.GetPi();
		float[] m;
		if (this.currentMatrixModeProjection) {
			m = this.pMatrix.Peek();
		}
		else {
			m = this.mvMatrix.Peek();
		}
		Vec3.Set(this.GLRotateTempVec3, x, y, z);
		Mat4.Rotate(m, m, angle, this.GLRotateTempVec3);
	}
	float[] GLRotateTempVec3;

	public void GLScale(float x, float y, float z)
	{
		float[] m;
		if (this.currentMatrixModeProjection) {
			m = this.pMatrix.Peek();
		}
		else {
			m = this.mvMatrix.Peek();
		}
		Vec3.Set(this.GLScaleTempVec3, x, y, z);
		Mat4.Scale(m, m, this.GLScaleTempVec3);
	}
	float[] GLScaleTempVec3;

	public void GLTranslate(float x, float y, float z)
	{
		float[] m;
		if (this.currentMatrixModeProjection) {
			m = this.pMatrix.Peek();
		}
		else {
			m = this.mvMatrix.Peek();
		}
		Vec3.Set(this.GLTranslateTempVec3, x, y, z);
		Mat4.Translate(m, m, this.GLTranslateTempVec3);
	}
	float[] GLTranslateTempVec3;

	CachedTexture GetCachedTextTexture(Text_ t)
	{
		for (int i = 0; i < this.cachedTextTexturesMax; i++) {
			CachedTextTexture ct = this.cachedTextTextures[i];
			if (ct == null) {
				continue;
			}
			if (ct.text.Equals_(t)) {
				return ct.texture;
			}
		}
		return null;
	}

	int GetCameraBlock()
	{
		int bx = this.MathFloor(this.CameraEyeX);
		int by = this.MathFloor(this.CameraEyeZ);
		int bz = this.MathFloor(this.CameraEyeY);
		if (!this.map.IsValidPos(bx, by, bz)) {
			return 0;
		}
		return this.map.GetBlockValid(bx, by, bz);
	}

	internal float GetCharacterEyesHeight()
	{
		return this.entities[this.LocalPlayerId].drawModel.eyeHeight;
	}

	internal float GetCurrentBlockHealth(int x, int y, int z)
	{
		if (this.blockHealth.ContainsKey(x, y, z)) {
			return this.blockHealth.Get(x, y, z);
		}
		int blocktype = this.map.GetBlock(x, y, z);
		return this.d_Data.Strength()[blocktype];
	}

	internal int GetDialogId(string name)
	{
		for (int i = 0; i < this.dialogsCount; i++) {
			if (this.dialogs[i] == null) {
				continue;
			}
			if (this.dialogs[i].key == name) {
				return i;
			}
		}
		return -1;
	}

	internal byte[] GetFile(string p)
	{
		string pLowercase = this.platform.StringToLower(p);
		for (int i = 0; i < this.assets.count; i++) {
			if (this.assets.items[i].name == pLowercase) {
				return this.assets.items[i].data;
			}
		}
		return null;
	}

	internal int GetFileLength(string p)
	{
		string pLowercase = this.platform.StringToLower(p);
		for (int i = 0; i < this.assets.count; i++) {
			if (this.assets.items[i].name == pLowercase) {
				return this.assets.items[i].dataLength;
			}
		}
		return 0;
	}

	public bool GetFreeMouse()
	{
		if (this.overheadcamera) {
			return true;
		}
		return !this.platform.IsMousePointerLocked();
	}

	internal int GetKey(int key)
	{
		if (this.options == null) {
			return key;
		}
		if (this.options.Keys[key] != 0) {
			return this.options.Keys[key];
		}
		return key;
	}

	public int GetLight(int x, int y, int z)
	{
		int light = this.map.MaybeGetLight(x, y, z);
		if (light == -1) {
			if (x >= 0 && x < this.map.MapSizeX && y >= 0 && y < this.map.MapSizeY && z >= this.d_Heightmap.GetBlock(x, y)) {
				return this.sunlight_;
			}
			else {
				return 0;
			}
		}
		else {
			return light;
		}
	}

	public static float GetPi()
	{
		float a = 3141592;
		return a / 1000000;
	}

	public GamePlatform GetPlatform()
	{
		return this.platform;
	}

	internal int GetPlayerEyesBlock()
	{
		float pX = this.player.position.x;
		float pY = this.player.position.y;
		float pZ = this.player.position.z;
		pY += this.entities[this.LocalPlayerId].drawModel.eyeHeight;
		int bx = this.MathFloor(pX);
		int by = this.MathFloor(pZ);
		int bz = this.MathFloor(pY);
		if (!this.map.IsValidPos(bx, by, bz)) {
			if (pY < this.WaterLevel()) {
				return -1;
			}
			return 0;
		}
		return this.map.GetBlockValid(bx, by, bz);
	}

	public int GetPlayerEyesBlockX()
	{
		return this.platform.FloatToInt(this.MathFloor(this.player.position.x));
	}

	public int GetPlayerEyesBlockY()
	{
		return this.platform.FloatToInt(this.MathFloor(this.player.position.z));
	}

	public int GetPlayerEyesBlockZ()
	{
		return this.platform.FloatToInt(this.MathFloor(this.player.position.y + this.entities[this.LocalPlayerId].drawModel.eyeHeight));
	}

	internal Packet_ServerRedirect GetRedirect()
	{
		return this.redirectTo;
	}

	internal int GetTexture(string p)
	{
		if (!this.textures.Contains(p)) {
			BoolRef found = new BoolRef();
			BitmapCi bmp = this.platform.BitmapCreateFromPng(this.GetFile(p), this.GetFileLength(p));
			int texture = this.platform.LoadTextureFromBitmap(bmp);
			this.textures.Set(p, texture);
			this.platform.BitmapDelete(bmp);
		}
		return this.textures.Get(p);
	}

	internal int GetTextureOrLoad(string name, BitmapCi bmp)
	{
		if (!this.textures.Contains(name)) {
			BoolRef found = new BoolRef();
			this.textures.Set(name, this.platform.LoadTextureFromBitmap(bmp));
		}
		return this.textures.Get(name);
	}

	internal void GotoDraw2d(float dt)
	{
		this.SetAmbientLight(Game.ColorFromArgb(255, 255, 255, 255));
		this.Draw2d(dt);
		NewFrameEventArgs args_ = new NewFrameEventArgs();
		args_.SetDt(dt);
		for (int i = 0; i < this.clientmodsCount; i++) {
			this.clientmods[i].OnNewFrame(this, args_);
		}
		this.mouseleftclick = this.mouserightclick = false;
		this.mouseleftdeclick = this.mouserightdeclick = false;
		if (!this.issingleplayer || this.issingleplayer && this.platform.SinglePlayerServerLoaded() || !this.platform.SinglePlayerServerAvailable()) {
			if (!this.startedconnecting) {
				this.startedconnecting = true;
				this.Connect__();
			}
		}
	}

	internal void GuiStateBackToGame()
	{
		this.guistate = GuiState.Normal;
		this.SetFreeMouse(false);
	}
	internal TypingState GuiTyping;
	internal string GuiTypingBuffer;

	internal void HandleMaterialKeys(int eKey)
	{
		if (eKey == this.GetKey(110)) {
			this.ActiveMaterial = 0;
		}
		if (eKey == this.GetKey(111)) {
			this.ActiveMaterial = 1;
		}
		if (eKey == this.GetKey(112)) {
			this.ActiveMaterial = 2;
		}
		if (eKey == this.GetKey(113)) {
			this.ActiveMaterial = 3;
		}
		if (eKey == this.GetKey(114)) {
			this.ActiveMaterial = 4;
		}
		if (eKey == this.GetKey(115)) {
			this.ActiveMaterial = 5;
		}
		if (eKey == this.GetKey(116)) {
			this.ActiveMaterial = 6;
		}
		if (eKey == this.GetKey(117)) {
			this.ActiveMaterial = 7;
		}
		if (eKey == this.GetKey(118)) {
			this.ActiveMaterial = 8;
		}
		if (eKey == this.GetKey(109)) {
			this.ActiveMaterial = 9;
		}
	}

	bool HasAsset(string md5, string name)
	{
		for (int i = 0; i < this.assets.count; i++) {
			if (this.assets.items[i].md5 == md5) {
				if (this.assets.items[i].name == name) {
					return true;
				}
			}
		}
		return false;
	}

	public byte HeadingByte(float orientationX, float orientationY, float orientationZ)
	{
		return Game.IntToByte(this.platform.FloatToInt(orientationY % (2 * Game.GetPi()) / (2 * Game.GetPi()) * 256));
	}

	public int Height()
	{
		return this.platform.GetCanvasHeight();
	}
	public const int HourDetail = 4;

	public static byte IntToByte(int a)
	{
		return (byte) a;
	}

	void InvalidPlayerWarning(int playerid)
	{
		this.platform.ConsoleWriteLine(this.platform.StringFormat("Position update of nonexistent player {0}.", this.platform.IntToString(playerid)));
	}

	internal void InvalidVersionAllow()
	{
		if (this.invalidVersionDrawMessage != null) {
			this.invalidVersionDrawMessage = null;
			this.ProcessServerIdentification(this.invalidVersionPacketIdentification);
			this.invalidVersionPacketIdentification = null;
		}
	}

	internal void InventoryClick(Packet_InventoryPosition pos)
	{
		this.SendPacketClient(ClientPackets.InventoryClick(pos));
	}

	internal Packet_InventoryPosition InventoryPositionMainArea(int x, int y)
	{
		Packet_InventoryPosition pos = new Packet_InventoryPosition();
		pos.Type = 0;
		pos.AreaX = x;
		pos.AreaY = y;
		return pos;
	}

	internal Packet_InventoryPosition InventoryPositionMaterialSelector(int materialId)
	{
		Packet_InventoryPosition pos = new Packet_InventoryPosition();
		pos.Type = 2;
		pos.MaterialId = materialId;
		return pos;
	}

	internal void InvokeMapLoadingProgress(int progressPercent, int progressBytes, string status)
	{
		this.maploadingprogress = new MapLoadingProgressEventArgs();
		this.maploadingprogress.ProgressPercent = progressPercent;
		this.maploadingprogress.ProgressBytes = progressBytes;
		this.maploadingprogress.ProgressStatus = status;
	}
	internal bool IronSights;

	internal bool IsAnyPlayerInPos(int blockposX, int blockposY, int blockposZ)
	{
		for (int i = 0; i < this.entitiesCount; i++) {
			Entity e = this.entities[i];
			if (e == null) {
				continue;
			}
			if (e.drawModel == null) {
				continue;
			}
			if (e.networkPosition == null || e.networkPosition != null && e.networkPosition.PositionLoaded) {
				if (this.IsPlayerInPos(e.position.x, e.position.y, e.position.z, blockposX, blockposY, blockposZ, e.drawModel.ModelHeight)) {
					return true;
				}
			}
		}
		return this.IsPlayerInPos(this.player.position.x, this.player.position.y, this.player.position.z, blockposX, blockposY, blockposZ, this.player.drawModel.ModelHeight);
	}

	public bool IsEmptyForPhysics(Packet_BlockType block)
	{
		return block.DrawType == 9 || block.WalkableType != 2 && block.WalkableType != 1;
	}

	internal bool IsFillBlock(int blocktype)
	{
		return blocktype == this.d_Data.BlockIdFillArea() || blocktype == this.d_Data.BlockIdFillStart() || blocktype == this.d_Data.BlockIdCuboid();
	}

	internal bool IsLava(int blockType)
	{
		string name = this.blocktypes[blockType].Name;
		if (name == null) {
			return false;
		}
		return this.platform.StringContains(name, "Lava");
	}

	bool IsPlayerInPos(float playerposX, float playerposY, float playerposZ, int blockposX, int blockposY, int blockposZ, float playerHeight)
	{
		for (int i = 0; i < this.FloorFloat(playerHeight) + 1; i++) {
			if (ScriptCharacterPhysics.BoxPointDistance(blockposX, blockposZ, blockposY, blockposX + 1, blockposZ + 1, blockposY + 1, playerposX, playerposY + i + this.constWallDistance, playerposZ) < this.constWallDistance) {
				return true;
			}
		}
		return false;
	}

	public bool IsRail(Packet_BlockType block)
	{
		return block.Rail > 0;
	}
	internal bool IsShiftPressed;
	internal bool IsTeamchat;

	internal bool IsTileEmptyForPhysics(int x, int y, int z)
	{
		if (z >= this.map.MapSizeZ) {
			return true;
		}
		if (x < 0 || y < 0 || z < 0) {
			return this.controls.GetFreemove() != 0;
		}
		if (x >= this.map.MapSizeX || y >= this.map.MapSizeY) {
			return this.controls.GetFreemove() != 0;
		}
		int block = this.map.GetBlockValid(x, y, z);
		return block == 0 || block == this.d_Data.BlockIdFillArea() || this.IsWater(block);
	}

	internal bool IsTileEmptyForPhysicsClose(int x, int y, int z)
	{
		return this.IsTileEmptyForPhysics(x, y, z) || this.map.IsValidPos(x, y, z) && this.blocktypes[this.map.GetBlock(x, y, z)].DrawType == 11 || this.map.IsValidPos(x, y, z) && this.IsEmptyForPhysics(this.blocktypes[this.map.GetBlock(x, y, z)]);
	}

	public static bool IsTransparentForLight(Packet_BlockType b)
	{
		return b.DrawType != 1 && b.DrawType != 8;
	}
	internal bool IsTyping;

	internal bool IsUsableBlock(int blocktype)
	{
		return this.d_Data.IsRailTile(blocktype) || this.blocktypes[blocktype].IsUsable;
	}

	internal bool IsValid(int blocktype)
	{
		return this.blocktypes[blocktype].Name != null;
	}

	internal bool IsWater(int blockType)
	{
		string name = this.blocktypes[blockType].Name;
		if (name == null) {
			return false;
		}
		return this.platform.StringContains(name, "Water");
	}

	internal bool IsWearingWeapon()
	{
		return this.d_Inventory.RightHand[this.ActiveMaterial] != null;
	}
	public const int KeyAltLeft = 5;
	public const int KeyAltRight = 6;

	internal void KeyDown(int eKey)
	{
		this.keyboardStateRaw[eKey] = true;
		if (this.guistate != GuiState.MapLoading) {
			for (int i = 0; i < this.clientmodsCount; i++) {
				KeyEventArgs args_ = new KeyEventArgs();
				args_.SetKeyCode(eKey);
				this.clientmods[i].OnKeyDown(this, args_);
				if (args_.GetHandled()) {
					return;
				}
			}
		}
		this.keyboardState[eKey] = true;
		this.InvalidVersionAllow();
		if (eKey == this.GetKey(15)) {
			float lagSeconds = this.one * (this.platform.TimeMillisecondsFromStart() - this.LastReceivedMilliseconds) / 1000;
			if (lagSeconds >= 10 || this.guistate == GuiState.MapLoading) {
				this.Reconnect();
			}
		}
		if (eKey == this.GetKey(1) || eKey == this.GetKey(2)) {
			this.IsShiftPressed = true;
		}
		if (this.guistate == GuiState.Normal) {
			string strFreemoveNotAllowed = "You are not allowed to enable freemove.";
			if (eKey == this.GetKey(10)) {
				if (!this.AllowFreemove) {
					this.Log(strFreemoveNotAllowed);
					return;
				}
				this.movespeed = this.basemovespeed * 1;
				this.Log("Move speed: 1x.");
			}
			if (eKey == this.GetKey(11)) {
				if (!this.AllowFreemove) {
					this.Log(strFreemoveNotAllowed);
					return;
				}
				this.movespeed = this.basemovespeed * 10;
				this.Log(this.platform.StringFormat(this.language.MoveSpeed(), this.platform.IntToString(10)));
			}
			if (eKey == this.GetKey(12)) {
				if (!this.AllowFreemove) {
					this.Log(strFreemoveNotAllowed);
					return;
				}
				this.stopPlayerMove = true;
				if (this.controls.GetFreemove() == 0) {
					this.controls.SetFreemove(1);
					this.Log(this.language.MoveFree());
				}
				else if (this.controls.GetFreemove() == 1) {
					this.controls.SetFreemove(2);
					this.Log(this.language.MoveFreeNoclip());
				}
				else if (this.controls.GetFreemove() == 2) {
					this.controls.SetFreemove(0);
					this.Log(this.language.MoveNormal());
				}
			}
			if (eKey == this.GetKey(91)) {
				this.drawblockinfo = !this.drawblockinfo;
			}
			int playerx = this.platform.FloatToInt(this.player.position.x);
			int playery = this.platform.FloatToInt(this.player.position.z);
			if (playerx >= 0 && playerx < this.map.MapSizeX && playery >= 0 && playery < this.map.MapSizeY) {
				this.performanceinfo.Set("height", this.platform.StringFormat("height:{0}", this.platform.IntToString(this.d_Heightmap.GetBlock(playerx, playery))));
			}
			if (eKey == this.GetKey(14)) {
				this.CameraChange();
			}
			if (eKey == this.GetKey(121) || eKey == this.GetKey(80)) {
				if (this.cameratype == CameraType.Overhead) {
					this.overheadcameradistance -= 1;
				}
				else if (this.cameratype == CameraType.Tpp) {
					this.tppcameradistance -= 1;
				}
			}
			if (eKey == this.GetKey(120) || eKey == this.GetKey(79)) {
				if (this.cameratype == CameraType.Overhead) {
					this.overheadcameradistance += 1;
				}
				else if (this.cameratype == CameraType.Tpp) {
					this.tppcameradistance += 1;
				}
			}
			if (this.overheadcameradistance < this.TPP_CAMERA_DISTANCE_MIN) {
				this.overheadcameradistance = this.TPP_CAMERA_DISTANCE_MIN;
			}
			if (this.overheadcameradistance > this.TPP_CAMERA_DISTANCE_MAX) {
				this.overheadcameradistance = this.TPP_CAMERA_DISTANCE_MAX;
			}
			if (this.tppcameradistance < this.TPP_CAMERA_DISTANCE_MIN) {
				this.tppcameradistance = this.TPP_CAMERA_DISTANCE_MIN;
			}
			if (this.tppcameradistance > this.TPP_CAMERA_DISTANCE_MAX) {
				this.tppcameradistance = this.TPP_CAMERA_DISTANCE_MAX;
			}
			if (eKey == this.GetKey(15)) {
				this.RedrawAllBlocks();
			}
			if (eKey == 17) {
				this.ToggleVsync();
				if (this.ENABLE_LAG == 0) {
					this.Log(this.language.FrameRateVsync());
				}
				if (this.ENABLE_LAG == 1) {
					this.Log(this.language.FrameRateUnlimited());
				}
				if (this.ENABLE_LAG == 2) {
					this.Log(this.language.FrameRateLagSimulation());
				}
			}
			if (eKey == this.GetKey(52)) {
				this.SendPacketClient(ClientPackets.SpecialKeyTabPlayerList());
			}
			if (eKey == this.GetKey(87)) {
				if (this.currentAttackedBlock != null) {
					int posX = this.currentAttackedBlock.X;
					int posY = this.currentAttackedBlock.Y;
					int posZ = this.currentAttackedBlock.Z;
					int blocktype = this.map.GetBlock(this.currentAttackedBlock.X, this.currentAttackedBlock.Y, this.currentAttackedBlock.Z);
					if (this.IsUsableBlock(blocktype)) {
						if (this.d_Data.IsRailTile(blocktype)) {
							this.player.position.x = posX + this.one / 2;
							this.player.position.y = posZ + 1;
							this.player.position.z = posY + this.one / 2;
							this.stopPlayerMove = true;
							this.controls.SetFreemove(0);
						}
						else {
							this.SendSetBlock(posX, posY, posZ, 2, 0, this.ActiveMaterial);
						}
					}
				}
				if (this.currentlyAttackedEntity != -1) {
					if (this.entities[this.currentlyAttackedEntity].usable) {
						for (int i = 0; i < this.clientmodsCount; i++) {
							if (this.clientmods[i] == null) {
								continue;
							}
							OnUseEntityArgs args = new OnUseEntityArgs();
							args.entityId = this.currentlyAttackedEntity;
							this.clientmods[i].OnUseEntity(this, args);
						}
						this.SendPacketClient(ClientPackets.UseEntity(this.currentlyAttackedEntity));
					}
				}
			}
			if (eKey == this.GetKey(97)) {
				this.Respawn();
			}
			if (eKey == this.GetKey(94)) {
				this.SendPacketClient(ClientPackets.SpecialKeySelectTeam());
			}
			if (eKey == this.GetKey(98)) {
				this.SendPacketClient(ClientPackets.SpecialKeySetSpawn());
				this.playerPositionSpawnX = this.player.position.x;
				this.playerPositionSpawnY = this.player.position.y;
				this.playerPositionSpawnZ = this.player.position.z;
				this.player.position.x = this.platform.FloatToInt(this.player.position.x) + this.one / 2;
				this.player.position.z = this.platform.FloatToInt(this.player.position.z) + this.one / 2;
			}
			if (eKey == this.GetKey(88)) {
				this.ToggleFog();
				this.Log(this.platform.StringFormat(this.language.FogDistance(), this.platform.IntToString(this.platform.FloatToInt(this.d_Config3d.viewdistance))));
				this.OnResize();
			}
			if (eKey == this.GetKey(84)) {
				this.ShowInventory();
				return;
			}
			this.HandleMaterialKeys(eKey);
		}
		if (this.guistate == GuiState.Inventory) {
			if (eKey == this.GetKey(84) || eKey == this.GetKey(50)) {
				this.GuiStateBackToGame();
			}
			return;
		}
		if (this.guistate == GuiState.MapLoading) {
			if (eKey == this.GetKey(50)) {
				this.ExitToMainMenu_();
			}
		}
		if (this.guistate == GuiState.CraftingRecipes) {
			if (eKey == this.GetKey(50)) {
				this.GuiStateBackToGame();
			}
		}
		if (this.guistate == GuiState.Normal) {
			if (eKey == this.GetKey(50)) {
				this.EscapeMenuStart();
				return;
			}
		}
	}

	internal void KeyPress(int eKeyChar)
	{
		for (int i = 0; i < this.clientmodsCount; i++) {
			if (this.clientmods[i] == null) {
				continue;
			}
			KeyPressEventArgs args_ = new KeyPressEventArgs();
			args_.SetKeyChar(eKeyChar);
			this.clientmods[i].OnKeyPress(this, args_);
			if (args_.GetHandled()) {
				return;
			}
		}
	}

	internal void KeyUp(int eKey)
	{
		this.keyboardStateRaw[eKey] = false;
		for (int i = 0; i < this.clientmodsCount; i++) {
			KeyEventArgs args_ = new KeyEventArgs();
			args_.SetKeyCode(eKey);
			this.clientmods[i].OnKeyUp(this, args_);
			if (args_.GetHandled()) {
				return;
			}
		}
		this.keyboardState[eKey] = false;
		if (eKey == this.GetKey(1) || eKey == this.GetKey(2)) {
			this.IsShiftPressed = false;
		}
	}
	internal int LastReceivedMilliseconds;

	internal bool LavaSwimmingCamera()
	{
		return this.IsLava(this.GetCameraBlock());
	}

	internal float Length(float x, float y, float z)
	{
		return this.platform.MathSqrt(x * x + y * y + z * z);
	}
	internal int[] LoadedAmmo;
	internal int LocalPlayerId;

	internal void Log(string p)
	{
		this.AddChatline(p);
	}

	internal void MainThreadOnRenderFrame(float deltaTime)
	{
		this.UpdateResize();
		if (this.guistate == GuiState.MapLoading) {
			this.platform.GlClearColorRgbaf(0, 0, 0, 1);
		}
		else {
			this.platform.GlClearColorRgbaf(this.one * 0 / 255, this.one * 0 / 255, this.one * 0 / 255, this.one * 255 / 255);
		}
		this.mouseSmoothingAccum += deltaTime;
		float constMouseDt = 1f / 300;
		while (this.mouseSmoothingAccum > constMouseDt) {
			this.mouseSmoothingAccum -= constMouseDt;
			this.UpdateMouseViewportControl(constMouseDt);
		}
		this.platform.ApplicationDoEvents();
		this.accumulator += deltaTime;
		if (this.accumulator > 1) {
			this.accumulator = 1;
		}
		float dt = this.one / 75;
		while (this.accumulator >= dt) {
			this.FrameTick(dt);
			this.accumulator -= dt;
		}
		if (this.guistate == GuiState.MapLoading) {
			this.GotoDraw2d(deltaTime);
			return;
		}
		if (this.ENABLE_LAG == 2) {
			this.platform.ThreadSpinWait(20000000);
		}
		this.SetAmbientLight(this.terraincolor());
		this.platform.GlClearColorBufferAndDepthBuffer();
		this.platform.BindTexture2d(this.d_TerrainTextures.terrainTexture());
		for (int i = 0; i < this.clientmodsCount; i++) {
			if (this.clientmods[i] == null) {
				continue;
			}
			this.clientmods[i].OnBeforeNewFrameDraw3d(this, deltaTime);
		}
		this.GLMatrixModeModelView();
		this.GLLoadMatrix(this.camera);
		this.CameraMatrix.lastmvmatrix = this.camera;
		this.d_FrustumCulling.CalcFrustumEquations();
		bool drawgame = this.guistate != GuiState.MapLoading;
		if (drawgame) {
			this.platform.GlEnableDepthTest();
			for (int i = 0; i < this.clientmodsCount; i++) {
				if (this.clientmods[i] == null) {
					continue;
				}
				this.clientmods[i].OnNewFrameDraw3d(this, deltaTime);
			}
		}
		this.GotoDraw2d(deltaTime);
	}

	CachedTexture MakeTextTexture(Text_ t)
	{
		CachedTexture ct = new CachedTexture();
		BitmapCi bmp = this.textColorRenderer.CreateTextTexture(t);
		ct.sizeX = this.platform.BitmapGetWidth(bmp);
		ct.sizeY = this.platform.BitmapGetHeight(bmp);
		ct.textureId = this.platform.LoadTextureFromBitmap(bmp);
		this.platform.BitmapDelete(bmp);
		return ct;
	}

	internal void MapLoaded()
	{
		this.RedrawAllBlocks();
		this.materialSlots = this.d_Data.DefaultMaterialSlots();
		this.GuiStateBackToGame();
		this.playerPositionSpawnX = this.player.position.x;
		this.playerPositionSpawnY = this.player.position.y;
		this.playerPositionSpawnZ = this.player.position.z;
	}

	public void MapLoadingStart()
	{
		this.guistate = GuiState.MapLoading;
		this.SetFreeMouse(true);
		this.maploadingprogress = new MapLoadingProgressEventArgs();
		this.fontMapLoading = FontCi.Create("Arial", 14, 0);
	}

	public int MaterialSlots_(int i)
	{
		Packet_Item item = this.d_Inventory.RightHand[i];
		int m = this.d_Data.BlockIdDirt();
		if (item != null && item.ItemClass == 0) {
			m = this.d_Inventory.RightHand[i].BlockId;
		}
		return m;
	}

	public int MathFloor(float a)
	{
		if (a >= 0) {
			return this.platform.FloatToInt(a);
		}
		else {
			return this.platform.FloatToInt(a) - 1;
		}
	}

	internal void MouseDown(MouseEventArgs args)
	{
		if (args.GetButton() == 0) {
			this.mouseLeft = true;
		}
		if (args.GetButton() == 1) {
			this.mouseMiddle = true;
		}
		if (args.GetButton() == 2) {
			this.mouseRight = true;
		}
		if (args.GetButton() == 0) {
			this.mouseleftclick = true;
		}
		if (args.GetButton() == 2) {
			this.mouserightclick = true;
		}
		for (int i = 0; i < this.clientmodsCount; i++) {
			if (this.clientmods[i] == null) {
				continue;
			}
			this.clientmods[i].OnMouseDown(this, args);
		}
		if (this.mousePointerLockShouldBe) {
			this.platform.RequestMousePointerLock();
			this.mouseDeltaX = 0;
			this.mouseDeltaY = 0;
		}
		this.InvalidVersionAllow();
	}

	public void MouseMove(MouseEventArgs e)
	{
		if (!e.GetEmulated() || e.GetForceUsage()) {
			this.mouseCurrentX = e.GetX();
			this.mouseCurrentY = e.GetY();
		}
		if (e.GetEmulated() || e.GetForceUsage()) {
			this.mouseDeltaX += e.GetMovementX();
			this.mouseDeltaY += e.GetMovementY();
		}
		for (int i = 0; i < this.clientmodsCount; i++) {
			if (this.clientmods[i] == null) {
				continue;
			}
			this.clientmods[i].OnMouseMove(this, e);
		}
	}

	internal void MouseUp(MouseEventArgs args)
	{
		if (args.GetButton() == 0) {
			this.mouseLeft = false;
		}
		if (args.GetButton() == 1) {
			this.mouseMiddle = false;
		}
		if (args.GetButton() == 2) {
			this.mouseRight = false;
		}
		if (args.GetButton() == 0) {
			this.mouseleftdeclick = true;
		}
		if (args.GetButton() == 2) {
			this.mouserightdeclick = true;
		}
		for (int i = 0; i < this.clientmodsCount; i++) {
			if (this.clientmods[i] == null) {
				continue;
			}
			this.clientmods[i].OnMouseUp(this, args);
		}
	}

	internal void MouseWheelChanged(MouseWheelEventArgs e)
	{
		float eDeltaPrecise = e.GetDeltaPrecise();
		if (this.keyboardState[this.GetKey(1)]) {
			if (this.cameratype == CameraType.Overhead) {
				this.overheadcameradistance -= eDeltaPrecise;
				if (this.overheadcameradistance < this.TPP_CAMERA_DISTANCE_MIN) {
					this.overheadcameradistance = this.TPP_CAMERA_DISTANCE_MIN;
				}
				if (this.overheadcameradistance > this.TPP_CAMERA_DISTANCE_MAX) {
					this.overheadcameradistance = this.TPP_CAMERA_DISTANCE_MAX;
				}
			}
			if (this.cameratype == CameraType.Tpp) {
				this.tppcameradistance -= eDeltaPrecise;
				if (this.tppcameradistance < this.TPP_CAMERA_DISTANCE_MIN) {
					this.tppcameradistance = this.TPP_CAMERA_DISTANCE_MIN;
				}
				if (this.tppcameradistance > this.TPP_CAMERA_DISTANCE_MAX) {
					this.tppcameradistance = this.TPP_CAMERA_DISTANCE_MAX;
				}
			}
		}
		for (int i = 0; i < this.clientmodsCount; i++) {
			if (this.clientmods[i] == null) {
				continue;
			}
			this.clientmods[i].OnMouseWheelChanged(this, e);
		}
	}

	internal float MoveSpeedNow()
	{
		float movespeednow = this.movespeed;
		{
			int blockunderplayer = this.BlockUnderPlayer();
			if (blockunderplayer != -1) {
				float floorSpeed = this.d_Data.WalkSpeed()[blockunderplayer];
				if (floorSpeed != 0) {
					movespeednow *= floorSpeed;
				}
			}
		}
		if (this.keyboardState[this.GetKey(1)]) {
			movespeednow *= this.one * 2 / 10;
		}
		Packet_Item item = this.d_Inventory.RightHand[this.ActiveMaterial];
		if (item != null && item.ItemClass == 0) {
			float itemSpeed = this.DeserializeFloat(this.blocktypes[item.BlockId].WalkSpeedWhenUsedFloat);
			if (itemSpeed != 0) {
				movespeednow *= itemSpeed;
			}
			if (this.IronSights) {
				float ironSightsSpeed = this.DeserializeFloat(this.blocktypes[item.BlockId].IronSightsMoveSpeedFloat);
				if (ironSightsSpeed != 0) {
					movespeednow *= ironSightsSpeed;
				}
			}
		}
		return movespeednow;
	}

	internal void MoveToInventory(Packet_InventoryPosition from)
	{
		this.SendPacketClient(ClientPackets.MoveToInventory(from));
	}

	internal BlockPosSide Nearest(BlockPosSide[] pick2, int pick2Count, float x, float y, float z)
	{
		float minDist = 1000000;
		BlockPosSide nearest = null;
		for (int i = 0; i < pick2Count; i++) {
			float dist = this.Dist(pick2[i].blockPos[0], pick2[i].blockPos[1], pick2[i].blockPos[2], x, y, z);
			if (dist < minDist) {
				minDist = dist;
				nearest = pick2[i];
			}
		}
		return nearest;
	}
	internal Packet_BlockType[] NewBlockTypes;

	public float NextFloat(float min, float max)
	{
		return this.rnd.NextFloat() * (max - min) + min;
	}
	internal int[] NightLevels;

	public void OnBackPressed()
	{
	}

	internal void OnFocusChanged()
	{
		if (this.guistate == GuiState.Normal) {
			this.EscapeMenuStart();
		}
	}

	public void OnRenderFrame(float deltaTime)
	{
		this.taskScheduler.Update(this, deltaTime);
	}

	internal void OnResize()
	{
		this.platform.GlViewport(0, 0, this.Width(), this.Height());
		this.Set3dProjection2();
		if (this.sendResize) {
			this.SendGameResolution();
		}
	}

	public void OnTouchEnd(TouchEventArgs e)
	{
		this.mouseCurrentX = 0;
		this.mouseCurrentY = 0;
		for (int i = 0; i < this.clientmodsCount; i++) {
			if (this.clientmods[i] == null) {
				continue;
			}
			this.clientmods[i].OnTouchEnd(this, e);
			if (e.GetHandled()) {
				return;
			}
		}
	}

	public void OnTouchMove(TouchEventArgs e)
	{
		for (int i = 0; i < this.clientmodsCount; i++) {
			if (this.clientmods[i] == null) {
				continue;
			}
			this.clientmods[i].OnTouchMove(this, e);
			if (e.GetHandled()) {
				return;
			}
		}
	}

	public void OnTouchStart(TouchEventArgs e)
	{
		this.InvalidVersionAllow();
		this.mouseCurrentX = e.GetX();
		this.mouseCurrentY = e.GetY();
		this.mouseleftclick = true;
		for (int i = 0; i < this.clientmodsCount; i++) {
			if (this.clientmods[i] == null) {
				continue;
			}
			this.clientmods[i].OnTouchStart(this, e);
			if (e.GetHandled()) {
				return;
			}
		}
	}

	public void OrthoMode(int width, int height)
	{
		this.GLMatrixModeProjection();
		this.GLPushMatrix();
		this.GLLoadIdentity();
		this.GLOrtho(0, width, height, 0, 0, 1);
		this.SetMatrixUniformProjection();
		this.GLMatrixModeModelView();
		this.GLPushMatrix();
		this.GLLoadIdentity();
		this.SetMatrixUniformModelView();
	}
	internal float PICK_DISTANCE;

	public void PerspectiveMode()
	{
		this.GLMatrixModeProjection();
		this.GLPopMatrix();
		this.SetMatrixUniformProjection();
		this.GLMatrixModeModelView();
		this.GLPopMatrix();
		this.SetMatrixUniformModelView();
	}

	public BlockPosSide[] Pick(BlockOctreeSearcher s_, Line3D line, IntRef retCount)
	{
		int minX = this.platform.FloatToInt(MathCi.MinFloat(line.Start[0], line.End[0]));
		int minY = this.platform.FloatToInt(MathCi.MinFloat(line.Start[1], line.End[1]));
		int minZ = this.platform.FloatToInt(MathCi.MinFloat(line.Start[2], line.End[2]));
		if (minX < 0) {
			minX = 0;
		}
		if (minY < 0) {
			minY = 0;
		}
		if (minZ < 0) {
			minZ = 0;
		}
		int maxX = this.platform.FloatToInt(MathCi.MaxFloat(line.Start[0], line.End[0]));
		int maxY = this.platform.FloatToInt(MathCi.MaxFloat(line.Start[1], line.End[1]));
		int maxZ = this.platform.FloatToInt(MathCi.MaxFloat(line.Start[2], line.End[2]));
		if (maxX > this.map.MapSizeX) {
			maxX = this.map.MapSizeX;
		}
		if (maxY > this.map.MapSizeZ) {
			maxY = this.map.MapSizeZ;
		}
		if (maxZ > this.map.MapSizeY) {
			maxZ = this.map.MapSizeY;
		}
		int sizex = maxX - minX + 1;
		int sizey = maxY - minY + 1;
		int sizez = maxZ - minZ + 1;
		int size = BitTools.NextPowerOfTwo(MathCi.MaxInt(sizex, MathCi.MaxInt(sizey, sizez)));
		s_.StartBox = Box3D.Create(minX, minY, minZ, size);
		BlockPosSide[] pick2 = s_.LineIntersection(IsBlockEmpty_.Create(this), GetBlockHeight_.Create(this), line, retCount);
		this.PickSort(pick2, retCount.value, line.Start[0], line.Start[1], line.Start[2]);
		return pick2;
	}

	void PickSort(BlockPosSide[] pick, int pickCount, float x, float y, float z)
	{
		bool changed = false;
		do {
			changed = false;
			for (int i = 0; i < pickCount - 1; i++) {
				float dist = this.Dist(pick[i].blockPos[0], pick[i].blockPos[1], pick[i].blockPos[2], x, y, z);
				float distNext = this.Dist(pick[i + 1].blockPos[0], pick[i + 1].blockPos[1], pick[i + 1].blockPos[2], x, y, z);
				if (dist > distNext) {
					changed = true;
					BlockPosSide swapTemp = pick[i];
					pick[i] = pick[i + 1];
					pick[i + 1] = swapTemp;
				}
			}
		}
		while (changed);
	}

	public byte PitchByte(float orientationX, float orientationY, float orientationZ)
	{
		float xx = (orientationX + Game.GetPi()) % (2 * Game.GetPi());
		xx = xx / (2 * Game.GetPi());
		return Game.IntToByte(this.platform.FloatToInt(xx * 256));
	}

	public void PlaySoundAt(string name, float x, float y, float z)
	{
		if (x == 0 && y == 0 && z == 0) {
			this.AudioPlay(name);
		}
		else {
			this.AudioPlayAt(name, x, z, y);
		}
	}
	internal float PlayerPushDistance;
	internal Packet_ServerPlayerStats PlayerStats;

	internal void ProcessServerIdentification(Packet_Server packet)
	{
		this.LocalPlayerId = packet.Identification.AssignedClientId;
		this.ServerInfo.connectdata = this.connectdata;
		this.ServerInfo.ServerName = packet.Identification.ServerName;
		this.ServerInfo.ServerMotd = packet.Identification.ServerMotd;
		this.d_TerrainChunkTesselator.ENABLE_TEXTURE_TILING = packet.Identification.RenderHint_ == 0;
		Packet_StringList requiredMd5 = packet.Identification.RequiredBlobMd5;
		Packet_StringList requiredName = packet.Identification.RequiredBlobName;
		this.ChatLog("[GAME] Processed server identification");
		int getCount = 0;
		if (requiredMd5 != null) {
			this.ChatLog(this.platform.StringFormat("[GAME] Server has {0} assets", this.platform.IntToString(requiredMd5.ItemsCount)));
			for (int i = 0; i < requiredMd5.ItemsCount; i++) {
				string md5 = requiredMd5.Items[i];
				if (this.platform.IsCached(md5)) {
					Asset cachedAsset = this.platform.LoadAssetFromCache(md5);
					string name;
					if (requiredName != null) {
						name = requiredName.Items[i];
					}
					else {
						name = cachedAsset.name;
					}
					this.SetFile(name, cachedAsset.md5, cachedAsset.data, cachedAsset.dataLength);
				}
				else {
					if (requiredName != null) {
						if (!this.HasAsset(md5, requiredName.Items[i])) {
							this.getAsset[getCount++] = md5;
						}
					}
					else {
						this.getAsset[getCount++] = md5;
					}
				}
			}
			this.ChatLog(this.platform.StringFormat("[GAME] Will download {0} missing assets", this.platform.IntToString(getCount)));
		}
		this.SendGameResolution();
		this.ChatLog("[GAME] Sent window resolution to server");
		this.sendResize = true;
		this.SendRequestBlob(this.getAsset, getCount);
		this.ChatLog("[GAME] Sent BLOB request");
		if (packet.Identification.MapSizeX != this.map.MapSizeX || packet.Identification.MapSizeY != this.map.MapSizeY || packet.Identification.MapSizeZ != this.map.MapSizeZ) {
			this.map.Reset(packet.Identification.MapSizeX, packet.Identification.MapSizeY, packet.Identification.MapSizeZ);
			this.d_Heightmap.Restart();
		}
		this.shadowssimple = packet.Identification.DisableShadows == 1 ? true : false;
		this.maxdrawdistance = 256;
		this.ChatLog("[GAME] Map initialized");
	}

	public void QueueActionCommit(Action_ action)
	{
		this.commitActions.Add(action);
	}

	internal static float RadToAngle256(float value)
	{
		return value / (2 * Game.GetPi()) * 255;
	}
	internal float RadiusWhenMoving;
	internal int ReceivedMapLength;

	internal void Reconnect()
	{
		this.reconnect = true;
	}

	internal void RedrawAllBlocks()
	{
		this.shouldRedrawAllBlocks = true;
	}

	internal void RedrawBlock(int x, int y, int z)
	{
		this.map.SetBlockDirty(x, y, z);
	}

	internal void Respawn()
	{
		this.SendPacketClient(ClientPackets.SpecialKeyRespawn());
		this.stopPlayerMove = true;
	}

	internal void RevertSpeculative(float dt)
	{
		for (int i = 0; i < this.speculativeCount; i++) {
			Speculative s_ = this.speculative[i];
			if (s_ == null) {
				continue;
			}
			if (this.one * (this.platform.TimeMillisecondsFromStart() - s_.timeMilliseconds) / 1000 > 2) {
				this.RedrawBlock(s_.x, s_.y, s_.z);
				this.speculative[i] = null;
			}
		}
	}

	public float Scale()
	{
		if (this.platform.IsSmallScreen()) {
			float scale = this.one * this.Width() / 1280;
			return scale;
		}
		else {
			return this.one;
		}
	}
	internal int SelectedBlockPositionX;
	internal int SelectedBlockPositionY;
	internal int SelectedBlockPositionZ;
	internal int SelectedEntityId;

	internal void SendChat(string s)
	{
		this.SendPacketClient(ClientPackets.Chat(s, this.IsTeamchat ? 1 : 0));
	}

	internal void SendFillArea(int startx, int starty, int startz, int endx, int endy, int endz, int blockType)
	{
		this.SendPacketClient(ClientPackets.FillArea(startx, starty, startz, endx, endy, endz, blockType, this.ActiveMaterial));
	}

	internal void SendGameResolution()
	{
		this.SendPacketClient(ClientPackets.GameResolution(this.Width(), this.Height()));
	}

	internal void SendLeave(int reason)
	{
		this.SendPacketClient(ClientPackets.Leave(reason));
	}

	public void SendPacket(byte[] packet, int packetLength)
	{
		INetOutgoingMessage msg = new INetOutgoingMessage();
		msg.Write(packet, packetLength);
		this.main.SendMessage(msg, MyNetDeliveryMethod.ReliableOrdered);
	}

	public void SendPacketClient(Packet_Client packetClient)
	{
		byte[] packet = this.Serialize(packetClient, this.packetLen);
		this.SendPacket(packet, this.packetLen.value);
	}

	internal void SendPingReply()
	{
		this.SendPacketClient(ClientPackets.PingReply());
	}

	internal void SendRequestBlob(string[] required, int requiredCount)
	{
		this.SendPacketClient(ClientPackets.RequestBlob(this, required, requiredCount));
	}

	internal void SendSetBlock(int x, int y, int z, int mode, int type, int materialslot)
	{
		this.SendPacketClient(ClientPackets.SetBlock(x, y, z, mode, type, materialslot));
	}

	internal void SendSetBlockAndUpdateSpeculative(int material, int x, int y, int z, int mode)
	{
		this.SendSetBlock(x, y, z, mode, material, this.ActiveMaterial);
		Packet_Item item = this.d_Inventory.RightHand[this.ActiveMaterial];
		if (item != null && item.ItemClass == 0) {
			int blockid = material;
			if (mode == 0) {
				blockid = 0;
			}
			Speculative s_ = new Speculative();
			s_.x = x;
			s_.y = y;
			s_.z = z;
			s_.blocktype = this.map.GetBlock(x, y, z);
			s_.timeMilliseconds = this.platform.TimeMillisecondsFromStart();
			this.AddSpeculative(s_);
			this.SetBlock(x, y, z, blockid);
			this.RedrawBlock(x, y, z);
		}
		else {
		}
	}

	public byte[] Serialize(Packet_Client packet, IntRef retLength)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ClientSerializer.Serialize(ms, packet);
		byte[] data = ms.ToArray();
		retLength.value = ms.Length();
		return data;
	}

	public int SerializeFloat(float p)
	{
		return this.platform.FloatToInt(p * 32);
	}
	internal ServerInformation ServerInfo;

	public void Set3dProjection(float zfar, float fov)
	{
		float aspect_ratio = this.one * this.Width() / this.Height();
		Mat4.Perspective(this.Set3dProjectionTempMat4, fov, aspect_ratio, this.znear, zfar);
		this.CameraMatrix.lastpmatrix = this.Set3dProjectionTempMat4;
		this.GLMatrixModeProjection();
		this.GLLoadMatrix(this.Set3dProjectionTempMat4);
		this.SetMatrixUniformProjection();
	}

	internal void Set3dProjection1(float zfar_)
	{
		this.Set3dProjection(zfar_, this.currentfov());
	}

	internal void Set3dProjection2()
	{
		this.Set3dProjection1(this.zfar());
	}
	float[] Set3dProjectionTempMat4;

	internal void SetAmbientLight(int color)
	{
		int r = Game.ColorR(color);
		int g = Game.ColorG(color);
		int b = Game.ColorB(color);
		this.platform.GlLightModelAmbient(r, g, b);
	}

	internal void SetBlock(int x, int y, int z, int tileType)
	{
		this.map.SetBlockRaw(x, y, z, tileType);
		this.map.SetChunkDirty(x / 16, y / 16, z / 16, true, true);
		this.ShadowsOnSetBlock(x, y, z);
		this.lastplacedblockX = x;
		this.lastplacedblockY = y;
		this.lastplacedblockZ = z;
	}

	internal void SetCamera(CameraType type)
	{
		if (type == CameraType.Fpp) {
			this.cameratype = CameraType.Fpp;
			this.SetFreeMouse(false);
			this.ENABLE_TPP_VIEW = false;
			this.overheadcamera = false;
		}
		else if (type == CameraType.Tpp) {
			this.cameratype = CameraType.Tpp;
			this.ENABLE_TPP_VIEW = true;
		}
		else {
			this.cameratype = CameraType.Overhead;
			this.overheadcamera = true;
			this.SetFreeMouse(true);
			this.ENABLE_TPP_VIEW = true;
			this.playerdestination = Vector3Ref.Create(this.player.position.x, this.player.position.y, this.player.position.z);
		}
	}

	internal void SetCharacterEyesHeight(float value)
	{
		this.entities[this.LocalPlayerId].drawModel.eyeHeight = value;
	}

	public void SetFile(string name, string md5, byte[] downloaded, int downloadedLength)
	{
		string nameLowercase = this.platform.StringToLower(name);
		if (nameLowercase == "mousecursor.png") {
			this.platform.SetWindowCursor(0, 0, 32, 32, downloaded, downloadedLength);
		}
		Asset newAsset = new Asset();
		newAsset.data = downloaded;
		newAsset.dataLength = downloadedLength;
		newAsset.name = nameLowercase;
		newAsset.md5 = md5;
		for (int i = 0; i < this.assets.count; i++) {
			if (this.assets.items[i] == null) {
				continue;
			}
			if (this.assets.items[i].name == nameLowercase) {
				if (this.options.UseServerTextures) {
					this.assets.items[i] = newAsset;
				}
				this.CacheAsset(newAsset);
				return;
			}
		}
		this.assets.items[this.assets.count++] = newAsset;
		this.CacheAsset(newAsset);
	}

	internal void SetFog()
	{
		if (this.d_Config3d.viewdistance >= 512) {
			return;
		}
		float density = this.one * 25 / 10000;
		int fogR;
		int fogG;
		int fogB;
		int fogA;
		if (this.SkySphereNight && !this.shadowssimple) {
			fogR = 0;
			fogG = 0;
			fogB = 0;
			fogA = 255;
		}
		else {
			fogR = 0;
			fogG = 0;
			fogB = 0;
			fogA = 255;
		}
		this.platform.GlEnableFog();
		this.platform.GlHintFogHintNicest();
		this.platform.GlFogFogModeExp2();
		this.platform.GlFogFogColor(fogR, fogG, fogB, fogA);
		this.platform.GlFogFogDensity(density);
	}

	public void SetFreeMouse(bool value)
	{
		this.mousePointerLockShouldBe = !value;
		if (value) {
			this.platform.ExitMousePointerLock();
		}
		else {
			this.platform.RequestMousePointerLock();
		}
	}

	public void SetMatrixUniformModelView()
	{
		this.platform.SetMatrixUniformModelView(this.mvMatrix.Peek());
	}

	public void SetMatrixUniformProjection()
	{
		this.platform.SetMatrixUniformProjection(this.pMatrix.Peek());
	}

	public void SetMatrixUniforms()
	{
		this.platform.SetMatrixUniformProjection(this.pMatrix.Peek());
		this.platform.SetMatrixUniformModelView(this.mvMatrix.Peek());
	}

	public void SetPlatform(GamePlatform value)
	{
		this.platform = value;
	}

	internal void SetTileAndUpdate(int x, int y, int z, int type)
	{
		this.SetBlock(x, y, z, type);
		this.RedrawBlock(x, y, z);
	}

	internal void ShadowsOnSetBlock(int x, int y, int z)
	{
		int oldheight = this.d_Heightmap.GetBlock(x, y);
		this.UpdateColumnHeight(x, y);
		int newheight = this.d_Heightmap.GetBlock(x, y);
		int min = MathCi.MinInt(oldheight, newheight);
		int max = MathCi.MaxInt(oldheight, newheight);
		for (int i = min; i < max; i++) {
			if (i / 16 != z / 16) {
				this.map.SetChunkDirty(x / 16, y / 16, i / 16, true, true);
			}
		}
		for (int xx = 0; xx < 3; xx++) {
			for (int yy = 0; yy < 3; yy++) {
				for (int zz = 0; zz < 3; zz++) {
					int cx = x / 16 + xx - 1;
					int cy = y / 16 + yy - 1;
					int cz = z / 16 + zz - 1;
					if (this.map.IsValidChunkPos(cx, cy, cz)) {
						this.map.SetChunkDirty(cx, cy, cz, true, false);
					}
				}
			}
		}
	}

	public void ShowEscapeMenu()
	{
		this.guistate = GuiState.EscapeMenu;
		this.menustate = new MenuState();
		this.SetFreeMouse(true);
	}

	public void ShowInventory()
	{
		this.guistate = GuiState.Inventory;
		this.menustate = new MenuState();
		this.SetFreeMouse(true);
	}
	internal bool SkySphereNight;

	public void Start()
	{
		this.textColorRenderer = new TextColorRenderer();
		this.textColorRenderer.platform = this.platform;
		this.language.platform = this.platform;
		this.language.LoadTranslations();
		GameData gamedata = new GameData();
		gamedata.Start();
		Config3d config3d = new Config3d();
		if (this.platform.IsFastSystem()) {
			config3d.viewdistance = 128;
		}
		else {
			config3d.viewdistance = 32;
		}
		ITerrainTextures terrainTextures = new ITerrainTextures();
		terrainTextures.game = this;
		this.d_TextureAtlasConverter = new TextureAtlasConverter();
		this.d_TerrainTextures = terrainTextures;
		FrustumCulling frustumculling = new FrustumCulling();
		frustumculling.d_GetCameraMatrix = this.CameraMatrix;
		frustumculling.platform = this.platform;
		this.d_FrustumCulling = frustumculling;
		TerrainChunkTesselatorCi terrainchunktesselator = new TerrainChunkTesselatorCi();
		this.d_TerrainChunkTesselator = terrainchunktesselator;
		this.d_Batcher = new MeshBatcher();
		this.d_Batcher.d_FrustumCulling = frustumculling;
		this.d_Batcher.game = this;
		this.d_FrustumCulling = frustumculling;
		this.d_Data = gamedata;
		this.d_DataMonsters = new GameDataMonsters();
		this.d_Config3d = config3d;
		ModDrawParticleEffectBlockBreak particle = new ModDrawParticleEffectBlockBreak();
		this.particleEffectBlockBreak = particle;
		this.d_Data = gamedata;
		this.d_TerrainTextures = terrainTextures;
		this.map.Reset(256, 256, 128);
		SunMoonRenderer sunmoonrenderer = new SunMoonRenderer();
		this.d_SunMoonRenderer = sunmoonrenderer;
		this.d_SunMoonRenderer = sunmoonrenderer;
		this.d_Heightmap = new InfiniteMapChunked2d();
		this.d_Heightmap.d_Map = this;
		this.d_Heightmap.Restart();
		this.d_TerrainChunkTesselator = terrainchunktesselator;
		terrainchunktesselator.game = this;
		Packet_Inventory inventory = new Packet_Inventory();
		inventory.RightHand = new Packet_Item[10];
		GameDataItemsClient dataItems = new GameDataItemsClient();
		dataItems.game = this;
		InventoryUtilClient inventoryUtil = new InventoryUtilClient();
		this.d_Inventory = inventory;
		this.d_InventoryUtil = inventoryUtil;
		inventoryUtil.d_Inventory = inventory;
		inventoryUtil.d_Items = dataItems;
		this.d_Inventory = inventory;
		this.platform.AddOnCrash(OnCrashHandlerLeave.Create(this));
		this.rnd = this.platform.RandomCreate();
		this.clientmods = new ClientMod[128];
		this.clientmodsCount = 0;
		this.modmanager.game = this;
		this.AddMod(new ModDrawMain());
		this.AddMod(new ModUpdateMain());
		this.AddMod(new ModNetworkProcess());
		this.AddMod(new ModUnloadRendererChunks());
		this.AddMod(new ModAutoCamera());
		this.AddMod(new ModFpsHistoryGraph());
		this.AddMod(new ModWalkSound());
		this.AddMod(new ModFallDamageToPlayer());
		this.AddMod(new ModBlockDamageToPlayer());
		this.AddMod(new ModLoadPlayerTextures());
		this.AddMod(new ModSendPosition());
		this.AddMod(new ModInterpolatePositions());
		this.AddMod(new ModRail());
		this.AddMod(new ModCompass());
		this.AddMod(new ModGrenade());
		this.AddMod(new ModBullet());
		this.AddMod(new ModExpire());
		this.AddMod(new ModReloadAmmo());
		this.AddMod(new ModPush());
		if (this.platform.IsFastSystem()) {
			this.AddMod(new ModSkySphereAnimated());
		}
		else {
			this.AddMod(new ModSkySphereStatic());
		}
		this.AddMod(sunmoonrenderer);
		this.AddMod(new ModDrawTestModel());
		this.AddMod(new ModDrawLinesAroundSelectedBlock());
		this.AddMod(new ModDebugChunk());
		this.AddMod(new ModDrawArea());
		this.AddMod(new ModDrawTerrain());
		this.AddMod(new ModDrawPlayers());
		this.AddMod(new ModDrawPlayerNames());
		this.AddMod(new ModDrawText());
		this.AddMod(new ModDrawParticleEffectBlockBreak());
		this.AddMod(new ModDrawSprites());
		this.AddMod(new ModDrawMinecarts());
		this.AddMod(new ModDrawHand2d());
		this.AddMod(new ModDrawHand3d());
		this.AddMod(new ModGuiCrafting());
		this.AddMod(new ModDialog());
		this.AddMod(new ModPicking());
		this.AddMod(new ModClearInactivePlayersDrawInfo());
		this.AddMod(new ModCameraKeys());
		this.AddMod(new ModSendActiveMaterial());
		this.AddMod(new ModCamera());
		this.AddMod(new ModNetworkEntity());
		this.AddMod(new ModGuiInventory());
		this.AddMod(new ModGuiTouchButtons());
		this.AddMod(new ModGuiEscapeMenu());
		this.AddMod(new ModGuiMapLoading());
		this.AddMod(new ModDraw2dMisc());
		this.AddMod(new ModGuiPlayerStats());
		this.AddMod(new ModGuiChat());
		this.AddMod(new ModScreenshot());
		this.AddMod(new ModAudio());
		this.s = new BlockOctreeSearcher();
		this.s.platform = this.platform;
		this.LastReceivedMilliseconds = this.platform.TimeMillisecondsFromStart();
		this.ENABLE_DRAW_TEST_CHARACTER = this.platform.IsDebuggerAttached();
		int maxTextureSize_ = this.platform.GlGetMaxTextureSize();
		if (maxTextureSize_ < 1024) {
			maxTextureSize_ = 1024;
		}
		this.maxTextureSize = maxTextureSize_;
		this.MapLoadingStart();
		this.platform.GlClearColorRgbaf(0, 0, 0, 1);
		if (this.d_Config3d.ENABLE_BACKFACECULLING) {
			this.platform.GlDepthMask(true);
			this.platform.GlEnableDepthTest();
			this.platform.GlCullFaceBack();
			this.platform.GlEnableCullFace();
		}
		this.platform.GlEnableLighting();
		this.platform.GlEnableColorMaterial();
		this.platform.GlColorMaterialFrontAndBackAmbientAndDiffuse();
		this.platform.GlShadeModelSmooth();
	}

	public void StartTyping()
	{
		this.GuiTyping = TypingState.Typing;
		this.IsTyping = true;
		this.GuiTypingBuffer = "";
		this.IsTeamchat = false;
	}

	public void StopTyping()
	{
		this.GuiTyping = TypingState.None;
	}

	public static bool StringEquals(string strA, string strB)
	{
		if (strA == null && strB == null) {
			return true;
		}
		if (strA == null || strB == null) {
			return false;
		}
		return strA == strB;
	}

	internal bool SwimmingBody()
	{
		int block = this.map.GetBlock(this.platform.FloatToInt(this.player.position.x), this.platform.FloatToInt(this.player.position.z), this.platform.FloatToInt(this.player.position.y + 1));
		if (block == -1) {
			return true;
		}
		return this.d_Data.WalkableType1()[block] == 1;
	}

	internal bool SwimmingEyes()
	{
		int eyesBlock = this.GetPlayerEyesBlock();
		if (eyesBlock == -1) {
			return true;
		}
		return this.d_Data.WalkableType1()[eyesBlock] == 1;
	}
	internal int TPP_CAMERA_DISTANCE_MAX;
	internal int TPP_CAMERA_DISTANCE_MIN;

	internal int TextSizeHeight(string s, int size)
	{
		IntRef width = new IntRef();
		IntRef height = new IntRef();
		this.platform.TextSize(s, size, width, height);
		return height.value;
	}

	internal int TextSizeWidth(string s, int size)
	{
		IntRef width = new IntRef();
		IntRef height = new IntRef();
		this.platform.TextSize(s, size, width, height);
		return width.value;
	}
	internal int[][] TextureId;
	internal int[] TextureIdForInventory;

	public void ToggleFog()
	{
		int[] drawDistances = new int[10];
		int drawDistancesCount = 0;
		drawDistances[drawDistancesCount++] = 32;
		if (this.maxdrawdistance >= 64) {
			drawDistances[drawDistancesCount++] = 64;
		}
		if (this.maxdrawdistance >= 128) {
			drawDistances[drawDistancesCount++] = 128;
		}
		if (this.maxdrawdistance >= 256) {
			drawDistances[drawDistancesCount++] = 256;
		}
		if (this.maxdrawdistance >= 512) {
			drawDistances[drawDistancesCount++] = 512;
		}
		for (int i = 0; i < drawDistancesCount; i++) {
			if (this.d_Config3d.viewdistance == drawDistances[i]) {
				this.d_Config3d.viewdistance = drawDistances[(i + 1) % drawDistancesCount];
				this.RedrawAllBlocks();
				return;
			}
		}
		this.d_Config3d.viewdistance = drawDistances[0];
		this.RedrawAllBlocks();
	}

	internal void ToggleVsync()
	{
		this.ENABLE_LAG++;
		this.ENABLE_LAG = this.ENABLE_LAG % 3;
		this.UseVsync();
	}
	internal int[] TotalAmmo;

	public void Update(float dt)
	{
		for (int i = 0; i < this.clientmodsCount; i++) {
			if (this.clientmods[i] == null) {
				continue;
			}
			this.clientmods[i].OnNewFrameReadOnlyMainThread(this, dt);
		}
	}

	internal void UpdateColumnHeight(int x, int y)
	{
		int height = this.map.MapSizeZ - 1;
		for (int i = this.map.MapSizeZ - 1; i >= 0; i--) {
			height = i;
			if (!Game.IsTransparentForLight(this.blocktypes[this.map.GetBlock(x, y, i)])) {
				break;
			}
		}
		this.d_Heightmap.SetBlock(x, y, height);
	}

	internal void UpdateMouseViewportControl(float dt)
	{
		if (this.mouseSmoothing) {
			float constMouseSmoothing1 = 0.85f;
			float constMouseSmoothing2 = 0.8f;
			this.mouseSmoothingVelX = this.mouseSmoothingVelX + this.mouseDeltaX / 4 * constMouseSmoothing2;
			this.mouseSmoothingVelY = this.mouseSmoothingVelY + this.mouseDeltaY / 4 * constMouseSmoothing2;
			this.mouseSmoothingVelX = this.mouseSmoothingVelX * constMouseSmoothing1;
			this.mouseSmoothingVelY = this.mouseSmoothingVelY * constMouseSmoothing1;
		}
		else {
			this.mouseSmoothingVelX = this.mouseDeltaX;
			this.mouseSmoothingVelY = this.mouseDeltaY;
		}
		if (this.guistate == GuiState.Normal && this.enableCameraControl && this.platform.Focused()) {
			if (!this.overheadcamera) {
				if (this.platform.IsMousePointerLocked()) {
					this.player.position.roty += this.mouseSmoothingVelX * this.rotationspeed * 1f / 75;
					this.player.position.rotx += this.mouseSmoothingVelY * this.rotationspeed * 1f / 75;
					this.player.position.rotx = MathCi.ClampFloat(this.player.position.rotx, Game.GetPi() / 2 + this.one * 15 / 1000, Game.GetPi() / 2 + Game.GetPi() - this.one * 15 / 1000);
				}
				this.player.position.rotx += this.touchOrientationDy * this.constRotationSpeed * this.one / 75;
				this.player.position.roty += this.touchOrientationDx * this.constRotationSpeed * this.one / 75;
				this.touchOrientationDx = 0;
				this.touchOrientationDy = 0;
			}
			if (this.cameratype == CameraType.Overhead) {
				if (this.mouseMiddle || this.mouseRight) {
					this.overheadcameraK.TurnLeft(this.mouseDeltaX / 70);
					this.overheadcameraK.TurnUp(this.mouseDeltaY / 3);
				}
			}
		}
		this.mouseDeltaX = 0;
		this.mouseDeltaY = 0;
	}

	void UpdateResize()
	{
		if (this.lastWidth != this.platform.GetCanvasWidth() || this.lastHeight != this.platform.GetCanvasHeight()) {
			this.lastWidth = this.platform.GetCanvasWidth();
			this.lastHeight = this.platform.GetCanvasHeight();
			this.OnResize();
		}
	}

	public void UpdateTextRendererFont()
	{
		this.platform.SetTextRendererFont(this.Font);
	}

	internal void UseInventory(Packet_Inventory packet_Inventory)
	{
		this.d_Inventory = packet_Inventory;
		this.d_InventoryUtil.d_Inventory = packet_Inventory;
	}

	internal void UseTerrainTextureAtlas2d(BitmapCi atlas2d, int atlas2dWidth)
	{
		this.terrainTexture = this.platform.LoadTextureFromBitmap(atlas2d);
		int[] terrainTextures1d_;
		int terrainTextures1dCount = 0;
		{
			this.terrainTexturesPerAtlas = this.atlas1dheight() / (atlas2dWidth / this.atlas2dtiles());
			IntRef atlasesidCount = new IntRef();
			BitmapCi[] atlases1d = this.d_TextureAtlasConverter.Atlas2dInto1d(this.platform, atlas2d, this.atlas2dtiles(), this.atlas1dheight(), atlasesidCount);
			terrainTextures1d_ = new int[atlasesidCount.value];
			for (int i = 0; i < atlasesidCount.value; i++) {
				BitmapCi bmp = atlases1d[i];
				int texture = this.platform.LoadTextureFromBitmap(bmp);
				terrainTextures1d_[terrainTextures1dCount++] = texture;
				this.platform.BitmapDelete(bmp);
			}
		}
		this.terrainTextures1d = terrainTextures1d_;
	}

	internal void UseTerrainTextures(string[] textureIds, int textureIdsCount)
	{
		int tilesize = 32;
		BitmapData_ atlas2d = BitmapData_.Create(tilesize * this.atlas2dtiles(), tilesize * this.atlas2dtiles());
		for (int i = 0; i < textureIdsCount; i++) {
			if (textureIds[i] == null) {
				continue;
			}
			byte[] fileData = this.GetFile(StringTools.StringAppend(this.platform, textureIds[i], ".png"));
			if (fileData == null) {
				fileData = this.GetFile("Unknown.png");
			}
			if (fileData == null) {
				continue;
			}
			BitmapCi bmp = this.platform.BitmapCreateFromPng(fileData, this.platform.ByteArrayLength(fileData));
			if (this.platform.BitmapGetWidth(bmp) != tilesize) {
				this.platform.BitmapDelete(bmp);
				continue;
			}
			if (this.platform.BitmapGetHeight(bmp) != tilesize) {
				this.platform.BitmapDelete(bmp);
				continue;
			}
			int[] bmpPixels = new int[tilesize * tilesize];
			this.platform.BitmapGetPixelsArgb(bmp, bmpPixels);
			int x = i % this.texturesPacked();
			int y = i / this.texturesPacked();
			for (int xx = 0; xx < tilesize; xx++) {
				for (int yy = 0; yy < tilesize; yy++) {
					int c = bmpPixels[xx + yy * tilesize];
					atlas2d.SetPixel(x * tilesize + xx, y * tilesize + yy, c);
				}
			}
			this.platform.BitmapDelete(bmp);
		}
		BitmapCi bitmap = this.platform.BitmapCreate(atlas2d.width, atlas2d.height);
		this.platform.BitmapSetPixelsArgb(bitmap, atlas2d.argb);
		this.UseTerrainTextureAtlas2d(bitmap, atlas2d.width);
	}

	internal void UseVsync()
	{
		this.platform.SetVSync(this.ENABLE_LAG == 1 ? false : true);
	}

	internal string ValidFont(string family)
	{
		for (int i = 0; i < this.AllowedFontsCount; i++) {
			if (this.AllowedFonts[i] == family) {
				return family;
			}
		}
		return this.AllowedFonts[0];
	}

	public bool Vec3Equal(float ax, float ay, float az, float bx, float by, float bz)
	{
		return ax == bx && ay == by && az == bz;
	}

	internal float VectorAngleGet(float qX, float qY, float qZ)
	{
		return this.platform.MathAcos(qX / this.Length(qX, qY, qZ)) * MathCi.Sign(qZ);
	}

	public float WaterLevel()
	{
		return this.map.MapSizeZ / 2;
	}

	internal bool WaterSwimmingCamera()
	{
		if (this.GetCameraBlock() == -1) {
			return true;
		}
		return this.IsWater(this.GetCameraBlock());
	}

	internal bool WaterSwimmingEyes()
	{
		if (this.GetPlayerEyesBlock() == -1) {
			return true;
		}
		return this.IsWater(this.GetPlayerEyesBlock());
	}

	public float WeaponAttackStrength()
	{
		return this.NextFloat(2, 4);
	}

	internal void WearItem(Packet_InventoryPosition from, Packet_InventoryPosition to)
	{
		this.SendPacketClient(ClientPackets.WearItem(from, to));
	}

	public int WhiteTexture()
	{
		if (this.whitetexture == -1) {
			BitmapCi bmp = this.platform.BitmapCreate(1, 1);
			int[] pixels = new int[1];
			pixels[0] = Game.ColorFromArgb(255, 255, 255, 255);
			this.platform.BitmapSetPixelsArgb(bmp, pixels);
			this.whitetexture = this.platform.LoadTextureFromBitmap(bmp);
		}
		return this.whitetexture;
	}

	public int Width()
	{
		return this.platform.GetCanvasWidth();
	}
	internal AnimationState a;
	float accumulator;
	internal bool ammostarted;
	internal AssetList assets;
	internal FloatRef assetsLoadProgress;

	internal int atlas1dheight()
	{
		return this.maxTextureSize;
	}

	internal int atlas2dtiles()
	{
		return 32;
	}
	internal AudioControl audio;
	internal float basemovespeed;
	internal CitoMemoryStream blobdownload;
	internal string blobdownloadmd5;
	internal string blobdownloadname;
	internal DictionaryVector3Float blockHealth;

	public int blockheight(int x, int y, int z_)
	{
		for (int z = z_; z >= 0; z--) {
			if (this.map.GetBlock(x, y, z) != 0) {
				return z + 1;
			}
		}
		return 0;
	}
	internal Packet_BlockType[] blocktypes;
	internal CachedTextTexture[] cachedTextTextures;
	internal int cachedTextTexturesMax;
	internal float[] camera;
	internal CameraType cameratype;
	ModelData circleModelData;
	public const int clearcolorA = 255;
	public const int clearcolorB = 0;
	public const int clearcolorG = 0;
	public const int clearcolorR = 0;
	internal ClientMod[] clientmods;
	internal int clientmodsCount;
	internal ListAction commitActions;
	internal ConnectData connectdata;
	internal float constRotationSpeed;
	internal float constWallDistance;
	internal Controls controls;
	internal Vector3IntRef currentAttackedBlock;
	internal bool currentMatrixModeProjection;
	internal int currentTimeMilliseconds;

	internal float currentfov()
	{
		if (this.IronSights) {
			Packet_Item item = this.d_Inventory.RightHand[this.ActiveMaterial];
			if (item != null && item.ItemClass == 0) {
				if (this.DeserializeFloat(this.blocktypes[item.BlockId].IronSightsFovFloat) != 0) {
					return this.fov * this.DeserializeFloat(this.blocktypes[item.BlockId].IronSightsFovFloat);
				}
			}
		}
		return this.fov;
	}
	internal int currentlyAttackedEntity;
	internal MeshBatcher d_Batcher;
	internal Config3d d_Config3d;
	internal GameData d_Data;
	internal GameDataMonsters d_DataMonsters;
	internal GameExit d_Exit;
	internal FrustumCulling d_FrustumCulling;
	internal InfiniteMapChunked2d d_Heightmap;
	internal Packet_Inventory d_Inventory;
	internal InventoryUtilClient d_InventoryUtil;
	internal SunMoonRenderer d_SunMoonRenderer;
	internal TerrainChunkTesselatorCi d_TerrainChunkTesselator;
	internal ITerrainTextures d_TerrainTextures;
	internal TextureAtlasConverter d_TextureAtlasConverter;
	internal VisibleDialog[] dialogs;
	internal int dialogsCount;
	internal bool drawblockinfo;
	internal bool enableCameraControl;
	internal bool enable_move;
	internal Entity[] entities;
	internal int entitiesCount;
	public const int entityLocalIdStart = 256;
	public const int entityMonsterIdCount = 128;
	public const int entityMonsterIdStart = 128;
	internal bool escapeMenuRestart;
	internal bool exitToMainMenu;
	internal bool fancySkysphere;
	internal int fillAreaLimit;
	internal FontCi fontMapLoading;
	internal float fov;
	string[] getAsset;

	public float getblockheight(int x, int y, int z)
	{
		float RailHeight = this.one * 3 / 10;
		if (!this.map.IsValidPos(x, y, z)) {
			return 1;
		}
		if (this.blocktypes[this.map.GetBlock(x, y, z)].Rail != 0) {
			return RailHeight;
		}
		if (this.blocktypes[this.map.GetBlock(x, y, z)].DrawType == 11) {
			return this.one / 2;
		}
		if (this.blocktypes[this.map.GetBlock(x, y, z)].DrawType == 12) {
			return this.one / 20;
		}
		return 1;
	}
	internal int grenadecookingstartMilliseconds;
	internal float grenadetime;
	internal GuiState guistate;
	internal bool handRedraw;
	internal bool handSetAttackBuild;
	internal bool handSetAttackDestroy;
	internal int handTexture;
	float[] identityMatrix;
	internal string invalidVersionDrawMessage;
	internal Packet_Server invalidVersionPacketIdentification;
	internal bool isNight;
	internal bool isplayeronground;
	internal bool issingleplayer;
	internal bool[] keyboardState;
	internal bool[] keyboardStateRaw;
	internal Language language;
	int lastHeight;
	internal int lastOxygenTickMilliseconds;
	int lastWidth;
	internal int lastironsightschangeMilliseconds;
	internal int lastplacedblockX;
	internal int lastplacedblockY;
	internal int lastplacedblockZ;
	float lastplayerpositionX;
	float lastplayerpositionY;
	float lastplayerpositionZ;
	internal int lastpositionsentMilliseconds;
	internal bool leftpressedpicking;
	internal AnimationState localplayeranim;
	internal AnimationHint localplayeranimationhint;
	internal byte localstance;
	internal float[] mLightLevels;
	internal NetClient main;
	internal Map map;
	internal MapLoadingProgressEventArgs maploadingprogress;
	internal int[] materialSlots;
	internal int maxTextureSize;
	internal int maxdrawdistance;
	public const int maxlight = 15;
	internal MenuState menustate;
	public const int minlight = 0;
	float[] modelViewInverted;
	internal ClientModManager1 modmanager;
	internal float moonPositionX;
	internal float moonPositionY;
	internal float moonPositionZ;
	internal int mouseCurrentX;
	internal int mouseCurrentY;
	internal float mouseDeltaX;
	internal float mouseDeltaY;
	internal bool mouseLeft;
	internal bool mouseMiddle;
	bool mousePointerLockShouldBe;
	internal bool mouseRight;
	bool mouseSmoothing;
	float mouseSmoothingAccum;
	float mouseSmoothingVelX;
	float mouseSmoothingVelY;
	internal bool mouseleftclick;
	internal bool mouseleftdeclick;
	internal bool mouserightclick;
	internal bool mouserightdeclick;
	internal float movedz;
	internal float movespeed;
	internal StackMatrix4 mvMatrix;
	internal float one;
	internal OptionsCi options;
	internal bool overheadcamera;
	internal Kamera overheadcameraK;
	internal float overheadcameradistance;
	internal StackMatrix4 pMatrix;
	internal ClientPacketHandler[] packetHandlers;
	IntRef packetLen;
	internal ModDrawParticleEffectBlockBreak particleEffectBlockBreak;
	internal DictionaryStringString performanceinfo;
	internal int pistolcycle;
	internal GamePlatform platform;
	internal Entity player;
	internal float playerPositionSpawnX;
	internal float playerPositionSpawnY;
	internal float playerPositionSpawnZ;
	internal Vector3Ref playerdestination;
	internal int playertexturedefault;
	public const string playertexturedefaultfilename = "mineplayer.png";
	internal Vector3Ref playervelocity;
	internal float pushX;
	internal float pushY;
	internal float pushZ;
	Model quadModel;
	internal bool reachedHalfBlock;
	internal bool reachedwall;
	internal bool reachedwall_1blockhigh;
	internal bool reconnect;
	internal Packet_ServerRedirect redirectTo;
	internal int reloadblock;
	internal int reloadstartMilliseconds;
	internal RandomCi rnd;
	float rotationspeed;
	internal BlockOctreeSearcher s;
	internal int selectedmodelid;
	bool sendResize;
	internal string serverGameVersion;
	internal bool shadowssimple;
	internal bool shouldRedrawAllBlocks;
	internal ModSkySphereStatic skysphere;
	internal BoolRef soundnow;
	internal bool spawned;
	internal Speculative[] speculative;
	internal int speculativeCount;
	bool startedconnecting;
	internal bool stopPlayerMove;
	internal float sunPositionX;
	internal float sunPositionY;
	internal float sunPositionZ;
	internal int sunlight_;
	TaskScheduler taskScheduler;
	internal int terrainTexture;
	internal int[] terrainTextures1d;
	internal int terrainTexturesPerAtlas;

	internal int terraincolor()
	{
		if (this.WaterSwimmingCamera()) {
			return Game.ColorFromArgb(255, 78, 95, 140);
		}
		else if (this.LavaSwimmingCamera()) {
			return Game.ColorFromArgb(255, 222, 101, 46);
		}
		else {
			return Game.ColorFromArgb(255, 255, 255, 255);
		}
	}
	internal TextColorRenderer textColorRenderer;
	DictionaryStringInt1024 textures;

	internal int texturesPacked()
	{
		return 32;
	}
	internal int totaltimeMilliseconds;
	internal float touchMoveDx;
	internal float touchMoveDy;
	internal float touchOrientationDx;
	internal float touchOrientationDy;
	internal float tppcameradistance;
	internal string[] typinglog;
	internal int typinglogCount;
	internal int typinglogpos;
	internal bool wasmouseleft;
	internal bool wasmouseright;
	int whitetexture;

	internal int xcenter(float width)
	{
		return this.platform.FloatToInt(this.platform.GetCanvasWidth() / 2 - width / 2);
	}

	internal int ycenter(float height)
	{
		return this.platform.FloatToInt(this.platform.GetCanvasHeight() / 2 - height / 2);
	}

	internal float zfar()
	{
		if (this.d_Config3d.viewdistance >= 256) {
			return this.d_Config3d.viewdistance * 2;
		}
		return this.ENABLE_ZFAR ? this.d_Config3d.viewdistance : 99999;
	}
	internal float znear;
}

public class GameData
{
	public GameData()
	{
		this.mBlockIdEmpty = 0;
		this.mBlockIdDirt = -1;
		this.mBlockIdSponge = -1;
		this.mBlockIdTrampoline = -1;
		this.mBlockIdAdminium = -1;
		this.mBlockIdCompass = -1;
		this.mBlockIdLadder = -1;
		this.mBlockIdEmptyHand = -1;
		this.mBlockIdCraftingTable = -1;
		this.mBlockIdLava = -1;
		this.mBlockIdStationaryLava = -1;
		this.mBlockIdFillStart = -1;
		this.mBlockIdCuboid = -1;
		this.mBlockIdFillArea = -1;
		this.mBlockIdMinecart = -1;
		this.mBlockIdRailstart = -128;
	}

	public int BlockIdAdminium()
	{
		return this.mBlockIdAdminium;
	}

	public int BlockIdCompass()
	{
		return this.mBlockIdCompass;
	}

	public int BlockIdCraftingTable()
	{
		return this.mBlockIdCraftingTable;
	}

	public int BlockIdCuboid()
	{
		return this.mBlockIdCuboid;
	}

	public int BlockIdDirt()
	{
		return this.mBlockIdDirt;
	}

	public int BlockIdEmpty()
	{
		return this.mBlockIdEmpty;
	}

	public int BlockIdEmptyHand()
	{
		return this.mBlockIdEmptyHand;
	}

	public int BlockIdFillArea()
	{
		return this.mBlockIdFillArea;
	}

	public int BlockIdFillStart()
	{
		return this.mBlockIdFillStart;
	}

	public int BlockIdLadder()
	{
		return this.mBlockIdLadder;
	}

	public int BlockIdLava()
	{
		return this.mBlockIdLava;
	}

	public int BlockIdMinecart()
	{
		return this.mBlockIdMinecart;
	}

	public int BlockIdRailstart()
	{
		return this.mBlockIdRailstart;
	}

	public int BlockIdSponge()
	{
		return this.mBlockIdSponge;
	}

	public int BlockIdStationaryLava()
	{
		return this.mBlockIdStationaryLava;
	}

	public int BlockIdTrampoline()
	{
		return this.mBlockIdTrampoline;
	}

	public string[][] BreakSound()
	{
		return this.mBreakSound;
	}

	public string[][] BuildSound()
	{
		return this.mBuildSound;
	}

	public string[][] CloneSound()
	{
		return this.mCloneSound;
	}

	public int[] DamageToPlayer()
	{
		return this.mDamageToPlayer;
	}

	public int[] DefaultMaterialSlots()
	{
		return this.mDefaultMaterialSlots;
	}

	float DeserializeFloat(int p)
	{
		float one = 1;
		return one * p / 32;
	}

	void Initialize(int count)
	{
		this.mWhenPlayerPlacesGetsConvertedTo = new int[count];
		this.mIsFlower = new bool[count];
		this.mRail = new int[count];
		this.mWalkSpeed = new float[count];
		for (int i = 0; i < count; i++) {
			this.mWalkSpeed[i] = 1;
		}
		this.mIsSlipperyWalk = new bool[count];
		this.mWalkSound = new string[count][];
		for (int i = 0; i < count; i++) {
			this.mWalkSound[i] = new string[8];
		}
		this.mBreakSound = new string[count][];
		for (int i = 0; i < count; i++) {
			this.mBreakSound[i] = new string[8];
		}
		this.mBuildSound = new string[count][];
		for (int i = 0; i < count; i++) {
			this.mBuildSound[i] = new string[8];
		}
		this.mCloneSound = new string[count][];
		for (int i = 0; i < count; i++) {
			this.mCloneSound[i] = new string[8];
		}
		this.mLightRadius = new int[count];
		this.mStartInventoryAmount = new int[count];
		this.mStrength = new float[count];
		this.mDamageToPlayer = new int[count];
		this.mWalkableType = new int[count];
		this.mDefaultMaterialSlots = new int[10];
	}

	public bool[] IsFlower()
	{
		return this.mIsFlower;
	}

	public bool IsRailTile(int id)
	{
		return id >= this.BlockIdRailstart() && id < this.BlockIdRailstart() + 64;
	}

	public bool[] IsSlipperyWalk()
	{
		return this.mIsSlipperyWalk;
	}

	public int[] LightRadius()
	{
		return this.mLightRadius;
	}

	public int[] Rail()
	{
		return this.mRail;
	}

	public bool SetSpecialBlock(Packet_BlockType b, int id)
	{
		switch (b.Name) {
		case "Empty":
			this.mBlockIdEmpty = id;
			return true;
		case "Dirt":
			this.mBlockIdDirt = id;
			return true;
		case "Sponge":
			this.mBlockIdSponge = id;
			return true;
		case "Trampoline":
			this.mBlockIdTrampoline = id;
			return true;
		case "Adminium":
			this.mBlockIdAdminium = id;
			return true;
		case "Compass":
			this.mBlockIdCompass = id;
			return true;
		case "Ladder":
			this.mBlockIdLadder = id;
			return true;
		case "EmptyHand":
			this.mBlockIdEmptyHand = id;
			return true;
		case "CraftingTable":
			this.mBlockIdCraftingTable = id;
			return true;
		case "Lava":
			this.mBlockIdLava = id;
			return true;
		case "StationaryLava":
			this.mBlockIdStationaryLava = id;
			return true;
		case "FillStart":
			this.mBlockIdFillStart = id;
			return true;
		case "Cuboid":
			this.mBlockIdCuboid = id;
			return true;
		case "FillArea":
			this.mBlockIdFillArea = id;
			return true;
		case "Minecart":
			this.mBlockIdMinecart = id;
			return true;
		case "Rail0":
			this.mBlockIdRailstart = id;
			return true;
		default:
			return false;
		}
	}
	public const int SoundCount = 8;

	public void Start()
	{
		this.Initialize(1024);
	}

	public int[] StartInventoryAmount()
	{
		return this.mStartInventoryAmount;
	}

	public float[] Strength()
	{
		return this.mStrength;
	}

	public void Update()
	{
	}

	public void UseBlockType(GamePlatform platform, int id, Packet_BlockType b)
	{
		if (b.Name == null) {
			return;
		}
		if (b.WhenPlacedGetsConvertedTo != 0) {
			this.mWhenPlayerPlacesGetsConvertedTo[id] = b.WhenPlacedGetsConvertedTo;
		}
		else {
			this.mWhenPlayerPlacesGetsConvertedTo[id] = id;
		}
		this.IsFlower()[id] = b.DrawType == 5;
		this.Rail()[id] = b.Rail;
		this.WalkSpeed()[id] = this.DeserializeFloat(b.WalkSpeedFloat);
		this.IsSlipperyWalk()[id] = b.IsSlipperyWalk;
		this.WalkSound()[id] = new string[8];
		this.BreakSound()[id] = new string[8];
		this.BuildSound()[id] = new string[8];
		this.CloneSound()[id] = new string[8];
		if (b.Sounds != null) {
			for (int i = 0; i < b.Sounds.WalkCount; i++) {
				this.WalkSound()[id][i] = StringTools.StringAppend(platform, b.Sounds.Walk[i], ".wav");
			}
			for (int i = 0; i < b.Sounds.Break1Count; i++) {
				this.BreakSound()[id][i] = StringTools.StringAppend(platform, b.Sounds.Break1[i], ".wav");
			}
			for (int i = 0; i < b.Sounds.BuildCount; i++) {
				this.BuildSound()[id][i] = StringTools.StringAppend(platform, b.Sounds.Build[i], ".wav");
			}
			for (int i = 0; i < b.Sounds.CloneCount; i++) {
				this.CloneSound()[id][i] = StringTools.StringAppend(platform, b.Sounds.Clone[i], ".wav");
			}
		}
		this.LightRadius()[id] = b.LightRadius;
		this.Strength()[id] = b.Strength;
		this.DamageToPlayer()[id] = b.DamageToPlayer;
		this.WalkableType1()[id] = b.WalkableType;
		this.SetSpecialBlock(b, id);
	}

	public void UseBlockTypes(GamePlatform platform, Packet_BlockType[] blocktypes, int count)
	{
		for (int i = 0; i < count; i++) {
			if (blocktypes[i] != null) {
				this.UseBlockType(platform, i, blocktypes[i]);
			}
		}
	}

	public string[][] WalkSound()
	{
		return this.mWalkSound;
	}

	public float[] WalkSpeed()
	{
		return this.mWalkSpeed;
	}

	public int[] WalkableType1()
	{
		return this.mWalkableType;
	}

	public int[] WhenPlayerPlacesGetsConvertedTo()
	{
		return this.mWhenPlayerPlacesGetsConvertedTo;
	}
	int mBlockIdAdminium;
	int mBlockIdCompass;
	int mBlockIdCraftingTable;
	int mBlockIdCuboid;
	int mBlockIdDirt;
	int mBlockIdEmpty;
	int mBlockIdEmptyHand;
	int mBlockIdFillArea;
	int mBlockIdFillStart;
	int mBlockIdLadder;
	int mBlockIdLava;
	int mBlockIdMinecart;
	int mBlockIdRailstart;
	int mBlockIdSponge;
	int mBlockIdStationaryLava;
	int mBlockIdTrampoline;
	string[][] mBreakSound;
	string[][] mBuildSound;
	string[][] mCloneSound;
	int[] mDamageToPlayer;
	int[] mDefaultMaterialSlots;
	bool[] mIsFlower;
	bool[] mIsSlipperyWalk;
	int[] mLightRadius;
	int[] mRail;
	int[] mStartInventoryAmount;
	float[] mStrength;
	string[][] mWalkSound;
	float[] mWalkSpeed;
	int[] mWalkableType;
	int[] mWhenPlayerPlacesGetsConvertedTo;
}

public class GameDataItemsClient
{

	public bool CanWear(int selectedWear, Packet_Item item)
	{
		if (item == null) {
			return true;
		}
		if (item == null) {
			return true;
		}
		switch (selectedWear) {
		case 0:
			return item.ItemClass == 0;
		case 1:
			return false;
		case 2:
			return false;
		case 3:
			return false;
		case 4:
			return false;
		default:
			return false;
		}
	}

	public string ItemGraphics(Packet_Item item)
	{
		return null;
	}

	public string ItemInfo(Packet_Item item)
	{
		if (item.ItemClass == 0) {
			return this.game.language.Get(StringTools.StringAppend(this.game.platform, "Block_", this.game.blocktypes[item.BlockId].Name));
		}
		this.game.platform.ThrowException("ItemClass");
		return "ItemClass";
	}

	public int ItemSizeX(Packet_Item item)
	{
		if (item.ItemClass == 0) {
			return 1;
		}
		this.game.platform.ThrowException("ItemClass");
		return 1;
	}

	public int ItemSizeY(Packet_Item item)
	{
		if (item.ItemClass == 0) {
			return 1;
		}
		this.game.platform.ThrowException("ItemClass");
		return 1;
	}

	public Packet_Item Stack(Packet_Item itemA, Packet_Item itemB)
	{
		if (itemA.ItemClass == 0 && itemB.ItemClass == 0) {
			Packet_Item ret = new Packet_Item();
			ret.ItemClass = itemA.ItemClass;
			ret.BlockId = itemA.BlockId;
			ret.BlockCount = itemA.BlockCount + itemB.BlockCount;
			return ret;
		}
		else {
			return null;
		}
	}

	public int[] TextureIdForInventory()
	{
		return this.game.TextureIdForInventory;
	}
	internal Game game;
}

public class GameDataMonsters
{
	public GameDataMonsters()
	{
		int n = 5;
		this.MonsterCode = new string[n];
		this.MonsterName = new string[n];
		this.MonsterSkin = new string[n];
		this.MonsterCode[0] = "imp.txt";
		this.MonsterName[0] = "Imp";
		this.MonsterSkin[0] = "imp.png";
		this.MonsterCode[1] = "imp.txt";
		this.MonsterName[1] = "Fire Imp";
		this.MonsterSkin[1] = "impfire.png";
		this.MonsterCode[2] = "dragon.txt";
		this.MonsterName[2] = "Dragon";
		this.MonsterSkin[2] = "dragon.png";
		this.MonsterCode[3] = "zombie.txt";
		this.MonsterName[3] = "Zombie";
		this.MonsterSkin[3] = "zombie.png";
		this.MonsterCode[4] = "cyclops.txt";
		this.MonsterName[4] = "Cyclops";
		this.MonsterSkin[4] = "cyclops.png";
	}
	internal string[] MonsterCode;
	internal string[] MonsterName;
	internal string[] MonsterSkin;
}

public class GameExit
{

	public bool GetExit()
	{
		return this.exit;
	}

	public bool GetRestart()
	{
		return this.restart;
	}

	public void SetExit(bool p)
	{
		this.exit = p;
	}

	public void SetRestart(bool p)
	{
		this.restart = p;
	}
	internal bool exit;
	internal bool restart;
}

public abstract class GamePlatform
{

	public abstract void AddOnCrash(OnCrashHandler handler);

	public abstract void AddOnKeyEvent(KeyEventHandler handler);

	public abstract void AddOnMouseEvent(MouseEventHandler handler);

	public abstract void AddOnNewFrame(NewFrameHandler handler);

	public abstract void AddOnTouchEvent(TouchEventHandler handler);

	public abstract void ApplicationDoEvents();

	public abstract AudioCi AudioCreate(AudioData data);

	public abstract AudioData AudioDataCreate(byte[] data, int dataLength);

	public abstract bool AudioDataLoaded(AudioData data);

	public abstract void AudioDelete(AudioCi audioCi);

	public abstract bool AudioFinished(AudioCi audio);

	public abstract void AudioPause(AudioCi audio);

	public abstract void AudioPlay(AudioCi audio);

	public abstract void AudioSetPosition(AudioCi audio, float x, float y, float z);

	public abstract void AudioUpdateListener(float posX, float posY, float posZ, float orientX, float orientY, float orientZ);

	public abstract AviWriterCi AviWriterCreate();

	public abstract void BindTexture2d(int texture);

	public abstract BitmapCi BitmapCreate(int width, int height);

	public abstract BitmapCi BitmapCreateFromPng(byte[] data, int dataLength);

	public abstract void BitmapDelete(BitmapCi bmp);

	public abstract float BitmapGetHeight(BitmapCi bmp);

	public abstract void BitmapGetPixelsArgb(BitmapCi bitmap, int[] bmpPixels);

	public abstract float BitmapGetWidth(BitmapCi bmp);

	public abstract void BitmapSetPixelsArgb(BitmapCi bmp, int[] pixels);

	public abstract int ByteArrayLength(byte[] arr);

	public abstract EnetNetConnection CastToEnetNetConnection(NetConnection connection);

	public abstract PlayerInterpolationState CastToPlayerInterpolationState(InterpolatedObject a);

	public abstract void ChangeResolution(int width, int height, int bitsPerPixel, float refreshRate);

	public abstract string CharArrayToString(int[] charArray, int length);

	public abstract bool ChatLog(string servername, string p);

	public abstract bool ClipboardContainsText();

	public abstract string ClipboardGetText();

	public abstract void ClipboardSetText(string s);

	public abstract void ConsoleWriteLine(string p);

	public abstract Model CreateModel(ModelData modelData);

	public abstract BitmapCi CreateTextTexture(Text_ t);

	public abstract string DecodeHTMLEntities(string htmlencodedstring);

	public abstract void DeleteModel(Model model);

	public abstract string[] DirectoryGetFiles(string path, IntRef length);

	public abstract void DrawModel(Model model);

	public abstract void DrawModelData(ModelData data);

	public abstract void DrawModels(Model[] model, int count);

	public abstract bool EnetAvailable();

	public abstract EnetHost EnetCreateHost();

	public abstract bool EnetHostCheckEvents(EnetHost host, EnetEventRef event_);

	public abstract EnetPeer EnetHostConnect(EnetHost host, string hostName, int port, int data, int channelLimit);

	public abstract void EnetHostInitialize(EnetHost host, IPEndPointCi address, int peerLimit, int channelLimit, int incomingBandwidth, int outgoingBandwidth);

	public abstract void EnetHostInitializeServer(EnetHost host, int port, int peerLimit);

	public abstract bool EnetHostService(EnetHost host, int timeout, EnetEventRef enetEvent);

	public abstract void EnetPeerSend(EnetPeer peer, byte channelID, byte[] data, int dataLength, int flags);

	public abstract void Exit();

	public abstract bool ExitAvailable();

	public abstract void ExitMousePointerLock();

	public abstract string FileName(string fullpath);

	public abstract string FileOpenDialog(string extension, string extensionName, string initialDirectory);

	public abstract string[] FileReadAllLines(string path, IntRef length);

	public abstract float FloatModulo(float a, int b);

	public abstract float FloatParse(string value);

	public abstract int FloatToInt(float value);

	public abstract string FloatToString(float value);

	public abstract bool FloatTryParse(string s, FloatRef ret);

	public abstract bool Focused();

	public abstract void GLDeleteTexture(int id);

	public abstract void GLDisableAlphaTest();

	public abstract void GLEnableAlphaTest();

	public abstract void GLLineWidth(int width);

	public abstract int GetCanvasHeight();

	public abstract int GetCanvasWidth();

	public abstract DisplayResolutionCi GetDisplayResolutionDefault();

	public abstract DisplayResolutionCi[] GetDisplayResolutions(IntRef resolutionsCount);

	public abstract string GetGameVersion();

	public abstract string GetLanguageIso6391();

	public abstract Preferences GetPreferences();

	public abstract WindowState GetWindowState();

	public abstract void GlClearColorBufferAndDepthBuffer();

	public abstract void GlClearColorRgbaf(float r, float g, float b, float a);

	public abstract void GlClearDepthBuffer();

	public abstract void GlColorMaterialFrontAndBackAmbientAndDiffuse();

	public abstract void GlCullFaceBack();

	public abstract void GlDepthMask(bool flag);

	public abstract void GlDisableCullFace();

	public abstract void GlDisableDepthTest();

	public abstract void GlDisableFog();

	public abstract void GlEnableColorMaterial();

	public abstract void GlEnableCullFace();

	public abstract void GlEnableDepthTest();

	public abstract void GlEnableFog();

	public abstract void GlEnableLighting();

	public abstract void GlEnableTexture2d();

	public abstract void GlFogFogColor(int r, int g, int b, int a);

	public abstract void GlFogFogDensity(float density);

	public abstract void GlFogFogModeExp2();

	public abstract int GlGetMaxTextureSize();

	public abstract void GlHintFogHintNicest();

	public abstract void GlLightModelAmbient(int r, int g, int b);

	public abstract void GlShadeModelSmooth();

	public abstract void GlViewport(int x, int y, int width, int height);

	public abstract BitmapCi GrabScreenshot();

	public abstract byte[] GzipCompress(byte[] data, int dataLength, IntRef retLength);

	public abstract void GzipDecompress(byte[] compressed, int compressedLength, byte[] ret);

	public abstract void InitShaders();

	public abstract int IntParse(string value);

	public abstract string IntToString(int value);

	public abstract bool IsCached(string md5);

	public abstract bool IsChecksum(string checksum);

	public abstract bool IsDebuggerAttached();

	public abstract bool IsFastSystem();

	public abstract bool IsMousePointerLocked();

	public abstract bool IsSmallScreen();

	public abstract bool IsValidTypingChar(int c);

	public abstract string KeyName(int key);

	public abstract Asset LoadAssetFromCache(string md5);

	public abstract void LoadAssetsAsyc(AssetList list, FloatRef progress);

	public abstract int LoadTextureFromBitmap(BitmapCi bmp);

	public abstract float MathAcos(float p);

	public abstract float MathCos(float a);

	public abstract float MathSin(float a);

	public abstract float MathSqrt(float value);

	public abstract float MathTan(float p);

	public abstract void MessageBoxShowError(string text, string caption);

	public abstract MonitorObject MonitorCreate();

	public abstract void MonitorEnter(MonitorObject monitorObject);

	public abstract void MonitorExit(MonitorObject monitorObject);

	public abstract bool MouseCursorIsVisible();

	public abstract void MouseCursorSetVisible(bool value);

	public abstract bool MultithreadingAvailable();

	public abstract void OpenLinkInBrowser(string url);

	public abstract UriCi ParseUri(string uri);

	public abstract string PathCombine(string part1, string part2);

	public abstract string PathSavegames();

	public abstract string PathStorage();

	public abstract string QueryStringValue(string key);

	public abstract void QueueUserWorkItem(Action_ action);

	public abstract RandomCi RandomCreate();

	public abstract string[] ReadAllLines(string p, IntRef retCount);

	public abstract void RequestMousePointerLock();

	public abstract void RestoreWindowCursor();

	public abstract void SaveAssetToCache(Asset tosave);

	public abstract void SaveScreenshot();

	public abstract void SetMatrixUniformModelView(float[] mvMatrix);

	public abstract void SetMatrixUniformProjection(float[] pMatrix);

	public abstract void SetPreferences(Preferences preferences);

	public abstract void SetTextRendererFont(int fontID);

	public abstract void SetTitle(string applicationname);

	public abstract void SetVSync(bool enabled);

	public abstract void SetWindowCursor(int hotx, int hoty, int sizex, int sizey, byte[] imgdata, int imgdataLength);

	public abstract void SetWindowState(WindowState value);

	public abstract void ShowKeyboard(bool show);

	public abstract bool SinglePlayerServerAvailable();

	public abstract void SinglePlayerServerDisable();

	public abstract void SinglePlayerServerExit();

	public abstract DummyNetwork SinglePlayerServerGetNetwork();

	public abstract bool SinglePlayerServerLoaded();

	public abstract void SinglePlayerServerStart(string saveFilename);

	public abstract bool StringContains(string a, string b);

	public abstract bool StringEmpty(string data);

	public abstract string StringFormat(string format, string arg0);

	public abstract string StringFormat2(string format, string arg0, string arg1);

	public abstract string StringFormat3(string format, string arg0, string arg1, string arg2);

	public abstract string StringFormat4(string format, string arg0, string arg1, string arg2, string arg3);

	public abstract string StringFromUtf8ByteArray(byte[] value, int valueLength);

	public abstract int StringIndexOf(string s, string p);

	public abstract string StringJoin(string[] value, string separator);

	public abstract string StringReplace(string s, string from, string to);

	public abstract string[] StringSplit(string value, string separator, IntRef returnLength);

	public abstract bool StringStartsWithIgnoreCase(string a, string b);

	public abstract int[] StringToCharArray(string s, IntRef length);

	public abstract string StringToLower(string p);

	public abstract byte[] StringToUtf8ByteArray(string s, IntRef retLength);

	public abstract string StringTrim(string value);

	public abstract bool TcpAvailable();

	public abstract void TcpConnect(string ip, int port, BoolRef connected);

	public abstract int TcpReceive(byte[] data, int dataLength);

	public abstract void TcpSend(byte[] data, int length);

	public abstract void TextSize(string text, float fontSize, IntRef outWidth, IntRef outHeight);

	public abstract void ThreadSpinWait(int iterations);

	public abstract void ThrowException(string message);

	public abstract void ThumbnailDownloadAsync(string ip, int port, ThumbnailResponseCi response);

	public abstract int TimeMillisecondsFromStart();

	public abstract string Timestamp();

	public abstract void WebClientDownloadDataAsync(string url, HttpResponseCi response);

	public abstract void WebClientUploadDataAsync(string url, byte[] data, int dataLength, HttpResponseCi response);

	public abstract bool WebSocketAvailable();

	public abstract void WebSocketConnect(string ip, int port);

	public abstract int WebSocketReceive(byte[] data, int dataLength);

	public abstract void WebSocketSend(byte[] data, int dataLength);

	public abstract void WindowExit();
}

public class GameScreen : ClientMod
{
	public GameScreen()
	{
		this.WidgetCount = 64;
		this.widgets = new MenuWidget[this.WidgetCount];
	}

	public string CharRepeat(int c, int length)
	{
		int[] charArray = new int[length];
		for (int i = 0; i < length; i++) {
			charArray[i] = c;
		}
		return this.game.platform.CharArrayToString(charArray, length);
	}

	public string CharToString(int a)
	{
		int[] arr = new int[1];
		arr[0] = a;
		return this.game.platform.CharArrayToString(arr, 1);
	}

	public void DrawWidgets()
	{
		for (int i = 0; i < this.WidgetCount; i++) {
			MenuWidget w = this.widgets[i];
			if (w != null) {
				if (!w.visible) {
					continue;
				}
				string text = w.text;
				if (w.selected) {
					text = StringTools.StringAppend(this.game.platform, "&2", text);
				}
				if (w.type == WidgetType.Button) {
					if (w.buttonStyle == ButtonStyle.Text) {
					}
					else {
						if (w.image != null) {
							this.game.Draw2dBitmapFile(w.image, this.screenx + w.x, this.screeny + w.y, w.sizex, w.sizey);
						}
						else {
							this.game.Draw2dTexture(this.game.WhiteTexture(), this.screenx + w.x, this.screeny + w.y, w.sizex, w.sizey, null, 0, w.color, false);
						}
						this.game.Draw2dText1(text, this.screenx + this.game.platform.FloatToInt(w.x), this.screeny + this.game.platform.FloatToInt(w.y + w.sizey / 2), this.game.platform.FloatToInt(w.fontSize), null, false);
					}
				}
				if (w.type == WidgetType.Textbox) {
					if (w.password) {
						text = this.CharRepeat(42, StringTools.StringLength(this.game.platform, w.text));
					}
					if (w.editing) {
						text = StringTools.StringAppend(this.game.platform, text, "_");
					}
					{
						this.game.Draw2dText(text, w.font, this.screenx + w.x, this.screeny + w.y, null, false);
					}
					{
					}
				}
				if (w.type == WidgetType.Label) {
					this.game.Draw2dText(text, w.font, this.screenx + w.x, this.screeny + w.y, IntRef.Create(Game.ColorFromArgb(255, 0, 0, 0)), false);
				}
				if (w.description != null) {
				}
			}
		}
	}

	void KeyDown(KeyEventArgs e)
	{
		for (int i = 0; i < this.WidgetCount; i++) {
			MenuWidget w = this.widgets[i];
			if (w != null) {
				if (w.type == WidgetType.Textbox) {
					if (w.editing) {
						int key = e.GetKeyCode();
						if (e.GetCtrlPressed() && key == 104) {
							if (this.game.platform.ClipboardContainsText()) {
								w.text = StringTools.StringAppend(this.game.platform, w.text, this.game.platform.ClipboardGetText());
							}
							return;
						}
						if (key == 53) {
							if (StringTools.StringLength(this.game.platform, w.text) > 0) {
								w.text = StringTools.StringSubstring(this.game.platform, w.text, 0, StringTools.StringLength(this.game.platform, w.text) - 1);
							}
							return;
						}
					}
				}
			}
		}
	}

	void KeyPress(KeyPressEventArgs e)
	{
		for (int i = 0; i < this.WidgetCount; i++) {
			MenuWidget w = this.widgets[i];
			if (w != null) {
				if (w.type == WidgetType.Textbox) {
					if (w.editing) {
						if (this.game.platform.IsValidTypingChar(e.GetKeyChar())) {
							w.text = StringTools.StringAppend(this.game.platform, w.text, this.CharToString(e.GetKeyChar()));
						}
					}
				}
			}
		}
	}

	bool MouseDown(int x, int y)
	{
		bool handled = false;
		bool editingChange = false;
		for (int i = 0; i < this.WidgetCount; i++) {
			MenuWidget w = this.widgets[i];
			if (w != null) {
				if (w.type == WidgetType.Button) {
					w.pressed = this.pointInRect(x, y, this.screenx + w.x, this.screeny + w.y, w.sizex, w.sizey);
					if (w.pressed) {
						handled = true;
					}
				}
				if (w.type == WidgetType.Textbox) {
					w.pressed = this.pointInRect(x, y, this.screenx + w.x, this.screeny + w.y, w.sizex, w.sizey);
					if (w.pressed) {
						handled = true;
					}
					bool wasEditing = w.editing;
					w.editing = w.pressed;
					if (w.editing && !wasEditing) {
						this.game.platform.ShowKeyboard(true);
						editingChange = true;
					}
					if (!w.editing && wasEditing && !editingChange) {
						this.game.platform.ShowKeyboard(false);
					}
				}
			}
		}
		return handled;
	}

	void MouseMove(MouseEventArgs e)
	{
		if (e.GetEmulated() && !e.GetForceUsage()) {
			return;
		}
		for (int i = 0; i < this.WidgetCount; i++) {
			MenuWidget w = this.widgets[i];
			if (w != null) {
				w.hover = this.pointInRect(e.GetX(), e.GetY(), this.screenx + w.x, this.screeny + w.y, w.sizex, w.sizey);
			}
		}
	}

	void MouseUp(int x, int y)
	{
		for (int i = 0; i < this.WidgetCount; i++) {
			MenuWidget w = this.widgets[i];
			if (w != null) {
				w.pressed = false;
			}
		}
		for (int i = 0; i < this.WidgetCount; i++) {
			MenuWidget w = this.widgets[i];
			if (w != null) {
				if (w.type == WidgetType.Button) {
					if (this.pointInRect(x, y, this.screenx + w.x, this.screeny + w.y, w.sizex, w.sizey)) {
						this.OnButton(w);
					}
				}
			}
		}
	}

	public virtual void OnBackPressed()
	{
	}

	public virtual void OnButton(MenuWidget w)
	{
	}

	public override void OnKeyDown(Game game_, KeyEventArgs args)
	{
		this.KeyDown(args);
	}

	public override void OnKeyPress(Game game_, KeyPressEventArgs args)
	{
		this.KeyPress(args);
	}

	public override void OnMouseDown(Game game_, MouseEventArgs args)
	{
		this.MouseDown(args.GetX(), args.GetY());
	}

	public override void OnMouseMove(Game game_, MouseEventArgs args)
	{
		this.MouseMove(args);
	}

	public override void OnMouseUp(Game game_, MouseEventArgs args)
	{
		this.MouseUp(args.GetX(), args.GetY());
	}

	public virtual void OnMouseWheel(MouseWheelEventArgs e)
	{
	}

	public override void OnTouchEnd(Game game_, TouchEventArgs e)
	{
		this.ScreenOnTouchEnd(e);
	}

	public override void OnTouchStart(Game game_, TouchEventArgs e)
	{
		this.ScreenOnTouchStart(e);
	}

	public void ScreenOnTouchEnd(TouchEventArgs e)
	{
		this.MouseUp(e.GetX(), e.GetY());
	}

	public void ScreenOnTouchStart(TouchEventArgs e)
	{
		e.SetHandled(this.MouseDown(e.GetX(), e.GetY()));
	}
	internal int WidgetCount;
	internal Game game;

	bool pointInRect(float x, float y, float rx, float ry, float rw, float rh)
	{
		return x >= rx && y >= ry && x < rx + rw && y < ry + rh;
	}
	internal int screenx;
	internal int screeny;
	internal MenuWidget[] widgets;
}

public class GameVersionHelper
{

	static int DateToInt(int year, int month, int day)
	{
		return year * 10000 + month * 100 + day;
	}

	static bool IsVersionDate(GamePlatform platform, string version)
	{
		IntRef versionCharsCount = new IntRef();
		int[] versionChars = platform.StringToCharArray(version, versionCharsCount);
		if (versionCharsCount.value >= 10) {
			if (versionChars[4] == 45 && versionChars[7] == 45) {
				return true;
			}
		}
		return false;
	}

	public static bool ServerVersionAtLeast(GamePlatform platform, string serverGameVersion, int year, int month, int day)
	{
		if (serverGameVersion == null) {
			return true;
		}
		if (GameVersionHelper.VersionToInt(platform, serverGameVersion) < GameVersionHelper.DateToInt(year, month, day)) {
			return false;
		}
		return true;
	}

	static int VersionToInt(GamePlatform platform, string version)
	{
		int max = 1000000000;
		if (!GameVersionHelper.IsVersionDate(platform, version)) {
			return max;
		}
		FloatRef year = new FloatRef();
		FloatRef month = new FloatRef();
		FloatRef day = new FloatRef();
		if (platform.FloatTryParse(StringTools.StringSubstring(platform, version, 0, 4), year)) {
			if (platform.FloatTryParse(StringTools.StringSubstring(platform, version, 5, 2), month)) {
				if (platform.FloatTryParse(StringTools.StringSubstring(platform, version, 8, 2), day)) {
					int year_ = platform.FloatToInt(year.value);
					int month_ = platform.FloatToInt(month.value);
					int day_ = platform.FloatToInt(day.value);
					return year_ * 10000 + month_ * 100 + day_;
				}
			}
		}
		return max;
	}
}

public class GetBlockHeight_ : DelegateGetBlockHeight
{

	public static GetBlockHeight_ Create(Game w_)
	{
		GetBlockHeight_ g = new GetBlockHeight_();
		g.w = w_;
		return g;
	}

	public override float GetBlockHeight(int x, int y, int z)
	{
		return this.w.getblockheight(x, y, z);
	}
	internal Game w;
}

public class GetCameraMatrix : IGetCameraMatrix
{

	public override float[] GetModelViewMatrix()
	{
		return this.lastmvmatrix;
	}

	public override float[] GetProjectionMatrix()
	{
		return this.lastpmatrix;
	}
	internal float[] lastmvmatrix;
	internal float[] lastpmatrix;
}

public class GlKeys
{
	public const int A = 83;
	public const int AltLeft = 5;
	public const int AltRight = 6;
	public const int B = 84;
	public const int Back = 53;
	public const int BackSlash = 129;
	public const int BackSpace = 53;
	public const int BracketLeft = 122;
	public const int BracketRight = 123;
	public const int C = 85;
	public const int CapsLock = 60;
	public const int Clear = 65;
	public const int Comma = 126;
	public const int ControlLeft = 3;
	public const int ControlRight = 4;
	public const int D = 86;
	public const int Delete = 55;
	public const int Down = 46;
	public const int E = 87;
	public const int End = 59;
	public const int Enter = 49;
	public const int Escape = 50;
	public const int F = 88;
	public const int F1 = 10;
	public const int F10 = 19;
	public const int F11 = 20;
	public const int F12 = 21;
	public const int F13 = 22;
	public const int F14 = 23;
	public const int F15 = 24;
	public const int F16 = 25;
	public const int F17 = 26;
	public const int F18 = 27;
	public const int F19 = 28;
	public const int F2 = 11;
	public const int F20 = 29;
	public const int F21 = 30;
	public const int F22 = 31;
	public const int F23 = 32;
	public const int F24 = 33;
	public const int F25 = 34;
	public const int F26 = 35;
	public const int F27 = 36;
	public const int F28 = 37;
	public const int F29 = 38;
	public const int F3 = 12;
	public const int F30 = 39;
	public const int F31 = 40;
	public const int F32 = 41;
	public const int F33 = 42;
	public const int F34 = 43;
	public const int F35 = 44;
	public const int F4 = 13;
	public const int F5 = 14;
	public const int F6 = 15;
	public const int F7 = 16;
	public const int F8 = 17;
	public const int F9 = 18;
	public const int G = 89;
	public const int H = 90;
	public const int Home = 58;
	public const int I = 91;
	public const int Insert = 54;
	public const int J = 92;
	public const int K = 93;
	public const int Keypad0 = 67;
	public const int Keypad1 = 68;
	public const int Keypad2 = 69;
	public const int Keypad3 = 70;
	public const int Keypad4 = 71;
	public const int Keypad5 = 72;
	public const int Keypad6 = 73;
	public const int Keypad7 = 74;
	public const int Keypad8 = 75;
	public const int Keypad9 = 76;
	public const int KeypadAdd = 80;
	public const int KeypadDecimal = 81;
	public const int KeypadDivide = 77;
	public const int KeypadEnter = 82;
	public const int KeypadMinus = 79;
	public const int KeypadMultiply = 78;
	public const int KeypadPlus = 80;
	public const int KeypadSubtract = 79;
	public const int L = 94;
	public const int LAlt = 5;
	public const int LBracket = 122;
	public const int LControl = 3;
	public const int LShift = 1;
	public const int LWin = 7;
	public const int LastKey = 130;
	public const int Left = 47;
	public const int M = 95;
	public const int Menu = 9;
	public const int Minus = 120;
	public const int N = 96;
	public const int NumLock = 64;
	public const int Number0 = 109;
	public const int Number1 = 110;
	public const int Number2 = 111;
	public const int Number3 = 112;
	public const int Number4 = 113;
	public const int Number5 = 114;
	public const int Number6 = 115;
	public const int Number7 = 116;
	public const int Number8 = 117;
	public const int Number9 = 118;
	public const int O = 97;
	public const int P = 98;
	public const int PageDown = 57;
	public const int PageUp = 56;
	public const int Pause = 63;
	public const int Period = 127;
	public const int Plus = 121;
	public const int PrintScreen = 62;
	public const int Q = 99;
	public const int Quote = 125;
	public const int R = 100;
	public const int RAlt = 6;
	public const int RBracket = 123;
	public const int RControl = 4;
	public const int RShift = 2;
	public const int RWin = 8;
	public const int Right = 48;
	public const int S = 101;
	public const int ScrollLock = 61;
	public const int Semicolon = 124;
	public const int ShiftLeft = 1;
	public const int ShiftRight = 2;
	public const int Slash = 128;
	public const int Sleep = 66;
	public const int Space = 51;
	public const int T = 102;
	public const int Tab = 52;
	public const int Tilde = 119;
	public const int U = 103;
	public const int Unknown = 0;
	public const int Up = 45;
	public const int V = 104;
	public const int W = 105;
	public const int WinLeft = 7;
	public const int WinRight = 8;
	public const int X = 106;
	public const int Y = 107;
	public const int Z = 108;
}

public class GlMatrixMath
{

	public static float Abs(float len)
	{
		if (len < 0) {
			return -len;
		}
		else {
			return len;
		}
	}

	public static float GLMAT_EPSILON()
	{
		float one = 1;
		return one / 1000000;
	}

	public static float PI()
	{
		float a = 3141592;
		return a / 1000000;
	}

	public static float max(float a, float b)
	{
		if (a > b) {
			return a;
		}
		else {
			return b;
		}
	}

	public static float min(float a, float b)
	{
		if (a < b) {
			return a;
		}
		else {
			return b;
		}
	}
}

public class GlobalVar
{
	public const int MAX_BLOCKTYPES = 1024;
	public const int MAX_BLOCKTYPES_SQRT = 32;
}

public class Grenade_
{
	internal int block;
	internal int sourcePlayer;
	internal float velocityX;
	internal float velocityY;
	internal float velocityZ;
}

public enum GuiState
{
	Normal,
	EscapeMenu,
	Inventory,
	MapLoading,
	CraftingRecipes,
	ModalDialog
}

public class HashSetVector3IntRef
{
	public HashSetVector3IntRef()
	{
		this.max = 16;
		this.Start();
	}

	public void Set(Vector3IntRef value)
	{
		int i = 0;
		for (i = 0; i < this.max; i++) {
			if (this.values[i] == null) {
				break;
			}
			if (this.values[i].X == value.X && this.values[i].Y == value.Y && this.values[i].Z == value.Z) {
				return;
			}
		}
		this.values[i] = Vector3IntRef.Create(value.X, value.Y, value.Z);
	}

	public void Start()
	{
		this.values = new Vector3IntRef[this.max];
	}
	internal int max;
	internal Vector3IntRef[] values;
}

public class HttpResponseCi
{

	public bool GetDone()
	{
		return this.done;
	}

	public bool GetError()
	{
		return this.error;
	}

	internal string GetString(GamePlatform platform)
	{
		return platform.StringFromUtf8ByteArray(this.value, this.valueLength);
	}

	public byte[] GetValue()
	{
		return this.value;
	}

	public int GetValueLength()
	{
		return this.valueLength;
	}

	public void SetDone(bool value_)
	{
		this.done = value_;
	}

	public void SetError(bool value_)
	{
		this.error = value_;
	}

	public void SetValue(byte[] value_)
	{
		this.value = value_;
	}

	public void SetValueLength(int value_)
	{
		this.valueLength = value_;
	}
	internal bool done;
	internal bool error;
	internal byte[] value;
	internal int valueLength;
}

public abstract class IGetCameraMatrix
{

	public abstract float[] GetModelViewMatrix();

	public abstract float[] GetProjectionMatrix();
}

public abstract class IInterpolation
{

	public abstract InterpolatedObject Interpolate(InterpolatedObject a, InterpolatedObject b, float progress);
}

public abstract class IInventoryController
{

	public abstract void InventoryClick(Packet_InventoryPosition pos);

	public abstract void MoveToInventory(Packet_InventoryPosition from);

	public abstract void WearItem(Packet_InventoryPosition from, Packet_InventoryPosition to);
}

public abstract class IMapStorage2
{

	public abstract int GetBlock(int x, int y, int z);

	public abstract int GetMapSizeX();

	public abstract int GetMapSizeY();

	public abstract int GetMapSizeZ();

	public abstract void SetBlock(int x, int y, int z, int tileType);
}

public class INetOutgoingMessage
{

	public void Write(byte[] source, int sourceCount)
	{
		this.messageLength = sourceCount;
		this.message = new byte[sourceCount];
		for (int i = 0; i < sourceCount; i++) {
			this.message[i] = source[i];
		}
	}
	internal byte[] message;
	internal int messageLength;
}

public abstract class INetworkInterpolation
{

	public abstract void AddNetworkPacket(InterpolatedObject c, int timeMilliseconds);

	public abstract InterpolatedObject InterpolatedState(int timeMilliseconds);
}

public abstract class IPEndPointCi
{

	public abstract string AddressToString();
}

public class IPEndPointCiDefault : IPEndPointCi
{

	public override string AddressToString()
	{
		return this.address;
	}

	public static IPEndPointCiDefault Create(string address_)
	{
		IPEndPointCiDefault e = new IPEndPointCiDefault();
		e.address = address_;
		return e;
	}
	internal string address;
}

public class ITerrainTextures
{
	internal Game game;

	public int terrainTexture()
	{
		return this.game.terrainTexture;
	}

	public int[] terrainTextures1d()
	{
		return this.game.terrainTextures1d;
	}

	public int terrainTexturesPerAtlas()
	{
		return this.game.terrainTexturesPerAtlas;
	}

	public int texturesPacked()
	{
		return this.game.texturesPacked();
	}
}

public abstract class ImageOnLoadHandler
{

	public abstract void OnLoad();
}

public class InfiniteMapChunked2d
{

	public void ClearChunk(int x, int y)
	{
		int px = x / 16;
		int py = y / 16;
		this.chunks[MapUtilCi.Index2d(px, py, this.d_Map.map.MapSizeX / 16)] = null;
	}

	public int GetBlock(int x, int y)
	{
		int[] chunk = this.GetChunk(x, y);
		return chunk[MapUtilCi.Index2d(x % 16, y % 16, 16)];
	}

	public int[] GetChunk(int x, int y)
	{
		int[] chunk = null;
		int kx = x / 16;
		int ky = y / 16;
		if (this.chunks[MapUtilCi.Index2d(kx, ky, this.d_Map.map.MapSizeX / 16)] == null) {
			chunk = new int[256];
			for (int i = 0; i < 256; i++) {
				chunk[i] = 0;
			}
			this.chunks[MapUtilCi.Index2d(kx, ky, this.d_Map.map.MapSizeX / 16)] = chunk;
		}
		chunk = this.chunks[MapUtilCi.Index2d(kx, ky, this.d_Map.map.MapSizeX / 16)];
		return chunk;
	}

	public void Restart()
	{
		int n = this.d_Map.map.MapSizeX / 16 * this.d_Map.map.MapSizeY / 16;
		this.chunks = new int[n][];
		for (int i = 0; i < n; i++) {
			this.chunks[i] = null;
		}
	}

	public void SetBlock(int x, int y, int blocktype)
	{
		this.GetChunk(x, y)[MapUtilCi.Index2d(x % 16, y % 16, 16)] = blocktype;
	}
	internal int[][] chunks;
	public const int chunksize = 16;
	internal Game d_Map;
}

public class IntRef
{

	public static IntRef Create(int value_)
	{
		IntRef intref = new IntRef();
		intref.value = value_;
		return intref;
	}

	public int GetValue()
	{
		return this.value;
	}

	public void SetValue(int value_)
	{
		this.value = value_;
	}
	internal int value;
}

public class InterpolatedObject
{
}

public class InterpolationCi
{

	public static int InterpolateColor(GamePlatform platform, float progress, int[] colors, int colorsLength)
	{
		float one = 1;
		int colora = platform.FloatToInt((colorsLength - 1) * progress);
		if (colora < 0) {
			colora = 0;
		}
		if (colora >= colorsLength) {
			colora = colorsLength - 1;
		}
		int colorb = colora + 1;
		if (colorb >= colorsLength) {
			colorb = colorsLength - 1;
		}
		int a = colors[colora];
		int b = colors[colorb];
		float p = (progress - one * colora / (colorsLength - 1)) * (colorsLength - 1);
		int A = platform.FloatToInt(Game.ColorA(a) + (Game.ColorA(b) - Game.ColorA(a)) * p);
		int R = platform.FloatToInt(Game.ColorR(a) + (Game.ColorR(b) - Game.ColorR(a)) * p);
		int G = platform.FloatToInt(Game.ColorG(a) + (Game.ColorG(b) - Game.ColorG(a)) * p);
		int B = platform.FloatToInt(Game.ColorB(a) + (Game.ColorB(b) - Game.ColorB(a)) * p);
		return Game.ColorFromArgb(A, R, G, B);
	}
}

public class Intersection
{
	public Intersection()
	{
	}

	/// <summary>&lt;summary&gt;
	/// Warning: randomly returns incorrect hit position (back side of box).</summary>
	/// <remarks>&lt;/summary&gt;
	/// &lt;param name="box"&gt;&lt;/param&gt;
	/// &lt;param name="line"&gt;&lt;/param&gt;
	/// &lt;param name="hit"&gt;&lt;/param&gt;
	/// &lt;returns&gt;&lt;/returns&gt;</remarks>
	public static bool CheckLineBox(Box3D box, Line3D line, float[] hit)
	{
		return Intersection.CheckLineBox1(box.MinEdge, box.MaxEdge, line.Start, line.End, hit);
	}

	public static bool CheckLineBox1(float[] B1, float[] B2, float[] L1, float[] L2, float[] Hit)
	{
		if (L2[0] < B1[0] && L1[0] < B1[0])
			return false;
		if (L2[0] > B2[0] && L1[0] > B2[0])
			return false;
		if (L2[1] < B1[1] && L1[1] < B1[1])
			return false;
		if (L2[1] > B2[1] && L1[1] > B2[1])
			return false;
		if (L2[2] < B1[2] && L1[2] < B1[2])
			return false;
		if (L2[2] > B2[2] && L1[2] > B2[2])
			return false;
		if (L1[0] > B1[0] && L1[0] < B2[0] && L1[1] > B1[1] && L1[1] < B2[1] && L1[2] > B1[2] && L1[2] < B2[2]) {
			Hit[0] = L1[0];
			Hit[1] = L1[1];
			Hit[2] = L1[2];
			return true;
		}
		if (Intersection.GetIntersection(L1[0] - B1[0], L2[0] - B1[0], L1, L2, Hit) && Intersection.InBox(Hit, B1, B2, 1) || Intersection.GetIntersection(L1[1] - B1[1], L2[1] - B1[1], L1, L2, Hit) && Intersection.InBox(Hit, B1, B2, 2) || Intersection.GetIntersection(L1[2] - B1[2], L2[2] - B1[2], L1, L2, Hit) && Intersection.InBox(Hit, B1, B2, 3) || Intersection.GetIntersection(L1[0] - B2[0], L2[0] - B2[0], L1, L2, Hit) && Intersection.InBox(Hit, B1, B2, 1) || Intersection.GetIntersection(L1[1] - B2[1], L2[1] - B2[1], L1, L2, Hit) && Intersection.InBox(Hit, B1, B2, 2) || Intersection.GetIntersection(L1[2] - B2[2], L2[2] - B2[2], L1, L2, Hit) && Intersection.InBox(Hit, B1, B2, 3))
			return true;
		return false;
	}

	public static float[] CheckLineBoxExact(Line3D line, Box3D box)
	{
		float[] dir_ = new float[3];
		dir_[0] = line.End[0] - line.Start[0];
		dir_[1] = line.End[1] - line.Start[1];
		dir_[2] = line.End[2] - line.Start[2];
		float[] hit = new float[3];
		if (!Intersection.HitBoundingBox(box.MinEdge, box.MaxEdge, line.Start, dir_, hit)) {
			return null;
		}
		return hit;
	}

	static bool GetIntersection(float fDst1, float fDst2, float[] P1, float[] P2, float[] Hit)
	{
		if (fDst1 * fDst2 >= 0)
			return false;
		if (fDst1 == fDst2)
			return false;
		Hit[0] = P1[0] + (P2[0] - P1[0]) * -fDst1 / (fDst2 - fDst1);
		Hit[1] = P1[1] + (P2[1] - P1[1]) * -fDst1 / (fDst2 - fDst1);
		Hit[2] = P1[2] + (P2[2] - P1[2]) * -fDst1 / (fDst2 - fDst1);
		return true;
	}

	public static bool HitBoundingBox(float[] minB, float[] maxB, float[] origin, float[] dir, float[] coord)
	{
		bool inside = true;
		byte[] quadrant = new byte[3];
		int i;
		int whichPlane;
		float[] maxT = new float[3];
		float[] candidatePlane = new float[3];
		for (i = 0; i < 3; i++)
			if (origin[i] < minB[i]) {
				quadrant[i] = 1;
				candidatePlane[i] = minB[i];
				inside = false;
			}
			else if (origin[i] > maxB[i]) {
				quadrant[i] = 0;
				candidatePlane[i] = maxB[i];
				inside = false;
			}
			else {
				quadrant[i] = 2;
			}
		if (inside) {
			coord = origin;
			return true;
		}
		for (i = 0; i < 3; i++)
			if (quadrant[i] != 2 && dir[i] != 0)
				maxT[i] = (candidatePlane[i] - origin[i]) / dir[i];
			else
				maxT[i] = -1;
		whichPlane = 0;
		for (i = 1; i < 3; i++)
			if (maxT[whichPlane] < maxT[i])
				whichPlane = i;
		if (maxT[whichPlane] < 0)
			return false;
		for (i = 0; i < 3; i++)
			if (whichPlane != i) {
				coord[i] = origin[i] + maxT[whichPlane] * dir[i];
				if (coord[i] < minB[i] || coord[i] > maxB[i])
					return false;
			}
			else {
				coord[i] = candidatePlane[i];
			}
		return true;
	}

	static bool InBox(float[] Hit, float[] B1, float[] B2, int Axis)
	{
		if (Axis == 1 && Hit[2] > B1[2] && Hit[2] < B2[2] && Hit[1] > B1[1] && Hit[1] < B2[1])
			return true;
		if (Axis == 2 && Hit[2] > B1[2] && Hit[2] < B2[2] && Hit[0] > B1[0] && Hit[0] < B2[0])
			return true;
		if (Axis == 3 && Hit[0] > B1[0] && Hit[0] < B2[0] && Hit[1] > B1[1] && Hit[1] < B2[1])
			return true;
		return false;
	}
}

public class InventoryUtilClient
{
	public InventoryUtilClient()
	{
		this.CellCountX = 12;
		this.CellCountY = 42;
	}
	internal int CellCountX;
	internal int CellCountY;

	internal IntRef FreeHand(int ActiveMaterial_)
	{
		IntRef freehand = null;
		if (this.d_Inventory.RightHand[ActiveMaterial_] == null)
			return IntRef.Create(ActiveMaterial_);
		for (int i = 0; i < 10; i++) {
			if (this.d_Inventory.RightHand[i] == null) {
				return freehand;
			}
		}
		return null;
	}

	public bool IsValidCell(PointRef p)
	{
		return !(p.X < 0 || p.Y < 0 || p.X >= this.CellCountX || p.Y >= this.CellCountY);
	}

	internal PointRef ItemAtCell(PointRef p)
	{
		for (int i = 0; i < this.d_Inventory.ItemsCount; i++) {
			Packet_PositionItem k = this.d_Inventory.Items[i];
			Packet_Item item = k.Value_;
			for (int x = 0; x < this.d_Items.ItemSizeX(item); x++) {
				for (int y = 0; y < this.d_Items.ItemSizeY(item); y++) {
					int px = k.X + x;
					int py = k.Y + y;
					if (p.X == px && p.Y == py) {
						return PointRef.Create(k.X, k.Y);
					}
				}
			}
		}
		return null;
	}

	internal Packet_Item ItemAtWearPlace(int wearPlace, int activeMaterial)
	{
		switch (wearPlace) {
		case 0:
			return this.d_Inventory.RightHand[activeMaterial];
		case 1:
			return this.d_Inventory.MainArmor;
		case 2:
			return this.d_Inventory.Boots;
		case 3:
			return this.d_Inventory.Helmet;
		case 4:
			return this.d_Inventory.Gauntlet;
		default:
			return null;
		}
	}

	internal PointRef[] ItemsAtArea(int pX, int pY, int sizeX, int sizeY, IntRef retCount)
	{
		PointRef[] itemsAtArea = new PointRef[256];
		int itemsAtAreaCount = 0;
		for (int xx = 0; xx < sizeX; xx++) {
			for (int yy = 0; yy < sizeY; yy++) {
				PointRef cell = PointRef.Create(pX + xx, pY + yy);
				if (!this.IsValidCell(cell)) {
					return null;
				}
				if (this.ItemAtCell(cell) != null) {
					bool contains = false;
					for (int i = 0; i < itemsAtAreaCount; i++) {
						if (itemsAtArea[i] == null) {
							continue;
						}
						if (itemsAtArea[i].X == this.ItemAtCell(cell).X && itemsAtArea[i].Y == this.ItemAtCell(cell).Y) {
							contains = true;
						}
					}
					if (!contains) {
						itemsAtArea[itemsAtAreaCount++] = this.ItemAtCell(cell);
					}
				}
			}
		}
		retCount.value = itemsAtAreaCount;
		return itemsAtArea;
	}
	internal Packet_Inventory d_Inventory;
	internal GameDataItemsClient d_Items;
}

public class IsBlockEmpty_ : DelegateIsBlockEmpty
{

	public static IsBlockEmpty_ Create(Game w_)
	{
		IsBlockEmpty_ g = new IsBlockEmpty_();
		g.w = w_;
		return g;
	}

	public override bool IsBlockEmpty(int x, int y, int z)
	{
		return this.w.IsTileEmptyForPhysics(x, y, z);
	}
	Game w;
}

public class Kamera
{
	public Kamera()
	{
		this.one = 1;
		this.distance = 5;
		this.Angle = 45;
		this.MinimumDistance = 2;
		this.tt = 0;
		this.MaximumAngle = 89;
		this.MinimumAngle = 0;
		this.Center = new Vector3Ref();
	}
	internal float Angle;
	internal Vector3Ref Center;

	public float GetAngle()
	{
		return this.Angle;
	}

	float GetCameraHeightFromCenter(GamePlatform platform)
	{
		return platform.MathSin(this.Angle * Game.GetPi() / 180) * this.distance;
	}

	public void GetCenter(Vector3Ref ret)
	{
		ret.X = this.Center.X;
		ret.Y = this.Center.Y;
		ret.Z = this.Center.Z;
	}

	public float GetDistance()
	{
		return this.distance;
	}

	float GetFlatDistance(GamePlatform platform)
	{
		return platform.MathCos(this.Angle * Game.GetPi() / 180) * this.distance;
	}

	public void GetPosition(GamePlatform platform, Vector3Ref ret)
	{
		float cx = platform.MathCos(this.tt * this.one / 2) * this.GetFlatDistance(platform) + this.Center.X;
		float cy = platform.MathSin(this.tt * this.one / 2) * this.GetFlatDistance(platform) + this.Center.Z;
		ret.X = cx;
		ret.Y = this.Center.Y + this.GetCameraHeightFromCenter(platform);
		ret.Z = cy;
	}

	public float GetT()
	{
		return this.tt;
	}
	internal int MaximumAngle;
	internal int MinimumAngle;
	internal float MinimumDistance;

	public void Move(CameraMove camera_move, float p)
	{
		p *= 2;
		p *= 2;
		if (camera_move.TurnLeft) {
			this.TurnLeft(p);
		}
		if (camera_move.TurnRight) {
			this.TurnRight(p);
		}
		if (camera_move.DistanceUp) {
			this.SetDistance(this.GetDistance() + p);
		}
		if (camera_move.DistanceDown) {
			this.SetDistance(this.GetDistance() - p);
		}
		if (camera_move.AngleUp) {
			this.Angle += p * 10;
		}
		if (camera_move.AngleDown) {
			this.Angle -= p * 10;
		}
		this.SetDistance(camera_move.Distance);
		this.SetValidAngle();
	}

	public void SetAngle(float value)
	{
		this.Angle = value;
	}

	public void SetDistance(float value)
	{
		this.distance = value;
		if (this.distance < this.MinimumDistance) {
			this.distance = this.MinimumDistance;
		}
	}

	public void SetT(float value)
	{
		this.tt = value;
	}

	void SetValidAngle()
	{
		if (this.Angle > this.MaximumAngle) {
			this.Angle = this.MaximumAngle;
		}
		if (this.Angle < this.MinimumAngle) {
			this.Angle = this.MinimumAngle;
		}
	}

	public void TurnLeft(float p)
	{
		this.tt += p;
	}

	public void TurnRight(float p)
	{
		this.tt -= p;
	}

	public void TurnUp(float p)
	{
		this.Angle += p;
		this.SetValidAngle();
	}
	float distance;
	float one;
	internal float tt;
}

public class Key
{

	public static Key Create(int field, int wireType)
	{
		Key k = new Key();
		k.Field = field;
		k.WireType = wireType;
		return k;
	}
	int Field;

	public int GetField()
	{
		return this.Field;
	}

	public int GetWireType()
	{
		return this.WireType;
	}

	public void SetField(int value)
	{
		this.Field = value;
	}

	public void SetWireType(int value)
	{
		this.WireType = value;
	}
	int WireType;
}

public class KeyEventArgs
{

	public bool GetAltPressed()
	{
		return this.modifierAlt;
	}

	public bool GetCtrlPressed()
	{
		return this.modifierCtrl;
	}

	public bool GetHandled()
	{
		return this.handled;
	}

	public int GetKeyCode()
	{
		return this.keyCode;
	}

	public bool GetShiftPressed()
	{
		return this.modifierShift;
	}

	public void SetAltPressed(bool value)
	{
		this.modifierAlt = value;
	}

	public void SetCtrlPressed(bool value)
	{
		this.modifierCtrl = value;
	}

	public void SetHandled(bool value)
	{
		this.handled = value;
	}

	public void SetKeyCode(int value)
	{
		this.keyCode = value;
	}

	public void SetShiftPressed(bool value)
	{
		this.modifierShift = value;
	}
	bool handled;
	int keyCode;
	bool modifierAlt;
	bool modifierCtrl;
	bool modifierShift;
}

public abstract class KeyEventHandler
{

	public abstract void OnKeyDown(KeyEventArgs e);

	public abstract void OnKeyPress(KeyPressEventArgs e);

	public abstract void OnKeyUp(KeyEventArgs e);
}

public class KeyHelp
{
	internal int DefaultKey;
	internal string Text;
}

public class KeyPressEventArgs
{

	public bool GetHandled()
	{
		return this.handled;
	}

	public int GetKeyChar()
	{
		return this.keyChar;
	}

	public void SetHandled(bool value)
	{
		this.handled = value;
	}

	public void SetKeyChar(int value)
	{
		this.keyChar = value;
	}
	bool handled;
	int keyChar;
}

/// <summary>&lt;summary&gt;
/// Storage of unknown fields
/// &lt;/summary&gt;</summary>
public class KeyValue
{

	public static KeyValue Create(Key key, byte[] value)
	{
		KeyValue k = new KeyValue();
		k.Key_ = key;
		k.Value = value;
		return k;
	}
	Key Key_;
	byte[] Value;
}

public class KeyValueStringInt
{
	internal string key;
	internal int value;
}

public class KeyValueStringString
{
	internal string key;
	internal string value;
}

public class Keyframe
{
	internal string animationName;
	internal int frame;
	internal int keyframeType;
	internal string nodeName;
	internal float x;
	internal float y;
	internal float z;
}

public class KeyframeType
{

	public static string GetName(int p)
	{
		if (p == 1) {
			return "pos";
		}
		if (p == 2) {
			return "rot";
		}
		if (p == 3) {
			return "siz";
		}
		if (p == 4) {
			return "piv";
		}
		if (p == 5) {
			return "sca";
		}
		return "";
	}

	public static int GetValue(string p)
	{
		if (p == "pos") {
			return 1;
		}
		if (p == "rot") {
			return 2;
		}
		if (p == "siz") {
			return 3;
		}
		if (p == "piv") {
			return 4;
		}
		if (p == "sca") {
			return 5;
		}
		return 0;
	}
	public const int Pivot = 4;
	public const int Position = 1;
	public const int Rotation = 2;
	public const int Scale = 5;
	public const int Size = 3;
}

public class Language
{
	public Language()
	{
		this.stringsMax = 32768;
		this.stringsCount = 0;
		this.strings = new TranslatedString[this.stringsMax];
		this.loadedLanguagesCount = 0;
		this.loadedLanguagesMax = 64;
		this.loadedLanguages = new string[this.loadedLanguagesMax];
	}

	void Add(string language, string id, string translated)
	{
		if (this.IsNewLanguage(language)) {
			if (this.loadedLanguagesCount < this.loadedLanguagesMax) {
				this.loadedLanguages[this.loadedLanguagesCount] = language;
				this.loadedLanguagesCount++;
			}
		}
		if (this.stringsCount > this.stringsMax) {
			return;
		}
		if (this.ContainsTranslation(language, id)) {
			return;
		}
		TranslatedString s = new TranslatedString();
		s.language = language;
		s.id = id;
		s.translated = translated;
		this.strings[this.stringsCount++] = s;
	}

	void AddEnglish()
	{
		this.Add("en", "MainMenu_AssetsLoadProgress", "Loading... {0}%");
		this.Add("en", "MainMenu_Singleplayer", "Singleplayer");
		this.Add("en", "MainMenu_Multiplayer", "Multiplayer");
		this.Add("en", "MainMenu_Quit", "&cQuit");
		this.Add("en", "MainMenu_ButtonBack", "Back");
		this.Add("en", "MainMenu_SingleplayerButtonCreate", "Create or open...");
		this.Add("en", "MainMenu_Login", "Login");
		this.Add("en", "MainMenu_LoginUsername", "Username");
		this.Add("en", "MainMenu_LoginPassword", "Password");
		this.Add("en", "MainMenu_LoginRemember", "Remember me");
		this.Add("en", "MainMenu_ChoiceYes", "Yes");
		this.Add("en", "MainMenu_ChoiceNo", "No");
		this.Add("en", "MainMenu_LoginInvalid", "&4Invalid username or password");
		this.Add("en", "MainMenu_LoginConnecting", "Connecting...");
		this.Add("en", "MainMenu_MultiplayerConnect", "Connect");
		this.Add("en", "MainMenu_MultiplayerConnectIP", "Connect to IP");
		this.Add("en", "MainMenu_MultiplayerRefresh", "Refresh");
		this.Add("en", "MainMenu_MultiplayerLoading", "Loading...");
		this.Add("en", "MainMenu_ConnectToIpConnect", "Connect");
		this.Add("en", "MainMenu_ConnectToIpIp", "IP");
		this.Add("en", "MainMenu_ConnectToIpPort", "Port");
		this.Add("en", "CannotWriteChatLog", "Cannot write to chat log file {0}.");
		this.Add("en", "ChunkUpdates", "Chunk updates: {0}");
		this.Add("en", "Connecting", "Connecting...");
		this.Add("en", "ConnectingProgressKilobytes", "{0} KB");
		this.Add("en", "ConnectingProgressPercent", "{0}%");
		this.Add("en", "DefaultKeys", "Default keys");
		this.Add("en", "Exit", "Return to main menu");
		this.Add("en", "FogDistance", "Fog distance: {0}");
		this.Add("en", "FontOption", "Font: {0}");
		this.Add("en", "FrameRateLagSimulation", "Frame rate: lag simulation.");
		this.Add("en", "FrameRateUnlimited", "Frame rate: unlimited.");
		this.Add("en", "FrameRateVsync", "Frame rate: vsync.");
		this.Add("en", "FreemoveNotAllowed", "Freemove is not allowed on this server.");
		this.Add("en", "GameName", "Manic Digger");
		this.Add("en", "Graphics", "Graphics");
		this.Add("en", "InvalidVersionConnectAnyway", "Invalid game version. Local: {0}, Server: {1}. Do you want to connect anyway?");
		this.Add("en", "KeyBlockInfo", "Block information");
		this.Add("en", "KeyChange", "{0}: {1}");
		this.Add("en", "KeyChat", "Chat");
		this.Add("en", "KeyCraft", "Craft");
		this.Add("en", "KeyFreeMove", "Free move");
		this.Add("en", "KeyFullscreen", "Fullscreen");
		this.Add("en", "KeyJump", "Jump");
		this.Add("en", "KeyMoveBack", "Move back");
		this.Add("en", "KeyMoveFoward", "Move foward");
		this.Add("en", "KeyMoveLeft", "Move left");
		this.Add("en", "KeyMoveRight", "Move right");
		this.Add("en", "KeyMoveSpeed", "{0}x move speed");
		this.Add("en", "KeyPlayersList", "Players list");
		this.Add("en", "KeyReloadWeapon", "Reload weapon");
		this.Add("en", "KeyRespawn", "Respawn");
		this.Add("en", "KeyReverseMinecart", "Reverse minecart");
		this.Add("en", "Keys", "Keys");
		this.Add("en", "KeyScreenshot", "Screenshot");
		this.Add("en", "KeySetSpawnPosition", "Set spawn position");
		this.Add("en", "KeyShowMaterialSelector", "Open inventory");
		this.Add("en", "KeyTeamChat", "Team Chat");
		this.Add("en", "KeyTextEditor", "Texteditor");
		this.Add("en", "KeyThirdPersonCamera", "Third-person camera");
		this.Add("en", "KeyToggleFogDistance", "Toggle fog distance");
		this.Add("en", "KeyUse", "Use");
		this.Add("en", "MoveFree", "Move: Free.");
		this.Add("en", "MoveFreeNoclip", "Move: Free, Noclip.");
		this.Add("en", "MoveNormal", "Move: Normal.");
		this.Add("en", "MoveSpeed", "Move Speed: {0}.");
		this.Add("en", "NoMaterialsForCrafting", "No materials for crafting.");
		this.Add("en", "Off", "OFF");
		this.Add("en", "On", "ON");
		this.Add("en", "Options", "Options");
		this.Add("en", "Other", "Other");
		this.Add("en", "PressToUse", "(press {0} to use)");
		this.Add("en", "Respawn", "Respawn");
		this.Add("en", "ReturnToGame", "Return to game");
		this.Add("en", "ReturnToMainMenu", "Back");
		this.Add("en", "ReturnToOptionsMenu", "Return to options menu");
		this.Add("en", "ShadowsOption", "Shadows: {0}");
		this.Add("en", "SoundOption", "Sound: {0}");
		this.Add("en", "AutoJumpOption", "Auto Jump: {0}");
		this.Add("en", "ClientLanguageOption", "Language: {0}");
		this.Add("en", "SpawnPositionSet", "Spawn position set.");
		this.Add("en", "SpawnPositionSetTo", "Spawn position set to: {0}");
		this.Add("en", "Triangles", "Triangles: {0}");
		this.Add("en", "UseServerTexturesOption", "Use server textures (restart): {0}");
		this.Add("en", "ViewDistanceOption", "View distance: {0}");
		this.Add("en", "OptionSmoothShadows", "Smooth shadows: {0}");
		this.Add("en", "OptionFramerate", "Framerate: {0}");
		this.Add("en", "OptionResolution", "Resolution: {0}");
		this.Add("en", "OptionFullscreen", "Fullscreen: {0}");
		this.Add("en", "OptionDarkenSides", "Darken block sides: {0}");
		this.Add("en", "Server_CannotWriteLogFile", "Cannot write to server log file {0}.");
		this.Add("en", "Server_LoadingSavegame", "Loading savegame...");
		this.Add("en", "Server_CreatingSavegame", "Creating new savegame file.");
		this.Add("en", "Server_LoadedSavegame", "Savegame loaded: ");
		this.Add("en", "Server_ConfigNotFound", "Server configuration file not found, creating new.");
		this.Add("en", "Server_ConfigCorruptBackup", "ServerConfig corrupt! Created new. Backup saved as ServerConfig.txt.old");
		this.Add("en", "Server_ConfigCorruptNoBackup", "ServerConfig corrupt! Created new. COULD NOT BACKUP OLD!");
		this.Add("en", "Server_ConfigLoaded", "Server configuration loaded.");
		this.Add("en", "Server_ClientConfigNotFound", "Server client configuration file not found, creating new.");
		this.Add("en", "Server_ClientConfigGuestGroupNotFound", "Default guest group not found!");
		this.Add("en", "Server_ClientConfigRegisteredGroupNotFound", "Default registered group not found!");
		this.Add("en", "Server_ClientConfigLoaded", "Server client configuration loaded.");
		this.Add("en", "Server_InvalidSpawnCoordinates", "Invalid default spawn coordinates!");
		this.Add("en", "Server_ProgressDownloadingData", "Downloading data...");
		this.Add("en", "Server_ProgressGenerating", "Generating world...");
		this.Add("en", "Server_ProgressDownloadingMap", "Downloading map...");
		this.Add("en", "Server_NoChatPrivilege", "{0}Insufficient privileges to chat.");
		this.Add("en", "Server_FillAreaInvalid", "Fillarea is invalid or contains blocks in an area you are not allowed to build in.");
		this.Add("en", "Server_FillAreaTooLarge", "Fill area is too large.");
		this.Add("en", "Server_NoSpectatorBuild", "Spectators are not allowed to build.");
		this.Add("en", "Server_NoBuildPrivilege", "Insufficient privileges to build.");
		this.Add("en", "Server_NoBuildPermissionHere", "You need permission to build in this section of the world.");
		this.Add("en", "Server_NoSpectatorUse", "Spectators are not allowed to use blocks.");
		this.Add("en", "Server_NoUsePrivilege", "Insufficient privileges to use blocks.");
		this.Add("en", "Server_PlayerJoin", "Player {0} joins.");
		this.Add("en", "Server_PlayerDisconnect", "Player {0} disconnected.");
		this.Add("en", "Server_UsernameBanned", "Your username has been banned from this server.{0}");
		this.Add("en", "Server_NoGuests", "Guests are not allowed on this server. Login or register an account.");
		this.Add("en", "Server_UsernameInvalid", "Invalid username (allowed characters: a-z,A-Z,0-9,-,_; max. length: 16).");
		this.Add("en", "Server_PasswordInvalid", "Invalid server password.");
		this.Add("en", "Server_ClientException", "Your client threw an exception at server.");
		this.Add("en", "Server_IPBanned", "Your IP has been banned from this server.{0}");
		this.Add("en", "Server_TooManyPlayers", "Too many players! Try to connect later.");
		this.Add("en", "Server_HTTPServerError", "Cannot start HTTP server on TCP port {0}.");
		this.Add("en", "Server_HTTPServerStarted", "HTTP server listening on TCP port {0}.");
		this.Add("en", "Server_HeartbeatSent", "Heartbeat sent.");
		this.Add("en", "Server_HeartbeatError", "Unable to send heartbeat.");
		this.Add("en", "Server_BanlistLoaded", "Server banlist loaded.");
		this.Add("en", "Server_BanlistCorruptNoBackup", "Banlist corrupt! Created new. COULD NOT BACKUP OLD!");
		this.Add("en", "Server_BanlistCorrupt", "Banlist corrupt! Created new. Backup saved as ServerBanlist.txt.old");
		this.Add("en", "Server_BanlistNotFound", "Server banlist not found, creating new.");
		this.Add("en", "Server_SetupAccept", "y");
		this.Add("en", "Server_SetupEnableHTTP", "Dou you want to enable the builtin HTTP server? (Y/N)");
		this.Add("en", "Server_SetupMaxClients", "Enter the maximum number of clients (Default: 16)");
		this.Add("en", "Server_SetupMaxClientsInvalidValue", "Number may not be negative. Using default (16)");
		this.Add("en", "Server_SetupMaxClientsInvalidInput", "Invalid input. Using default (16)");
		this.Add("en", "Server_SetupPort", "Enter the port the server shall run on (Default: 25565)");
		this.Add("en", "Server_SetupPortInvalidValue", "Out of port range. Using default (25565)");
		this.Add("en", "Server_SetupPortInvalidInput", "Invalid input. Using default (25565)");
		this.Add("en", "Server_SetupWelcomeMessage", "Enter the welcome message (displayed when joining your server)");
		this.Add("en", "Server_SetupMOTD", "Enter the MOTD (displayed on server list)");
		this.Add("en", "Server_SetupName", "Please enter the server's name");
		this.Add("en", "Server_SetupPublic", "Do you want the server to be public (visible on the server list)? (Y/N)");
		this.Add("en", "Server_SetupQuestion", "Would you like to set up some basic parameters? (Y/N)");
		this.Add("en", "Server_SetupFirstStart", "It seems this is the first time you started this server.");
		this.Add("en", "Server_GameSaved", "Game saved. ({0} seconds)");
		this.Add("en", "Server_InvalidBackupName", "Invalid backup filename: ");
		this.Add("en", "Server_MonitorConfigLoaded", "Server monitor configuration loaded.");
		this.Add("en", "Server_MonitorConfigNotFound", "Server monitor configuration file not found, creating new.");
		this.Add("en", "Server_MonitorChatMuted", "Spam protection: {0} has been muted for {1} seconds.");
		this.Add("en", "Server_MonitorChatNotSent", "Spam protection: Your message has not been sent.");
		this.Add("en", "Server_MonitorBuildingDisabled", "{0} exceeds set block limit.");
		this.Add("en", "Server_CommandInvalidArgs", "Invalid arguments. Type /help to see command's usage.");
		this.Add("en", "Server_CommandInvalidSpawnPosition", "Invalid spawn position.");
		this.Add("en", "Server_CommandNonexistantPlayer", "{0}Player {1} does not exist.");
		this.Add("en", "Server_CommandInvalidPosition", "Invalid position.");
		this.Add("en", "Server_CommandInsufficientPrivileges", "{0}Insufficient privileges to access this command.");
		this.Add("en", "Server_CommandBackupFailed", "{0}Backup could not be created. Check filename.");
		this.Add("en", "Server_CommandBackupCreated", "{0}Backup created.");
		this.Add("en", "Server_CommandException", "Command exception.");
		this.Add("en", "Server_CommandUnknown", "Unknown command /");
		this.Add("en", "Server_CommandPlayerNotFound", "{0}Player {1} not found.");
		this.Add("en", "Server_CommandPMNoAnswer", "{0}No PM to answer.");
		this.Add("en", "Server_CommandGroupNotFound", "{0}Group {1} not found.");
		this.Add("en", "Server_CommandTargetGroupSuperior", "{0}The target group is superior your group.");
		this.Add("en", "Server_CommandTargetUserSuperior", "{0}Target user is superior or equal.");
		this.Add("en", "Server_CommandSetGroupTo", "{0}{1} set group of {2} to {3}.");
		this.Add("en", "Server_CommandOpTargetOffline", "{0}Player {1} is offline. Use /chgrp_offline command.");
		this.Add("en", "Server_CommandOpTargetOnline", "{0}Player {1} is online. Use /chgrp command.");
		this.Add("en", "Server_CommandInvalidGroup", "{0}Invalid group.");
		this.Add("en", "Server_CommandSetOfflineGroupTo", "{0}{1} set group of {2} to {3} (offline).");
		this.Add("en", "Server_CommandRemoveSuccess", "{0}Client {1} removed from config.");
		this.Add("en", "Server_CommandRemoveNotFound", "{0}No entry of client {1} found.");
		this.Add("en", "Server_CommandLoginNoPW", "{0}Group {1} doesn't allow password access.");
		this.Add("en", "Server_CommandLoginSuccess", "{0}{1} logs in group {2}.");
		this.Add("en", "Server_CommandLoginInfo", "Type /help see your available privileges.");
		this.Add("en", "Server_CommandLoginInvalidPassword", "{0}Invalid password.");
		this.Add("en", "Server_CommandWelcomeChanged", "{0}{1} set new welcome message: {2}");
		this.Add("en", "Server_CommandKickBanReason", " Reason: ");
		this.Add("en", "Server_CommandKickMessage", "{0}{1} was kicked by {2}.{3}");
		this.Add("en", "Server_CommandKickNotification", "You were kicked by an administrator.{0}");
		this.Add("en", "Server_CommandNonexistantID", "{0}Player ID {1} does not exist.");
		this.Add("en", "Server_CommandBanMessage", "{0}{1} was permanently banned by {2}.{3}");
		this.Add("en", "Server_CommandBanNotification", "You were permanently banned by an administrator.{0}");
		this.Add("en", "Server_CommandIPBanMessage", "{0}{1} was permanently IP banned by {2}.{3}");
		this.Add("en", "Server_CommandIPBanNotification", "You were permanently IP banned by an administrator.{0}");
		this.Add("en", "Server_CommandTimeBanMessage", "{0}{1} was banned by {2} for {3} minutes.{4}");
		this.Add("en", "Server_CommandTimeBanNotification", "You were banned by an administrator for {0} minutes.{1}");
		this.Add("en", "Server_CommandTimeIPBanMessage", "{0}{1} was IP banned by {2} for {3} minutes.{4}");
		this.Add("en", "Server_CommandTimeIPBanNotification", "You were IP banned by an administrator for {0} minutes.{1}");
		this.Add("en", "Server_CommandTimeBanInvalidValue", "Duration must be greater than 0!");
		this.Add("en", "Server_CommandBanOfflineTargetOnline", "{0}Player {1} is online. Use /ban command.");
		this.Add("en", "Server_CommandBanOfflineMessage", "{0}{1} (offline) was banned by {2}.{3}");
		this.Add("en", "Server_CommandUnbanSuccess", "{0}Player {1} unbanned.");
		this.Add("en", "Server_CommandUnbanIPNotFound", "{0}IP {1} not found.");
		this.Add("en", "Server_CommandUnbanIPSuccess", "{0}IP {1} unbanned.");
		this.Add("en", "Server_CommandGiveAll", "{0}Given all blocks to {1}");
		this.Add("en", "Server_CommandGiveSuccess", "{0}Given {1} {2} to {3}.");
		this.Add("en", "Server_CommandResetInventorySuccess", "{0}{1}reset inventory of {2}.");
		this.Add("en", "Server_CommandResetInventoryOfflineSuccess", "{0}{1}reset inventory of {2} (offline).");
		this.Add("en", "Server_CommandMonstersToggle", "{0} turned monsters {1}.");
		this.Add("en", "Server_CommandAreaAddIdInUse", "{0}Area ID already in use.");
		this.Add("en", "Server_CommandAreaAddSuccess", "{0}New area added: {1}");
		this.Add("en", "Server_CommandAreaDeleteNonexistant", "{0}Area does not exist.");
		this.Add("en", "Server_CommandAreaDeleteSuccess", "{0}Area deleted.");
		this.Add("en", "Server_CommandAnnouncementMessage", "{0}Announcement: {1}");
		this.Add("en", "Server_CommandSetSpawnInvalidCoordinates", "{0}Invalid spawn coordinates.");
		this.Add("en", "Server_CommandSetSpawnDefaultSuccess", "{0}Default spawn position set to {1},{2},{3}.");
		this.Add("en", "Server_CommandSetSpawnGroupSuccess", "{0}Spawn position of group {1} set to {2},{3},{4}.");
		this.Add("en", "Server_CommandSetSpawnPlayerSuccess", "{0}Spawn position of player {1} set to {2},{3},{4}.");
		this.Add("en", "Server_CommandPrivilegeAddHasAlready", "{0}Player {1} already has privilege {2}.");
		this.Add("en", "Server_CommandPrivilegeAddSuccess", "{0}New privilege for {1}: {2}");
		this.Add("en", "Server_CommandPrivilegeRemoveNoPriv", "{0}Player {1} doesn't have privilege {2}.");
		this.Add("en", "Server_CommandPrivilegeRemoveSuccess", "{0} {1} lost privilege: {2}");
		this.Add("en", "Server_CommandRestartSuccess", "{0}{1} restarted server.");
		this.Add("en", "Server_CommandShutdownSuccess", "{0}{1} shut down the server.");
		this.Add("en", "Server_CommandRestartModsSuccess", "{0}{1} restarted mods.");
		this.Add("en", "Server_CommandTeleportInvalidCoordinates", "{0}Invalid coordinates.");
		this.Add("en", "Server_CommandTeleportSuccess", "{0}New Position ({1},{2},{3}).");
		this.Add("en", "Server_CommandTeleportTargetMessage", "{0}You have been teleported to ({1},{2},{3}) by {4}.");
		this.Add("en", "Server_CommandTeleportSourceMessage", "{0}You teleported {1} to ({2},{3},{4}).");
		this.Add("en", "Server_CommandFillLimitDefaultSuccess", "{0}Default fill area limit set to {1}.");
		this.Add("en", "Server_CommandFillLimitGroupSuccess", "{0}Fill area limit of group {1} set to {2}.");
		this.Add("en", "Server_CommandFillLimitPlayerSuccess", "{0}Fill area limit of player {1} set to {2}.");
		this.Add("en", "Server_CommandInvalidType", "Invalid type.");
	}

	public TranslatedString[] AllStrings()
	{
		return this.strings;
	}

	public string AutoJumpOption()
	{
		return this.Get("AutoJumpOption");
	}

	public string CannotWriteChatLog()
	{
		return this.Get("CannotWriteChatLog");
	}

	public string ChunkUpdates()
	{
		return this.Get("ChunkUpdates");
	}

	public string ClientLanguageOption()
	{
		return this.Get("ClientLanguageOption");
	}

	public string Connecting()
	{
		return this.Get("Connecting");
	}

	public string ConnectingProgressKilobytes()
	{
		return this.Get("ConnectingProgressKilobytes");
	}

	public string ConnectingProgressPercent()
	{
		return this.Get("ConnectingProgressPercent");
	}

	bool ContainsTranslation(string language, string id)
	{
		for (int i = 0; i < this.stringsCount; i++) {
			if (this.strings[i] == null) {
				continue;
			}
			if (this.strings[i].language == language) {
				if (this.strings[i].id == id) {
					return true;
				}
			}
		}
		return false;
	}

	public string DefaultKeys()
	{
		return this.Get("DefaultKeys");
	}

	public string Exit()
	{
		return this.Get("Exit");
	}

	public string FogDistance()
	{
		return this.Get("FogDistance");
	}

	public string FontOption()
	{
		return this.Get("FontOption");
	}

	public string FrameRateLagSimulation()
	{
		return this.Get("FrameRateLagSimulation");
	}

	public string FrameRateUnlimited()
	{
		return this.Get("FrameRateUnlimited");
	}

	public string FrameRateVsync()
	{
		return this.Get("FrameRateVsync");
	}

	public string FreemoveNotAllowed()
	{
		return this.Get("FreemoveNotAllowed");
	}

	public string GameName()
	{
		return this.Get("GameName");
	}

	public string Get(string id)
	{
		string currentLanguage = "en";
		if (this.OverrideLanguage != null) {
			currentLanguage = this.OverrideLanguage;
		}
		else if (this.platform != null) {
			currentLanguage = this.platform.GetLanguageIso6391();
		}
		for (int i = 0; i < this.stringsCount; i++) {
			if (this.strings[i] == null) {
				continue;
			}
			if (this.strings[i].id == id && this.strings[i].language == currentLanguage) {
				return this.strings[i].translated;
			}
		}
		for (int i = 0; i < this.stringsCount; i++) {
			if (this.strings[i] == null) {
				continue;
			}
			if (this.strings[i].id == id && this.strings[i].language == "en") {
				return this.strings[i].translated;
			}
		}
		return id;
	}

	public string GetUsedLanguage()
	{
		string currentLanguage = "en";
		if (this.OverrideLanguage != null) {
			currentLanguage = this.OverrideLanguage;
		}
		else if (this.platform != null) {
			currentLanguage = this.platform.GetLanguageIso6391();
		}
		return currentLanguage;
	}

	public string Graphics()
	{
		return this.Get("Graphics");
	}

	public string InvalidVersionConnectAnyway()
	{
		return this.Get("InvalidVersionConnectAnyway");
	}

	public bool IsNewLanguage(string language)
	{
		for (int i = 0; i < this.loadedLanguagesMax; i++) {
			if (this.loadedLanguages[i] == null) {
				continue;
			}
			if (this.loadedLanguages[i] == language) {
				return false;
			}
		}
		return true;
	}

	public string KeyBlockInfo()
	{
		return this.Get("KeyBlockInfo");
	}

	public string KeyChange()
	{
		return this.Get("KeyChange");
	}

	public string KeyChat()
	{
		return this.Get("KeyChat");
	}

	public string KeyCraft()
	{
		return this.Get("KeyCraft");
	}

	public string KeyFreeMove()
	{
		return this.Get("KeyFreeMove");
	}

	public string KeyFullscreen()
	{
		return this.Get("KeyFullscreen");
	}

	public string KeyJump()
	{
		return this.Get("KeyJump");
	}

	public string KeyMoveBack()
	{
		return this.Get("KeyMoveBack");
	}

	public string KeyMoveFoward()
	{
		return this.Get("KeyMoveFoward");
	}

	public string KeyMoveLeft()
	{
		return this.Get("KeyMoveLeft");
	}

	public string KeyMoveRight()
	{
		return this.Get("KeyMoveRight");
	}

	public string KeyMoveSpeed()
	{
		return this.Get("KeyMoveSpeed");
	}

	public string KeyPlayersList()
	{
		return this.Get("KeyPlayersList");
	}

	public string KeyReloadWeapon()
	{
		return this.Get("KeyReloadWeapon");
	}

	public string KeyRespawn()
	{
		return this.Get("KeyRespawn");
	}

	public string KeyReverseMinecart()
	{
		return this.Get("KeyReverseMinecart");
	}

	public string KeyScreenshot()
	{
		return this.Get("KeyScreenshot");
	}

	public string KeySetSpawnPosition()
	{
		return this.Get("KeySetSpawnPosition");
	}

	public string KeyShowMaterialSelector()
	{
		return this.Get("KeyShowMaterialSelector");
	}

	public string KeyTeamChat()
	{
		return this.Get("KeyTeamChat");
	}

	public string KeyTextEditor()
	{
		return this.Get("KeyTextEditor");
	}

	public string KeyThirdPersonCamera()
	{
		return this.Get("KeyThirdPersonCamera");
	}

	public string KeyToggleFogDistance()
	{
		return this.Get("KeyToggleFogDistance");
	}

	public string KeyUse()
	{
		return this.Get("KeyUse");
	}

	public string Keys()
	{
		return this.Get("Keys");
	}

	public void LoadTranslations()
	{
		IntRef fileCount = IntRef.Create(0);
		string[] fileList = this.platform.DirectoryGetFiles(this.platform.PathCombine("data", "localization"), fileCount);
		for (int i = 0; i < fileCount.value; i++) {
			IntRef lineCount = IntRef.Create(0);
			string[] lineList = this.platform.FileReadAllLines(fileList[i], lineCount);
			for (int j = 1; j < lineCount.value; j++) {
				if (this.platform.StringEmpty(lineList[j])) {
					continue;
				}
				IntRef splitCount = IntRef.Create(0);
				string[] splitList = this.platform.StringSplit(lineList[j], "=", splitCount);
				if (splitCount.value >= 2) {
					this.Add(lineList[0], splitList[0], splitList[1]);
				}
			}
		}
		this.AddEnglish();
	}

	public string MoveFree()
	{
		return this.Get("MoveFree");
	}

	public string MoveFreeNoclip()
	{
		return this.Get("MoveFreeNoclip");
	}

	public string MoveNormal()
	{
		return this.Get("MoveNormal");
	}

	public string MoveSpeed()
	{
		return this.Get("MoveSpeed");
	}

	public void NextLanguage()
	{
		if (this.OverrideLanguage == null) {
			this.OverrideLanguage = "en";
		}
		int languageIndex = -1;
		for (int i = 0; i < this.loadedLanguagesMax; i++) {
			if (this.loadedLanguages[i] == null) {
				continue;
			}
			if (this.loadedLanguages[i] == this.OverrideLanguage) {
				languageIndex = i;
			}
		}
		if (languageIndex < 0) {
			languageIndex = 0;
		}
		languageIndex++;
		if (languageIndex >= this.loadedLanguagesMax || languageIndex >= this.loadedLanguagesCount) {
			languageIndex = 0;
		}
		this.OverrideLanguage = this.loadedLanguages[languageIndex];
	}

	public string NoMaterialsForCrafting()
	{
		return this.Get("NoMaterialsForCrafting");
	}

	public string Off()
	{
		return this.Get("Off");
	}

	public string On()
	{
		return this.Get("On");
	}

	public string OptionFramerate()
	{
		return this.Get("OptionFramerate");
	}

	public string OptionFullscreen()
	{
		return this.Get("OptionFullscreen");
	}

	public string OptionResolution()
	{
		return this.Get("OptionResolution");
	}

	public string OptionSmoothShadows()
	{
		return this.Get("OptionSmoothShadows");
	}

	public string Options()
	{
		return this.Get("Options");
	}

	public string Other()
	{
		return this.Get("Other");
	}

	public void Override(string language, string id, string translated)
	{
		if (this.IsNewLanguage(language)) {
			if (this.loadedLanguagesCount < this.loadedLanguagesMax) {
				this.loadedLanguages[this.loadedLanguagesCount] = language;
				this.loadedLanguagesCount++;
			}
		}
		if (!this.ContainsTranslation(language, id)) {
			this.Add(language, id, translated);
		}
		else {
			int replaceIndex = -1;
			for (int i = 0; i < this.stringsCount; i++) {
				if (this.strings[i] == null) {
					continue;
				}
				if (this.strings[i].language == language) {
					if (this.strings[i].id == id) {
						replaceIndex = i;
						break;
					}
				}
			}
			if (replaceIndex != -1) {
				TranslatedString s = new TranslatedString();
				s.language = language;
				s.id = id;
				s.translated = translated;
				this.strings[replaceIndex] = s;
			}
		}
	}
	internal string OverrideLanguage;

	public string PressToUse()
	{
		return this.Get("PressToUse");
	}

	public string Respawn()
	{
		return this.Get("Respawn");
	}

	public string ReturnToGame()
	{
		return this.Get("ReturnToGame");
	}

	public string ReturnToMainMenu()
	{
		return this.Get("ReturnToMainMenu");
	}

	public string ReturnToOptionsMenu()
	{
		return this.Get("ReturnToOptionsMenu");
	}

	public string ServerBanlistCorrupt()
	{
		return this.Get("Server_BanlistCorrupt");
	}

	public string ServerBanlistCorruptNoBackup()
	{
		return this.Get("Server_BanlistCorruptNoBackup");
	}

	public string ServerBanlistLoaded()
	{
		return this.Get("Server_BanlistLoaded");
	}

	public string ServerBanlistNotFound()
	{
		return this.Get("Server_BanlistNotFound");
	}

	public string ServerCannotWriteLog()
	{
		return this.Get("Server_CannotWriteLogFile");
	}

	public string ServerClientConfigGuestGroupNotFound()
	{
		return this.Get("Server_ClientConfigGuestGroupNotFound");
	}

	public string ServerClientConfigLoaded()
	{
		return this.Get("Server_ClientConfigLoaded");
	}

	public string ServerClientConfigNotFound()
	{
		return this.Get("Server_ClientConfigNotFound");
	}

	public string ServerClientConfigRegisteredGroupNotFound()
	{
		return this.Get("Server_ClientConfigRegisteredGroupNotFound");
	}

	public string ServerClientException()
	{
		return this.Get("Server_ClientException");
	}

	public string ServerConfigCorruptBackup()
	{
		return this.Get("Server_ConfigCorruptBackup");
	}

	public string ServerConfigCorruptNoBackup()
	{
		return this.Get("Server_ConfigCorruptNoBackup");
	}

	public string ServerConfigLoaded()
	{
		return this.Get("Server_ConfigLoaded");
	}

	public string ServerConfigNotFound()
	{
		return this.Get("Server_ConfigNotFound");
	}

	public string ServerCreatingSavegame()
	{
		return this.Get("Server_CreatingSavegame");
	}

	public string ServerFillAreaInvalid()
	{
		return this.Get("Server_FillAreaInvalid");
	}

	public string ServerFillAreaTooLarge()
	{
		return this.Get("Server_FillAreaTooLarge");
	}

	public string ServerGameSaved()
	{
		return this.Get("Server_GameSaved");
	}

	public string ServerHTTPServerError()
	{
		return this.Get("Server_HTTPServerError");
	}

	public string ServerHTTPServerStarted()
	{
		return this.Get("Server_HTTPServerStarted");
	}

	public string ServerHeartbeatError()
	{
		return this.Get("Server_HeartbeatError");
	}

	public string ServerHeartbeatSent()
	{
		return this.Get("Server_HeartbeatSent");
	}

	public string ServerIPBanned()
	{
		return this.Get("Server_IPBanned");
	}

	public string ServerInvalidBackupName()
	{
		return this.Get("Server_InvalidBackupName");
	}

	public string ServerInvalidSpawnCoordinates()
	{
		return this.Get("Server_InvalidSpawnCoordinates");
	}

	public string ServerLoadedSavegame()
	{
		return this.Get("Server_LoadedSavegame");
	}

	public string ServerLoadingSavegame()
	{
		return this.Get("Server_LoadingSavegame");
	}

	public string ServerMonitorBuildingDisabled()
	{
		return this.Get("Server_MonitorBuildingDisabled");
	}

	public string ServerMonitorChatMuted()
	{
		return this.Get("Server_MonitorChatMuted");
	}

	public string ServerMonitorChatNotSent()
	{
		return this.Get("Server_MonitorChatNotSent");
	}

	public string ServerMonitorConfigLoaded()
	{
		return this.Get("Server_MonitorConfigLoaded");
	}

	public string ServerMonitorConfigNotFound()
	{
		return this.Get("Server_MonitorConfigNotFound");
	}

	public string ServerNoBuildPermissionHere()
	{
		return this.Get("Server_NoBuildPermissionHere");
	}

	public string ServerNoBuildPrivilege()
	{
		return this.Get("Server_NoBuildPrivilege");
	}

	public string ServerNoChatPrivilege()
	{
		return this.Get("Server_NoChatPrivilege");
	}

	public string ServerNoGuests()
	{
		return this.Get("Server_NoGuests");
	}

	public string ServerNoSpectatorBuild()
	{
		return this.Get("Server_NoSpectatorBuild");
	}

	public string ServerNoSpectatorUse()
	{
		return this.Get("Server_NoSpectatorUse");
	}

	public string ServerNoUsePrivilege()
	{
		return this.Get("Server_NoUsePrivilege");
	}

	public string ServerPasswordInvalid()
	{
		return this.Get("Server_PasswordInvalid");
	}

	public string ServerPlayerDisconnect()
	{
		return this.Get("Server_PlayerDisconnect");
	}

	public string ServerPlayerJoin()
	{
		return this.Get("Server_PlayerJoin");
	}

	public string ServerProgressDownloadingData()
	{
		return this.Get("Server_ProgressDownloadingData");
	}

	public string ServerProgressDownloadingMap()
	{
		return this.Get("Server_ProgressDownloadingMap");
	}

	public string ServerProgressGenerating()
	{
		return this.Get("Server_ProgressGenerating");
	}

	public string ServerSetupAccept()
	{
		return this.Get("Server_SetupAccept");
	}

	public string ServerSetupEnableHTTP()
	{
		return this.Get("Server_SetupEnableHTTP");
	}

	public string ServerSetupFirstStart()
	{
		return this.Get("Server_SetupFirstStart");
	}

	public string ServerSetupMOTD()
	{
		return this.Get("Server_SetupMOTD");
	}

	public string ServerSetupMaxClients()
	{
		return this.Get("Server_SetupMaxClients");
	}

	public string ServerSetupMaxClientsInvalidInput()
	{
		return this.Get("Server_SetupMaxClientsInvalidInput");
	}

	public string ServerSetupMaxClientsInvalidValue()
	{
		return this.Get("Server_SetupMaxClientsInvalidValue");
	}

	public string ServerSetupName()
	{
		return this.Get("Server_SetupName");
	}

	public string ServerSetupPort()
	{
		return this.Get("Server_SetupPort");
	}

	public string ServerSetupPortInvalidInput()
	{
		return this.Get("Server_SetupPortInvalidInput");
	}

	public string ServerSetupPortInvalidValue()
	{
		return this.Get("Server_SetupPortInvalidValue");
	}

	public string ServerSetupPublic()
	{
		return this.Get("Server_SetupPublic");
	}

	public string ServerSetupQuestion()
	{
		return this.Get("Server_SetupQuestion");
	}

	public string ServerSetupWelcomeMessage()
	{
		return this.Get("Server_SetupWelcomeMessage");
	}

	public string ServerTooManyPlayers()
	{
		return this.Get("Server_TooManyPlayers");
	}

	public string ServerUsernameBanned()
	{
		return this.Get("Server_UsernameBanned");
	}

	public string ServerUsernameInvalid()
	{
		return this.Get("Server_UsernameInvalid");
	}

	public string ShadowsOption()
	{
		return this.Get("ShadowsOption");
	}

	public string SoundOption()
	{
		return this.Get("SoundOption");
	}

	public string SpawnPositionSet()
	{
		return this.Get("SpawnPositionSet");
	}

	public string SpawnPositionSetTo()
	{
		return this.Get("SpawnPositionSetTo");
	}

	public string Triangles()
	{
		return this.Get("Triangles");
	}

	public string UseServerTexturesOption()
	{
		return this.Get("UseServerTexturesOption");
	}

	public string ViewDistanceOption()
	{
		return this.Get("ViewDistanceOption");
	}
	internal string[] loadedLanguages;
	internal int loadedLanguagesCount;
	internal int loadedLanguagesMax;
	internal GamePlatform platform;
	TranslatedString[] strings;
	int stringsCount;
	int stringsMax;
}

public class LightBase
{
	public LightBase()
	{
		this.flood = new LightFlood();
		this.workData = new int[4096];
	}

	public void CalculateChunkBaseLight(Game game, int cx, int cy, int cz, int[] dataLightRadius, bool[] transparentForLight)
	{
		Chunk chunk = game.map.GetChunk_(cx, cy, cz);
		if (chunk.data != null) {
			for (int i = 0; i < 4096; i++) {
				this.workData[i] = chunk.data[i];
			}
		}
		if (chunk.dataInt != null) {
			for (int i = 0; i < 4096; i++) {
				this.workData[i] = chunk.dataInt[i];
			}
		}
		int sunlight = game.sunlight_;
		byte[] workLight = chunk.baseLight;
		for (int i = 0; i < 4096; i++) {
			workLight[i] = 0;
		}
		LightBase.Sunlight(game, cx, cy, cz, workLight, dataLightRadius, sunlight);
		this.SunlightFlood(this.workData, workLight, dataLightRadius, transparentForLight);
		this.LightEmitting(this.workData, workLight, dataLightRadius, transparentForLight);
	}

	static int GetLightHeight(Game game, int cx, int cy, int xx, int yy)
	{
		int[] chunk = game.d_Heightmap.chunks[MapUtilCi.Index2d(cx, cy, game.map.MapSizeX / 16)];
		if (chunk == null) {
			return 0;
		}
		return chunk[MapUtilCi.Index2d(xx % 16, yy % 16, 16)];
	}

	void LightEmitting(int[] workportion, byte[] worklight, int[] dataLightRadius, bool[] dataTransparent)
	{
		for (int pos = 0; pos < 4096; pos++) {
			if (workportion[pos] >= 10) {
				if (dataLightRadius[workportion[pos]] != 0) {
					if (dataLightRadius[workportion[pos]] > worklight[pos]) {
						int xx = MapUtilCi.PosX(pos, 16, 16);
						int yy = MapUtilCi.PosY(pos, 16, 16);
						int zz = MapUtilCi.PosZ(pos, 16, 16);
						int l = dataLightRadius[workportion[pos]];
						worklight[pos] = Game.IntToByte(MathCi.MaxInt(l, worklight[pos]));
						this.flood.FloodLight(workportion, worklight, xx, yy, zz, dataLightRadius, dataTransparent);
					}
				}
			}
		}
	}

	static void Sunlight(Game game, int cx, int cy, int cz, byte[] worklight, int[] dataLightRadius, int sunlight)
	{
		int baseheight = cz * 16;
		for (int xx = 0; xx < 16; xx++) {
			for (int yy = 0; yy < 16; yy++) {
				int height = LightBase.GetLightHeight(game, cx, cy, xx, yy);
				int h = height - baseheight;
				if (h < 0) {
					h = 0;
				}
				if (h > 16) {
					continue;
				}
				int pos = (h * 16 + yy) * 16 + xx;
				for (int zz = h; zz < 16; zz++) {
					worklight[pos] = Game.IntToByte(sunlight);
					pos += 256;
				}
			}
		}
	}

	void SunlightFlood(int[] workportion, byte[] worklight, int[] dataLightRadius, bool[] dataTransparent)
	{
		for (int xx = 0; xx < 16; xx++) {
			for (int yy = 0; yy < 16; yy++) {
				for (int zz = 0; zz < 16; zz++) {
					int pos = (zz * 16 + yy) * 16 + xx;
					if (!dataTransparent[workportion[pos]]) {
						continue;
					}
					int curlight = worklight[pos];
					int posXPlus1 = pos + 1;
					int posYPlus1 = pos + 16;
					if (xx + 1 < 16 && worklight[posXPlus1] != curlight && dataTransparent[workportion[posXPlus1]]) {
						this.flood.FloodLight(workportion, worklight, xx, yy, zz, dataLightRadius, dataTransparent);
						this.flood.FloodLight(workportion, worklight, xx + 1, yy, zz, dataLightRadius, dataTransparent);
					}
					if (yy + 1 < 16 && worklight[posYPlus1] != curlight && dataTransparent[workportion[posYPlus1]]) {
						this.flood.FloodLight(workportion, worklight, xx, yy, zz, dataLightRadius, dataTransparent);
						this.flood.FloodLight(workportion, worklight, xx, yy + 1, zz, dataLightRadius, dataTransparent);
					}
				}
			}
		}
	}
	LightFlood flood;
	int[] workData;
}

public class LightBetweenChunks
{
	public LightBetweenChunks()
	{
		this.chunksLight = new byte[27][];
		for (int i = 0; i < 27; i++) {
			this.chunksLight[i] = new byte[4096];
		}
		this.chunksData = new int[27][];
		for (int i = 0; i < 27; i++) {
			this.chunksData[i] = new int[4096];
		}
		this.flood = new LightFlood();
	}

	void ArrayFillByte(byte[] arr, int n, byte value)
	{
		for (int i = 0; i < n; i++) {
			arr[i] = value;
		}
	}

	void ArrayFillInt(int[] arr, int n, int value)
	{
		for (int i = 0; i < n; i++) {
			arr[i] = value;
		}
	}

	public void CalculateLightBetweenChunks(Game game, int cx, int cy, int cz, int[] dataLightRadius, bool[] dataTransparent)
	{
		this.Input(game, cx, cy, cz);
		this.FloodBetweenChunks_(dataLightRadius, dataTransparent);
		this.Output(game, cx, cy, cz);
	}

	void FloodBetweenChunks(byte[][] chunksLight_, byte[] cLight, byte[] dcLight, int cx, int cy, int cz, int dcx, int dcy, int dcz, int xx, int yy, int zz, int dxx, int dyy, int dzz, int[] dataLightRadius, bool[] dataTransparent)
	{
		int sourceLight = cLight[(zz * 16 + yy) * 16 + xx];
		int targetLight = dcLight[(dzz * 16 + dyy) * 16 + dxx];
		if (targetLight < sourceLight - 1) {
			dcLight[(dzz * 16 + dyy) * 16 + dxx] = Game.IntToByte(sourceLight - 1);
			this.flood.FloodLight(this.chunksData[(dcz * 3 + dcy) * 3 + dcx], dcLight, dxx, dyy, dzz, dataLightRadius, dataTransparent);
		}
	}

	void FloodBetweenChunks_(int[] dataLightRadius, bool[] dataTransparent)
	{
		for (int i = 0; i < 2; i++) {
			for (int x = 0; x < 3; x++) {
				for (int y = 0; y < 3; y++) {
					for (int z = 0; z < 3; z++) {
						byte[] clight = this.chunksLight[(z * 3 + y) * 3 + x];
						if (z < 2) {
							byte[] dclight = this.chunksLight[((z + 1) * 3 + y) * 3 + x];
							for (int xx = 0; xx < 16; xx++) {
								for (int yy = 0; yy < 16; yy++) {
									this.FloodBetweenChunks(this.chunksLight, clight, dclight, x, y, z, x, y, z + 1, xx, yy, 15, xx, yy, 0, dataLightRadius, dataTransparent);
								}
							}
						}
						if (z > 0) {
							byte[] dclight = this.chunksLight[((z - 1) * 3 + y) * 3 + x];
							for (int xx = 0; xx < 16; xx++) {
								for (int yy = 0; yy < 16; yy++) {
									this.FloodBetweenChunks(this.chunksLight, clight, dclight, x, y, z, x, y, z - 1, xx, yy, 0, xx, yy, 15, dataLightRadius, dataTransparent);
								}
							}
						}
						if (x < 2) {
							byte[] dclight = this.chunksLight[(z * 3 + y) * 3 + x + 1];
							for (int yy = 0; yy < 16; yy++) {
								for (int zz = 0; zz < 16; zz++) {
									this.FloodBetweenChunks(this.chunksLight, clight, dclight, x, y, z, x + 1, y, z, 15, yy, zz, 0, yy, zz, dataLightRadius, dataTransparent);
								}
							}
						}
						if (x > 0) {
							byte[] dclight = this.chunksLight[(z * 3 + y) * 3 + x - 1];
							for (int yy = 0; yy < 16; yy++) {
								for (int zz = 0; zz < 16; zz++) {
									this.FloodBetweenChunks(this.chunksLight, clight, dclight, x, y, z, x - 1, y, z, 0, yy, zz, 15, yy, zz, dataLightRadius, dataTransparent);
								}
							}
						}
						if (y < 2) {
							byte[] dclight = this.chunksLight[(z * 3 + y + 1) * 3 + x];
							for (int xx = 0; xx < 16; xx++) {
								for (int zz = 0; zz < 16; zz++) {
									this.FloodBetweenChunks(this.chunksLight, clight, dclight, x, y, z, x, y + 1, z, xx, 15, zz, xx, 0, zz, dataLightRadius, dataTransparent);
								}
							}
						}
						if (y > 0) {
							byte[] dclight = this.chunksLight[(z * 3 + y - 1) * 3 + x];
							for (int xx = 0; xx < 16; xx++) {
								for (int zz = 0; zz < 16; zz++) {
									this.FloodBetweenChunks(this.chunksLight, clight, dclight, x, y, z, x, y - 1, z, xx, 0, zz, xx, 15, zz, dataLightRadius, dataTransparent);
								}
							}
						}
					}
				}
			}
		}
	}

	void Input(Game game, int cx, int cy, int cz)
	{
		for (int x = 0; x < 3; x++) {
			for (int y = 0; y < 3; y++) {
				for (int z = 0; z < 3; z++) {
					int pcx = cx + x - 1;
					int pcy = cy + y - 1;
					int pcz = cz + z - 1;
					if (!game.map.IsValidChunkPos(pcx, pcy, pcz)) {
						this.ArrayFillInt(this.chunksData[(z * 3 + y) * 3 + x], 4096, 0);
						this.ArrayFillByte(this.chunksLight[(z * 3 + y) * 3 + x], 4096, 0);
						continue;
					}
					Chunk p = game.map.GetChunk_(pcx, pcy, pcz);
					int[] data = this.chunksData[(z * 3 + y) * 3 + x];
					if (p.data != null) {
						for (int i = 0; i < 4096; i++) {
							data[i] = p.data[i];
						}
					}
					if (p.dataInt != null) {
						for (int i = 0; i < 4096; i++) {
							data[i] = p.dataInt[i];
						}
					}
					byte[] light = this.chunksLight[(z * 3 + y) * 3 + x];
					for (int i = 0; i < 4096; i++) {
						light[i] = p.baseLight[i];
					}
				}
			}
		}
	}

	void Output(Game game, int cx, int cy, int cz)
	{
		Chunk chunk = game.map.GetChunk_(cx, cy, cz);
		for (int x = 0; x < 18; x++) {
			for (int y = 0; y < 18; y++) {
				for (int z = 0; z < 18; z++) {
					int baseglobalx = 15 + x;
					int baseglobaly = 15 + y;
					int baseglobalz = 15 + z;
					byte light = 15;
					int basecx = baseglobalx / 16;
					int basecy = baseglobaly / 16;
					int basecz = baseglobalz / 16;
					{
						int basexx = baseglobalx % 16;
						int baseyy = baseglobaly % 16;
						int basezz = baseglobalz % 16;
						light = this.chunksLight[(basecz * 3 + basecy) * 3 + basecx][(basezz * 16 + baseyy) * 16 + basexx];
					}
					chunk.rendered.light[(z * 18 + y) * 18 + x] = light;
				}
			}
		}
	}
	int[][] chunksData;
	byte[][] chunksLight;
	LightFlood flood;
}

public class LightFlood
{
	public LightFlood()
	{
		this.q = new FastQueueInt();
		this.q.Initialize(1024);
	}

	public void FloodLight(int[] chunk, byte[] light, int startx, int starty, int startz, int[] dataLightRadius, bool[] dataTransparent)
	{
		int start = (startz * 16 + starty) * 16 + startx;
		if (light[start] == 0) {
			return;
		}
		this.q.Clear();
		this.q.Push(start);
		for (;;) {
			if (this.q.Count == 0) {
				break;
			}
			int vPos = this.q.Pop();
			int vLight = light[vPos];
			if (vLight == 0) {
				continue;
			}
			int vBlock = chunk[vPos];
			if (!dataTransparent[vBlock] && dataLightRadius[vBlock] == 0) {
				continue;
			}
			int x = MapUtilCi.PosX(vPos, 16, 16);
			int y = MapUtilCi.PosY(vPos, 16, 16);
			int z = MapUtilCi.PosZ(vPos, 16, 16);
			if (x < 15) {
				LightFlood.Push(this.q, light, vLight, vPos + 1);
			}
			if (x > 0) {
				LightFlood.Push(this.q, light, vLight, vPos + -1);
			}
			if (y < 15) {
				LightFlood.Push(this.q, light, vLight, vPos + 16);
			}
			if (y > 0) {
				LightFlood.Push(this.q, light, vLight, vPos + -16);
			}
			if (z < 15) {
				LightFlood.Push(this.q, light, vLight, vPos + 256);
			}
			if (z > 0) {
				LightFlood.Push(this.q, light, vLight, vPos + -256);
			}
		}
	}

	static void Push(FastQueueInt q_, byte[] light, int vLight, int newPos)
	{
		if (light[newPos] < vLight - 1) {
			light[newPos] = Game.IntToByte(vLight - 1);
			q_.Push(newPos);
		}
	}
	public const int XMinus = -1;
	public const int XPlus = 1;
	public const int YMinus = -16;
	public const int YPlus = 16;
	public const int ZMinus = -256;
	public const int ZPlus = 256;
	FastQueueInt q;
}

public class Line3D
{
	internal float[] End;
	internal float[] Start;
}

public class ListAction
{

	internal void Add(Action_ action)
	{
		this.items[this.count++] = action;
	}

	internal void Clear()
	{
		for (int i = 0; i < this.count; i++) {
			this.items[i] = null;
		}
		this.count = 0;
	}

	internal int Count()
	{
		return this.count;
	}

	public static ListAction Create(int max_)
	{
		ListAction l = new ListAction();
		l.Start(max_);
		return l;
	}

	internal void RemoveAt(int index)
	{
		for (int i = index; i < this.count - 1; i++) {
			this.items[i] = this.items[i + 1];
		}
		this.count--;
	}

	public void Start(int max_)
	{
		this.max = max_;
		this.items = new Action_[max_];
		this.count = 0;
	}
	internal int count;
	internal Action_[] items;
	internal int max;
}

public class ListBox3d
{
	internal Box3D[] arr;
	internal int count;
}

public class ListConnectedPlayer
{
	public ListConnectedPlayer()
	{
		this.items = new ConnectedPlayer[1024];
		this.count = 0;
	}

	internal void Add(ConnectedPlayer connectedPlayer)
	{
		this.items[this.count++] = connectedPlayer;
	}

	internal void RemoveAt(int at)
	{
		for (int i = at; i < this.count - 1; i++) {
			this.items[i] = this.items[i + 1];
		}
		this.count--;
	}
	internal int count;
	internal ConnectedPlayer[] items;
}

public class ListInfo
{
	public ListInfo()
	{
		this.render = true;
	}
	internal float centerX;
	internal float centerY;
	internal float centerZ;
	internal bool empty;
	internal int indicescount;
	internal Model model;
	internal float radius;
	internal bool render;
	internal int texture;
	internal bool transparent;
}

public class LoginClientCi
{

	public void Login(GamePlatform platform, string user, string password, string publicServerKey, string token, LoginResultRef result, LoginData resultLoginData_)
	{
		this.loginResult = result;
		this.resultLoginData = resultLoginData_;
		result.value = LoginResult.Connecting;
		this.LoginUser = user;
		this.LoginPassword = password;
		this.LoginToken = token;
		this.LoginPublicServerKey = publicServerKey;
		this.shouldLogin = true;
	}
	string LoginPassword;
	string LoginPublicServerKey;
	string LoginToken;
	string LoginUser;

	public void Update(GamePlatform platform)
	{
		if (this.loginResult == null) {
			return;
		}
		if (this.loginUrlResponse == null && this.loginUrl == null) {
			this.loginUrlResponse = new HttpResponseCi();
			platform.WebClientDownloadDataAsync("http://manicdigger.sourceforge.net/login.php", this.loginUrlResponse);
		}
		if (this.loginUrlResponse != null && this.loginUrlResponse.done) {
			this.loginUrl = platform.StringFromUtf8ByteArray(this.loginUrlResponse.value, this.loginUrlResponse.valueLength);
			this.loginUrlResponse = null;
		}
		if (this.loginUrl != null) {
			if (this.shouldLogin) {
				this.shouldLogin = false;
				string requestString = platform.StringFormat4("username={0}&password={1}&server={2}&token={3}", this.LoginUser, this.LoginPassword, this.LoginPublicServerKey, this.LoginToken);
				IntRef byteArrayLength = new IntRef();
				byte[] byteArray = platform.StringToUtf8ByteArray(requestString, byteArrayLength);
				this.loginResponse = new HttpResponseCi();
				platform.WebClientUploadDataAsync(this.loginUrl, byteArray, byteArrayLength.value, this.loginResponse);
			}
			if (this.loginResponse != null && this.loginResponse.done) {
				string responseString = platform.StringFromUtf8ByteArray(this.loginResponse.value, this.loginResponse.valueLength);
				this.resultLoginData.PasswordCorrect = !(platform.StringContains(responseString, "Wrong username") || platform.StringContains(responseString, "Incorrect username"));
				this.resultLoginData.ServerCorrect = !platform.StringContains(responseString, "server");
				if (this.resultLoginData.PasswordCorrect) {
					this.loginResult.value = LoginResult.Ok;
				}
				else {
					this.loginResult.value = LoginResult.Failed;
				}
				IntRef linesCount = new IntRef();
				string[] lines = platform.ReadAllLines(responseString, linesCount);
				if (linesCount.value >= 3) {
					this.resultLoginData.AuthCode = lines[0];
					this.resultLoginData.ServerAddress = lines[1];
					this.resultLoginData.Port = platform.IntParse(lines[2]);
					this.resultLoginData.Token = lines[3];
				}
				this.loginResponse = null;
			}
		}
	}
	HttpResponseCi loginResponse;
	internal LoginResultRef loginResult;
	string loginUrl;
	HttpResponseCi loginUrlResponse;
	LoginData resultLoginData;
	bool shouldLogin;
}

public class LoginData
{
	internal string AuthCode;
	internal bool PasswordCorrect;
	internal int Port;
	internal string ServerAddress;
	internal bool ServerCorrect;
	internal string Token;
}

public enum LoginResult
{
	None,
	Connecting,
	Failed,
	Ok
}

public class LoginResultRef
{
	internal LoginResult value;
}

public class MainMenu
{
	public MainMenu()
	{
		this.one = 1;
		this.textures = new DictionaryStringInt1024();
		this.textTextures = new TextTexture[256];
		this.textTexturesCount = 0;
		this.screen = new ScreenMain();
		this.screen.menu = this;
		this.loginClient = new LoginClientCi();
		this.assets = new AssetList();
		this.assetsLoadProgress = new FloatRef();
	}

	void Animate(float dt)
	{
		float maxDt = 1;
		if (dt > maxDt) {
			dt = maxDt;
		}
		if (this.xInv) {
			if (this.xRot <= -this.overlap) {
				this.xInv = false;
				this.xSpeed = this.minspeed + this.rnd.MaxNext(5);
			}
			this.xRot -= this.xSpeed * dt;
		}
		else {
			if (this.xRot >= this.overlap) {
				this.xInv = true;
				this.xSpeed = this.minspeed + this.rnd.MaxNext(5);
			}
			this.xRot += this.xSpeed * dt;
		}
		if (this.yInv) {
			if (this.yRot <= -this.overlap) {
				this.yInv = false;
				this.ySpeed = this.minspeed + this.rnd.MaxNext(5);
			}
			this.yRot -= this.ySpeed * dt;
		}
		else {
			if (this.yRot >= this.overlap) {
				this.yInv = true;
				this.ySpeed = this.minspeed + this.rnd.MaxNext(5);
			}
			this.yRot += this.ySpeed * dt;
		}
	}

	public string CharRepeat(int c, int length)
	{
		int[] charArray = new int[length];
		for (int i = 0; i < length; i++) {
			charArray[i] = c;
		}
		return this.p.CharArrayToString(charArray, length);
	}

	public string CharToString(int a)
	{
		int[] arr = new int[1];
		arr[0] = a;
		return this.p.CharArrayToString(arr, 1);
	}

	internal void ConnectToGame(LoginData loginResultData, string username)
	{
		ConnectData connectData = new ConnectData();
		connectData.Ip = loginResultData.ServerAddress;
		connectData.Port = loginResultData.Port;
		connectData.Auth = loginResultData.AuthCode;
		connectData.Username = username;
		this.StartGame(false, null, connectData);
	}

	public void ConnectToSingleplayer(string filename)
	{
		this.StartGame(true, filename, null);
	}

	internal void CreateAccount(string user, string password, LoginResultRef loginResult)
	{
		if (user == "" || password == "") {
			loginResult.value = LoginResult.Failed;
		}
		else {
			loginResult.value = LoginResult.Ok;
		}
	}

	public void Draw2dQuad(int textureid, float dx, float dy, float dw, float dh)
	{
		Mat4.Identity_(this.mvMatrix);
		Mat4.Translate(this.mvMatrix, this.mvMatrix, Vec3.FromValues(dx, dy, 0));
		Mat4.Scale(this.mvMatrix, this.mvMatrix, Vec3.FromValues(dw, dh, 0));
		Mat4.Scale(this.mvMatrix, this.mvMatrix, Vec3.FromValues(this.one / 2, this.one / 2, 0));
		Mat4.Translate(this.mvMatrix, this.mvMatrix, Vec3.FromValues(this.one, this.one, 0));
		this.SetMatrixUniforms();
		if (this.cubeModel == null) {
			this.cubeModel = this.p.CreateModel(QuadModelData.GetQuadModelData());
		}
		this.p.BindTexture2d(textureid);
		this.p.DrawModel(this.cubeModel);
	}

	internal void DrawBackground()
	{
		this.backgroundW = 512;
		this.backgroundH = 512;
		this.windowX = this.p.GetCanvasWidth();
		this.windowY = this.p.GetCanvasHeight();
		int countX = this.p.FloatToInt((this.windowX + 2 * this.overlap) / this.backgroundW) + 1;
		int countY = this.p.FloatToInt((this.windowY + 2 * this.overlap) / this.backgroundH) + 1;
		for (int x = 0; x < countX; x++) {
			for (int y = 0; y < countY; y++) {
				this.Draw2dQuad(this.GetTexture("background.png"), x * this.backgroundW + this.xRot - this.overlap, y * this.backgroundH + this.yRot - this.overlap, this.backgroundW, this.backgroundH);
			}
		}
	}

	internal void DrawButton(string text, float fontSize, float dx, float dy, float dw, float dh, bool pressed)
	{
		this.Draw2dQuad(pressed ? this.GetTexture("button_sel.png") : this.GetTexture("button.png"), dx, dy, dw, dh);
		if (text != null && text != "") {
			this.DrawText(text, fontSize, dx + dw / 2, dy + dh / 2, TextAlign.Center, TextBaseline.Middle);
		}
	}

	void DrawScene(float dt)
	{
		this.p.GlViewport(0, 0, this.viewportWidth, this.viewportHeight);
		this.p.GlClearColorBufferAndDepthBuffer();
		this.p.GlDisableDepthTest();
		this.p.GlDisableCullFace();
		{
		}
		{
			Mat4.Identity_(this.pMatrix);
			Mat4.Ortho(this.pMatrix, 0, this.p.GetCanvasWidth(), this.p.GetCanvasHeight(), 0, 0, 10);
		}
		this.screen.Render(dt);
	}

	internal void DrawServerButton(string name, string motd, string gamemode, string playercount, float x, float y, float width, float height, string image)
	{
		this.Draw2dQuad(this.GetTexture("serverlist_entry_background.png"), x, y, width, height);
		this.Draw2dQuad(this.GetTexture(image), x, y, height, height);
		this.DrawText(name, 14, x + 70, y + 5, TextAlign.Left, TextBaseline.Top);
		this.DrawText(gamemode, 12, x + width - 10, y + height - 5, TextAlign.Right, TextBaseline.Bottom);
		this.DrawText(playercount, 12, x + width - 10, y + 5, TextAlign.Right, TextBaseline.Top);
		this.DrawText(motd, 12, x + 70, y + height - 5, TextAlign.Left, TextBaseline.Bottom);
	}

	internal void DrawText(string text, float fontSize, float x, float y, TextAlign align, TextBaseline baseline)
	{
		TextTexture t = this.GetTextTexture(text, fontSize);
		int dx = 0;
		int dy = 0;
		if (align == TextAlign.Center) {
			dx -= t.textwidth / 2;
		}
		if (align == TextAlign.Right) {
			dx -= t.textwidth;
		}
		if (baseline == TextBaseline.Middle) {
			dy -= t.textheight / 2;
		}
		if (baseline == TextBaseline.Bottom) {
			dy -= t.textheight;
		}
		this.Draw2dQuad(t.texture, x + dx, y + dy, t.texturewidth, t.textureheight);
	}

	internal void Exit()
	{
		this.p.Exit();
	}

	internal byte[] GetFile(string name)
	{
		string pLowercase = this.p.StringToLower(name);
		for (int i = 0; i < this.assets.count; i++) {
			if (this.assets.items[i].name == pLowercase) {
				return this.assets.items[i].data;
			}
		}
		return null;
	}

	internal int GetFileLength(string name)
	{
		string pLowercase = this.p.StringToLower(name);
		for (int i = 0; i < this.assets.count; i++) {
			if (this.assets.items[i].name == pLowercase) {
				return this.assets.items[i].dataLength;
			}
		}
		return 0;
	}

	internal string[] GetSavegames(IntRef length)
	{
		string[] files = this.p.DirectoryGetFiles(this.p.PathSavegames(), length);
		string[] savegames = new string[length.value];
		int count = 0;
		for (int i = 0; i < length.value; i++) {
			if (this.StringEndsWith(files[i], ".mddbs")) {
				savegames[count++] = files[i];
			}
		}
		length.value = count;
		return savegames;
	}

	public float GetScale()
	{
		float scale;
		if (this.p.IsSmallScreen()) {
			scale = this.one * this.p.GetCanvasWidth() / 1280;
		}
		else {
			scale = this.one;
		}
		return scale;
	}

	TextTexture GetTextTexture(string text, float fontSize)
	{
		for (int i = 0; i < this.textTexturesCount; i++) {
			TextTexture t = this.textTextures[i];
			if (t == null) {
				continue;
			}
			if (t.text == text && t.size == fontSize) {
				return t;
			}
		}
		TextTexture textTexture = new TextTexture();
		Text_ text_ = new Text_();
		text_.text = text;
		text_.fontsize = fontSize;
		text_.fontfamily = "Arial";
		text_.color = Game.ColorFromArgb(255, 255, 255, 255);
		BitmapCi textBitmap = this.textColorRenderer.CreateTextTexture(text_);
		int texture = this.p.LoadTextureFromBitmap(textBitmap);
		IntRef textWidth = new IntRef();
		IntRef textHeight = new IntRef();
		this.p.TextSize(text, fontSize, textWidth, textHeight);
		textTexture.texture = texture;
		textTexture.texturewidth = this.p.FloatToInt(this.p.BitmapGetWidth(textBitmap));
		textTexture.textureheight = this.p.FloatToInt(this.p.BitmapGetHeight(textBitmap));
		textTexture.text = text;
		textTexture.size = fontSize;
		textTexture.textwidth = textWidth.value;
		textTexture.textheight = textHeight.value;
		this.p.BitmapDelete(textBitmap);
		this.textTextures[this.textTexturesCount++] = textTexture;
		return textTexture;
	}

	internal int GetTexture(string name)
	{
		if (!this.textures.Contains(name)) {
			BoolRef found = new BoolRef();
			BitmapCi bmp = this.p.BitmapCreateFromPng(this.GetFile(name), this.GetFileLength(name));
			int texture = this.p.LoadTextureFromBitmap(bmp);
			this.textures.Set(name, texture);
			this.p.BitmapDelete(bmp);
		}
		return this.textures.Get(name);
	}

	public void HandleKeyDown(KeyEventArgs e)
	{
		this.currentlyPressedKeys[e.GetKeyCode()] = true;
		this.screen.OnKeyDown(e);
	}

	public void HandleKeyPress(KeyPressEventArgs e)
	{
		if (e.GetKeyChar() == 70 || e.GetKeyChar() == 102) {
			this.filter += 1;
			if (this.filter == 3) {
				this.filter = 0;
			}
		}
		if (e.GetKeyChar() == 96) {
			this.screen.OnBackPressed();
		}
		this.screen.OnKeyPress(e);
	}

	public void HandleKeyUp(KeyEventArgs e)
	{
		this.currentlyPressedKeys[e.GetKeyCode()] = false;
		this.screen.OnKeyUp(e);
	}

	public void HandleMouseDown(MouseEventArgs e)
	{
		this.mousePressed = true;
		this.previousMouseX = e.GetX();
		this.previousMouseY = e.GetY();
		this.screen.OnMouseDown(e);
	}

	public void HandleMouseMove(MouseEventArgs e)
	{
		float dx = e.GetMovementX();
		float dy = e.GetMovementY();
		this.previousMouseX = e.GetX();
		this.previousMouseY = e.GetY();
		if (this.mousePressed) {
		}
		this.screen.OnMouseMove(e);
	}

	public void HandleMouseUp(MouseEventArgs e)
	{
		this.mousePressed = false;
		this.screen.OnMouseUp(e);
	}

	public void HandleMouseWheel(MouseWheelEventArgs e)
	{
		this.z += e.GetDeltaPrecise() / 5;
		this.screen.OnMouseWheel(e);
	}

	public void HandleTouchEnd(TouchEventArgs e)
	{
		this.screen.OnTouchEnd(e);
	}

	public void HandleTouchMove(TouchEventArgs e)
	{
		this.screen.OnTouchMove(e);
		if (e.GetId() != this.touchId) {
			return;
		}
		float dx = e.GetX() - this.previousTouchX;
		float dy = e.GetY() - this.previousTouchY;
		this.previousTouchX = e.GetX();
		this.previousTouchY = e.GetY();
		this.ySpeed += dx / 10;
		this.xSpeed += dy / 10;
	}

	public void HandleTouchStart(TouchEventArgs e)
	{
		this.touchId = e.GetId();
		this.previousTouchX = e.GetX();
		this.previousTouchY = e.GetY();
		this.screen.OnTouchStart(e);
	}

	internal void Login(string user, string password, string serverHash, string token, LoginResultRef loginResult, LoginData loginResultData)
	{
		if (user == "" || password == "" && token == "") {
			loginResult.value = LoginResult.Failed;
		}
		else {
			this.loginClient.Login(this.p, user, password, serverHash, token, loginResult, loginResultData);
		}
	}

	public void OnNewFrame(NewFrameEventArgs args)
	{
		if (!this.initialized) {
			this.initialized = true;
			this.p.InitShaders();
			this.p.GlClearColorRgbaf(0, 0, 0, 1);
			this.p.GlEnableDepthTest();
		}
		this.viewportWidth = this.p.GetCanvasWidth();
		this.viewportHeight = this.p.GetCanvasHeight();
		this.DrawScene(args.GetDt());
		this.Animate(args.GetDt());
		this.loginClient.Update(this.p);
	}

	void SetMatrixUniforms()
	{
		this.p.SetMatrixUniformProjection(this.pMatrix);
		this.p.SetMatrixUniformModelView(this.mvMatrix);
	}

	public void Start(GamePlatform p_)
	{
		this.p = p_;
		this.lang = new Language();
		this.lang.platform = this.p;
		this.lang.LoadTranslations();
		this.p.SetTitle(this.lang.GameName());
		this.textColorRenderer = new TextColorRenderer();
		this.textColorRenderer.platform = p_;
		p_.LoadAssetsAsyc(this.assets, this.assetsLoadProgress);
		this.overlap = 200;
		this.minspeed = 20;
		this.rnd = this.p.RandomCreate();
		this.xRot = 0;
		this.xInv = false;
		this.xSpeed = this.minspeed + this.rnd.MaxNext(5);
		this.yRot = 0;
		this.yInv = false;
		this.ySpeed = this.minspeed + this.rnd.MaxNext(5);
		this.z = -5;
		this.filter = 0;
		this.mvMatrix = Mat4.Create();
		this.pMatrix = Mat4.Create();
		this.currentlyPressedKeys = new bool[256];
		this.p.AddOnNewFrame(MainMenuNewFrameHandler.Create(this));
		this.p.AddOnKeyEvent(MainMenuKeyEventHandler.Create(this));
		this.p.AddOnMouseEvent(MainMenuMouseEventHandler.Create(this));
		this.p.AddOnTouchEvent(MainMenuTouchEventHandler.Create(this));
	}

	internal void StartConnectToIp()
	{
		ScreenConnectToIp screenConnectToIp = new ScreenConnectToIp();
		this.screen = screenConnectToIp;
		this.screen.menu = this;
		this.screen.LoadTranslations();
	}

	public void StartGame(bool singleplayer, string singleplayerSavePath, ConnectData connectData)
	{
		ScreenGame screenGame = new ScreenGame();
		screenGame.menu = this;
		screenGame.Start(this.p, singleplayer, singleplayerSavePath, connectData);
		this.screen = screenGame;
	}

	internal void StartLogin(string serverHash, string ip, int port)
	{
		ScreenLogin screenLogin = new ScreenLogin();
		screenLogin.serverHash = serverHash;
		screenLogin.serverIp = ip;
		screenLogin.serverPort = port;
		this.screen = screenLogin;
		this.screen.menu = this;
		this.screen.LoadTranslations();
	}

	internal void StartMainMenu()
	{
		this.screen = new ScreenMain();
		this.screen.menu = this;
		this.p.ExitMousePointerLock();
	}

	internal void StartModifyWorld()
	{
	}

	internal void StartMultiplayer()
	{
		this.screen = new ScreenMultiplayer();
		this.screen.menu = this;
		this.screen.LoadTranslations();
	}

	internal void StartNewWorld()
	{
	}

	internal void StartSingleplayer()
	{
		this.screen = new ScreenSingleplayer();
		this.screen.menu = this;
		this.screen.LoadTranslations();
	}

	public bool StringEndsWith(string s, string value)
	{
		return StringTools.StringSubstring(this.p, s, this.StringLength(s) - this.StringLength(value), this.StringLength(value)) == value;
	}

	public int StringLength(string a)
	{
		IntRef length = new IntRef();
		this.p.StringToCharArray(a, length);
		return length.value;
	}
	internal AssetList assets;
	internal FloatRef assetsLoadProgress;
	internal int backgroundH;
	internal int backgroundW;
	Model cubeModel;
	bool[] currentlyPressedKeys;

	float degToRad(float degrees)
	{
		return degrees * GlMatrixMath.PI() / 180;
	}
	int filter;
	bool initialized;
	internal Language lang;
	LoginClientCi loginClient;
	int minspeed;
	bool mousePressed;
	float[] mvMatrix;
	internal float one;
	int overlap;
	internal GamePlatform p;
	float[] pMatrix;
	int previousMouseX;
	int previousMouseY;
	int previousTouchX;
	int previousTouchY;
	RandomCi rnd;
	Screen screen;
	internal TextColorRenderer textColorRenderer;
	TextTexture[] textTextures;
	int textTexturesCount;
	internal DictionaryStringInt1024 textures;
	int touchId;
	int viewportHeight;
	int viewportWidth;
	internal float windowX;
	internal float windowY;
	bool xInv;
	float xRot;
	float xSpeed;
	bool yInv;
	float yRot;
	float ySpeed;
	float z;
}

public class MainMenuKeyEventHandler : KeyEventHandler
{

	public static MainMenuKeyEventHandler Create(MainMenu l)
	{
		MainMenuKeyEventHandler h = new MainMenuKeyEventHandler();
		h.l = l;
		return h;
	}

	public override void OnKeyDown(KeyEventArgs e)
	{
		this.l.HandleKeyDown(e);
	}

	public override void OnKeyPress(KeyPressEventArgs e)
	{
		this.l.HandleKeyPress(e);
	}

	public override void OnKeyUp(KeyEventArgs e)
	{
		this.l.HandleKeyUp(e);
	}
	MainMenu l;
}

public class MainMenuMouseEventHandler : MouseEventHandler
{

	public static MainMenuMouseEventHandler Create(MainMenu l)
	{
		MainMenuMouseEventHandler h = new MainMenuMouseEventHandler();
		h.l = l;
		return h;
	}

	public override void OnMouseDown(MouseEventArgs e)
	{
		this.l.HandleMouseDown(e);
	}

	public override void OnMouseMove(MouseEventArgs e)
	{
		this.l.HandleMouseMove(e);
	}

	public override void OnMouseUp(MouseEventArgs e)
	{
		this.l.HandleMouseUp(e);
	}

	public override void OnMouseWheel(MouseWheelEventArgs e)
	{
		this.l.HandleMouseWheel(e);
	}
	MainMenu l;
}

public class MainMenuNewFrameHandler : NewFrameHandler
{

	public static MainMenuNewFrameHandler Create(MainMenu l)
	{
		MainMenuNewFrameHandler h = new MainMenuNewFrameHandler();
		h.l = l;
		return h;
	}

	public override void OnNewFrame(NewFrameEventArgs args)
	{
		this.l.OnNewFrame(args);
	}
	MainMenu l;
}

public class MainMenuTouchEventHandler : TouchEventHandler
{

	public static MainMenuTouchEventHandler Create(MainMenu l)
	{
		MainMenuTouchEventHandler h = new MainMenuTouchEventHandler();
		h.l = l;
		return h;
	}

	public override void OnTouchEnd(TouchEventArgs e)
	{
		this.l.HandleTouchEnd(e);
	}

	public override void OnTouchMove(TouchEventArgs e)
	{
		this.l.HandleTouchMove(e);
	}

	public override void OnTouchStart(TouchEventArgs e)
	{
		this.l.HandleTouchStart(e);
	}
	MainMenu l;
}

public class Map
{

	public void CopyChunk(Chunk chunk, int[] output)
	{
		int n = 4096;
		if (chunk.dataInt != null) {
			for (int i = 0; i < n; i++) {
				output[i] = chunk.dataInt[i];
			}
		}
		else {
			for (int i = 0; i < n; i++) {
				output[i] = chunk.data[i];
			}
		}
	}

	public void FillChunk(Chunk destination, int destinationchunksize, int sourcex, int sourcey, int sourcez, int[] source, int sourcechunksizeX, int sourcechunksizeY, int sourcechunksizeZ)
	{
		for (int x = 0; x < destinationchunksize; x++) {
			for (int y = 0; y < destinationchunksize; y++) {
				for (int z = 0; z < destinationchunksize; z++) {
					{
						destination.SetBlockInChunk((z * destinationchunksize + y) * destinationchunksize + x, source[((z + sourcez) * sourcechunksizeY + y + sourcey) * sourcechunksizeX + x + sourcex]);
					}
				}
			}
		}
	}

	public int GetBlock(int x, int y, int z)
	{
		if (!this.IsValidPos(x, y, z)) {
			return 0;
		}
		return this.GetBlockValid(x, y, z);
	}

	public int GetBlockValid(int x, int y, int z)
	{
		int cx = x >> 4;
		int cy = y >> 4;
		int cz = z >> 4;
		int chunkpos = (cz * (this.MapSizeY >> 4) + cy) * (this.MapSizeX >> 4) + cx;
		if (this.chunks[chunkpos] == null) {
			return 0;
		}
		else {
			int pos = ((z & 15) * 16 + (y & 15)) * 16 + (x & 15);
			return this.chunks[chunkpos].GetBlockInChunk(pos);
		}
	}

	public Chunk GetChunk(int x, int y, int z)
	{
		x = x / 16;
		y = y / 16;
		z = z / 16;
		return this.GetChunk_(x, y, z);
	}

	public Chunk GetChunk_(int cx, int cy, int cz)
	{
		int mapsizexchunks = this.MapSizeX / 16;
		int mapsizeychunks = this.MapSizeY / 16;
		Chunk chunk = this.chunks[(cz * mapsizeychunks + cy) * mapsizexchunks + cx];
		if (chunk == null) {
			Chunk c = new Chunk();
			c.data = new byte[4096];
			c.baseLight = new byte[4096];
			this.chunks[(cz * mapsizeychunks + cy) * mapsizexchunks + cx] = c;
			return this.chunks[(cz * mapsizeychunks + cy) * mapsizexchunks + cx];
		}
		return chunk;
	}

	public void GetMapPortion(int[] outPortion, int x, int y, int z, int portionsizex, int portionsizey, int portionsizez)
	{
		int outPortionCount = portionsizex * portionsizey * portionsizez;
		for (int i = 0; i < outPortionCount; i++) {
			outPortion[i] = 0;
		}
		int mapchunksx = this.MapSizeX / 16;
		int mapchunksy = this.MapSizeY / 16;
		int mapchunksz = this.MapSizeZ / 16;
		int mapsizechunks = mapchunksx * mapchunksy * mapchunksz;
		for (int xx = 0; xx < portionsizex; xx++) {
			for (int yy = 0; yy < portionsizey; yy++) {
				for (int zz = 0; zz < portionsizez; zz++) {
					int cx = x + xx >> 4;
					int cy = y + yy >> 4;
					int cz = z + zz >> 4;
					int cpos = (cz * mapchunksy + cy) * mapchunksx + cx;
					if (cpos < 0 || cpos >= mapsizechunks) {
						continue;
					}
					Chunk chunk = this.chunks[cpos];
					if (chunk == null || !chunk.ChunkHasData()) {
						continue;
					}
					int chunkGlobalX = cx << 4;
					int chunkGlobalY = cy << 4;
					int chunkGlobalZ = cz << 4;
					int inChunkX = x + xx - chunkGlobalX;
					int inChunkY = y + yy - chunkGlobalY;
					int inChunkZ = z + zz - chunkGlobalZ;
					int pos = ((inChunkZ << 4) + inChunkY << 4) + inChunkX;
					int block = chunk.GetBlockInChunk(pos);
					outPortion[(zz * portionsizey + yy) * portionsizex + xx] = block;
				}
			}
		}
	}

	public bool IsChunkRendered(int cx, int cy, int cz)
	{
		Chunk c = this.chunks[MapUtilCi.Index3d(cx, cy, cz, this.mapsizexchunks(), this.mapsizeychunks())];
		if (c == null) {
			return false;
		}
		return c.rendered != null && c.rendered.ids != null;
	}

	public bool IsValidChunkPos(int cx, int cy, int cz)
	{
		return cx >= 0 && cy >= 0 && cz >= 0 && cx < this.MapSizeX / 16 && cy < this.MapSizeY / 16 && cz < this.MapSizeZ / 16;
	}

	public bool IsValidPos(int x, int y, int z)
	{
		if (x < 0 || y < 0 || z < 0) {
			return false;
		}
		if (x >= this.MapSizeX || y >= this.MapSizeY || z >= this.MapSizeZ) {
			return false;
		}
		return true;
	}
	internal int MapSizeX;
	internal int MapSizeY;
	internal int MapSizeZ;

	public int MaybeGetLight(int x, int y, int z)
	{
		int light = -1;
		int cx = x / 16;
		int cy = y / 16;
		int cz = z / 16;
		if (this.IsValidPos(x, y, z) && this.IsValidChunkPos(cx, cy, cz)) {
			Chunk c = this.chunks[MapUtilCi.Index3d(cx, cy, cz, this.mapsizexchunks(), this.mapsizeychunks())];
			if (c == null || c.rendered == null || c.rendered.light == null) {
				light = -1;
			}
			else {
				light = c.rendered.light[MapUtilCi.Index3d(x % 16 + 1, y % 16 + 1, z % 16 + 1, 18, 18)];
			}
		}
		return light;
	}

	public void Reset(int sizex, int sizey, int sizez)
	{
		this.MapSizeX = sizex;
		this.MapSizeY = sizey;
		this.MapSizeZ = sizez;
		this.chunks = new Chunk[sizex / 16 * sizey / 16 * sizez / 16];
	}

	public void SetBlockDirty(int x, int y, int z)
	{
		Vector3IntRef[] around = ModDrawTerrain.BlocksAround7(Vector3IntRef.Create(x, y, z));
		for (int i = 0; i < 7; i++) {
			Vector3IntRef a = around[i];
			int xx = a.X;
			int yy = a.Y;
			int zz = a.Z;
			if (xx < 0 || yy < 0 || zz < 0 || xx >= this.MapSizeX || yy >= this.MapSizeY || zz >= this.MapSizeZ) {
				return;
			}
			this.SetChunkDirty(xx / 16, yy / 16, zz / 16, true, true);
		}
	}

	public void SetBlockRaw(int x, int y, int z, int tileType)
	{
		Chunk chunk = this.GetChunk(x, y, z);
		int pos = (z % 16 * 16 + y % 16) * 16 + x % 16;
		chunk.SetBlockInChunk(pos, tileType);
	}

	public void SetChunkDirty(int cx, int cy, int cz, bool dirty, bool blockschanged)
	{
		if (!this.IsValidChunkPos(cx, cy, cz)) {
			return;
		}
		Chunk c = this.chunks[MapUtilCi.Index3d(cx, cy, cz, this.mapsizexchunks(), this.mapsizeychunks())];
		if (c == null) {
			return;
		}
		if (c.rendered == null) {
			c.rendered = new RenderedChunk();
		}
		c.rendered.dirty = dirty;
		if (blockschanged) {
			c.baseLightDirty = true;
		}
	}

	public void SetChunksAroundDirty(int cx, int cy, int cz)
	{
		if (this.IsValidChunkPos(cx, cy, cz)) {
			this.SetChunkDirty(cx - 1, cy, cz, true, false);
		}
		if (this.IsValidChunkPos(cx - 1, cy, cz)) {
			this.SetChunkDirty(cx - 1, cy, cz, true, false);
		}
		if (this.IsValidChunkPos(cx + 1, cy, cz)) {
			this.SetChunkDirty(cx + 1, cy, cz, true, false);
		}
		if (this.IsValidChunkPos(cx, cy - 1, cz)) {
			this.SetChunkDirty(cx, cy - 1, cz, true, false);
		}
		if (this.IsValidChunkPos(cx, cy + 1, cz)) {
			this.SetChunkDirty(cx, cy + 1, cz, true, false);
		}
		if (this.IsValidChunkPos(cx, cy, cz - 1)) {
			this.SetChunkDirty(cx, cy, cz - 1, true, false);
		}
		if (this.IsValidChunkPos(cx, cy, cz + 1)) {
			this.SetChunkDirty(cx, cy, cz + 1, true, false);
		}
	}

	public void SetMapPortion(int x, int y, int z, int[] chunk, int sizeX, int sizeY, int sizeZ)
	{
		int chunksizex = sizeX;
		int chunksizey = sizeY;
		int chunksizez = sizeZ;
		int chunksize = 16;
		Chunk[] localchunks = new Chunk[chunksizex / chunksize * chunksizey / chunksize * chunksizez / chunksize];
		for (int cx = 0; cx < chunksizex / chunksize; cx++) {
			for (int cy = 0; cy < chunksizey / chunksize; cy++) {
				for (int cz = 0; cz < chunksizex / chunksize; cz++) {
					localchunks[(cz * chunksizey / chunksize + cy) * chunksizex / chunksize + cx] = this.GetChunk(x + cx * chunksize, y + cy * chunksize, z + cz * chunksize);
					this.FillChunk(localchunks[(cz * chunksizey / chunksize + cy) * chunksizex / chunksize + cx], chunksize, cx * chunksize, cy * chunksize, cz * chunksize, chunk, sizeX, sizeY, sizeZ);
				}
			}
		}
		for (int xxx = 0; xxx < chunksizex; xxx += chunksize) {
			for (int yyy = 0; yyy < chunksizex; yyy += chunksize) {
				for (int zzz = 0; zzz < chunksizex; zzz += chunksize) {
					this.SetChunkDirty((x + xxx) / chunksize, (y + yyy) / chunksize, (z + zzz) / chunksize, true, true);
					this.SetChunksAroundDirty((x + xxx) / chunksize, (y + yyy) / chunksize, (z + zzz) / chunksize);
				}
			}
		}
	}
	internal Chunk[] chunks;

	public int mapsizexchunks()
	{
		return this.MapSizeX >> 4;
	}

	public int mapsizeychunks()
	{
		return this.MapSizeY >> 4;
	}

	public int mapsizezchunks()
	{
		return this.MapSizeZ >> 4;
	}
}

public class MapLoadingProgressEventArgs
{
	internal int ProgressBytes;
	internal int ProgressPercent;
	internal string ProgressStatus;
}

public class MapStorage2 : IMapStorage2
{

	public static MapStorage2 Create(Game game)
	{
		MapStorage2 s = new MapStorage2();
		s.game = game;
		return s;
	}

	public override int GetBlock(int x, int y, int z)
	{
		return this.game.map.GetBlock(x, y, z);
	}

	public override int GetMapSizeX()
	{
		return this.game.map.MapSizeX;
	}

	public override int GetMapSizeY()
	{
		return this.game.map.MapSizeY;
	}

	public override int GetMapSizeZ()
	{
		return this.game.map.MapSizeZ;
	}

	public override void SetBlock(int x, int y, int z, int tileType)
	{
		this.game.SetBlock(x, y, z, tileType);
	}
	Game game;
}

public class MapUtilCi
{

	public static int Index2d(int x, int y, int sizex)
	{
		return x + y * sizex;
	}

	public static int Index3d(int x, int y, int h, int sizex, int sizey)
	{
		return (h * sizey + y) * sizex + x;
	}

	public static void Pos(int index, int sizex, int sizey, Vector3Ref ret)
	{
		int x = index % sizex;
		int y = index / sizex % sizey;
		int h = index / (sizex * sizey);
		ret.X = x;
		ret.Y = y;
		ret.Z = h;
	}

	internal static void PosInt(int index, int sizex, int sizey, Vector3IntRef ret)
	{
		int x = index % sizex;
		int y = index / sizex % sizey;
		int h = index / (sizex * sizey);
		ret.X = x;
		ret.Y = y;
		ret.Z = h;
	}

	public static int PosX(int index, int sizex, int sizey)
	{
		return index % sizex;
	}

	public static int PosY(int index, int sizex, int sizey)
	{
		return index / sizex % sizey;
	}

	public static int PosZ(int index, int sizex, int sizey)
	{
		return index / (sizex * sizey);
	}
}

/// <summary>2x2 Matrix</summary>
public class Mat2
{

	/// <summary>Calculates the adjugate of a mat2
	/// Returns output</summary>
	/// <param name="output">the receiving matrix</param>
	/// <param name="a">the source matrix</param>
	public static float[] Adjoint(float[] output, float[] a)
	{
		float a0 = a[0];
		output[0] = a[3];
		output[1] = -a[1];
		output[2] = -a[2];
		output[3] = a0;
		return output;
	}

	/// <summary>Creates a new mat2 initialized with values from an existing matrix
	/// Returns a new 2x2 matrix</summary>
	/// <param name="a">matrix to clone</param>
	public static float[] CloneIt(float[] a)
	{
		float[] output = new float[4];
		output[0] = a[0];
		output[1] = a[1];
		output[2] = a[2];
		output[3] = a[3];
		return output;
	}

	/// <summary>Copy the values from one mat2 to another
	/// Returns output</summary>
	/// <param name="output">the receiving matrix</param>
	/// <param name="a">the source matrix</param>
	public static float[] Copy(float[] output, float[] a)
	{
		output[0] = a[0];
		output[1] = a[1];
		output[2] = a[2];
		output[3] = a[3];
		return output;
	}

	/// <summary>Creates a new identity mat2
	/// Returns a new 2x2 matrix</summary>
	public static float[] Create()
	{
		float[] output = new float[4];
		output[0] = 1;
		output[1] = 0;
		output[2] = 0;
		output[3] = 1;
		return output;
	}

	/// <summary>Calculates the determinant of a mat2
	/// Returns determinant of a</summary>
	/// <param name="a">the source matrix</param>
	public static float Determinant(float[] a)
	{
		return a[0] * a[3] - a[2] * a[1];
	}

	/// <summary>Set a mat2 to the identity matrix
	/// Returns output</summary>
	/// <param name="output">the receiving matrix</param>
	public static float[] Identity_(float[] output)
	{
		output[0] = 1;
		output[1] = 0;
		output[2] = 0;
		output[3] = 1;
		return output;
	}

	/// <summary>Inverts a mat2
	/// Returns output</summary>
	/// <param name="output">the receiving matrix</param>
	/// <param name="a">the source matrix</param>
	public static float[] Invert(float[] output, float[] a)
	{
		float a0 = a[0];
		float a1 = a[1];
		float a2 = a[2];
		float a3 = a[3];
		float det = a0 * a3 - a2 * a1;
		if (det == 0) {
			return null;
		}
		float one = 1;
		det = one / det;
		output[0] = a3 * det;
		output[1] = -a1 * det;
		output[2] = -a2 * det;
		output[3] = a0 * det;
		return output;
	}

	/// <summary>Alias for {@link mat2.multiply}</summary>
	public static float[] Mul(float[] output, float[] a, float[] b)
	{
		return Mat2.Multiply(output, a, b);
	}

	/// <summary>Multiplies two mat2's
	/// Returns output</summary>
	/// <param name="output">the receiving matrix</param>
	/// <param name="a">the first operand</param>
	/// <param name="b">the second operand</param>
	public static float[] Multiply(float[] output, float[] a, float[] b)
	{
		float a0 = a[0];
		float a1 = a[1];
		float a2 = a[2];
		float a3 = a[3];
		float b0 = b[0];
		float b1 = b[1];
		float b2 = b[2];
		float b3 = b[3];
		output[0] = a0 * b0 + a1 * b2;
		output[1] = a0 * b1 + a1 * b3;
		output[2] = a2 * b0 + a3 * b2;
		output[3] = a2 * b1 + a3 * b3;
		return output;
	}

	/// <summary>Rotates a mat2 by the given angle
	/// Returns output</summary>
	/// <param name="output">the receiving matrix</param>
	/// <param name="a">the matrix to rotate</param>
	/// <param name="rad">the angle to rotate the matrix by</param>
	public static float[] Rotate(float[] output, float[] a, float rad)
	{
		float a0 = a[0];
		float a1 = a[1];
		float a2 = a[2];
		float a3 = a[3];
		float s = Platform.Sin(rad);
		float c = Platform.Cos(rad);
		output[0] = a0 * c + a1 * s;
		output[1] = a0 * -s + a1 * c;
		output[2] = a2 * c + a3 * s;
		output[3] = a2 * -s + a3 * c;
		return output;
	}

	/// <summary>Scales the mat2 by the dimensions in the given vec2
	/// Returns output</summary>
	/// <param name="output">the receiving matrix</param>
	/// <param name="a">the matrix to rotate</param>
	/// <param name="v">the vec2 to scale the matrix by</param>
	public static float[] Scale(float[] output, float[] a, float[] v)
	{
		float a0 = a[0];
		float a1 = a[1];
		float a2 = a[2];
		float a3 = a[3];
		float v0 = v[0];
		float v1 = v[1];
		output[0] = a0 * v0;
		output[1] = a1 * v1;
		output[2] = a2 * v0;
		output[3] = a3 * v1;
		return output;
	}

	/// <summary>Transpose the values of a mat2
	/// Returns output</summary>
	/// <param name="output">the receiving matrix</param>
	/// <param name="a">the source matrix</param>
	public static float[] Transpose(float[] output, float[] a)
	{
		output[0] = a[0];
		output[1] = a[2];
		output[2] = a[1];
		output[3] = a[3];
		return output;
	}

	/// <summary>**</summary>
	void f()
	{
	}
}

public class Mat2d
{

	/// <summary>Creates a new mat2d initialized with values from an existing matrix
	/// Returns a new 2x3 matrix</summary>
	/// <param name="a">matrix to clone</param>
	public static float[] CloneIt(float[] a)
	{
		float[] output = new float[6];
		output[0] = a[0];
		output[1] = a[1];
		output[2] = a[2];
		output[3] = a[3];
		output[4] = a[4];
		output[5] = a[5];
		return output;
	}

	/// <summary>Copy the values from one mat2d to another
	/// Returns output</summary>
	/// <param name="output">the receiving matrix</param>
	/// <param name="a">the source matrix</param>
	public static float[] Copy(float[] output, float[] a)
	{
		output[0] = a[0];
		output[1] = a[1];
		output[2] = a[2];
		output[3] = a[3];
		output[4] = a[4];
		output[5] = a[5];
		return output;
	}

	/// <summary>Creates a new identity mat2d
	/// Returns a new 2x3 matrix</summary>
	public static float[] Create()
	{
		float[] output = new float[6];
		output[0] = 1;
		output[1] = 0;
		output[2] = 0;
		output[3] = 1;
		output[4] = 0;
		output[5] = 0;
		return output;
	}

	/// <summary>Calculates the determinant of a mat2d
	/// Returns determinant of a</summary>
	/// <param name="a">the source matrix</param>
	public static float Determinant(float[] a)
	{
		return a[0] * a[3] - a[1] * a[2];
	}

	/// <summary>Set a mat2d to the identity matrix
	/// Returns output</summary>
	/// <param name="output">the receiving matrix</param>
	public static float[] Identity_(float[] output)
	{
		output[0] = 1;
		output[1] = 0;
		output[2] = 0;
		output[3] = 1;
		output[4] = 0;
		output[5] = 0;
		return output;
	}

	/// <summary>Inverts a mat2d
	/// Returns output</summary>
	/// <param name="output">the receiving matrix</param>
	/// <param name="a">the source matrix</param>
	public static float[] Invert(float[] output, float[] a)
	{
		float aa = a[0];
		float ab = a[1];
		float ac = a[2];
		float ad = a[3];
		float atx = a[4];
		float aty = a[5];
		float det = aa * ad - ab * ac;
		if (det == 0) {
			return null;
		}
		float one = 1;
		det = one / det;
		output[0] = ad * det;
		output[1] = -ab * det;
		output[2] = -ac * det;
		output[3] = aa * det;
		output[4] = (ac * aty - ad * atx) * det;
		output[5] = (ab * atx - aa * aty) * det;
		return output;
	}

	/// <summary>Alias for {@link mat2d.multiply} @function</summary>
	public static float[] Mul(float[] output, float[] a, float[] b)
	{
		return Mat2d.Multiply(output, a, b);
	}

	/// <summary>Multiplies two mat2d's
	/// Returns output</summary>
	/// <param name="output">the receiving matrix</param>
	/// <param name="a">the first operand</param>
	/// <param name="b">the second operand</param>
	public static float[] Multiply(float[] output, float[] a, float[] b)
	{
		float aa = a[0];
		float ab = a[1];
		float ac = a[2];
		float ad = a[3];
		float atx = a[4];
		float aty = a[5];
		float ba = b[0];
		float bb = b[1];
		float bc = b[2];
		float bd = b[3];
		float btx = b[4];
		float bty = b[5];
		output[0] = aa * ba + ab * bc;
		output[1] = aa * bb + ab * bd;
		output[2] = ac * ba + ad * bc;
		output[3] = ac * bb + ad * bd;
		output[4] = ba * atx + bc * aty + btx;
		output[5] = bb * atx + bd * aty + bty;
		return output;
	}

	/// <summary>Rotates a mat2d by the given angle
	/// Returns output</summary>
	/// <param name="output">the receiving matrix</param>
	/// <param name="a">the matrix to rotate</param>
	/// <param name="rad">the angle to rotate the matrix by</param>
	public static float[] Rotate(float[] output, float[] a, float rad)
	{
		float aa = a[0];
		float ab = a[1];
		float ac = a[2];
		float ad = a[3];
		float atx = a[4];
		float aty = a[5];
		float st = Platform.Sin(rad);
		float ct = Platform.Cos(rad);
		output[0] = aa * ct + ab * st;
		output[1] = -aa * st + ab * ct;
		output[2] = ac * ct + ad * st;
		output[3] = -ac * st + ct * ad;
		output[4] = ct * atx + st * aty;
		output[5] = ct * aty - st * atx;
		return output;
	}

	/// <summary>Scales the mat2d by the dimensions in the given vec2
	/// Returns output</summary>
	/// <param name="output">the receiving matrix</param>
	/// <param name="a">the matrix to translate</param>
	/// <param name="v">the vec2 to scale the matrix by</param>
	public static float[] Scale(float[] output, float[] a, float[] v)
	{
		float vx = v[0];
		float vy = v[1];
		output[0] = a[0] * vx;
		output[1] = a[1] * vy;
		output[2] = a[2] * vx;
		output[3] = a[3] * vy;
		output[4] = a[4] * vx;
		output[5] = a[5] * vy;
		return output;
	}

	/// <summary>Translates the mat2d by the dimensions in the given vec2
	/// Returns output</summary>
	/// <param name="output">the receiving matrix</param>
	/// <param name="a">the matrix to translate</param>
	/// <param name="v">the vec2 to translate the matrix by</param>
	public static float[] Translate(float[] output, float[] a, float[] v)
	{
		output[0] = a[0];
		output[1] = a[1];
		output[2] = a[2];
		output[3] = a[3];
		output[4] = a[4] + v[0];
		output[5] = a[5] + v[1];
		return output;
	}

	/// <summary>**</summary>
	void f()
	{
	}
}

public class Mat3
{

	/// <summary>**</summary>
	public static float[] Adjoint(float[] output, float[] a)
	{
		float a00 = a[0];
		float a01 = a[1];
		float a02 = a[2];
		float a10 = a[3];
		float a11 = a[4];
		float a12 = a[5];
		float a20 = a[6];
		float a21 = a[7];
		float a22 = a[8];
		output[0] = a11 * a22 - a12 * a21;
		output[1] = a02 * a21 - a01 * a22;
		output[2] = a01 * a12 - a02 * a11;
		output[3] = a12 * a20 - a10 * a22;
		output[4] = a00 * a22 - a02 * a20;
		output[5] = a02 * a10 - a00 * a12;
		output[6] = a10 * a21 - a11 * a20;
		output[7] = a01 * a20 - a00 * a21;
		output[8] = a00 * a11 - a01 * a10;
		return output;
	}

	/// <summary>**</summary>
	public static float[] CloneIt(float[] a)
	{
		float[] output = new float[9];
		output[0] = a[0];
		output[1] = a[1];
		output[2] = a[2];
		output[3] = a[3];
		output[4] = a[4];
		output[5] = a[5];
		output[6] = a[6];
		output[7] = a[7];
		output[8] = a[8];
		return output;
	}

	/// <summary>**</summary>
	public static float[] Copy(float[] output, float[] a)
	{
		output[0] = a[0];
		output[1] = a[1];
		output[2] = a[2];
		output[3] = a[3];
		output[4] = a[4];
		output[5] = a[5];
		output[6] = a[6];
		output[7] = a[7];
		output[8] = a[8];
		return output;
	}

	/// <summary>**</summary>
	public static float[] Create()
	{
		float[] output = new float[9];
		output[0] = 1;
		output[1] = 0;
		output[2] = 0;
		output[3] = 0;
		output[4] = 1;
		output[5] = 0;
		output[6] = 0;
		output[7] = 0;
		output[8] = 1;
		return output;
	}

	/// <summary>**</summary>
	public static float Determinant(float[] a)
	{
		float a00 = a[0];
		float a01 = a[1];
		float a02 = a[2];
		float a10 = a[3];
		float a11 = a[4];
		float a12 = a[5];
		float a20 = a[6];
		float a21 = a[7];
		float a22 = a[8];
		return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
	}

	/// <summary>**</summary>
	public static float[] FromMat2d(float[] output, float[] a)
	{
		output[0] = a[0];
		output[1] = a[1];
		output[2] = 0;
		output[3] = a[2];
		output[4] = a[3];
		output[5] = 0;
		output[6] = a[4];
		output[7] = a[5];
		output[8] = 1;
		return output;
	}

	/// <summary>**</summary>
	public static float[] FromMat4(float[] output, float[] a)
	{
		output[0] = a[0];
		output[1] = a[1];
		output[2] = a[2];
		output[3] = a[4];
		output[4] = a[5];
		output[5] = a[6];
		output[6] = a[8];
		output[7] = a[9];
		output[8] = a[10];
		return output;
	}

	/// <summary>**</summary>
	public static float[] FromQuat(float[] output, float[] q)
	{
		float x = q[0];
		float y = q[1];
		float z = q[2];
		float w = q[3];
		float x2 = x + x;
		float y2 = y + y;
		float z2 = z + z;
		float xx = x * x2;
		float xy = x * y2;
		float xz = x * z2;
		float yy = y * y2;
		float yz = y * z2;
		float zz = z * z2;
		float wx = w * x2;
		float wy = w * y2;
		float wz = w * z2;
		output[0] = 1 - (yy + zz);
		output[3] = xy + wz;
		output[6] = xz - wy;
		output[1] = xy - wz;
		output[4] = 1 - (xx + zz);
		output[7] = yz + wx;
		output[2] = xz + wy;
		output[5] = yz - wx;
		output[8] = 1 - (xx + yy);
		return output;
	}

	/// <summary>**</summary>
	public static float[] Identity_(float[] output)
	{
		output[0] = 1;
		output[1] = 0;
		output[2] = 0;
		output[3] = 0;
		output[4] = 1;
		output[5] = 0;
		output[6] = 0;
		output[7] = 0;
		output[8] = 1;
		return output;
	}

	/// <summary>**</summary>
	public static float[] Invert(float[] output, float[] a)
	{
		float a00 = a[0];
		float a01 = a[1];
		float a02 = a[2];
		float a10 = a[3];
		float a11 = a[4];
		float a12 = a[5];
		float a20 = a[6];
		float a21 = a[7];
		float a22 = a[8];
		float b01 = a22 * a11 - a12 * a21;
		float b11 = -a22 * a10 + a12 * a20;
		float b21 = a21 * a10 - a11 * a20;
		float det = a00 * b01 + a01 * b11 + a02 * b21;
		if (det == 0) {
			return null;
		}
		float one = 1;
		det = one / det;
		output[0] = b01 * det;
		output[1] = (-a22 * a01 + a02 * a21) * det;
		output[2] = (a12 * a01 - a02 * a11) * det;
		output[3] = b11 * det;
		output[4] = (a22 * a00 - a02 * a20) * det;
		output[5] = (-a12 * a00 + a02 * a10) * det;
		output[6] = b21 * det;
		output[7] = (-a21 * a00 + a01 * a20) * det;
		output[8] = (a11 * a00 - a01 * a10) * det;
		return output;
	}

	/// <summary>**</summary>
	public static float[] Mul(float[] output, float[] a, float[] b)
	{
		return Mat3.Multiply(output, a, b);
	}

	/// <summary>**</summary>
	public static float[] Multiply(float[] output, float[] a, float[] b)
	{
		float a00 = a[0];
		float a01 = a[1];
		float a02 = a[2];
		float a10 = a[3];
		float a11 = a[4];
		float a12 = a[5];
		float a20 = a[6];
		float a21 = a[7];
		float a22 = a[8];
		float b00 = b[0];
		float b01 = b[1];
		float b02 = b[2];
		float b10 = b[3];
		float b11 = b[4];
		float b12 = b[5];
		float b20 = b[6];
		float b21 = b[7];
		float b22 = b[8];
		output[0] = b00 * a00 + b01 * a10 + b02 * a20;
		output[1] = b00 * a01 + b01 * a11 + b02 * a21;
		output[2] = b00 * a02 + b01 * a12 + b02 * a22;
		output[3] = b10 * a00 + b11 * a10 + b12 * a20;
		output[4] = b10 * a01 + b11 * a11 + b12 * a21;
		output[5] = b10 * a02 + b11 * a12 + b12 * a22;
		output[6] = b20 * a00 + b21 * a10 + b22 * a20;
		output[7] = b20 * a01 + b21 * a11 + b22 * a21;
		output[8] = b20 * a02 + b21 * a12 + b22 * a22;
		return output;
	}

	/// <summary>**</summary>
	public static float[] NormalFromMat4(float[] output, float[] a)
	{
		float a00 = a[0];
		float a01 = a[1];
		float a02 = a[2];
		float a03 = a[3];
		float a10 = a[4];
		float a11 = a[5];
		float a12 = a[6];
		float a13 = a[7];
		float a20 = a[8];
		float a21 = a[9];
		float a22 = a[10];
		float a23 = a[11];
		float a30 = a[12];
		float a31 = a[13];
		float a32 = a[14];
		float a33 = a[15];
		float b00 = a00 * a11 - a01 * a10;
		float b01 = a00 * a12 - a02 * a10;
		float b02 = a00 * a13 - a03 * a10;
		float b03 = a01 * a12 - a02 * a11;
		float b04 = a01 * a13 - a03 * a11;
		float b05 = a02 * a13 - a03 * a12;
		float b06 = a20 * a31 - a21 * a30;
		float b07 = a20 * a32 - a22 * a30;
		float b08 = a20 * a33 - a23 * a30;
		float b09 = a21 * a32 - a22 * a31;
		float b10 = a21 * a33 - a23 * a31;
		float b11 = a22 * a33 - a23 * a32;
		float det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
		if (det == 0) {
			return null;
		}
		float one = 1;
		det = one / det;
		output[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
		output[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
		output[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
		output[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
		output[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
		output[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
		output[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
		output[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
		output[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
		return output;
	}

	/// <summary>**</summary>
	public static float[] Rotate(float[] output, float[] a, float rad)
	{
		float a00 = a[0];
		float a01 = a[1];
		float a02 = a[2];
		float a10 = a[3];
		float a11 = a[4];
		float a12 = a[5];
		float a20 = a[6];
		float a21 = a[7];
		float a22 = a[8];
		float s = Platform.Sin(rad);
		float c = Platform.Cos(rad);
		output[0] = c * a00 + s * a10;
		output[1] = c * a01 + s * a11;
		output[2] = c * a02 + s * a12;
		output[3] = c * a10 - s * a00;
		output[4] = c * a11 - s * a01;
		output[5] = c * a12 - s * a02;
		output[6] = a20;
		output[7] = a21;
		output[8] = a22;
		return output;
	}

	/// <summary>**</summary>
	public static float[] Scale(float[] output, float[] a, float[] v)
	{
		float x = v[0];
		float y = v[1];
		output[0] = x * a[0];
		output[1] = x * a[1];
		output[2] = x * a[2];
		output[3] = y * a[3];
		output[4] = y * a[4];
		output[5] = y * a[5];
		output[6] = a[6];
		output[7] = a[7];
		output[8] = a[8];
		return output;
	}

	/// <summary>**</summary>
	public static float[] Translate(float[] output, float[] a, float[] v)
	{
		float a00 = a[0];
		float a01 = a[1];
		float a02 = a[2];
		float a10 = a[3];
		float a11 = a[4];
		float a12 = a[5];
		float a20 = a[6];
		float a21 = a[7];
		float a22 = a[8];
		float x = v[0];
		float y = v[1];
		output[0] = a00;
		output[1] = a01;
		output[2] = a02;
		output[3] = a10;
		output[4] = a11;
		output[5] = a12;
		output[6] = x * a00 + y * a10 + a20;
		output[7] = x * a01 + y * a11 + a21;
		output[8] = x * a02 + y * a12 + a22;
		return output;
	}

	/// <summary>**</summary>
	public static float[] Transpose(float[] output, float[] a)
	{
		if (output == a) {
			float a01 = a[1];
			float a02 = a[2];
			float a12 = a[5];
			output[1] = a[3];
			output[2] = a[6];
			output[3] = a01;
			output[5] = a[7];
			output[6] = a02;
			output[7] = a12;
		}
		else {
			output[0] = a[0];
			output[1] = a[3];
			output[2] = a[6];
			output[3] = a[1];
			output[4] = a[4];
			output[5] = a[7];
			output[6] = a[2];
			output[7] = a[5];
			output[8] = a[8];
		}
		return output;
	}

	/// <summary>**</summary>
	void f()
	{
	}
}

/// <summary>4x4 Matrix</summary>
public class Mat4
{

	/// <summary>Calculates the adjugate of a mat4
	/// @returns {mat4} out</summary>
	/// <param name="output">@param {mat4} out the receiving matrix</param>
	/// <param name="a">@param {mat4} a the source matrix</param>
	public static float[] Adjoint(float[] output, float[] a)
	{
		float a00 = a[0];
		float a01 = a[1];
		float a02 = a[2];
		float a03 = a[3];
		float a10 = a[4];
		float a11 = a[5];
		float a12 = a[6];
		float a13 = a[7];
		float a20 = a[8];
		float a21 = a[9];
		float a22 = a[10];
		float a23 = a[11];
		float a30 = a[12];
		float a31 = a[13];
		float a32 = a[14];
		float a33 = a[15];
		output[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
		output[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
		output[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
		output[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
		output[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
		output[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
		output[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
		output[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
		output[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
		output[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
		output[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
		output[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
		output[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
		output[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
		output[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
		output[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
		return output;
	}

	/// <summary>Creates a new mat4 initialized with values from an existing matrix
	/// Returns {mat4} a new 4x4 matrix</summary>
	/// <param name="a">{mat4} a matrix to clone</param>
	public static float[] CloneIt(float[] a)
	{
		float[] output = new float[16];
		output[0] = a[0];
		output[1] = a[1];
		output[2] = a[2];
		output[3] = a[3];
		output[4] = a[4];
		output[5] = a[5];
		output[6] = a[6];
		output[7] = a[7];
		output[8] = a[8];
		output[9] = a[9];
		output[10] = a[10];
		output[11] = a[11];
		output[12] = a[12];
		output[13] = a[13];
		output[14] = a[14];
		output[15] = a[15];
		return output;
	}

	/// <summary>Copy the values from one mat4 to another
	/// Returns {mat4} out</summary>
	/// <param name="output">{mat4} out the receiving matrix</param>
	/// <param name="a">{mat4} a the source matrix</param>
	public static float[] Copy(float[] output, float[] a)
	{
		output[0] = a[0];
		output[1] = a[1];
		output[2] = a[2];
		output[3] = a[3];
		output[4] = a[4];
		output[5] = a[5];
		output[6] = a[6];
		output[7] = a[7];
		output[8] = a[8];
		output[9] = a[9];
		output[10] = a[10];
		output[11] = a[11];
		output[12] = a[12];
		output[13] = a[13];
		output[14] = a[14];
		output[15] = a[15];
		return output;
	}

	/// <summary>Creates a new identity mat4
	/// Returns {mat4} a new 4x4 matrix</summary>
	public static float[] Create()
	{
		float[] output = new float[16];
		output[0] = 1;
		output[1] = 0;
		output[2] = 0;
		output[3] = 0;
		output[4] = 0;
		output[5] = 1;
		output[6] = 0;
		output[7] = 0;
		output[8] = 0;
		output[9] = 0;
		output[10] = 1;
		output[11] = 0;
		output[12] = 0;
		output[13] = 0;
		output[14] = 0;
		output[15] = 1;
		return output;
	}

	/// <summary>Calculates the determinant of a mat4
	/// @returns {Number} determinant of a</summary>
	/// <param name="a">@param {mat4} a the source matrix</param>
	public static float Determinant(float[] a)
	{
		float a00 = a[0];
		float a01 = a[1];
		float a02 = a[2];
		float a03 = a[3];
		float a10 = a[4];
		float a11 = a[5];
		float a12 = a[6];
		float a13 = a[7];
		float a20 = a[8];
		float a21 = a[9];
		float a22 = a[10];
		float a23 = a[11];
		float a30 = a[12];
		float a31 = a[13];
		float a32 = a[14];
		float a33 = a[15];
		float b00 = a00 * a11 - a01 * a10;
		float b01 = a00 * a12 - a02 * a10;
		float b02 = a00 * a13 - a03 * a10;
		float b03 = a01 * a12 - a02 * a11;
		float b04 = a01 * a13 - a03 * a11;
		float b05 = a02 * a13 - a03 * a12;
		float b06 = a20 * a31 - a21 * a30;
		float b07 = a20 * a32 - a22 * a30;
		float b08 = a20 * a33 - a23 * a30;
		float b09 = a21 * a32 - a22 * a31;
		float b10 = a21 * a33 - a23 * a31;
		float b11 = a22 * a33 - a23 * a32;
		return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
	}

	/// <summary>Calculates a 4x4 matrix from the given quaternion
	/// @returns {mat4} out</summary>
	/// <param name="output">{mat4} out mat4 receiving operation result</param>
	/// <param name="q">{quat} q Quaternion to create matrix from</param>
	public static float[] FromQuat(float[] output, float[] q)
	{
		float x = q[0];
		float y = q[1];
		float z = q[2];
		float w = q[3];
		float x2 = x + x;
		float y2 = y + y;
		float z2 = z + z;
		float xx = x * x2;
		float xy = x * y2;
		float xz = x * z2;
		float yy = y * y2;
		float yz = y * z2;
		float zz = z * z2;
		float wx = w * x2;
		float wy = w * y2;
		float wz = w * z2;
		output[0] = 1 - (yy + zz);
		output[1] = xy + wz;
		output[2] = xz - wy;
		output[3] = 0;
		output[4] = xy - wz;
		output[5] = 1 - (xx + zz);
		output[6] = yz + wx;
		output[7] = 0;
		output[8] = xz + wy;
		output[9] = yz - wx;
		output[10] = 1 - (xx + yy);
		output[11] = 0;
		output[12] = 0;
		output[13] = 0;
		output[14] = 0;
		output[15] = 1;
		return output;
	}

	/// <summary>Creates a matrix from a quaternion rotation and vector translation
	/// This is equivalent to (but much faster than):
	/// mat4.identity(dest);
	/// mat4.translate(dest, vec);
	/// var quatMat = mat4.create();
	/// quat4.toMat4(quat, quatMat);
	/// mat4.multiply(dest, quatMat);
	/// @returns {mat4} out</summary>
	/// <param name="output">{mat4} out mat4 receiving operation result</param>
	/// <param name="q">{quat4} q Rotation quaternion</param>
	/// <param name="v">{vec3} v Translation vector</param>
	public static float[] FromRotationTranslation(float[] output, float[] q, float[] v)
	{
		float x = q[0];
		float y = q[1];
		float z = q[2];
		float w = q[3];
		float x2 = x + x;
		float y2 = y + y;
		float z2 = z + z;
		float xx = x * x2;
		float xy = x * y2;
		float xz = x * z2;
		float yy = y * y2;
		float yz = y * z2;
		float zz = z * z2;
		float wx = w * x2;
		float wy = w * y2;
		float wz = w * z2;
		output[0] = 1 - (yy + zz);
		output[1] = xy + wz;
		output[2] = xz - wy;
		output[3] = 0;
		output[4] = xy - wz;
		output[5] = 1 - (xx + zz);
		output[6] = yz + wx;
		output[7] = 0;
		output[8] = xz + wy;
		output[9] = yz - wx;
		output[10] = 1 - (xx + yy);
		output[11] = 0;
		output[12] = v[0];
		output[13] = v[1];
		output[14] = v[2];
		output[15] = 1;
		return output;
	}

	/// <summary>Generates a frustum matrix with the given bounds
	/// @returns {mat4} out</summary>
	/// <param name="output">{mat4} out mat4 frustum matrix will be written into</param>
	/// <param name="left">{Number} left Left bound of the frustum</param>
	/// <param name="right">{Number} right Right bound of the frustum</param>
	/// <param name="bottom">{Number} bottom Bottom bound of the frustum</param>
	/// <param name="top">{Number} top Top bound of the frustum</param>
	/// <param name="near">{Number} near Near bound of the frustum</param>
	/// <param name="far">{Number} far Far bound of the frustum</param>
	public static float[] Frustum(float[] output, float left, float right, float bottom, float top, float near, float far)
	{
		float rl = 1 / (right - left);
		float tb = 1 / (top - bottom);
		float nf = 1 / (near - far);
		output[0] = near * 2 * rl;
		output[1] = 0;
		output[2] = 0;
		output[3] = 0;
		output[4] = 0;
		output[5] = near * 2 * tb;
		output[6] = 0;
		output[7] = 0;
		output[8] = (right + left) * rl;
		output[9] = (top + bottom) * tb;
		output[10] = (far + near) * nf;
		output[11] = -1;
		output[12] = 0;
		output[13] = 0;
		output[14] = far * near * 2 * nf;
		output[15] = 0;
		return output;
	}

	/// <summary>Set a mat4 to the identity matrix
	/// Returns {mat4} out</summary>
	/// <param name="output">{mat4} out the receiving matrix</param>
	public static float[] Identity_(float[] output)
	{
		output[0] = 1;
		output[1] = 0;
		output[2] = 0;
		output[3] = 0;
		output[4] = 0;
		output[5] = 1;
		output[6] = 0;
		output[7] = 0;
		output[8] = 0;
		output[9] = 0;
		output[10] = 1;
		output[11] = 0;
		output[12] = 0;
		output[13] = 0;
		output[14] = 0;
		output[15] = 1;
		return output;
	}

	/// <summary>Inverts a mat4
	/// @returns {mat4} out</summary>
	/// <param name="output">{mat4} out the receiving matrix</param>
	/// <param name="a">{mat4} a the source matrix</param>
	public static float[] Invert(float[] output, float[] a)
	{
		float a00 = a[0];
		float a01 = a[1];
		float a02 = a[2];
		float a03 = a[3];
		float a10 = a[4];
		float a11 = a[5];
		float a12 = a[6];
		float a13 = a[7];
		float a20 = a[8];
		float a21 = a[9];
		float a22 = a[10];
		float a23 = a[11];
		float a30 = a[12];
		float a31 = a[13];
		float a32 = a[14];
		float a33 = a[15];
		float b00 = a00 * a11 - a01 * a10;
		float b01 = a00 * a12 - a02 * a10;
		float b02 = a00 * a13 - a03 * a10;
		float b03 = a01 * a12 - a02 * a11;
		float b04 = a01 * a13 - a03 * a11;
		float b05 = a02 * a13 - a03 * a12;
		float b06 = a20 * a31 - a21 * a30;
		float b07 = a20 * a32 - a22 * a30;
		float b08 = a20 * a33 - a23 * a30;
		float b09 = a21 * a32 - a22 * a31;
		float b10 = a21 * a33 - a23 * a31;
		float b11 = a22 * a33 - a23 * a32;
		float det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
		if (det == 0) {
			return null;
		}
		float one = 1;
		det = one / det;
		output[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
		output[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
		output[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
		output[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
		output[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
		output[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
		output[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
		output[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
		output[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
		output[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
		output[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
		output[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
		output[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
		output[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
		output[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
		output[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
		return output;
	}

	/// <summary>Generates a look-at matrix with the given eye position, focal point, and up axis
	/// @returns {mat4} out</summary>
	/// <param name="output">{mat4} out mat4 frustum matrix will be written into</param>
	/// <param name="eye">{vec3} eye Position of the viewer</param>
	/// <param name="center">{vec3} center Point the viewer is looking at</param>
	/// <param name="up">{vec3} up vec3 pointing up</param>
	public static float[] LookAt(float[] output, float[] eye, float[] center, float[] up)
	{
		float x0;
		float x1;
		float x2;
		float y0;
		float y1;
		float y2;
		float z0;
		float z1;
		float z2;
		float len;
		float eyex = eye[0];
		float eyey = eye[1];
		float eyez = eye[2];
		float upx = up[0];
		float upy = up[1];
		float upz = up[2];
		float centerx = center[0];
		float centery = center[1];
		float centerz = center[2];
		if (GlMatrixMath.Abs(eyex - centerx) < GlMatrixMath.GLMAT_EPSILON() && GlMatrixMath.Abs(eyey - centery) < GlMatrixMath.GLMAT_EPSILON() && GlMatrixMath.Abs(eyez - centerz) < GlMatrixMath.GLMAT_EPSILON()) {
			return Mat4.Identity_(output);
		}
		z0 = eyex - centerx;
		z1 = eyey - centery;
		z2 = eyez - centerz;
		len = 1 / Platform.Sqrt(z0 * z0 + z1 * z1 + z2 * z2);
		z0 *= len;
		z1 *= len;
		z2 *= len;
		x0 = upy * z2 - upz * z1;
		x1 = upz * z0 - upx * z2;
		x2 = upx * z1 - upy * z0;
		len = Platform.Sqrt(x0 * x0 + x1 * x1 + x2 * x2);
		if (len == 0) {
			x0 = 0;
			x1 = 0;
			x2 = 0;
		}
		else {
			len = 1 / len;
			x0 *= len;
			x1 *= len;
			x2 *= len;
		}
		y0 = z1 * x2 - z2 * x1;
		y1 = z2 * x0 - z0 * x2;
		y2 = z0 * x1 - z1 * x0;
		len = Platform.Sqrt(y0 * y0 + y1 * y1 + y2 * y2);
		if (len == 0) {
			y0 = 0;
			y1 = 0;
			y2 = 0;
		}
		else {
			len = 1 / len;
			y0 *= len;
			y1 *= len;
			y2 *= len;
		}
		output[0] = x0;
		output[1] = y0;
		output[2] = z0;
		output[3] = 0;
		output[4] = x1;
		output[5] = y1;
		output[6] = z1;
		output[7] = 0;
		output[8] = x2;
		output[9] = y2;
		output[10] = z2;
		output[11] = 0;
		output[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
		output[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
		output[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
		output[15] = 1;
		return output;
	}

	/// <summary>Alias for {@link mat4.multiply}</summary>
	public static float[] Mul(float[] output, float[] a, float[] b)
	{
		return Mat4.Multiply(output, a, b);
	}

	/// <summary>Multiplies two mat4's
	/// @returns {mat4} out</summary>
	/// <param name="output">@param {mat4} out the receiving matrix</param>
	/// <param name="a">@param {mat4} a the first operand</param>
	/// <param name="b">@param {mat4} b the second operand</param>
	public static float[] Multiply(float[] output, float[] a, float[] b)
	{
		float a00 = a[0];
		float a01 = a[1];
		float a02 = a[2];
		float a03 = a[3];
		float a10 = a[4];
		float a11 = a[5];
		float a12 = a[6];
		float a13 = a[7];
		float a20 = a[8];
		float a21 = a[9];
		float a22 = a[10];
		float a23 = a[11];
		float a30 = a[12];
		float a31 = a[13];
		float a32 = a[14];
		float a33 = a[15];
		float b0 = b[0];
		float b1 = b[1];
		float b2 = b[2];
		float b3 = b[3];
		output[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
		output[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
		output[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
		output[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
		b0 = b[4];
		b1 = b[5];
		b2 = b[6];
		b3 = b[7];
		output[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
		output[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
		output[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
		output[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
		b0 = b[8];
		b1 = b[9];
		b2 = b[10];
		b3 = b[11];
		output[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
		output[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
		output[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
		output[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
		b0 = b[12];
		b1 = b[13];
		b2 = b[14];
		b3 = b[15];
		output[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
		output[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
		output[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
		output[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
		return output;
	}

	/// <summary>Generates a orthogonal projection matrix with the given bounds
	/// @returns {mat4} out</summary>
	/// <param name="output">{mat4} out mat4 frustum matrix will be written into</param>
	/// <param name="left">{number} left Left bound of the frustum</param>
	/// <param name="right">{number} right Right bound of the frustum</param>
	/// <param name="bottom">{number} bottom Bottom bound of the frustum</param>
	/// <param name="top">{number} top Top bound of the frustum</param>
	/// <param name="near">{number} near Near bound of the frustum</param>
	/// <param name="far">{number} far Far bound of the frustum</param>
	public static float[] Ortho(float[] output, float left, float right, float bottom, float top, float near, float far)
	{
		float lr = 1 / (left - right);
		float bt = 1 / (bottom - top);
		float nf = 1 / (near - far);
		output[0] = -2 * lr;
		output[1] = 0;
		output[2] = 0;
		output[3] = 0;
		output[4] = 0;
		output[5] = -2 * bt;
		output[6] = 0;
		output[7] = 0;
		output[8] = 0;
		output[9] = 0;
		output[10] = 2 * nf;
		output[11] = 0;
		output[12] = (left + right) * lr;
		output[13] = (top + bottom) * bt;
		output[14] = (far + near) * nf;
		output[15] = 1;
		return output;
	}

	/// <summary>Generates a perspective projection matrix with the given bounds
	/// @returns {mat4} out</summary>
	/// <param name="output">{mat4} out mat4 frustum matrix will be written into</param>
	/// <param name="fovy">{number} fovy Vertical field of view in radians</param>
	/// <param name="aspect">{number} aspect Aspect ratio. typically viewport width/height</param>
	/// <param name="near">{number} near Near bound of the frustum</param>
	/// <param name="far">{number} far Far bound of the frustum</param>
	public static float[] Perspective(float[] output, float fovy, float aspect, float near, float far)
	{
		float one = 1;
		float f = one / Platform.Tan(fovy / 2);
		float nf = 1 / (near - far);
		output[0] = f / aspect;
		output[1] = 0;
		output[2] = 0;
		output[3] = 0;
		output[4] = 0;
		output[5] = f;
		output[6] = 0;
		output[7] = 0;
		output[8] = 0;
		output[9] = 0;
		output[10] = (far + near) * nf;
		output[11] = -1;
		output[12] = 0;
		output[13] = 0;
		output[14] = 2 * far * near * nf;
		output[15] = 0;
		return output;
	}

	/// <summary>Rotates a mat4 by the given angle
	/// @returns {mat4} out</summary>
	/// <param name="output">{mat4} out the receiving matrix</param>
	/// <param name="a">{mat4} a the matrix to rotate</param>
	/// <param name="rad">{Number} rad the angle to rotate the matrix by</param>
	/// <param name="axis">{vec3} axis the axis to rotate around</param>
	public static float[] Rotate(float[] output, float[] a, float rad, float[] axis)
	{
		float x = axis[0];
		float y = axis[1];
		float z = axis[2];
		float len = Platform.Sqrt(x * x + y * y + z * z);
		float s;
		float c;
		float t;
		float a00;
		float a01;
		float a02;
		float a03;
		float a10;
		float a11;
		float a12;
		float a13;
		float a20;
		float a21;
		float a22;
		float a23;
		float b00;
		float b01;
		float b02;
		float b10;
		float b11;
		float b12;
		float b20;
		float b21;
		float b22;
		if (GlMatrixMath.Abs(len) < GlMatrixMath.GLMAT_EPSILON()) {
			return null;
		}
		len = 1 / len;
		x *= len;
		y *= len;
		z *= len;
		s = Platform.Sin(rad);
		c = Platform.Cos(rad);
		t = 1 - c;
		a00 = a[0];
		a01 = a[1];
		a02 = a[2];
		a03 = a[3];
		a10 = a[4];
		a11 = a[5];
		a12 = a[6];
		a13 = a[7];
		a20 = a[8];
		a21 = a[9];
		a22 = a[10];
		a23 = a[11];
		b00 = x * x * t + c;
		b01 = y * x * t + z * s;
		b02 = z * x * t - y * s;
		b10 = x * y * t - z * s;
		b11 = y * y * t + c;
		b12 = z * y * t + x * s;
		b20 = x * z * t + y * s;
		b21 = y * z * t - x * s;
		b22 = z * z * t + c;
		output[0] = a00 * b00 + a10 * b01 + a20 * b02;
		output[1] = a01 * b00 + a11 * b01 + a21 * b02;
		output[2] = a02 * b00 + a12 * b01 + a22 * b02;
		output[3] = a03 * b00 + a13 * b01 + a23 * b02;
		output[4] = a00 * b10 + a10 * b11 + a20 * b12;
		output[5] = a01 * b10 + a11 * b11 + a21 * b12;
		output[6] = a02 * b10 + a12 * b11 + a22 * b12;
		output[7] = a03 * b10 + a13 * b11 + a23 * b12;
		output[8] = a00 * b20 + a10 * b21 + a20 * b22;
		output[9] = a01 * b20 + a11 * b21 + a21 * b22;
		output[10] = a02 * b20 + a12 * b21 + a22 * b22;
		output[11] = a03 * b20 + a13 * b21 + a23 * b22;
		if (a != output) {
			output[12] = a[12];
			output[13] = a[13];
			output[14] = a[14];
			output[15] = a[15];
		}
		return output;
	}

	/// <summary>Rotates a matrix by the given angle around the X axis
	/// @returns {mat4} out</summary>
	/// <param name="output">{mat4} out the receiving matrix</param>
	/// <param name="a">{mat4} a the matrix to rotate</param>
	/// <param name="rad">{Number} rad the angle to rotate the matrix by</param>
	public static float[] RotateX(float[] output, float[] a, float rad)
	{
		float s = Platform.Sin(rad);
		float c = Platform.Cos(rad);
		float a10 = a[4];
		float a11 = a[5];
		float a12 = a[6];
		float a13 = a[7];
		float a20 = a[8];
		float a21 = a[9];
		float a22 = a[10];
		float a23 = a[11];
		if (a != output) {
			output[0] = a[0];
			output[1] = a[1];
			output[2] = a[2];
			output[3] = a[3];
			output[12] = a[12];
			output[13] = a[13];
			output[14] = a[14];
			output[15] = a[15];
		}
		output[4] = a10 * c + a20 * s;
		output[5] = a11 * c + a21 * s;
		output[6] = a12 * c + a22 * s;
		output[7] = a13 * c + a23 * s;
		output[8] = a20 * c - a10 * s;
		output[9] = a21 * c - a11 * s;
		output[10] = a22 * c - a12 * s;
		output[11] = a23 * c - a13 * s;
		return output;
	}

	/// <summary>Rotates a matrix by the given angle around the Y axis
	/// @returns {mat4} out</summary>
	/// <param name="output">{mat4} out the receiving matrix</param>
	/// <param name="a">{mat4} a the matrix to rotate</param>
	/// <param name="rad">{Number} rad the angle to rotate the matrix by</param>
	public static float[] RotateY(float[] output, float[] a, float rad)
	{
		float s = Platform.Sin(rad);
		float c = Platform.Cos(rad);
		float a00 = a[0];
		float a01 = a[1];
		float a02 = a[2];
		float a03 = a[3];
		float a20 = a[8];
		float a21 = a[9];
		float a22 = a[10];
		float a23 = a[11];
		if (a != output) {
			output[4] = a[4];
			output[5] = a[5];
			output[6] = a[6];
			output[7] = a[7];
			output[12] = a[12];
			output[13] = a[13];
			output[14] = a[14];
			output[15] = a[15];
		}
		output[0] = a00 * c - a20 * s;
		output[1] = a01 * c - a21 * s;
		output[2] = a02 * c - a22 * s;
		output[3] = a03 * c - a23 * s;
		output[8] = a00 * s + a20 * c;
		output[9] = a01 * s + a21 * c;
		output[10] = a02 * s + a22 * c;
		output[11] = a03 * s + a23 * c;
		return output;
	}

	/// <summary>Rotates a matrix by the given angle around the Z axis
	/// @returns {mat4} out</summary>
	/// <param name="output">{mat4} out the receiving matrix</param>
	/// <param name="a">{mat4} a the matrix to rotate</param>
	/// <param name="rad">{Number} rad the angle to rotate the matrix by</param>
	public static float[] RotateZ(float[] output, float[] a, float rad)
	{
		float s = Platform.Sin(rad);
		float c = Platform.Cos(rad);
		float a00 = a[0];
		float a01 = a[1];
		float a02 = a[2];
		float a03 = a[3];
		float a10 = a[4];
		float a11 = a[5];
		float a12 = a[6];
		float a13 = a[7];
		if (a != output) {
			output[8] = a[8];
			output[9] = a[9];
			output[10] = a[10];
			output[11] = a[11];
			output[12] = a[12];
			output[13] = a[13];
			output[14] = a[14];
			output[15] = a[15];
		}
		output[0] = a00 * c + a10 * s;
		output[1] = a01 * c + a11 * s;
		output[2] = a02 * c + a12 * s;
		output[3] = a03 * c + a13 * s;
		output[4] = a10 * c - a00 * s;
		output[5] = a11 * c - a01 * s;
		output[6] = a12 * c - a02 * s;
		output[7] = a13 * c - a03 * s;
		return output;
	}

	/// <summary>Scales the mat4 by the dimensions in the given vec3
	/// @returns {mat4} out</summary>
	/// <param name="output">{mat4} out the receiving matrix</param>
	/// <param name="a">{mat4} a the matrix to scale</param>
	/// <param name="v">{vec3} v the vec3 to scale the matrix by</param>
	public static float[] Scale(float[] output, float[] a, float[] v)
	{
		float x = v[0];
		float y = v[1];
		float z = v[2];
		output[0] = a[0] * x;
		output[1] = a[1] * x;
		output[2] = a[2] * x;
		output[3] = a[3] * x;
		output[4] = a[4] * y;
		output[5] = a[5] * y;
		output[6] = a[6] * y;
		output[7] = a[7] * y;
		output[8] = a[8] * z;
		output[9] = a[9] * z;
		output[10] = a[10] * z;
		output[11] = a[11] * z;
		output[12] = a[12];
		output[13] = a[13];
		output[14] = a[14];
		output[15] = a[15];
		return output;
	}

	/// <summary>Translate a mat4 by the given vector
	/// @returns {mat4} out</summary>
	/// <param name="output">{mat4} out the receiving matrix</param>
	/// <param name="a">{mat4} a the matrix to translate</param>
	/// <param name="v">{vec3} v vector to translate by</param>
	public static float[] Translate(float[] output, float[] a, float[] v)
	{
		float x = v[0];
		float y = v[1];
		float z = v[2];
		float a00;
		float a01;
		float a02;
		float a03;
		float a10;
		float a11;
		float a12;
		float a13;
		float a20;
		float a21;
		float a22;
		float a23;
		if (a == output) {
			output[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
			output[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
			output[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
			output[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
		}
		else {
			a00 = a[0];
			a01 = a[1];
			a02 = a[2];
			a03 = a[3];
			a10 = a[4];
			a11 = a[5];
			a12 = a[6];
			a13 = a[7];
			a20 = a[8];
			a21 = a[9];
			a22 = a[10];
			a23 = a[11];
			output[0] = a00;
			output[1] = a01;
			output[2] = a02;
			output[3] = a03;
			output[4] = a10;
			output[5] = a11;
			output[6] = a12;
			output[7] = a13;
			output[8] = a20;
			output[9] = a21;
			output[10] = a22;
			output[11] = a23;
			output[12] = a00 * x + a10 * y + a20 * z + a[12];
			output[13] = a01 * x + a11 * y + a21 * z + a[13];
			output[14] = a02 * x + a12 * y + a22 * z + a[14];
			output[15] = a03 * x + a13 * y + a23 * z + a[15];
		}
		return output;
	}

	/// <summary>Transpose the values of a mat4
	/// @returns {mat4} out</summary>
	/// <param name="output">@param {mat4} out the receiving matrix</param>
	/// <param name="a">@param {mat4} a the source matrix</param>
	public static float[] Transpose(float[] output, float[] a)
	{
		if (output == a) {
			float a01 = a[1];
			float a02 = a[2];
			float a03 = a[3];
			float a12 = a[6];
			float a13 = a[7];
			float a23 = a[11];
			output[1] = a[4];
			output[2] = a[8];
			output[3] = a[12];
			output[4] = a01;
			output[6] = a[9];
			output[7] = a[13];
			output[8] = a02;
			output[9] = a12;
			output[11] = a[14];
			output[12] = a03;
			output[13] = a13;
			output[14] = a23;
		}
		else {
			output[0] = a[0];
			output[1] = a[4];
			output[2] = a[8];
			output[3] = a[12];
			output[4] = a[1];
			output[5] = a[5];
			output[6] = a[9];
			output[7] = a[13];
			output[8] = a[2];
			output[9] = a[6];
			output[10] = a[10];
			output[11] = a[14];
			output[12] = a[3];
			output[13] = a[7];
			output[14] = a[11];
			output[15] = a[15];
		}
		return output;
	}

	/// <summary>**</summary>
	void f()
	{
	}
}

public class MathCi
{

	public static float AbsFloat(float b)
	{
		if (b >= 0) {
			return b;
		}
		else {
			return 0 - b;
		}
	}

	public static float ClampFloat(float value, float min, float max)
	{
		float result = value;
		if (value > max) {
			result = max;
		}
		if (value < min) {
			result = min;
		}
		return result;
	}

	public static int ClampInt(int value, int min, int max)
	{
		int result = value;
		if (value > max) {
			result = max;
		}
		if (value < min) {
			result = min;
		}
		return result;
	}

	public static float MaxFloat(float a, float b)
	{
		if (a >= b) {
			return a;
		}
		else {
			return b;
		}
	}

	public static int MaxInt(int a, int b)
	{
		if (a >= b) {
			return a;
		}
		else {
			return b;
		}
	}

	public static float MinFloat(float a, float b)
	{
		if (a <= b) {
			return a;
		}
		else {
			return b;
		}
	}

	public static int MinInt(int a, int b)
	{
		if (a <= b) {
			return a;
		}
		else {
			return b;
		}
	}

	public static int Sign(float q)
	{
		if (q < 0) {
			return -1;
		}
		else if (q == 0) {
			return 0;
		}
		else {
			return 1;
		}
	}
}

public class MenuState
{
	internal int selected;
}

public class MenuWidget
{
	public MenuWidget()
	{
		this.visible = true;
		this.fontSize = 14;
		this.nextWidget = -1;
		this.hasKeyboardFocus = false;
	}

	public void GetFocus()
	{
		this.hasKeyboardFocus = true;
		if (this.type == WidgetType.Textbox) {
			this.editing = true;
		}
	}

	public void LoseFocus()
	{
		this.hasKeyboardFocus = false;
		if (this.type == WidgetType.Textbox) {
			this.editing = false;
		}
	}
	internal ButtonStyle buttonStyle;
	internal int color;
	internal string description;
	internal bool editing;
	internal FontCi font;
	internal float fontSize;
	internal bool hasKeyboardFocus;
	internal bool hover;
	internal string id;
	internal string image;
	internal bool isbutton;
	internal int nextWidget;
	internal bool password;
	internal bool pressed;
	internal bool selected;
	internal float sizex;
	internal float sizey;
	internal string text;
	internal WidgetType type;
	internal bool visible;
	internal float x;
	internal float y;
}

public class MeshBatcher
{
	public MeshBatcher()
	{
		int modelsMax = 16384;
		this.models = new ListInfo[modelsMax];
		for (int i = 0; i < modelsMax; i++) {
			this.models[i] = new ListInfo();
		}
		this.modelsCount = 0;
		this.BindTexture = true;
		this.glTextures = new int[10];
		this.glTexturesLength = 10;
		this.empty = new int[modelsMax];
		this.emptyCount = 0;
	}

	public int Add(ModelData modelData, bool transparent, int texture, float centerX, float centerY, float centerZ, float radius)
	{
		int id;
		if (this.emptyCount > 0) {
			id = this.empty[this.emptyCount - 1];
			this.emptyCount--;
		}
		else {
			id = this.modelsCount;
			this.modelsCount++;
		}
		Model model = this.game.platform.CreateModel(modelData);
		ListInfo li = this.models[id];
		li.indicescount = modelData.GetIndicesCount();
		li.centerX = centerX;
		li.centerY = centerY;
		li.centerZ = centerZ;
		li.radius = radius;
		li.transparent = transparent;
		li.empty = false;
		li.texture = this.GetTextureId(texture);
		li.model = model;
		return id;
	}

	int ArrayIndexOf(int[] glTextures, int length, int glTexture)
	{
		for (int i = 0; i < length; i++) {
			if (glTextures[i] == glTexture) {
				return i;
			}
		}
		return -1;
	}
	internal bool BindTexture;

	public void Clear()
	{
		int count = this.modelsCount;
		for (int i = 0; i < count; i++) {
			if (!this.models[i].empty) {
				this.Remove(i);
			}
		}
	}

	public void Draw(float playerPositionX, float playerPositionY, float playerPositionZ)
	{
		this.UpdateCulling();
		this.SortListsByTexture();
		for (int i = 0; i < 10; i++) {
			if (this.tocallSolid[i].Count == 0) {
				continue;
			}
			if (this.BindTexture) {
				this.game.platform.BindTexture2d(this.glTextures[i]);
			}
			this.game.DrawModels(this.tocallSolid[i].Lists, this.tocallSolid[i].Count);
		}
		this.game.platform.GlDisableCullFace();
		for (int i = 0; i < 10; i++) {
			if (this.tocallTransparent[i].Count == 0) {
				continue;
			}
			if (this.BindTexture) {
				this.game.platform.BindTexture2d(this.glTextures[i]);
			}
			this.game.DrawModels(this.tocallTransparent[i].Lists, this.tocallTransparent[i].Count);
		}
		this.game.platform.GlEnableCullFace();
	}

	int GetTextureId(int glTexture)
	{
		int id = this.ArrayIndexOf(this.glTextures, this.glTexturesLength, glTexture);
		if (id != -1) {
			return id;
		}
		id = this.ArrayIndexOf(this.glTextures, this.glTexturesLength, 0);
		if (id != -1) {
			this.glTextures[id] = glTexture;
			return id;
		}
		int increase = 10;
		int[] glTextures2 = new int[this.glTexturesLength + increase];
		for (int i = 0; i < this.glTexturesLength; i++) {
			glTextures2[i] = this.glTextures[i];
		}
		this.glTextures = glTextures2;
		this.glTexturesLength = this.glTexturesLength + increase;
		this.glTextures[this.glTexturesLength - increase] = glTexture;
		return this.glTexturesLength - increase;
	}

	public void Remove(int id)
	{
		this.game.platform.DeleteModel(this.models[id].model);
		this.models[id].empty = true;
		this.empty[this.emptyCount++] = id;
	}

	void SortListsByTexture()
	{
		if (this.tocallSolid == null) {
			this.tocallSolid = new ToCall[10];
			this.tocallTransparent = new ToCall[10];
			for (int i = 0; i < 10; i++) {
				this.tocallSolid[i] = new ToCall();
				this.tocallTransparent[i] = new ToCall();
			}
			for (int i = 0; i < 10; i++) {
				int max = 256;
				this.tocallSolid[i].Lists = new Model[max];
				this.tocallSolid[i].Max = max;
				this.tocallTransparent[i].Lists = new Model[max];
				this.tocallTransparent[i].Max = max;
			}
		}
		for (int i = 0; i < 10; i++) {
			this.tocallSolid[i].Count = 0;
			this.tocallTransparent[i].Count = 0;
		}
		for (int i = 0; i < this.modelsCount; i++) {
			ListInfo li = this.models[i];
			if (!li.render) {
				continue;
			}
			if (li.empty) {
				continue;
			}
			ToCall tocall;
			if (!li.transparent) {
				tocall = this.tocallSolid[li.texture];
			}
			else {
				tocall = this.tocallTransparent[li.texture];
			}
			if (tocall.Count >= tocall.Max) {
				Model[] old = tocall.Lists;
				Model[] new_ = new Model[tocall.Max * 2];
				for (int k = 0; k < tocall.Max; k++) {
					new_[k] = old[k];
				}
				tocall.Lists = new_;
				tocall.Max = tocall.Max * 2;
			}
			tocall.Lists[tocall.Count++] = this.models[i].model;
		}
	}

	public int TotalTriangleCount()
	{
		int sum = 0;
		int count = this.modelsCount;
		for (int i = 0; i < count; i++) {
			if (!this.models[i].empty) {
				ListInfo li = this.models[i];
				if (li.render) {
					sum += li.indicescount;
				}
			}
		}
		return sum / 3;
	}

	void UpdateCulling()
	{
		int licount = this.modelsCount;
		for (int i = 0; i < licount; i++) {
			ListInfo li = this.models[i];
			float centerX = li.centerX;
			float centerY = li.centerY;
			float centerZ = li.centerZ;
			li.render = this.d_FrustumCulling.SphereInFrustum(centerX, centerY, centerZ, li.radius);
		}
	}
	internal FrustumCulling d_FrustumCulling;
	int[] empty;
	int emptyCount;
	internal Game game;
	int[] glTextures;
	int glTexturesLength;
	ListInfo[] models;
	int modelsCount;
	public const int texturesCount = 10;
	ToCall[] tocallSolid;
	ToCall[] tocallTransparent;
}

public class Minecart
{
	internal VehicleDirection12 direction;
	internal bool enabled;
	internal VehicleDirection12 lastdirection;
	internal float positionX;
	internal float positionY;
	internal float positionZ;
	internal float progress;
}

public class MiscCi
{

	public static bool ReadBool(string str)
	{
		if (str == null) {
			return false;
		}
		else {
			return str != "0" && str != "false" && str != "False" && str != "FALSE";
		}
	}

	public static byte[] UshortArrayToByteArray(int[] input, int inputLength)
	{
		int outputLength = inputLength * 2;
		byte[] output = new byte[outputLength];
		for (int i = 0; i < inputLength; i++) {
			output[i * 2] = Game.IntToByte(input[i] & 255);
			output[i * 2 + 1] = Game.IntToByte(input[i] >> 8 & 255);
		}
		return output;
	}

	public static float Vec3Length(float x, float y, float z)
	{
		return Platform.Sqrt(x * x + y * y + z * z);
	}
}

public class ModAudio : ClientMod
{
	public ModAudio()
	{
		this.audioData = new DictionaryStringAudioData();
		this.wasLoaded = false;
	}

	AudioData GetAudioData(Game game, string sound)
	{
		if (!this.audioData.Contains(sound)) {
			AudioData a = game.platform.AudioDataCreate(game.GetFile(sound), game.GetFileLength(sound));
			this.audioData.Set(sound, a);
		}
		return this.audioData.GetById(this.audioData.GetId(sound));
	}

	public override void OnNewFrame(Game game, NewFrameEventArgs args)
	{
		if (game.assetsLoadProgress.value != 1) {
			return;
		}
		if (!this.wasLoaded) {
			this.wasLoaded = true;
			this.Preload(game);
		}
		for (int i = 0; i < game.audio.soundsCount; i++) {
			Sound_ sound = game.audio.sounds[i];
			if (sound == null) {
				continue;
			}
			if (sound.audio != null) {
				continue;
			}
			AudioData data = this.GetAudioData(game, sound.name);
			if (game.platform.AudioDataLoaded(data)) {
				sound.audio = game.platform.AudioCreate(data);
				game.platform.AudioPlay(sound.audio);
			}
		}
		for (int i = 0; i < game.audio.soundsCount; i++) {
			Sound_ sound = game.audio.sounds[i];
			if (sound == null) {
				continue;
			}
			if (sound.audio == null) {
				continue;
			}
			game.platform.AudioSetPosition(sound.audio, sound.x, sound.y, sound.z);
		}
		for (int i = 0; i < game.audio.soundsCount; i++) {
			Sound_ sound = game.audio.sounds[i];
			if (sound == null) {
				continue;
			}
			if (sound.audio == null) {
				continue;
			}
			if (sound.stop) {
				game.platform.AudioDelete(sound.audio);
				game.audio.sounds[i] = null;
			}
		}
		for (int i = 0; i < game.audio.soundsCount; i++) {
			Sound_ sound = game.audio.sounds[i];
			if (sound == null) {
				continue;
			}
			if (sound.audio == null) {
				continue;
			}
			if (sound.loop) {
				if (game.platform.AudioFinished(sound.audio) && sound.loop) {
					AudioData data = this.GetAudioData(game, sound.name);
					if (game.platform.AudioDataLoaded(data)) {
						sound.audio = game.platform.AudioCreate(data);
						game.platform.AudioPlay(sound.audio);
					}
				}
			}
			else {
				if (game.platform.AudioFinished(sound.audio)) {
					game.audio.sounds[i] = null;
				}
			}
		}
	}

	void Preload(Game game)
	{
		for (int k = 0; k < game.assets.count; k++) {
			string s = game.assets.items[k].name;
			string sound = game.platform.StringReplace(s, ".ogg", "");
			if (s == sound) {
				continue;
			}
			this.GetAudioData(game, s);
		}
	}
	DictionaryStringAudioData audioData;
	bool wasLoaded;
}

public class ModAutoCamera : ClientMod
{

	float Distance(CameraPoint a, CameraPoint b)
	{
		float dx = a.positionGlX - b.positionGlX;
		float dy = a.positionGlY - b.positionGlY;
		float dz = a.positionGlZ - b.positionGlZ;
		return this.p.MathSqrt(dx * dx + dy * dy + dz * dz);
	}

	public override bool OnClientCommand(Game game, ClientCommandArgs args)
	{
		if (args.command == "cam") {
			IntRef argumentsLength = new IntRef();
			string[] arguments = this.p.StringSplit(args.arguments, " ", argumentsLength);
			if (this.p.StringTrim(args.arguments) == "") {
				this.m.DisplayNotification("&6AutoCamera help.");
				this.m.DisplayNotification("&6.cam p&f - add a point to path");
				this.m.DisplayNotification("&6.cam start [real seconds]&f - play the path");
				this.m.DisplayNotification("&6.cam rec [real seconds] [video seconds]&f - play and record to .avi file");
				this.m.DisplayNotification("&6.cam stop&f - stop playing and recording");
				this.m.DisplayNotification("&6.cam clear&f - remove all points from path");
				this.m.DisplayNotification("&6.cam save&f - copy path points to clipboard");
				this.m.DisplayNotification("&6.cam load [points]&f - load path points");
				return true;
			}
			if (arguments[0] == "p") {
				this.m.DisplayNotification("Point defined.");
				CameraPoint point = new CameraPoint();
				point.positionGlX = this.m.GetLocalPositionX();
				point.positionGlY = this.m.GetLocalPositionY();
				point.positionGlZ = this.m.GetLocalPositionZ();
				point.orientationGlX = this.m.GetLocalOrientationX();
				point.orientationGlY = this.m.GetLocalOrientationY();
				point.orientationGlZ = this.m.GetLocalOrientationZ();
				this.cameraPoints[this.cameraPointsCount++] = point;
			}
			if (arguments[0] == "start" || arguments[0] == "play" || arguments[0] == "rec") {
				if (!this.m.IsFreemoveAllowed()) {
					this.m.DisplayNotification("Free move not allowed.");
					return true;
				}
				if (this.cameraPointsCount == 0) {
					this.m.DisplayNotification("No points defined. Enter points with \".cam p\" command.");
					return true;
				}
				this.playingSpeed = 1;
				float totalRecTime = -1;
				if (arguments[0] == "rec") {
					if (argumentsLength.value >= 3) {
						totalRecTime = this.p.FloatParse(arguments[2]);
					}
					this.avi = this.m.AviWriterCreate();
					this.avi.Open(this.p.StringFormat("{0}.avi", this.p.Timestamp()), 60, this.m.GetWindowWidth(), this.m.GetWindowHeight());
				}
				if (argumentsLength.value >= 2) {
					float totalTime = this.p.FloatParse(arguments[1]);
					this.playingSpeed = this.TotalDistance() / totalTime;
					if (totalRecTime == -1) {
						this.recspeed = 10;
					}
					else {
						this.recspeed = totalTime / totalRecTime;
					}
				}
				this.playingTime = 0;
				this.firstFrameDone = false;
				this.previousPositionX = this.m.GetLocalPositionX();
				this.previousPositionY = this.m.GetLocalPositionY();
				this.previousPositionZ = this.m.GetLocalPositionZ();
				this.previousOrientationX = this.m.GetLocalOrientationX();
				this.previousOrientationY = this.m.GetLocalOrientationY();
				this.previousOrientationZ = this.m.GetLocalOrientationZ();
				this.m.ShowGui(0);
				this.previousFreemove = this.m.GetFreemove();
				this.m.SetFreemove(2);
				this.m.EnableCameraControl(false);
			}
			if (arguments[0] == "stop") {
				this.m.DisplayNotification("Camera stopped.");
				this.Stop();
			}
			if (arguments[0] == "clear") {
				this.m.DisplayNotification("Camera points cleared.");
				this.cameraPointsCount = 0;
				this.Stop();
			}
			if (arguments[0] == "save") {
				string s = "1,";
				for (int i = 0; i < this.cameraPointsCount; i++) {
					CameraPoint point = this.cameraPoints[i];
					s = this.p.StringFormat2("{0}{1},", s, this.p.IntToString(this.p.FloatToInt(point.positionGlX * 100)));
					s = this.p.StringFormat2("{0}{1},", s, this.p.IntToString(this.p.FloatToInt(point.positionGlY * 100)));
					s = this.p.StringFormat2("{0}{1},", s, this.p.IntToString(this.p.FloatToInt(point.positionGlZ * 100)));
					s = this.p.StringFormat2("{0}{1},", s, this.p.IntToString(this.p.FloatToInt(point.orientationGlX * 1000)));
					s = this.p.StringFormat2("{0}{1},", s, this.p.IntToString(this.p.FloatToInt(point.orientationGlY * 1000)));
					s = this.p.StringFormat2("{0}{1}", s, this.p.IntToString(this.p.FloatToInt(point.orientationGlZ * 1000)));
					if (i != this.cameraPointsCount - 1) {
						s = this.p.StringFormat("{0},", s);
					}
				}
				this.p.ClipboardSetText(s);
				this.m.DisplayNotification("Camera points copied to clipboard.");
			}
			if (arguments[0] == "load") {
				IntRef pointsLength = new IntRef();
				string[] points = this.p.StringSplit(arguments[1], ",", pointsLength);
				int n = (pointsLength.value - 1) / 6;
				this.cameraPointsCount = 0;
				for (int i = 0; i < n; i++) {
					CameraPoint point = new CameraPoint();
					point.positionGlX = this.one * this.p.IntParse(points[1 + i * 6 + 0]) / 100;
					point.positionGlY = this.one * this.p.IntParse(points[1 + i * 6 + 1]) / 100;
					point.positionGlZ = this.one * this.p.IntParse(points[1 + i * 6 + 2]) / 100;
					point.orientationGlX = this.one * this.p.IntParse(points[1 + i * 6 + 3]) / 1000;
					point.orientationGlY = this.one * this.p.IntParse(points[1 + i * 6 + 4]) / 1000;
					point.orientationGlZ = this.one * this.p.IntParse(points[1 + i * 6 + 5]) / 1000;
					this.cameraPoints[this.cameraPointsCount++] = point;
				}
				this.m.DisplayNotification(this.p.StringFormat("Camera points loaded: {0}", this.p.IntToString(n)));
			}
			return true;
		}
		return false;
	}

	public override void OnNewFrame(Game game, NewFrameEventArgs args)
	{
		float dt = args.GetDt();
		if (this.playingTime == -1) {
			return;
		}
		this.playingTime += dt;
		float playingDist = this.playingTime * this.playingSpeed;
		this.UpdateAvi(dt);
		float distA = 0;
		int foundPoint = -1;
		for (int i = 0; i < this.cameraPointsCount - 1; i++) {
			CameraPoint a = this.cameraPoints[i];
			CameraPoint b = this.cameraPoints[i + 1];
			float dist = this.Distance(a, b);
			if (playingDist >= distA && playingDist < distA + dist) {
				foundPoint = i;
				break;
			}
			distA += dist;
		}
		if (foundPoint == -1) {
			this.Stop();
			return;
		}
		{
			CameraPoint a = this.cameraPoints[foundPoint];
			CameraPoint b = this.cameraPoints[foundPoint + 1];
			CameraPoint aminus = a;
			CameraPoint bplus = b;
			if (foundPoint - 1 >= 0) {
				aminus = this.cameraPoints[foundPoint - 1];
			}
			if (foundPoint + 2 < this.cameraPointsCount) {
				bplus = this.cameraPoints[foundPoint + 2];
			}
			float t = (playingDist - distA) / this.Distance(a, b);
			float x = ModAutoCamera.q(t, aminus.positionGlX, a.positionGlX, b.positionGlX, bplus.positionGlX);
			float y = ModAutoCamera.q(t, aminus.positionGlY, a.positionGlY, b.positionGlY, bplus.positionGlY);
			float z = ModAutoCamera.q(t, aminus.positionGlZ, a.positionGlZ, b.positionGlZ, bplus.positionGlZ);
			this.m.SetLocalPosition(x, y, z);
			float orientx = ModAutoCamera.q(t, aminus.orientationGlX, a.orientationGlX, b.orientationGlX, bplus.orientationGlX);
			float orienty = ModAutoCamera.q(t, aminus.orientationGlY, a.orientationGlY, b.orientationGlY, bplus.orientationGlY);
			float orientz = ModAutoCamera.q(t, aminus.orientationGlZ, a.orientationGlZ, b.orientationGlZ, bplus.orientationGlZ);
			this.m.SetLocalOrientation(orientx, orienty, orientz);
		}
	}

	public override void Start(ClientModManager modmanager)
	{
		this.m = modmanager;
		this.p = modmanager.GetPlatform();
		this.one = 1;
		this.cameraPoints = new CameraPoint[256];
		this.cameraPointsCount = 0;
		this.playingTime = -1;
		this.position = new float[3];
		this.orientation = new float[3];
	}

	void Stop()
	{
		this.m.ShowGui(1);
		this.m.EnableCameraControl(true);
		if (this.playingTime != -1) {
			this.m.SetFreemove(this.previousFreemove);
			this.m.SetLocalPosition(this.previousPositionX, this.previousPositionY, this.previousPositionZ);
			this.m.SetLocalOrientation(this.previousOrientationX, this.previousOrientationY, this.previousOrientationZ);
		}
		this.playingTime = -1;
		if (this.avi != null) {
			this.avi.Close();
			this.avi = null;
		}
	}

	float TotalDistance()
	{
		float totalDistance = 0;
		for (int i = 0; i < this.cameraPointsCount - 1; i++) {
			CameraPoint a = this.cameraPoints[i];
			CameraPoint b = this.cameraPoints[i + 1];
			float dist = this.Distance(a, b);
			totalDistance += dist;
		}
		return totalDistance;
	}

	void UpdateAvi(float dt)
	{
		if (this.avi == null) {
			return;
		}
		if (!this.firstFrameDone) {
			this.firstFrameDone = true;
			return;
		}
		this.writeAccum += dt;
		float totalTime = this.playingSpeed * this.TotalDistance();
		if (this.writeAccum >= this.one / 60 * this.recspeed) {
			this.writeAccum -= this.one / 60 * this.recspeed;
			BitmapCi bmp = this.m.GrabScreenshot();
			this.avi.AddFrame(bmp);
			bmp.Dispose();
		}
	}
	AviWriterCi avi;
	CameraPoint[] cameraPoints;
	int cameraPointsCount;
	bool firstFrameDone;
	ClientModManager m;
	float one;
	float[] orientation;
	GamePlatform p;
	float playingSpeed;
	float playingTime;
	float[] position;
	int previousFreemove;
	float previousOrientationX;
	float previousOrientationY;
	float previousOrientationZ;
	float previousPositionX;
	float previousPositionY;
	float previousPositionZ;

	public static float q(float t, float p0, float p1, float p2, float p3)
	{
		float one_ = 1;
		return one_ / 2 * (2 * p1 + (-p0 + p2) * t + (2 * p0 - 5 * p1 + 4 * p2 - p3) * t * t + (-p0 + 3 * p1 - 3 * p2 + p3) * t * t * t);
	}
	float recspeed;
	float writeAccum;
}

public class ModBlockDamageToPlayer : ClientMod
{
	public ModBlockDamageToPlayer()
	{
		this.one = 1;
		this.BlockDamageToPlayerTimer = TimerCi.Create(1, 2);
	}
	public const int BlockDamageToPlayerEvery = 1;
	TimerCi BlockDamageToPlayerTimer;

	public override void OnNewFrameFixed(Game game, NewFrameEventArgs args)
	{
		if (game.guistate == GuiState.MapLoading) {
			return;
		}
		if (game.FollowId() == null) {
			this.UpdateBlockDamageToPlayer(game, args.GetDt());
		}
	}

	internal void UpdateBlockDamageToPlayer(Game game, float dt)
	{
		float pX = game.player.position.x;
		float pY = game.player.position.y;
		float pZ = game.player.position.z;
		pY += game.entities[game.LocalPlayerId].drawModel.eyeHeight;
		int block1 = 0;
		int block2 = 0;
		if (game.map.IsValidPos(game.MathFloor(pX), game.MathFloor(pZ), game.MathFloor(pY))) {
			block1 = game.map.GetBlock(game.platform.FloatToInt(pX), game.platform.FloatToInt(pZ), game.platform.FloatToInt(pY));
		}
		if (game.map.IsValidPos(game.MathFloor(pX), game.MathFloor(pZ), game.MathFloor(pY) - 1)) {
			block2 = game.map.GetBlock(game.platform.FloatToInt(pX), game.platform.FloatToInt(pZ), game.platform.FloatToInt(pY) - 1);
		}
		int damage = game.d_Data.DamageToPlayer()[block1] + game.d_Data.DamageToPlayer()[block2];
		if (damage > 0) {
			int hurtingBlock = block1;
			if (hurtingBlock == 0 || game.d_Data.DamageToPlayer()[hurtingBlock] == 0) {
				hurtingBlock = block2;
			}
			int times = this.BlockDamageToPlayerTimer.Update(dt);
			for (int i = 0; i < times; i++) {
				game.ApplyDamageToPlayer(damage, 1, hurtingBlock);
			}
		}
		int deltaTime = game.platform.FloatToInt(this.one * (game.platform.TimeMillisecondsFromStart() - game.lastOxygenTickMilliseconds));
		if (deltaTime >= 1000) {
			if (game.WaterSwimmingEyes()) {
				game.PlayerStats.CurrentOxygen -= 1;
				if (game.PlayerStats.CurrentOxygen <= 0) {
					game.PlayerStats.CurrentOxygen = 0;
					int dmg = game.platform.FloatToInt(this.one * game.PlayerStats.MaxHealth / 10);
					if (dmg < 1) {
						dmg = 1;
					}
					game.ApplyDamageToPlayer(dmg, 2, block1);
				}
			}
			else {
				game.PlayerStats.CurrentOxygen = game.PlayerStats.MaxOxygen;
			}
			if (GameVersionHelper.ServerVersionAtLeast(game.platform, game.serverGameVersion, 2014, 3, 31)) {
				game.SendPacketClient(ClientPackets.Oxygen(game.PlayerStats.CurrentOxygen));
			}
			game.lastOxygenTickMilliseconds = game.platform.TimeMillisecondsFromStart();
		}
	}
	float one;
}

public class ModBullet : ClientMod
{

	public override void OnNewFrameDraw3d(Game game, float dt)
	{
		for (int i = 0; i < game.entitiesCount; i++) {
			Entity entity = game.entities[i];
			if (entity == null) {
				continue;
			}
			if (entity.bullet == null) {
				continue;
			}
			Bullet_ b = entity.bullet;
			if (b.progress < 1) {
				b.progress = 1;
			}
			float dirX = b.toX - b.fromX;
			float dirY = b.toY - b.fromY;
			float dirZ = b.toZ - b.fromZ;
			float length = game.Dist(0, 0, 0, dirX, dirY, dirZ);
			dirX /= length;
			dirY /= length;
			dirZ /= length;
			float posX = b.fromX;
			float posY = b.fromY;
			float posZ = b.fromZ;
			posX += dirX * (b.progress + b.speed * dt);
			posY += dirY * (b.progress + b.speed * dt);
			posZ += dirZ * (b.progress + b.speed * dt);
			b.progress += b.speed * dt;
			entity.sprite.positionX = posX;
			entity.sprite.positionY = posY;
			entity.sprite.positionZ = posZ;
			if (b.progress > length) {
				game.entities[i] = null;
			}
		}
	}
}

public class ModCamera : ClientMod
{
	public ModCamera()
	{
		this.OverheadCamera_cameraEye = new Vector3Ref();
		this.upVec3 = Vec3.FromValues(0, 1, 0);
	}

	internal float[] FppCamera(Game game)
	{
		Vector3Ref forward = new Vector3Ref();
		VectorTool.ToVectorInFixedSystem(0, 0, 1, game.player.position.rotx, game.player.position.roty, forward);
		Vector3Ref cameraEye = new Vector3Ref();
		Vector3Ref cameraTarget = new Vector3Ref();
		float playerEyeX = game.player.position.x;
		float playerEyeY = game.player.position.y + game.GetCharacterEyesHeight();
		float playerEyeZ = game.player.position.z;
		if (!game.ENABLE_TPP_VIEW) {
			cameraEye.X = playerEyeX;
			cameraEye.Y = playerEyeY;
			cameraEye.Z = playerEyeZ;
			cameraTarget.X = playerEyeX + forward.X;
			cameraTarget.Y = playerEyeY + forward.Y;
			cameraTarget.Z = playerEyeZ + forward.Z;
		}
		else {
			cameraEye.X = playerEyeX + forward.X * -game.tppcameradistance;
			cameraEye.Y = playerEyeY + forward.Y * -game.tppcameradistance;
			cameraEye.Z = playerEyeZ + forward.Z * -game.tppcameradistance;
			cameraTarget.X = playerEyeX;
			cameraTarget.Y = playerEyeY;
			cameraTarget.Z = playerEyeZ;
			FloatRef currentTppcameradistance = FloatRef.Create(game.tppcameradistance);
			this.LimitThirdPersonCameraToWalls(game, cameraEye, cameraTarget, currentTppcameradistance);
		}
		float[] ret = new float[16];
		Mat4.LookAt(ret, Vec3.FromValues(cameraEye.X, cameraEye.Y, cameraEye.Z), Vec3.FromValues(cameraTarget.X, cameraTarget.Y, cameraTarget.Z), this.upVec3);
		game.CameraEyeX = cameraEye.X;
		game.CameraEyeY = cameraEye.Y;
		game.CameraEyeZ = cameraEye.Z;
		return ret;
	}

	internal void LimitThirdPersonCameraToWalls(Game game, Vector3Ref eye, Vector3Ref target, FloatRef curtppcameradistance)
	{
		float one = 1;
		Vector3Ref ray_start_point = target;
		Vector3Ref raytarget = eye;
		Line3D pick = new Line3D();
		float raydirX = raytarget.X - ray_start_point.X;
		float raydirY = raytarget.Y - ray_start_point.Y;
		float raydirZ = raytarget.Z - ray_start_point.Z;
		float raydirLength1 = game.Length(raydirX, raydirY, raydirZ);
		raydirX /= raydirLength1;
		raydirY /= raydirLength1;
		raydirZ /= raydirLength1;
		raydirX = raydirX * (game.tppcameradistance + 1);
		raydirY = raydirY * (game.tppcameradistance + 1);
		raydirZ = raydirZ * (game.tppcameradistance + 1);
		pick.Start = Vec3.FromValues(ray_start_point.X, ray_start_point.Y, ray_start_point.Z);
		pick.End = new float[3];
		pick.End[0] = ray_start_point.X + raydirX;
		pick.End[1] = ray_start_point.Y + raydirY;
		pick.End[2] = ray_start_point.Z + raydirZ;
		IntRef pick2Count = new IntRef();
		BlockPosSide[] pick2 = game.Pick(game.s, pick, pick2Count);
		if (pick2Count.value > 0) {
			BlockPosSide pick2nearest = game.Nearest(pick2, pick2Count.value, ray_start_point.X, ray_start_point.Y, ray_start_point.Z);
			float pickX = pick2nearest.blockPos[0] - target.X;
			float pickY = pick2nearest.blockPos[1] - target.Y;
			float pickZ = pick2nearest.blockPos[2] - target.Z;
			float pickdistance = game.Length(pickX, pickY, pickZ);
			curtppcameradistance.value = MathCi.MinFloat(pickdistance - 1, curtppcameradistance.value);
			if (curtppcameradistance.value < one * 3 / 10) {
				curtppcameradistance.value = one * 3 / 10;
			}
		}
		float cameraDirectionX = target.X - eye.X;
		float cameraDirectionY = target.Y - eye.Y;
		float cameraDirectionZ = target.Z - eye.Z;
		float raydirLength = game.Length(raydirX, raydirY, raydirZ);
		raydirX /= raydirLength;
		raydirY /= raydirLength;
		raydirZ /= raydirLength;
		eye.X = target.X + raydirX * curtppcameradistance.value;
		eye.Y = target.Y + raydirY * curtppcameradistance.value;
		eye.Z = target.Z + raydirZ * curtppcameradistance.value;
	}

	public override void OnBeforeNewFrameDraw3d(Game game, float deltaTime)
	{
		if (game.overheadcamera) {
			game.camera = this.OverheadCamera(game);
		}
		else {
			game.camera = this.FppCamera(game);
		}
	}

	internal float[] OverheadCamera(Game game)
	{
		game.overheadcameraK.GetPosition(game.platform, this.OverheadCamera_cameraEye);
		Vector3Ref cameraEye = this.OverheadCamera_cameraEye;
		Vector3Ref cameraTarget = Vector3Ref.Create(game.overheadcameraK.Center.X, game.overheadcameraK.Center.Y + game.GetCharacterEyesHeight(), game.overheadcameraK.Center.Z);
		FloatRef currentOverheadcameradistance = FloatRef.Create(game.overheadcameradistance);
		this.LimitThirdPersonCameraToWalls(game, cameraEye, cameraTarget, currentOverheadcameradistance);
		float[] ret = new float[16];
		Mat4.LookAt(ret, Vec3.FromValues(cameraEye.X, cameraEye.Y, cameraEye.Z), Vec3.FromValues(cameraTarget.X, cameraTarget.Y, cameraTarget.Z), this.upVec3);
		game.CameraEyeX = cameraEye.X;
		game.CameraEyeY = cameraEye.Y;
		game.CameraEyeZ = cameraEye.Z;
		return ret;
	}
	internal Vector3Ref OverheadCamera_cameraEye;
	float[] upVec3;
}

public class ModCameraKeys : ClientMod
{

	public override void OnNewFrameFixed(Game game, NewFrameEventArgs args)
	{
		float one = 1;
		float dt = args.GetDt();
		if (game.guistate == GuiState.MapLoading) {
			return;
		}
		bool angleup = false;
		bool angledown = false;
		float overheadcameraanglemovearea = one * 5 / 100;
		float overheadcameraspeed = 3;
		game.controls.wantsjump = game.guistate == GuiState.Normal && game.GuiTyping == TypingState.None && game.keyboardState[game.GetKey(51)];
		game.controls.wantsjumphalf = false;
		game.controls.shiftkeydown = game.guistate == GuiState.Normal && game.GuiTyping == TypingState.None && game.keyboardState[game.GetKey(1)];
		game.controls.movedx = 0;
		game.controls.movedy = 0;
		game.controls.moveup = false;
		game.controls.movedown = false;
		if (game.guistate == GuiState.Normal) {
			if (game.GuiTyping == TypingState.None) {
				if (game.reachedwall_1blockhigh && (game.AutoJumpEnabled || !game.platform.IsMousePointerLocked())) {
					game.controls.wantsjump = true;
				}
				if (game.reachedHalfBlock) {
					game.controls.wantsjumphalf = true;
				}
				if (game.overheadcamera) {
					CameraMove m = new CameraMove();
					if (game.keyboardState[game.GetKey(83)]) {
						game.overheadcameraK.TurnRight(dt * overheadcameraspeed);
					}
					if (game.keyboardState[game.GetKey(86)]) {
						game.overheadcameraK.TurnLeft(dt * overheadcameraspeed);
					}
					if (game.keyboardState[game.GetKey(105)]) {
						angleup = true;
					}
					if (game.keyboardState[game.GetKey(101)]) {
						angledown = true;
					}
					game.overheadcameraK.Center.X = game.player.position.x;
					game.overheadcameraK.Center.Y = game.player.position.y;
					game.overheadcameraK.Center.Z = game.player.position.z;
					m.Distance = game.overheadcameradistance;
					m.AngleUp = angleup;
					m.AngleDown = angledown;
					game.overheadcameraK.Move(m, dt);
					float toDest = game.Dist(game.player.position.x, game.player.position.y, game.player.position.z, game.playerdestination.X + one / 2, game.playerdestination.Y - one / 2, game.playerdestination.Z + one / 2);
					if (toDest >= 1) {
						game.controls.movedy += 1;
						if (game.reachedwall) {
							game.controls.wantsjump = true;
						}
						float qX = game.playerdestination.X - game.player.position.x;
						float qY = game.playerdestination.Y - game.player.position.y;
						float qZ = game.playerdestination.Z - game.player.position.z;
						float angle = game.VectorAngleGet(qX, qY, qZ);
						game.player.position.roty = Game.GetPi() / 2 + angle;
						game.player.position.rotx = Game.GetPi();
					}
				}
				else if (game.enable_move) {
					if (game.keyboardState[game.GetKey(105)]) {
						game.controls.movedy += 1;
					}
					if (game.keyboardState[game.GetKey(101)]) {
						game.controls.movedy += -1;
					}
					if (game.keyboardState[game.GetKey(83)]) {
						game.controls.movedx += -1;
						game.localplayeranimationhint.leanleft = true;
						game.localstance = 1;
					}
					else {
						game.localplayeranimationhint.leanleft = false;
					}
					if (game.keyboardState[game.GetKey(86)]) {
						game.controls.movedx += 1;
						game.localplayeranimationhint.leanright = true;
						game.localstance = 2;
					}
					else {
						game.localplayeranimationhint.leanright = false;
					}
					if (!game.localplayeranimationhint.leanleft && !game.localplayeranimationhint.leanright) {
						game.localstance = 0;
					}
					game.controls.movedx += game.touchMoveDx;
					game.controls.movedy += game.touchMoveDy;
				}
			}
			if (game.controls.GetFreemove() != 0 || game.SwimmingEyes()) {
				if (game.GuiTyping == TypingState.None && game.keyboardState[game.GetKey(51)]) {
					game.controls.moveup = true;
				}
				if (game.GuiTyping == TypingState.None && game.keyboardState[game.GetKey(3)]) {
					game.controls.movedown = true;
				}
			}
		}
	}
}

public class ModClearInactivePlayersDrawInfo : ClientMod
{

	public override void OnNewFrameFixed(Game game, NewFrameEventArgs args)
	{
		float one = 1;
		int now = game.platform.TimeMillisecondsFromStart();
		for (int i = 0; i < 64; i++) {
			if (game.entities[i] == null) {
				continue;
			}
			if (game.entities[i].playerDrawInfo == null) {
				continue;
			}
			if (game.entities[i].networkPosition == null) {
				continue;
			}
			int kKey = i;
			Entity p = game.entities[i];
			if (one * (now - p.networkPosition.LastUpdateMilliseconds) / 1000 > 2) {
				p.playerDrawInfo = null;
				p.networkPosition.PositionLoaded = false;
			}
		}
	}
}

public class ModCompass : ClientMod
{
	public ModCompass()
	{
		this.one = 1;
		this.compassid = -1;
		this.needleid = -1;
		this.compassangle = 0;
		this.compassvertex = 1;
	}

	bool CompassInActiveMaterials(Game game)
	{
		for (int i = 0; i < 10; i++) {
			if (game.MaterialSlots_(i) == game.d_Data.BlockIdCompass()) {
				return true;
			}
		}
		return false;
	}

	public void DrawCompass(Game game)
	{
		if (!this.CompassInActiveMaterials(game))
			return;
		if (this.compassid == -1) {
			this.compassid = game.GetTexture("compass.png");
			this.needleid = game.GetTexture("compassneedle.png");
		}
		float size = 175;
		float posX = game.Width() - 100;
		float posY = 100;
		float playerorientation = -(game.player.position.roty / (2 * Game.GetPi()) * 360);
		this.compassvertex += (playerorientation - this.compassangle) / 50;
		this.compassvertex *= this.one * 9 / 10;
		this.compassangle += this.compassvertex;
		game.Draw2dTexture(this.compassid, posX - size / 2, posY - size / 2, size, size, null, 0, Game.ColorFromArgb(255, 255, 255, 255), false);
		game.GLPushMatrix();
		game.GLTranslate(posX, posY, 0);
		game.GLRotate(this.compassangle, 0, 0, 90);
		game.GLTranslate(-size / 2, -size / 2, 0);
		game.Draw2dTexture(this.needleid, 0, 0, size, size, null, 0, Game.ColorFromArgb(255, 255, 255, 255), false);
		game.GLPopMatrix();
	}

	public override void OnNewFrameDraw2d(Game game, float dt)
	{
		if (game.guistate == GuiState.MapLoading) {
			return;
		}
		this.DrawCompass(game);
	}
	float compassangle;
	int compassid;
	float compassvertex;
	int needleid;
	float one;
}

public class ModDebugChunk : ClientMod
{
	public ModDebugChunk()
	{
		this.draw = false;
		this.lines = new DrawWireframeCube();
	}

	public override bool OnClientCommand(Game game, ClientCommandArgs args)
	{
		if (args.command == "chunk") {
			this.draw = !this.draw;
			return true;
		}
		return false;
	}

	public override void OnNewFrameDraw3d(Game game, float deltaTime)
	{
		if (this.draw) {
			this.lines.DrawWireframeCube_(game, game.platform.FloatToInt(game.player.position.x / 16) * 16 + 8, game.platform.FloatToInt(game.player.position.y / 16) * 16 + 8, game.platform.FloatToInt(game.player.position.z / 16) * 16 + 8, 16, 16, 16);
		}
	}
	bool draw;
	DrawWireframeCube lines;
}

public class ModDialog : ClientMod
{
	public ModDialog()
	{
		this.packetHandler = new ClientPacketHandlerDialog();
	}

	internal void DrawDialogs(Game game)
	{
		for (int i = 0; i < game.dialogsCount; i++) {
			if (game.dialogs[i] == null) {
				continue;
			}
			VisibleDialog d = game.dialogs[i];
			int x = game.Width() / 2 - d.value.Width / 2;
			int y = game.Height() / 2 - d.value.Height_ / 2;
			d.screen.screenx = x;
			d.screen.screeny = y;
			d.screen.DrawWidgets();
		}
	}

	public override void OnKeyDown(Game game, KeyEventArgs args)
	{
		for (int i = 0; i < game.dialogsCount; i++) {
			if (game.dialogs[i] == null) {
				continue;
			}
			game.dialogs[i].screen.OnKeyDown(game, args);
		}
		if (game.guistate == GuiState.Normal) {
			if (args.GetKeyCode() == game.GetKey(50)) {
				for (int i = 0; i < game.dialogsCount; i++) {
					if (game.dialogs[i] == null) {
						continue;
					}
					VisibleDialog d = game.dialogs[i];
					if (d.value.IsModal != 0) {
						game.dialogs[i] = null;
						return;
					}
				}
				game.ShowEscapeMenu();
				args.SetHandled(true);
				return;
			}
		}
		if (game.guistate == GuiState.ModalDialog) {
			if (args.GetKeyCode() == game.GetKey(50)) {
				for (int i = 0; i < game.dialogsCount; i++) {
					if (game.dialogs[i] == null) {
						continue;
					}
					if (game.dialogs[i].value.IsModal != 0) {
						game.dialogs[i] = null;
					}
				}
				game.SendPacketClient(ClientPackets.DialogClick("Esc", new string[0], 0));
				game.GuiStateBackToGame();
				args.SetHandled(true);
			}
			if (args.GetKeyCode() == game.GetKey(52)) {
				game.SendPacketClient(ClientPackets.DialogClick("Tab", new string[0], 0));
				args.SetHandled(true);
			}
			return;
		}
	}

	public override void OnKeyPress(Game game, KeyPressEventArgs args)
	{
		if (game.guistate != GuiState.ModalDialog && game.guistate != GuiState.Normal) {
			return;
		}
		if (game.IsTyping) {
			return;
		}
		for (int i = 0; i < game.dialogsCount; i++) {
			if (game.dialogs[i] == null) {
				continue;
			}
			game.dialogs[i].screen.OnKeyPress(game, args);
		}
		for (int k = 0; k < game.dialogsCount; k++) {
			if (game.dialogs[k] == null) {
				continue;
			}
			VisibleDialog d = game.dialogs[k];
			for (int i = 0; i < d.value.WidgetsCount; i++) {
				Packet_Widget w = d.value.Widgets[i];
				if (w == null) {
					continue;
				}
				string valid = "abcdefghijklmnopqrstuvwxyz1234567890\t ";
				if (game.platform.StringContains(valid, game.CharToString(w.ClickKey))) {
					if (args.GetKeyChar() == w.ClickKey) {
						game.SendPacketClient(ClientPackets.DialogClick(w.Id, new string[0], 0));
						return;
					}
				}
			}
		}
	}

	public override void OnKeyUp(Game game, KeyEventArgs args)
	{
		for (int i = 0; i < game.dialogsCount; i++) {
			if (game.dialogs[i] == null) {
				continue;
			}
			game.dialogs[i].screen.OnKeyUp(game, args);
		}
	}

	public override void OnMouseDown(Game game, MouseEventArgs args)
	{
		for (int i = 0; i < game.dialogsCount; i++) {
			if (game.dialogs[i] == null) {
				continue;
			}
			game.dialogs[i].screen.OnMouseDown(game, args);
		}
	}

	public override void OnMouseUp(Game game, MouseEventArgs args)
	{
		for (int i = 0; i < game.dialogsCount; i++) {
			if (game.dialogs[i] == null) {
				continue;
			}
			game.dialogs[i].screen.OnMouseUp(game, args);
		}
	}

	public override void OnNewFrameDraw2d(Game game, float deltaTime)
	{
		game.packetHandlers[52] = this.packetHandler;
		this.DrawDialogs(game);
	}
	ClientPacketHandler packetHandler;
}

public class ModDraw2dMisc : ClientMod
{

	internal void DrawAim(Game game)
	{
		if (game.cameratype == CameraType.Overhead) {
			return;
		}
		int aimwidth = 32;
		int aimheight = 32;
		game.platform.BindTexture2d(0);
		if (game.CurrentAimRadius() > 1) {
			float fov_ = game.currentfov();
			game.Circle3i(game.Width() / 2, game.Height() / 2, game.CurrentAimRadius() * game.fov / fov_);
		}
		game.Draw2dBitmapFile("target.png", game.Width() / 2 - aimwidth / 2, game.Height() / 2 - aimheight / 2, aimwidth, aimheight);
	}

	internal void DrawAmmo(Game game)
	{
		Packet_Item item = game.d_Inventory.RightHand[game.ActiveMaterial];
		if (item != null && item.ItemClass == 0) {
			if (game.blocktypes[item.BlockId].IsPistol) {
				int loaded = game.LoadedAmmo[item.BlockId];
				int total = game.TotalAmmo[item.BlockId];
				string s = game.platform.StringFormat2("{0}/{1}", game.platform.IntToString(loaded), game.platform.IntToString(total - loaded));
				FontCi font = new FontCi();
				font.family = "Arial";
				font.size = 18;
				game.Draw2dText(s, font, game.Width() - game.TextSizeWidth(s, 18) - 50, game.Height() - game.TextSizeHeight(s, 18) - 50, loaded == 0 ? IntRef.Create(Game.ColorFromArgb(255, 255, 0, 0)) : IntRef.Create(Game.ColorFromArgb(255, 255, 255, 255)), false);
				if (loaded == 0) {
					font.size = 14;
					string pressR = "Press R to reload";
					game.Draw2dText(pressR, font, game.Width() - game.TextSizeWidth(pressR, 14) - 50, game.Height() - game.TextSizeHeight(s, 14) - 80, IntRef.Create(Game.ColorFromArgb(255, 255, 0, 0)), false);
				}
			}
		}
	}

	public void DrawBlockInfo(Game game)
	{
		if (!game.drawblockinfo) {
			return;
		}
		int x = game.SelectedBlockPositionX;
		int y = game.SelectedBlockPositionZ;
		int z = game.SelectedBlockPositionY;
		if (!game.map.IsValidPos(x, y, z)) {
			return;
		}
		int blocktype = game.map.GetBlock(x, y, z);
		if (!game.IsValid(blocktype)) {
			return;
		}
		game.currentAttackedBlock = Vector3IntRef.Create(x, y, z);
		this.DrawEnemyHealthBlock(game);
	}

	void DrawDisconnected(Game game)
	{
		float one = 1;
		float lagSeconds = one * (game.platform.TimeMillisecondsFromStart() - game.LastReceivedMilliseconds) / 1000;
		if (lagSeconds >= 10 && lagSeconds < 86400 && game.invalidVersionDrawMessage == null && !(game.issingleplayer && !game.platform.SinglePlayerServerLoaded())) {
			game.Draw2dBitmapFile("disconnected.png", game.Width() - 100, 50, 50, 50);
			FontCi font = new FontCi();
			font.family = "Arial";
			font.size = 12;
			game.Draw2dText(game.platform.IntToString(game.platform.FloatToInt(lagSeconds)), font, game.Width() - 100, 110, null, false);
			game.Draw2dText("Press F6 to reconnect", font, game.Width() / 2 - 100, 50, null, false);
		}
	}

	internal void DrawEnemyHealthBlock(Game game)
	{
		if (game.currentAttackedBlock != null) {
			int x = game.currentAttackedBlock.X;
			int y = game.currentAttackedBlock.Y;
			int z = game.currentAttackedBlock.Z;
			int blocktype = game.map.GetBlock(x, y, z);
			float health = game.GetCurrentBlockHealth(x, y, z);
			float progress = health / game.d_Data.Strength()[blocktype];
			if (game.IsUsableBlock(blocktype)) {
				this.DrawEnemyHealthUseInfo(game, game.language.Get(StringTools.StringAppend(game.platform, "Block_", game.blocktypes[blocktype].Name)), progress, true);
			}
			this.DrawEnemyHealthCommon(game, game.language.Get(StringTools.StringAppend(game.platform, "Block_", game.blocktypes[blocktype].Name)), progress);
		}
		if (game.currentlyAttackedEntity != -1) {
			Entity e = game.entities[game.currentlyAttackedEntity];
			if (e == null) {
				return;
			}
			float health;
			if (e.playerStats != null) {
				health = game.one * e.playerStats.CurrentHealth / e.playerStats.MaxHealth;
			}
			else {
				health = 1;
			}
			string name = "Unknown";
			if (e.drawName != null) {
				name = e.drawName.Name;
			}
			if (e.usable) {
				this.DrawEnemyHealthUseInfo(game, game.language.Get(name), health, true);
			}
			this.DrawEnemyHealthCommon(game, game.language.Get(name), health);
		}
	}

	internal void DrawEnemyHealthCommon(Game game, string name, float progress)
	{
		this.DrawEnemyHealthUseInfo(game, name, 1, false);
	}

	internal void DrawEnemyHealthUseInfo(Game game, string name, float progress, bool useInfo)
	{
		int y = useInfo ? 55 : 35;
		game.Draw2dTexture(game.WhiteTexture(), game.xcenter(300), 40, 300, y, null, 0, Game.ColorFromArgb(255, 0, 0, 0), false);
		game.Draw2dTexture(game.WhiteTexture(), game.xcenter(300), 40, 300 * progress, y, null, 0, Game.ColorFromArgb(255, 255, 0, 0), false);
		FontCi font = new FontCi();
		font.family = "Arial";
		font.size = 14;
		IntRef w = new IntRef();
		IntRef h = new IntRef();
		game.platform.TextSize(name, 14, w, h);
		game.Draw2dText(name, font, game.xcenter(w.value), 40, null, false);
		if (useInfo) {
			name = game.platform.StringFormat(game.language.PressToUse(), "E");
			game.platform.TextSize(name, 10, w, h);
			FontCi font2 = new FontCi();
			font2.family = "Arial";
			font2.size = 10;
			game.Draw2dText(name, font2, game.xcenter(w.value), 70, null, false);
		}
	}

	void DrawLocalPosition(Game game)
	{
		float one = 1;
		if (game.ENABLE_DRAWPOSITION) {
			float heading = one * game.HeadingByte(game.player.position.rotx, game.player.position.roty, game.player.position.rotz);
			float pitch = one * game.PitchByte(game.player.position.rotx, game.player.position.roty, game.player.position.rotz);
			string postext = game.platform.StringFormat("X: {0}", game.platform.IntToString(game.MathFloor(game.player.position.x)));
			postext = StringTools.StringAppend(game.platform, postext, ",\tY: ");
			postext = StringTools.StringAppend(game.platform, postext, game.platform.IntToString(game.MathFloor(game.player.position.z)));
			postext = StringTools.StringAppend(game.platform, postext, ",\tZ: ");
			postext = StringTools.StringAppend(game.platform, postext, game.platform.IntToString(game.MathFloor(game.player.position.y)));
			postext = StringTools.StringAppend(game.platform, postext, "\nHeading: ");
			postext = StringTools.StringAppend(game.platform, postext, game.platform.IntToString(game.MathFloor(heading)));
			postext = StringTools.StringAppend(game.platform, postext, "\nPitch: ");
			postext = StringTools.StringAppend(game.platform, postext, game.platform.IntToString(game.MathFloor(pitch)));
			FontCi font = new FontCi();
			font.family = "Arial";
			font.size = 11;
			game.Draw2dText(postext, font, 100, 460, null, false);
		}
	}

	internal void DrawMouseCursor(Game game)
	{
		if (!game.GetFreeMouse()) {
			return;
		}
		if (!game.platform.MouseCursorIsVisible()) {
			game.Draw2dBitmapFile("mousecursor.png", game.mouseCurrentX, game.mouseCurrentY, 32, 32);
		}
	}

	public override void OnNewFrameDraw2d(Game game, float deltaTime)
	{
		if (game.guistate == GuiState.Normal) {
			this.DrawAim(game);
		}
		if (game.guistate != GuiState.MapLoading) {
			this.DrawEnemyHealthBlock(game);
			this.DrawAmmo(game);
			this.DrawLocalPosition(game);
			this.DrawBlockInfo(game);
		}
		this.DrawMouseCursor(game);
		this.DrawDisconnected(game);
	}
}

public class ModDrawArea : ClientMod
{

	public override void OnHitEntity(Game game, OnUseEntityArgs e)
	{
		Entity entity = game.entities[e.entityId];
		if (entity == null) {
			return;
		}
		if (entity.drawArea == null) {
			return;
		}
		entity.drawArea.visible = !entity.drawArea.visible;
	}

	public override void OnNewFrameDraw3d(Game game, float deltaTime)
	{
		if (game.ENABLE_DRAW2D) {
			for (int i = 0; i < game.entitiesCount; i++) {
				Entity e = game.entities[i];
				if (e == null) {
					continue;
				}
				if (e.drawArea == null) {
					continue;
				}
				if (!e.drawArea.visible) {
					continue;
				}
				int x = e.drawArea.x + e.drawArea.sizex / 2;
				int y = e.drawArea.y + e.drawArea.sizey / 2;
				int z = e.drawArea.z + e.drawArea.sizez / 2;
				float scalex = e.drawArea.sizex;
				float scaley = e.drawArea.sizey;
				float scalez = e.drawArea.sizez;
				this.lines.DrawWireframeCube_(game, x, y, z, scalex, scaley, scalez);
			}
		}
	}

	public override void OnNewFrameFixed(Game game, NewFrameEventArgs args)
	{
		this.lines = new DrawWireframeCube();
	}
	DrawWireframeCube lines;
}

public class ModDrawHand2d : ClientMod
{

	public static string HandImage2d(Game game)
	{
		Packet_Item item = game.d_Inventory.RightHand[game.ActiveMaterial];
		string img = null;
		if (item != null) {
			img = game.blocktypes[item.BlockId].Handimage;
			if (game.IronSights) {
				img = game.blocktypes[item.BlockId].IronSightsImage;
			}
		}
		return img;
	}

	public override void OnNewFrameDraw3d(Game game, float deltaTime)
	{
		if (ModDrawHand2d.ShouldDrawHand(game)) {
			string img = ModDrawHand2d.HandImage2d(game);
			if (img != null) {
				game.OrthoMode(game.Width(), game.Height());
				if (this.lasthandimage != img) {
					this.lasthandimage = img;
					byte[] file = game.GetFile(img);
					BitmapCi bmp = game.platform.BitmapCreateFromPng(file, game.platform.ByteArrayLength(file));
					if (bmp != null) {
						game.handTexture = game.platform.LoadTextureFromBitmap(bmp);
						game.platform.BitmapDelete(bmp);
					}
				}
				game.Draw2dTexture(game.handTexture, game.Width() / 2, game.Height() - 512, 512, 512, null, 0, Game.ColorFromArgb(255, 255, 255, 255), false);
				game.PerspectiveMode();
			}
		}
	}

	public static bool ShouldDrawHand(Game game)
	{
		return !game.ENABLE_TPP_VIEW && game.ENABLE_DRAW2D;
	}
	internal string lasthandimage;
}

public class ModDrawHand3d : ClientMod
{
	public ModDrawHand3d()
	{
		this.one = 1;
		this.attackt = 0;
		this.buildt = 0;
		this.range = this.one * 7 / 100;
		this.speed = 5;
		this.animperiod = Game.GetPi() / (this.speed / 2);
		this.zzzposz = 0;
		this.t_ = 0;
		this.zzzx = -27;
		this.zzzy = -this.one * 137 / 10;
		this.zzzposx = -this.one * 2 / 10;
		this.zzzposy = -this.one * 4 / 10;
		this.attack = -1;
		this.build = false;
		this.slowdownTimerSpecial = 32000;
		this.d_BlockRendererTorch = new BlockRendererTorch();
	}

	public void AddVertex(ModelData model, float x, float y, float z, float u, float v, int color)
	{
		model.xyz[model.GetXyzCount() + 0] = x;
		model.xyz[model.GetXyzCount() + 1] = y;
		model.xyz[model.GetXyzCount() + 2] = z;
		model.uv[model.GetUvCount() + 0] = u;
		model.uv[model.GetUvCount() + 1] = v;
		model.rgba[model.GetRgbaCount() + 0] = Game.IntToByte(Game.ColorR(color));
		model.rgba[model.GetRgbaCount() + 1] = Game.IntToByte(Game.ColorG(color));
		model.rgba[model.GetRgbaCount() + 2] = Game.IntToByte(Game.ColorB(color));
		model.rgba[model.GetRgbaCount() + 3] = Game.IntToByte(Game.ColorA(color));
		model.verticesCount++;
	}

	void DrawCube(ModelData m, int x, int y, int z, int c)
	{
		{
			int sidetexture = this.GetWeaponTextureId(0);
			RectFRef texrec = TextureAtlas.TextureCoords2d(sidetexture, this.texturesPacked());
			int lastelement = m.GetVerticesCount();
			this.AddVertex(m, x + 0, z + 1, y + 0, texrec.Left(), texrec.Top(), c);
			this.AddVertex(m, x + 0, z + 1, y + 1, texrec.Left(), texrec.Bottom(), c);
			this.AddVertex(m, x + 1, z + 1, y + 0, texrec.Right(), texrec.Top(), c);
			this.AddVertex(m, x + 1, z + 1, y + 1, texrec.Right(), texrec.Bottom(), c);
			m.indices[m.indicesCount++] = lastelement + 0;
			m.indices[m.indicesCount++] = lastelement + 1;
			m.indices[m.indicesCount++] = lastelement + 2;
			m.indices[m.indicesCount++] = lastelement + 1;
			m.indices[m.indicesCount++] = lastelement + 3;
			m.indices[m.indicesCount++] = lastelement + 2;
		}
		{
			int sidetexture = this.GetWeaponTextureId(1);
			RectFRef texrec = TextureAtlas.TextureCoords2d(sidetexture, this.texturesPacked());
			int lastelement = m.GetVerticesCount();
			this.AddVertex(m, x + 0, z, y + 0, texrec.Left(), texrec.Top(), c);
			this.AddVertex(m, x + 0, z, y + 1, texrec.Left(), texrec.Bottom(), c);
			this.AddVertex(m, x + 1, z, y + 0, texrec.Right(), texrec.Top(), c);
			this.AddVertex(m, x + 1, z, y + 1, texrec.Right(), texrec.Bottom(), c);
			m.indices[m.indicesCount++] = lastelement + 1;
			m.indices[m.indicesCount++] = lastelement + 0;
			m.indices[m.indicesCount++] = lastelement + 2;
			m.indices[m.indicesCount++] = lastelement + 3;
			m.indices[m.indicesCount++] = lastelement + 1;
			m.indices[m.indicesCount++] = lastelement + 2;
		}
		{
			int sidetexture = this.GetWeaponTextureId(2);
			RectFRef texrec = TextureAtlas.TextureCoords2d(sidetexture, this.texturesPacked());
			int lastelement = m.GetVerticesCount();
			this.AddVertex(m, x + 0, z + 0, y + 0, texrec.Left(), texrec.Bottom(), c);
			this.AddVertex(m, x + 0, z + 0, y + 1, texrec.Right(), texrec.Bottom(), c);
			this.AddVertex(m, x + 0, z + 1, y + 0, texrec.Left(), texrec.Top(), c);
			this.AddVertex(m, x + 0, z + 1, y + 1, texrec.Right(), texrec.Top(), c);
			m.indices[m.indicesCount++] = lastelement + 0;
			m.indices[m.indicesCount++] = lastelement + 1;
			m.indices[m.indicesCount++] = lastelement + 2;
			m.indices[m.indicesCount++] = lastelement + 1;
			m.indices[m.indicesCount++] = lastelement + 3;
			m.indices[m.indicesCount++] = lastelement + 2;
		}
		{
			int sidetexture = this.GetWeaponTextureId(3);
			RectFRef texrec = TextureAtlas.TextureCoords2d(sidetexture, this.texturesPacked());
			int lastelement = m.GetVerticesCount();
			this.AddVertex(m, x + 1, z + 0, y + 0, texrec.Left(), texrec.Bottom(), c);
			this.AddVertex(m, x + 1, z + 0, y + 1, texrec.Right(), texrec.Bottom(), c);
			this.AddVertex(m, x + 1, z + 1, y + 0, texrec.Left(), texrec.Top(), c);
			this.AddVertex(m, x + 1, z + 1, y + 1, texrec.Right(), texrec.Top(), c);
			m.indices[m.indicesCount++] = lastelement + 1;
			m.indices[m.indicesCount++] = lastelement + 0;
			m.indices[m.indicesCount++] = lastelement + 2;
			m.indices[m.indicesCount++] = lastelement + 3;
			m.indices[m.indicesCount++] = lastelement + 1;
			m.indices[m.indicesCount++] = lastelement + 2;
		}
		{
			int sidetexture = this.GetWeaponTextureId(4);
			RectFRef texrec = TextureAtlas.TextureCoords2d(sidetexture, this.texturesPacked());
			int lastelement = m.GetVerticesCount();
			this.AddVertex(m, x + 0, z + 0, y + 0, texrec.Left(), texrec.Bottom(), c);
			this.AddVertex(m, x + 0, z + 1, y + 0, texrec.Left(), texrec.Top(), c);
			this.AddVertex(m, x + 1, z + 0, y + 0, texrec.Right(), texrec.Bottom(), c);
			this.AddVertex(m, x + 1, z + 1, y + 0, texrec.Right(), texrec.Top(), c);
			m.indices[m.indicesCount++] = lastelement + 0;
			m.indices[m.indicesCount++] = lastelement + 1;
			m.indices[m.indicesCount++] = lastelement + 2;
			m.indices[m.indicesCount++] = lastelement + 1;
			m.indices[m.indicesCount++] = lastelement + 3;
			m.indices[m.indicesCount++] = lastelement + 2;
		}
		{
			int sidetexture = this.GetWeaponTextureId(5);
			RectFRef texrec = TextureAtlas.TextureCoords2d(sidetexture, this.texturesPacked());
			int lastelement = m.GetVerticesCount();
			this.AddVertex(m, x + 0, z + 0, y + 1, texrec.Left(), texrec.Bottom(), c);
			this.AddVertex(m, x + 0, z + 1, y + 1, texrec.Left(), texrec.Top(), c);
			this.AddVertex(m, x + 1, z + 0, y + 1, texrec.Right(), texrec.Bottom(), c);
			this.AddVertex(m, x + 1, z + 1, y + 1, texrec.Right(), texrec.Top(), c);
			m.indices[m.indicesCount++] = lastelement + 1;
			m.indices[m.indicesCount++] = lastelement + 0;
			m.indices[m.indicesCount++] = lastelement + 2;
			m.indices[m.indicesCount++] = lastelement + 3;
			m.indices[m.indicesCount++] = lastelement + 1;
			m.indices[m.indicesCount++] = lastelement + 2;
		}
	}

	public void DrawWeapon(float dt)
	{
		int light;
		if (this.IsTorch()) {
			light = 255;
		}
		else {
			light = this.game.platform.FloatToInt(this.Light() * 256);
			if (light > 255) {
				light = 255;
			}
			if (light < 0) {
				light = 0;
			}
		}
		this.game.platform.BindTexture2d(this.terrainTexture());
		Packet_Item item = this.game.d_Inventory.RightHand[this.game.ActiveMaterial];
		int curmaterial;
		if (item == null) {
			curmaterial = 0;
		}
		else {
			curmaterial = item.BlockId == 151 ? 128 : item.BlockId;
		}
		float curlight = this.Light();
		if (curmaterial != this.oldMaterial || curlight != this.oldLight || this.modelData == null || this.game.handRedraw) {
			this.game.handRedraw = false;
			this.modelData = new ModelData();
			this.modelData.indices = new int[128];
			this.modelData.xyz = new float[128];
			this.modelData.uv = new float[128];
			this.modelData.rgba = new byte[128];
			int x = 0;
			int y = 0;
			int z = 0;
			if (this.IsEmptyHand() || this.IsCompass()) {
				this.d_BlockRendererTorch.TopTexture = this.GetWeaponTextureId(0);
				this.d_BlockRendererTorch.SideTexture = this.GetWeaponTextureId(2);
				this.d_BlockRendererTorch.AddTorch(this.game.d_Data, this.game, this.modelData, x, y, z, TorchType.Normal);
			}
			else if (this.IsTorch()) {
				this.d_BlockRendererTorch.TopTexture = this.GetWeaponTextureId(0);
				this.d_BlockRendererTorch.SideTexture = this.GetWeaponTextureId(2);
				this.d_BlockRendererTorch.AddTorch(this.game.d_Data, this.game, this.modelData, x, y, z, TorchType.Normal);
			}
			else {
				this.DrawCube(this.modelData, x, y, z, Game.ColorFromArgb(255, light, light, light));
			}
		}
		this.oldMaterial = curmaterial;
		this.oldLight = curlight;
		this.game.platform.GlClearDepthBuffer();
		this.game.GLMatrixModeModelView();
		this.game.GLPushMatrix();
		this.game.GLLoadIdentity();
		this.game.GLTranslate(this.one * 3 / 10 + this.zzzposz - this.attackt * 5, -(this.one * 15 / 10) + this.zzzposx - this.buildt * 10, -(this.one * 15 / 10) + this.zzzposy);
		this.game.GLRotate(30 + this.zzzx - this.attackt * 300, 1, 0, 0);
		this.game.GLRotate(60 + this.zzzy, 0, 1, 0);
		this.game.GLScale(this.one * 8 / 10, this.one * 8 / 10, this.one * 8 / 10);
		bool move = !(this.oldplayerposX == this.game.player.position.x && this.oldplayerposY == this.game.player.position.y && this.oldplayerposZ == this.game.player.position.z);
		this.oldplayerposX = this.game.player.position.x;
		this.oldplayerposY = this.game.player.position.y;
		this.oldplayerposZ = this.game.player.position.z;
		if (move) {
			this.t_ += dt;
			this.slowdownTimer = this.slowdownTimerSpecial;
		}
		else {
			if (this.slowdownTimer == this.slowdownTimerSpecial) {
				this.slowdownTimer = this.animperiod / 2 - this.t_ % (this.animperiod / 2);
			}
			this.slowdownTimer -= dt;
			if (this.slowdownTimer < 0) {
				this.t_ = 0;
			}
			else {
				this.t_ += dt;
			}
		}
		this.zzzposx = this.rot(this.t_);
		this.zzzposz = this.rot2(this.t_);
		if (this.attack != -1) {
			this.attack += dt * 7;
			if (this.attack > Game.GetPi() / 2) {
				this.attack = -1;
				if (this.build) {
					this.buildt = 0;
				}
				else {
					this.attackt = 0;
				}
			}
			else {
				if (this.build) {
					this.buildt = this.rot(this.attack / 5);
					this.attackt = 0;
				}
				else {
					this.attackt = this.rot(this.attack / 5);
					this.buildt = 0;
				}
			}
		}
		this.game.platform.GlEnableTexture2d();
		this.game.platform.BindTexture2d(this.terrainTexture());
		this.game.DrawModelData(this.modelData);
		this.game.GLPopMatrix();
	}

	public int GetWeaponTextureId(int side)
	{
		Packet_Item item = this.game.d_Inventory.RightHand[this.game.ActiveMaterial];
		if (item == null || this.IsCompass() || item != null && item.BlockId == 0) {
			if (side == 0) {
				return this.game.TextureId[this.game.d_Data.BlockIdEmptyHand()][0];
			}
			return this.game.TextureId[this.game.d_Data.BlockIdEmptyHand()][2];
		}
		if (item.ItemClass == 0) {
			return this.game.TextureId[item.BlockId][side];
		}
		else {
			return 0;
		}
	}

	public bool IsCompass()
	{
		Packet_Item item = this.game.d_Inventory.RightHand[this.game.ActiveMaterial];
		return item != null && item.ItemClass == 0 && item.BlockId == this.game.d_Data.BlockIdCompass();
	}

	public bool IsEmptyHand()
	{
		Packet_Item item = this.game.d_Inventory.RightHand[this.game.ActiveMaterial];
		return item == null || item.BlockId == 0;
	}

	public bool IsTorch()
	{
		Packet_Item item = this.game.d_Inventory.RightHand[this.game.ActiveMaterial];
		return item != null && item.ItemClass == 0 && this.game.blocktypes[item.BlockId].DrawType == 4;
	}

	public float Light()
	{
		float posx = this.game.player.position.x;
		float posy = this.game.player.position.y;
		float posz = this.game.player.position.z;
		int light = this.game.GetLight(this.game.platform.FloatToInt(posx), this.game.platform.FloatToInt(posz), this.game.platform.FloatToInt(posy));
		return this.one * light / 15;
	}

	public override void OnNewFrameDraw3d(Game game_, float deltaTime)
	{
		if (ModDrawHand2d.ShouldDrawHand(game_)) {
			string img = ModDrawHand2d.HandImage2d(game_);
			if (img == null) {
				this.game = game_;
				if (this.game.handSetAttackBuild) {
					this.SetAttack(true, true);
					this.game.handSetAttackBuild = false;
				}
				if (this.game.handSetAttackDestroy) {
					this.SetAttack(true, false);
					this.game.handSetAttackDestroy = false;
				}
				this.DrawWeapon(deltaTime);
			}
		}
	}

	public void SetAttack(bool isattack, bool build)
	{
		this.build = build;
		if (isattack) {
			if (this.attack == -1) {
				this.attack = 0;
			}
		}
		else {
			this.attack = -1;
		}
	}
	float animperiod;
	float attack;
	float attackt;
	bool build;
	float buildt;
	internal BlockRendererTorch d_BlockRendererTorch;
	internal Game game;
	ModelData modelData;
	float oldLight;
	int oldMaterial;
	float oldplayerposX;
	float oldplayerposY;
	float oldplayerposZ;
	float one;
	float range;

	float rot(float t)
	{
		return this.game.platform.MathSin(t * 2 * this.speed) * this.range;
	}

	float rot2(float t)
	{
		return this.game.platform.MathSin((t + Game.GetPi()) * this.speed) * this.range;
	}
	float slowdownTimer;
	float slowdownTimerSpecial;
	float speed;
	float t_;

	public int terrainTexture()
	{
		return this.game.terrainTexture;
	}

	public int texturesPacked()
	{
		return this.game.texturesPacked();
	}
	float zzzposx;
	float zzzposy;
	float zzzposz;
	float zzzx;
	float zzzy;
}

public class ModDrawLinesAroundSelectedBlock : ClientMod
{
	public ModDrawLinesAroundSelectedBlock()
	{
		this.one = 1;
		this.lines = new DrawWireframeCube();
	}

	public override void OnNewFrameDraw3d(Game game, float deltaTime)
	{
		if (game.ENABLE_DRAW2D) {
			float size = this.one * 102 / 100;
			if (game.SelectedEntityId != -1) {
				Entity e = game.entities[game.SelectedEntityId];
				if (e != null) {
					this.lines.DrawWireframeCube_(game, e.position.x, e.position.y + e.drawModel.ModelHeight / 2, e.position.z, size, size * e.drawModel.ModelHeight, size);
				}
			}
			else {
				if (game.SelectedBlockPositionX != -1) {
					int x = game.SelectedBlockPositionX;
					int y = game.SelectedBlockPositionY;
					int z = game.SelectedBlockPositionZ;
					float pickcubeheight = game.getblockheight(game.platform.FloatToInt(x), game.platform.FloatToInt(z), game.platform.FloatToInt(y));
					float posx = x + this.one / 2;
					float posy = y + pickcubeheight * this.one / 2;
					float posz = z + this.one / 2;
					float scalex = size;
					float scaley = size * pickcubeheight;
					float scalez = size;
					this.lines.DrawWireframeCube_(game, posx, posy, posz, scalex, scaley, scalez);
				}
			}
		}
	}
	DrawWireframeCube lines;
	float one;
}

public class ModDrawMain : ClientMod
{

	public override void OnReadOnlyMainThread(Game game, float dt)
	{
		game.MainThreadOnRenderFrame(dt);
	}
}

public class ModDrawMinecarts : ClientMod
{
	public ModDrawMinecarts()
	{
		this.minecarttexture = -1;
	}

	public void Draw(Game game, float positionX, float positionY, float positionZ, VehicleDirection12 dir, VehicleDirection12 lastdir, float progress)
	{
		float one = 1;
		if (this.minecarttexture == -1) {
			this.minecarttexture = game.GetTexture("minecart.png");
		}
		game.GLPushMatrix();
		float pX = positionX;
		float pY = positionY;
		float pZ = positionZ;
		pY += -(one * 7 / 10);
		game.GLTranslate(pX, pY, pZ);
		float currot = this.vehiclerotation(dir);
		float lastrot = this.vehiclerotation(lastdir);
		float rot = AngleInterpolation.InterpolateAngle360(game.platform, lastrot, currot, progress);
		game.GLRotate(-rot - 90, 0, 1, 0);
		RectangleFloat[] cc = CuboidRenderer.CuboidNet(8, 8, 8, 0, 0);
		CuboidRenderer.CuboidNetNormalize(cc, 32, 16);
		game.platform.BindTexture2d(this.minecarttexture);
		CuboidRenderer.DrawCuboid(game, -(one * 5 / 10), -(one * 3 / 10), -(one * 5 / 10), 1, 1, 1, cc, 1);
		game.GLPopMatrix();
	}

	public override void OnNewFrameDraw3d(Game game, float deltaTime)
	{
		for (int i = 0; i < game.entitiesCount; i++) {
			if (game.entities[i] == null) {
				continue;
			}
			if (game.entities[i].minecart == null) {
				continue;
			}
			Minecart m = game.entities[i].minecart;
			if (!m.enabled) {
				continue;
			}
			this.Draw(game, m.positionX, m.positionY, m.positionZ, m.direction, m.lastdirection, m.progress);
		}
	}
	int minecarttexture;

	float vehiclerotation(VehicleDirection12 dir)
	{
		switch (dir) {
		case VehicleDirection12.VerticalUp:
			return 0;
		case VehicleDirection12.DownRightRight:
		case VehicleDirection12.UpLeftUp:
			return 45;
		case VehicleDirection12.HorizontalRight:
			return 90;
		case VehicleDirection12.UpRightRight:
		case VehicleDirection12.DownLeftDown:
			return 135;
		case VehicleDirection12.VerticalDown:
			return 180;
		case VehicleDirection12.UpLeftLeft:
		case VehicleDirection12.DownRightDown:
			return 225;
		case VehicleDirection12.HorizontalLeft:
			return 270;
		case VehicleDirection12.UpRightUp:
		case VehicleDirection12.DownLeftLeft:
			return 315;
		default:
			return 0;
		}
	}
}

public class ModDrawParticleEffectBlockBreak : ClientMod
{

	public override void OnNewFrameDraw3d(Game game, float deltaTime)
	{
	}

	public void StartParticleEffect(float x, float y, float z)
	{
	}
}

public class ModDrawPlayerNames : ClientMod
{

	public override void OnNewFrameDraw3d(Game game, float deltaTime)
	{
		for (int i = 0; i < game.entitiesCount; i++) {
			Entity e = game.entities[i];
			if (e == null) {
				continue;
			}
			if (e.drawName == null) {
				continue;
			}
			if (i == game.LocalPlayerId) {
				continue;
			}
			if (e.networkPosition != null && !e.networkPosition.PositionLoaded) {
				continue;
			}
			int kKey = i;
			DrawName p = game.entities[i].drawName;
			if (p.OnlyWhenSelected) {
				continue;
			}
			float posX = p.TextX + e.position.x;
			float posY = p.TextY + e.position.y + e.drawModel.ModelHeight + game.one * 7 / 10;
			float posZ = p.TextZ + e.position.z;
			if (game.Dist(game.player.position.x, game.player.position.y, game.player.position.z, posX, posY, posZ) < 20 || game.keyboardState[5] || game.keyboardState[6]) {
				string name = p.Name;
				{
					float shadow = game.one * game.GetLight(game.platform.FloatToInt(posX), game.platform.FloatToInt(posZ), game.platform.FloatToInt(posY)) / 15;
					game.GLPushMatrix();
					game.GLTranslate(posX, posY, posZ);
					ModDrawSprites.Billboard(game);
					float scale = game.one * 2 / 100;
					game.GLScale(scale, scale, scale);
					if (p.DrawHealth) {
						game.Draw2dTexture(game.WhiteTexture(), -26, -11, 52, 12, null, 0, Game.ColorFromArgb(255, 0, 0, 0), false);
						game.Draw2dTexture(game.WhiteTexture(), -25, -10, 50 * game.one * p.Health, 10, null, 0, Game.ColorFromArgb(255, 255, 0, 0), false);
					}
					FontCi font = new FontCi();
					font.family = "Arial";
					font.size = 14;
					game.Draw2dText(name, font, -game.TextSizeWidth(name, 14) / 2, 0, IntRef.Create(Game.ColorFromArgb(255, 255, 255, 255)), true);
					game.GLPopMatrix();
				}
			}
		}
	}
}

public class ModDrawPlayers : ClientMod
{
	public ModDrawPlayers()
	{
		this.one = 1;
	}

	internal void DrawPlayers(Game game, float dt)
	{
		game.totaltimeMilliseconds = game.platform.TimeMillisecondsFromStart();
		for (int i = 0; i < game.entitiesCount; i++) {
			if (game.entities[i] == null) {
				continue;
			}
			if (game.entities[i].drawModel == null) {
				continue;
			}
			Entity p_ = game.entities[i];
			if (i == game.LocalPlayerId && !game.ENABLE_TPP_VIEW) {
				continue;
			}
			if (p_.networkPosition != null && !p_.networkPosition.PositionLoaded) {
				continue;
			}
			if (!game.d_FrustumCulling.SphereInFrustum(p_.position.x, p_.position.y, p_.position.z, 3)) {
				continue;
			}
			if (p_.drawModel.CurrentTexture == -1) {
				continue;
			}
			int cx = game.platform.FloatToInt(p_.position.x) / 16;
			int cy = game.platform.FloatToInt(p_.position.z) / 16;
			int cz = game.platform.FloatToInt(p_.position.y) / 16;
			if (game.map.IsValidChunkPos(cx, cy, cz)) {
				if (!game.map.IsChunkRendered(cx, cy, cz)) {
					continue;
				}
			}
			float shadow = this.one * game.GetLight(game.platform.FloatToInt(p_.position.x), game.platform.FloatToInt(p_.position.z), game.platform.FloatToInt(p_.position.y)) / 15;
			if (p_.playerDrawInfo == null) {
				p_.playerDrawInfo = new PlayerDrawInfo();
			}
			p_.playerDrawInfo.anim.light = shadow;
			float FeetPosX = p_.position.x;
			float FeetPosY = p_.position.y;
			float FeetPosZ = p_.position.z;
			AnimationHint animHint = game.entities[i].playerDrawInfo.AnimationHint_;
			float playerspeed_;
			if (i == game.LocalPlayerId) {
				if (game.player.playerDrawInfo == null) {
					game.player.playerDrawInfo = new PlayerDrawInfo();
				}
				Vector3Ref playerspeed = Vector3Ref.Create(game.playervelocity.X / 60, game.playervelocity.Y / 60, game.playervelocity.Z / 60);
				float playerspeedf = playerspeed.Length() * this.one * 15 / 10;
				game.player.playerDrawInfo.moves = playerspeedf != 0;
				playerspeed_ = playerspeedf;
			}
			else {
				playerspeed_ = game.Length(p_.playerDrawInfo.velocityX, p_.playerDrawInfo.velocityY, p_.playerDrawInfo.velocityZ) / dt * this.one * 4 / 100;
			}
			{
				if (p_.drawModel.renderer == null) {
					p_.drawModel.renderer = new AnimatedModelRenderer();
					byte[] data = game.GetFile(p_.drawModel.Model_);
					int dataLength = game.GetFileLength(p_.drawModel.Model_);
					if (data != null) {
						string dataString = game.platform.StringFromUtf8ByteArray(data, dataLength);
						AnimatedModel model = AnimatedModelSerializer.Deserialize(game.platform, dataString);
						p_.drawModel.renderer.Start(game, model);
					}
				}
				game.GLPushMatrix();
				game.GLTranslate(FeetPosX, FeetPosY, FeetPosZ);
				game.GLRotate(PlayerInterpolate.RadToDeg(-p_.position.roty + Game.GetPi()), 0, 1, 0);
				game.platform.BindTexture2d(game.entities[i].drawModel.CurrentTexture);
				p_.drawModel.renderer.Render(dt, PlayerInterpolate.RadToDeg(p_.position.rotx + Game.GetPi()), true, p_.playerDrawInfo.moves, shadow);
				game.GLPopMatrix();
			}
		}
	}

	public override void OnNewFrameDraw3d(Game game, float deltaTime)
	{
		this.DrawPlayers(game, deltaTime);
	}
	float one;
}

public class ModDrawSprites : ClientMod
{

	public static void Billboard(Game game)
	{
		float[] m = game.mvMatrix.Peek();
		float d = game.platform.MathSqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2]);
		m[0] = d;
		m[1] = 0;
		m[2] = 0;
		m[3] = 0;
		m[4] = 0;
		m[5] = d;
		m[6] = 0;
		m[7] = 0;
		m[8] = 0;
		m[9] = 0;
		m[10] = d;
		m[11] = 0;
		m[12] = m[12];
		m[13] = m[13];
		m[14] = m[14];
		m[15] = 1;
		Mat4.RotateX(m, m, Game.GetPi());
		game.GLLoadMatrix(m);
	}

	public override void OnNewFrameDraw3d(Game game, float deltaTime)
	{
		float one = 1;
		for (int i = 0; i < game.entitiesCount; i++) {
			Entity entity = game.entities[i];
			if (entity == null) {
				continue;
			}
			if (entity.sprite == null) {
				continue;
			}
			Sprite b = entity.sprite;
			game.GLMatrixModeModelView();
			game.GLPushMatrix();
			game.GLTranslate(b.positionX, b.positionY, b.positionZ);
			ModDrawSprites.Billboard(game);
			game.GLScale(one * 2 / 100, one * 2 / 100, one * 2 / 100);
			game.GLTranslate(0 - b.size / 2, 0 - b.size / 2, 0);
			IntRef n = null;
			if (b.animationcount > 0) {
				float progress = one - entity.expires.timeLeft / entity.expires.totalTime;
				n = IntRef.Create(game.platform.FloatToInt(progress * (b.animationcount * b.animationcount - 1)));
			}
			game.Draw2dTexture(game.GetTexture(b.image), 0, 0, b.size, b.size, n, b.animationcount, Game.ColorFromArgb(255, 255, 255, 255), true);
			game.GLPopMatrix();
		}
	}
}

public class ModDrawTerrain : ClientMod
{
	public ModDrawTerrain()
	{
		this.currentChunk = new int[5832];
		this.currentChunkShadows = new byte[5832];
		this.tempnearestpos = new int[3];
		this.ids = new int[1024];
		this.idsCount = 0;
		this.redraw = new TerrainRendererRedraw[128];
		this.redrawCount = 0;
		this.CalculateShadowslightRadius = new int[1024];
		this.CalculateShadowsisTransparentForLight = new bool[1024];
		this.lightBase = new LightBase();
		this.lightBetweenChunks = new LightBetweenChunks();
		this.lastPerformanceInfoupdateMilliseconds = 0;
		this.lastchunkupdates = 0;
		this.started = false;
	}

	public static Vector3IntRef[] BlocksAround7(Vector3IntRef pos)
	{
		Vector3IntRef[] arr = new Vector3IntRef[7];
		arr[0] = pos;
		arr[1] = Vector3IntRef.Create(pos.X + 1, pos.Y + 0, pos.Z + 0);
		arr[2] = Vector3IntRef.Create(pos.X - 1, pos.Y + 0, pos.Z + 0);
		arr[3] = Vector3IntRef.Create(pos.X + 0, pos.Y + 1, pos.Z + 0);
		arr[4] = Vector3IntRef.Create(pos.X + 0, pos.Y - 1, pos.Z + 0);
		arr[5] = Vector3IntRef.Create(pos.X + 0, pos.Y + 0, pos.Z + 1);
		arr[6] = Vector3IntRef.Create(pos.X + 0, pos.Y + 0, pos.Z - 1);
		return arr;
	}

	void CalculateShadows(int cx, int cy, int cz)
	{
		for (int i = 0; i < 1024; i++) {
			if (this.game.blocktypes[i] == null) {
				continue;
			}
			this.CalculateShadowslightRadius[i] = this.game.blocktypes[i].LightRadius;
			this.CalculateShadowsisTransparentForLight[i] = this.IsTransparentForLight(i);
		}
		for (int xx = 0; xx < 3; xx++) {
			for (int yy = 0; yy < 3; yy++) {
				for (int zz = 0; zz < 3; zz++) {
					int cx1 = cx + xx - 1;
					int cy1 = cy + yy - 1;
					int cz1 = cz + zz - 1;
					if (!this.game.map.IsValidChunkPos(cx1, cy1, cz1)) {
						continue;
					}
					Chunk c = this.game.map.GetChunk(cx1 * this.chunksize, cy1 * this.chunksize, cz1 * this.chunksize);
					if (c.baseLightDirty) {
						this.lightBase.CalculateChunkBaseLight(this.game, cx1, cy1, cz1, this.CalculateShadowslightRadius, this.CalculateShadowsisTransparentForLight);
						c.baseLightDirty = false;
					}
				}
			}
		}
		Chunk chunk = this.game.map.GetChunk(cx * this.chunksize, cy * this.chunksize, cz * this.chunksize);
		if (chunk.rendered.light == null) {
			chunk.rendered.light = new byte[5832];
			for (int i = 0; i < 5832; i++) {
				chunk.rendered.light[i] = 15;
			}
		}
		this.lightBetweenChunks.CalculateLightBetweenChunks(this.game, cx, cy, cz, this.CalculateShadowslightRadius, this.CalculateShadowsisTransparentForLight);
		for (int i = 0; i < 5832; i++) {
			this.currentChunkShadows[i] = chunk.rendered.light[i];
		}
	}
	bool[] CalculateShadowsisTransparentForLight;
	int[] CalculateShadowslightRadius;

	public int ChunkUpdates()
	{
		return this.chunkupdates;
	}

	internal void Clear()
	{
		this.game.d_Batcher.Clear();
	}

	public override void Dispose(Game game_)
	{
		this.Clear();
	}

	void DoRedraw(TerrainRendererRedraw r)
	{
		this.idsCount = 0;
		Chunk c = r.c;
		if (c.rendered.ids != null) {
			for (int i = 0; i < c.rendered.idsCount; i++) {
				int loadedSubmesh = c.rendered.ids[i];
				this.game.d_Batcher.Remove(loadedSubmesh);
			}
		}
		for (int i = 0; i < r.dataCount; i++) {
			VerticesIndicesToLoad submesh = r.data[i];
			if (submesh.modelData.GetIndicesCount() != 0) {
				float centerVecX = submesh.positionX + this.chunksize / 2;
				float centerVecY = submesh.positionZ + this.chunksize / 2;
				float centerVecZ = submesh.positionY + this.chunksize / 2;
				float radius = this.sqrt3half * this.chunksize;
				this.ids[this.idsCount++] = this.game.d_Batcher.Add(submesh.modelData, submesh.transparent, submesh.texture, centerVecX, centerVecY, centerVecZ, radius);
			}
		}
		int[] idsarr = new int[this.idsCount];
		for (int i = 0; i < this.idsCount; i++) {
			idsarr[i] = this.ids[i];
		}
		c.rendered.ids = idsarr;
		c.rendered.idsCount = this.idsCount;
	}

	public void DrawTerrain()
	{
		this.game.d_Batcher.Draw(this.game.player.position.x, this.game.player.position.y, this.game.player.position.z);
	}

	void GetExtendedChunk(int x, int y, int z)
	{
		this.game.map.GetMapPortion(this.currentChunk, x * this.chunksize - 1, y * this.chunksize - 1, z * this.chunksize - 1, this.chunksize + 2, this.chunksize + 2, this.chunksize + 2);
	}

	bool IsSolidChunk(int[] currentChunk, int length)
	{
		int block = currentChunk[0];
		for (int i = 0; i < length; i++) {
			if (currentChunk[i] != currentChunk[0]) {
				return false;
			}
		}
		return true;
	}

	public bool IsTransparentForLight(int block)
	{
		Packet_BlockType b = this.game.blocktypes[block];
		return b.DrawType != 1 && b.DrawType != 8;
	}

	public void MainThreadCommit()
	{
		for (int i = 0; i < this.redrawCount; i++) {
			this.DoRedraw(this.redraw[i]);
			this.redraw[i] = null;
		}
		this.redrawCount = 0;
	}

	ModelData ModelDataClone(ModelData source)
	{
		ModelData dest = new ModelData();
		dest.xyz = new float[source.GetXyzCount()];
		for (int i = 0; i < source.GetXyzCount(); i++) {
			dest.xyz[i] = source.xyz[i];
		}
		dest.uv = new float[source.GetUvCount()];
		for (int i = 0; i < source.GetUvCount(); i++) {
			dest.uv[i] = source.uv[i];
		}
		dest.rgba = new byte[source.GetRgbaCount()];
		for (int i = 0; i < source.GetRgbaCount(); i++) {
			dest.rgba[i] = source.rgba[i];
		}
		dest.indices = new int[source.GetIndicesCount()];
		for (int i = 0; i < source.GetIndicesCount(); i++) {
			dest.indices[i] = source.indices[i];
		}
		dest.SetVerticesCount(source.GetVerticesCount());
		dest.SetIndicesCount(source.GetIndicesCount());
		return dest;
	}

	void NearestDirty(int[] nearestpos)
	{
		int nearestdist = 2147483647;
		nearestpos[0] = -1;
		nearestpos[1] = -1;
		nearestpos[2] = -1;
		int px = this.game.platform.FloatToInt(this.game.player.position.x) / this.chunksize;
		int py = this.game.platform.FloatToInt(this.game.player.position.z) / this.chunksize;
		int pz = this.game.platform.FloatToInt(this.game.player.position.y) / this.chunksize;
		int chunksxy = this.mapAreaSize() / this.chunksize / 2;
		int chunksz = this.mapAreaSizeZ() / this.chunksize / 2;
		int startx = px - chunksxy;
		int endx = px + chunksxy;
		int starty = py - chunksxy;
		int endy = py + chunksxy;
		int startz = pz - chunksz;
		int endz = pz + chunksz;
		if (startx < 0) {
			startx = 0;
		}
		if (starty < 0) {
			starty = 0;
		}
		if (startz < 0) {
			startz = 0;
		}
		if (endx >= this.mapsizexchunks()) {
			endx = this.mapsizexchunks() - 1;
		}
		if (endy >= this.mapsizeychunks()) {
			endy = this.mapsizeychunks() - 1;
		}
		if (endz >= this.mapsizezchunks()) {
			endz = this.mapsizezchunks() - 1;
		}
		int mapsizexchunks_ = this.mapsizexchunks();
		int mapsizeychunks_ = this.mapsizeychunks();
		for (int x = startx; x <= endx; x++) {
			for (int y = starty; y <= endy; y++) {
				for (int z = startz; z <= endz; z++) {
					Chunk c = this.game.map.chunks[(z * mapsizeychunks_ + y) * mapsizexchunks_ + x];
					if (c == null || c.rendered == null) {
						continue;
					}
					if (c.rendered.dirty) {
						int dx = px - x;
						int dy = py - y;
						int dz = pz - z;
						int dist = dx * dx + dy * dy + dz * dz;
						if (dist < nearestdist) {
							nearestdist = dist;
							nearestpos[0] = x;
							nearestpos[1] = y;
							nearestpos[2] = z;
						}
					}
				}
			}
		}
	}

	public override void OnNewFrameDraw3d(Game game_, float deltaTime)
	{
		this.game = game_;
		if (!this.started) {
			this.started = true;
		}
		if (this.game.shouldRedrawAllBlocks) {
			this.game.shouldRedrawAllBlocks = false;
			this.RedrawAllBlocks();
		}
		this.DrawTerrain();
		this.UpdatePerformanceInfo(deltaTime);
	}

	public override void OnReadOnlyBackgroundThread(Game game_, float dt)
	{
		this.game = game_;
		this.UpdateTerrain();
		game_.QueueActionCommit(TerrainRendererCommit.Create(this));
	}

	public void RedrawAllBlocks()
	{
		if (!this.terrainRendererStarted) {
			this.StartTerrain();
		}
		int chunksLength = this.game.map.MapSizeX / this.chunksize * this.game.map.MapSizeY / this.chunksize * this.game.map.MapSizeZ / this.chunksize;
		for (int i = 0; i < chunksLength; i++) {
			Chunk c = this.game.map.chunks[i];
			if (c == null) {
				continue;
			}
			if (c.rendered == null) {
				c.rendered = new RenderedChunk();
			}
			c.rendered.dirty = true;
			c.baseLightDirty = true;
		}
	}

	void RedrawChunk(int x, int y, int z)
	{
		Chunk c = this.game.map.chunks[MapUtilCi.Index3d(x, y, z, this.mapsizexchunks(), this.mapsizeychunks())];
		if (c == null) {
			return;
		}
		if (c.rendered == null) {
			c.rendered = new RenderedChunk();
		}
		c.rendered.dirty = false;
		this.chunkupdates++;
		this.GetExtendedChunk(x, y, z);
		TerrainRendererRedraw r = new TerrainRendererRedraw();
		r.c = c;
		VerticesIndicesToLoad[] a = null;
		IntRef retCount = new IntRef();
		if (!this.IsSolidChunk(this.currentChunk, (this.chunksize + 2) * (this.chunksize + 2) * (this.chunksize + 2))) {
			this.CalculateShadows(x, y, z);
			a = this.game.d_TerrainChunkTesselator.MakeChunk(x, y, z, this.currentChunk, this.currentChunkShadows, this.game.mLightLevels, retCount);
		}
		r.data = new VerticesIndicesToLoad[retCount.value];
		for (int i = 0; i < retCount.value; i++) {
			r.data[i] = this.VerticesIndicesToLoadClone(a[i]);
		}
		r.dataCount = retCount.value;
		this.redraw[this.redrawCount++] = r;
	}

	public void StartTerrain()
	{
		this.sqrt3half = this.game.platform.MathSqrt(3) / 2;
		this.game.d_TerrainChunkTesselator.Start();
		this.terrainRendererStarted = true;
		this.chunksize = 16;
	}

	public int TrianglesCount()
	{
		return this.game.d_Batcher.TotalTriangleCount();
	}

	internal void UpdatePerformanceInfo(float dt)
	{
		float elapsed = 1f * (this.game.platform.TimeMillisecondsFromStart() - this.lastPerformanceInfoupdateMilliseconds) / 1000;
		int triangles = this.TrianglesCount();
		if (elapsed >= 1) {
			this.lastPerformanceInfoupdateMilliseconds = this.game.platform.TimeMillisecondsFromStart();
			int chunkupdates_ = this.ChunkUpdates();
			this.game.performanceinfo.Set("chunk updates", this.game.platform.StringFormat(this.game.language.ChunkUpdates(), this.game.platform.IntToString(chunkupdates_ - this.lastchunkupdates)));
			this.lastchunkupdates = this.ChunkUpdates();
			this.game.performanceinfo.Set("triangles", this.game.platform.StringFormat(this.game.language.Triangles(), this.game.platform.IntToString(triangles)));
		}
	}

	public void UpdateTerrain()
	{
		if (!this.terrainRendererStarted) {
			return;
		}
		if (!(this.game.lastplacedblockX == -1 && this.game.lastplacedblockY == -1 && this.game.lastplacedblockZ == -1)) {
			HashSetVector3IntRef ChunksToRedraw = new HashSetVector3IntRef();
			Vector3IntRef[] around = ModDrawTerrain.BlocksAround7(Vector3IntRef.Create(this.game.lastplacedblockX, this.game.lastplacedblockY, this.game.lastplacedblockZ));
			for (int i = 0; i < 7; i++) {
				Vector3IntRef a = around[i];
				ChunksToRedraw.Set(Vector3IntRef.Create(a.X / this.chunksize, a.Y / this.chunksize, a.Z / this.chunksize));
			}
			for (int i = 0; i < ChunksToRedraw.max; i++) {
				if (ChunksToRedraw.values[i] == null) {
					break;
				}
				int[] c = new int[3];
				int xx = ChunksToRedraw.values[i].X;
				int yy = ChunksToRedraw.values[i].Y;
				int zz = ChunksToRedraw.values[i].Z;
				if (xx >= 0 && yy >= 0 && zz >= 0 && xx < this.game.map.MapSizeX / this.chunksize && yy < this.game.map.MapSizeY / this.chunksize && zz < this.game.map.MapSizeZ / this.chunksize) {
					Chunk chunk = this.game.map.chunks[(zz * this.mapsizeychunks() + yy) * this.mapsizexchunks() + xx];
					if (chunk == null || chunk.rendered == null) {
						continue;
					}
					if (chunk.rendered.dirty) {
						this.RedrawChunk(xx, yy, zz);
					}
				}
			}
			this.game.lastplacedblockX = -1;
			this.game.lastplacedblockY = -1;
			this.game.lastplacedblockZ = -1;
		}
		int updated = 0;
		for (;;) {
			this.NearestDirty(this.tempnearestpos);
			if (this.tempnearestpos[0] == -1 && this.tempnearestpos[1] == -1 && this.tempnearestpos[2] == -1) {
				break;
			}
			this.RedrawChunk(this.tempnearestpos[0], this.tempnearestpos[1], this.tempnearestpos[2]);
			{
				break;
			}
		}
	}

	VerticesIndicesToLoad VerticesIndicesToLoadClone(VerticesIndicesToLoad source)
	{
		VerticesIndicesToLoad dest = new VerticesIndicesToLoad();
		dest.modelData = this.ModelDataClone(source.modelData);
		dest.positionX = source.positionX;
		dest.positionY = source.positionY;
		dest.positionZ = source.positionZ;
		dest.texture = source.texture;
		dest.transparent = source.transparent;
		return dest;
	}

	int centerAreaSize()
	{
		return this.game.platform.FloatToInt(this.game.d_Config3d.viewdistance) / 2;
	}
	int chunksize;
	int chunkupdates;
	int[] currentChunk;
	byte[] currentChunkShadows;
	internal Game game;
	int[] ids;
	int idsCount;
	int lastPerformanceInfoupdateMilliseconds;
	int lastchunkupdates;
	LightBase lightBase;
	LightBetweenChunks lightBetweenChunks;

	int mapAreaSize()
	{
		return this.game.platform.FloatToInt(this.game.d_Config3d.viewdistance) * 2;
	}

	int mapAreaSizeZ()
	{
		return this.mapAreaSize();
	}

	int mapsizexchunks()
	{
		return this.game.map.mapsizexchunks();
	}

	int mapsizeychunks()
	{
		return this.game.map.mapsizeychunks();
	}

	int mapsizezchunks()
	{
		return this.game.map.mapsizezchunks();
	}

	public int maxlight()
	{
		return 15;
	}
	TerrainRendererRedraw[] redraw;
	int redrawCount;
	float sqrt3half;
	bool started;
	int[] tempnearestpos;
	bool terrainRendererStarted;
}

public class ModDrawTestModel : ClientMod
{

	void DrawTestModel(Game game, float deltaTime)
	{
		if (!game.ENABLE_DRAW_TEST_CHARACTER) {
			return;
		}
		if (this.testmodel == null) {
			this.testmodel = new AnimatedModelRenderer();
			byte[] data = game.GetFile("player.txt");
			int dataLength = game.GetFileLength("player.txt");
			string dataString = game.platform.StringFromUtf8ByteArray(data, dataLength);
			AnimatedModel model = AnimatedModelSerializer.Deserialize(game.platform, dataString);
			this.testmodel.Start(game, model);
		}
		game.GLPushMatrix();
		game.GLTranslate(game.map.MapSizeX / 2, game.blockheight(game.map.MapSizeX / 2, game.map.MapSizeY / 2 - 2, 128), game.map.MapSizeY / 2 - 2);
		game.platform.BindTexture2d(game.GetTexture("mineplayer.png"));
		this.testmodel.Render(deltaTime, 0, true, true, 1);
		game.GLPopMatrix();
	}

	public override bool OnClientCommand(Game game, ClientCommandArgs args)
	{
		if (args.command == "testmodel") {
			game.ENABLE_DRAW_TEST_CHARACTER = game.BoolCommandArgument(args.arguments);
			return true;
		}
		return false;
	}

	public override void OnNewFrameDraw3d(Game game, float deltaTime)
	{
		if (game.guistate == GuiState.MapLoading) {
			return;
		}
		this.DrawTestModel(game, deltaTime);
	}
	AnimatedModelRenderer testmodel;
}

public class ModDrawText : ClientMod
{

	public override void OnNewFrameDraw3d(Game game, float deltaTime)
	{
		for (int i = 0; i < game.entitiesCount; i++) {
			Entity e = game.entities[i];
			if (e == null) {
				continue;
			}
			if (e.drawText == null) {
				continue;
			}
			if (e.networkPosition != null && !e.networkPosition.PositionLoaded) {
				continue;
			}
			int kKey = i;
			EntityDrawText p = game.entities[i].drawText;
			float posX = -game.platform.MathSin(e.position.roty) * p.dx + e.position.x;
			float posY = p.dy + e.position.y;
			float posZ = game.platform.MathCos(e.position.roty) * p.dz + e.position.z;
			if (game.Dist(game.player.position.x, game.player.position.y, game.player.position.z, posX, posY, posZ) < 20 || game.keyboardState[5] || game.keyboardState[6]) {
				string text = p.text;
				{
					float shadow = game.one * game.GetLight(game.platform.FloatToInt(posX), game.platform.FloatToInt(posZ), game.platform.FloatToInt(posY)) / 15;
					game.GLPushMatrix();
					game.GLTranslate(posX, posY, posZ);
					game.GLRotate(180, 1, 0, 0);
					game.GLRotate(e.position.roty * 360 / (2 * Game.GetPi()), 0, 1, 0);
					float scale = game.one * 5 / 1000;
					game.GLScale(scale, scale, scale);
					FontCi font = new FontCi();
					font.family = "Arial";
					font.size = 14;
					game.Draw2dText(text, font, -game.TextSizeWidth(text, 14) / 2, 0, IntRef.Create(Game.ColorFromArgb(255, 255, 255, 255)), true);
					game.GLPopMatrix();
				}
			}
		}
	}
}

public class ModExpire : ClientMod
{

	void GrenadeExplosion(Game game, int grenadeEntityId)
	{
		float LocalPlayerPositionX = game.player.position.x;
		float LocalPlayerPositionY = game.player.position.y;
		float LocalPlayerPositionZ = game.player.position.z;
		Entity grenadeEntity = game.entities[grenadeEntityId];
		Sprite grenadeSprite = grenadeEntity.sprite;
		Grenade_ grenade = grenadeEntity.grenade;
		game.AudioPlayAt("grenadeexplosion.ogg", grenadeSprite.positionX, grenadeSprite.positionY, grenadeSprite.positionZ);
		{
			Entity entity = new Entity();
			Sprite spritenew = new Sprite();
			spritenew.image = "ani5.png";
			spritenew.positionX = grenadeSprite.positionX;
			spritenew.positionY = grenadeSprite.positionY + 1;
			spritenew.positionZ = grenadeSprite.positionZ;
			spritenew.size = 200;
			spritenew.animationcount = 4;
			entity.sprite = spritenew;
			entity.expires = Expires.Create(1);
			game.EntityAddLocal(entity);
		}
		{
			Packet_ServerExplosion explosion = new Packet_ServerExplosion();
			explosion.XFloat = game.SerializeFloat(grenadeSprite.positionX);
			explosion.YFloat = game.SerializeFloat(grenadeSprite.positionZ);
			explosion.ZFloat = game.SerializeFloat(grenadeSprite.positionY);
			explosion.RangeFloat = game.blocktypes[grenade.block].ExplosionRangeFloat;
			explosion.IsRelativeToPlayerPosition = 0;
			explosion.TimeFloat = game.blocktypes[grenade.block].ExplosionTimeFloat;
			Entity entity = new Entity();
			entity.push = explosion;
			entity.expires = new Expires();
			entity.expires.timeLeft = game.DeserializeFloat(game.blocktypes[grenade.block].ExplosionTimeFloat);
			game.EntityAddLocal(entity);
		}
		float dist = game.Dist(LocalPlayerPositionX, LocalPlayerPositionY, LocalPlayerPositionZ, grenadeSprite.positionX, grenadeSprite.positionY, grenadeSprite.positionZ);
		float dmg = (1 - dist / game.DeserializeFloat(game.blocktypes[grenade.block].ExplosionRangeFloat)) * game.DeserializeFloat(game.blocktypes[grenade.block].DamageBodyFloat);
		if (dmg > 0) {
			game.ApplyDamageToPlayer(game.platform.FloatToInt(dmg), 3, grenade.sourcePlayer);
		}
	}

	public override void OnNewFrameFixed(Game game, NewFrameEventArgs args)
	{
		for (int i = 0; i < game.entitiesCount; i++) {
			Entity entity = game.entities[i];
			if (entity == null) {
				continue;
			}
			if (entity.expires == null) {
				continue;
			}
			entity.expires.timeLeft -= args.GetDt();
			if (entity.expires.timeLeft <= 0) {
				if (entity.grenade != null) {
					this.GrenadeExplosion(game, i);
				}
				game.entities[i] = null;
			}
		}
	}
}

public class ModFallDamageToPlayer : ClientMod
{
	public ModFallDamageToPlayer()
	{
		this.one = 1;
		this.fallSoundPlaying = false;
	}

	public override void OnNewFrameFixed(Game game, NewFrameEventArgs args)
	{
		if (game.guistate == GuiState.MapLoading) {
			return;
		}
		if (game.controls.GetFreemove() != 0) {
			if (this.fallSoundPlaying) {
				this.SetFallSoundActive(game, false);
			}
			return;
		}
		if (game.FollowId() == null) {
			this.UpdateFallDamageToPlayer(game, args.GetDt());
		}
	}

	internal void SetFallSoundActive(Game game, bool active)
	{
		game.AudioPlayLoop("fallloop.wav", active, true);
		this.fallSoundPlaying = active;
	}

	internal void UpdateFallDamageToPlayer(Game game, float dt)
	{
		float movedz = game.movedz;
		float fallspeed = movedz / -game.basemovespeed;
		int posX = game.GetPlayerEyesBlockX();
		int posY = game.GetPlayerEyesBlockY();
		int posZ = game.GetPlayerEyesBlockZ();
		if (game.blockheight(posX, posY, posZ) < posZ - 8 || fallspeed > 3) {
			this.SetFallSoundActive(game, fallspeed > 2);
		}
		else {
			this.SetFallSoundActive(game, false);
		}
		if (game.map.IsValidPos(posX, posY, posZ - 3)) {
			int blockBelow = game.map.GetBlock(posX, posY, posZ - 3);
			if (blockBelow != 0 && !game.IsWater(blockBelow)) {
				float severity = 0;
				if (fallspeed < 4) {
					return;
				}
				else if (fallspeed < this.one * 45 / 10) {
					severity = this.one * 3 / 10;
				}
				else if (fallspeed < 5) {
					severity = this.one * 5 / 10;
				}
				else if (fallspeed < this.one * 55 / 10) {
					severity = this.one * 6 / 10;
				}
				else if (fallspeed < 6) {
					severity = this.one * 8 / 10;
				}
				else {
					severity = 1;
				}
				if (this.one * (game.platform.TimeMillisecondsFromStart() - this.lastfalldamagetimeMilliseconds) / 1000 < 1) {
					return;
				}
				this.lastfalldamagetimeMilliseconds = game.platform.TimeMillisecondsFromStart();
				game.ApplyDamageToPlayer(game.platform.FloatToInt(severity * game.PlayerStats.MaxHealth), 0, 0);
			}
		}
	}
	bool fallSoundPlaying;
	int lastfalldamagetimeMilliseconds;
	float one;
}

public class ModFpsHistoryGraph : ClientMod
{
	public ModFpsHistoryGraph()
	{
		this.one = 1;
		this.drawfpstext = false;
		this.drawfpsgraph = false;
		this.dtHistory = new float[300];
		for (int i = 0; i < 300; i++) {
			this.dtHistory[i] = 0;
		}
		this.todraw = new Draw2dData[300];
		for (int i = 0; i < 300; i++) {
			this.todraw[i] = new Draw2dData();
		}
	}

	void Draw()
	{
		if (this.drawfpsgraph || this.drawfpstext) {
			this.m.OrthoMode();
			if (this.drawfpsgraph) {
				this.DrawGraph();
			}
			if (this.drawfpstext) {
				this.m.Draw2dText(this.fpstext, 20, 20, 11);
			}
			this.m.PerspectiveMode();
		}
	}

	void DrawGraph()
	{
		float maxtime = 0;
		for (int i = 0; i < 300; i++) {
			float v = this.dtHistory[i];
			if (v > maxtime) {
				maxtime = v;
			}
		}
		int historyheight = 80;
		int posx = 25;
		int posy = this.m.GetWindowHeight() - historyheight - 20;
		int[] colors = new int[2];
		colors[0] = Game.ColorFromArgb(255, 0, 0, 0);
		colors[1] = Game.ColorFromArgb(255, 255, 0, 0);
		int linecolor = Game.ColorFromArgb(255, 255, 255, 255);
		for (int i = 0; i < 300; i++) {
			float time = this.dtHistory[i];
			time = time * 60 * historyheight;
			int c = InterpolationCi.InterpolateColor(this.m.GetPlatform(), this.one * i / 300, colors, 2);
			this.todraw[i].x1 = posx + i;
			this.todraw[i].y1 = posy - time;
			this.todraw[i].width = 1;
			this.todraw[i].height = time;
			this.todraw[i].inAtlasId = null;
			this.todraw[i].color = c;
		}
		this.m.Draw2dTextures(this.todraw, 300, this.m.WhiteTexture());
		this.m.Draw2dTexture(this.m.WhiteTexture(), posx, posy - historyheight, 300, 1, null, linecolor);
		this.m.Draw2dTexture(this.m.WhiteTexture(), posx, posy - historyheight * this.one * 60 / 75, 300, 1, null, linecolor);
		this.m.Draw2dTexture(this.m.WhiteTexture(), posx, posy - historyheight * this.one * 60 / 30, 300, 1, null, linecolor);
		this.m.Draw2dTexture(this.m.WhiteTexture(), posx, posy - historyheight * this.one * 60 / 150, 300, 1, null, linecolor);
		this.m.Draw2dText("60", posx, posy - historyheight * this.one * 60 / 60, 6);
		this.m.Draw2dText("75", posx, posy - historyheight * this.one * 60 / 75, 6);
		this.m.Draw2dText("30", posx, posy - historyheight * this.one * 60 / 30, 6);
		this.m.Draw2dText("150", posx, posy - historyheight * this.one * 60 / 150, 6);
	}

	public override bool OnClientCommand(Game game, ClientCommandArgs args)
	{
		if (args.command == "fps") {
			IntRef argumentsLength = new IntRef();
			string[] arguments = this.m.GetPlatform().StringSplit(args.arguments, " ", argumentsLength);
			if (this.m.GetPlatform().StringTrim(args.arguments) == "") {
				this.drawfpstext = true;
			}
			else if (arguments[0] == "1") {
				this.drawfpstext = true;
				this.drawfpsgraph = false;
			}
			else if (arguments[0] == "2") {
				this.drawfpstext = true;
				this.drawfpsgraph = true;
			}
			else {
				this.drawfpstext = false;
				this.drawfpsgraph = false;
			}
			return true;
		}
		return false;
	}

	public override void OnKeyDown(Game game, KeyEventArgs args)
	{
		if (args.GetKeyCode() == 16) {
			if (!this.drawfpsgraph) {
				this.drawfpstext = true;
				this.drawfpsgraph = true;
			}
			else {
				this.drawfpstext = false;
				this.drawfpsgraph = false;
			}
		}
	}

	public override void OnNewFrame(Game game, NewFrameEventArgs args)
	{
		float dt = args.GetDt();
		this.UpdateGraph(dt);
		this.UpdateTitleFps(dt);
		this.Draw();
	}

	public override void Start(ClientModManager modmanager)
	{
		this.m = modmanager;
	}

	void UpdateGraph(float dt)
	{
		for (int i = 0; i < 299; i++) {
			this.dtHistory[i] = this.dtHistory[i + 1];
		}
		this.dtHistory[299] = dt;
	}

	void UpdateTitleFps(float dt)
	{
		GamePlatform p = this.m.GetPlatform();
		this.fpscount++;
		this.longestframedt = MathCi.MaxFloat(this.longestframedt, dt);
		float elapsed = this.one * (p.TimeMillisecondsFromStart() - this.lasttitleupdateMilliseconds) / 1000;
		if (elapsed >= 1) {
			string fpstext1 = "";
			this.lasttitleupdateMilliseconds = p.TimeMillisecondsFromStart();
			fpstext1 = StringTools.StringAppend(p, fpstext1, p.StringFormat("FPS: {0}", p.IntToString(p.FloatToInt(this.one * this.fpscount / elapsed))));
			fpstext1 = StringTools.StringAppend(p, fpstext1, p.StringFormat(" (min: {0})", p.IntToString(p.FloatToInt(this.one / this.longestframedt))));
			this.longestframedt = 0;
			this.fpscount = 0;
			this.m.GetPerformanceInfo().Set("fps", fpstext1);
			string s = "";
			string[] l = new string[64];
			int lCount = 0;
			for (int i = 0; i < this.m.GetPerformanceInfo().count; i++) {
				if (this.m.GetPerformanceInfo().items[i] == null) {
					continue;
				}
				l[lCount++] = this.m.GetPerformanceInfo().items[i].value;
			}
			int perline = 2;
			for (int i = 0; i < lCount; i++) {
				s = StringTools.StringAppend(p, s, l[i]);
				if (i % perline == 0 && i != lCount - 1) {
					s = StringTools.StringAppend(p, s, ", ");
				}
				if (i % perline != 0) {
					s = StringTools.StringAppend(p, s, "\n");
				}
			}
			this.fpstext = s;
		}
	}
	bool drawfpsgraph;
	bool drawfpstext;
	float[] dtHistory;
	int fpscount;
	string fpstext;
	int lasttitleupdateMilliseconds;
	float longestframedt;
	ClientModManager m;
	float one;
	Draw2dData[] todraw;
}

public class ModGrenade : ClientMod
{
	public ModGrenade()
	{
		this.one = 1;
		this.projectilegravity = 20;
		this.bouncespeedmultiply = this.one * 5 / 10;
		this.walldistance = this.one * 3 / 10;
	}

	internal Vector3Ref GrenadeBounce(Game game, Vector3Ref oldposition, Vector3Ref newposition, Vector3Ref velocity, float dt)
	{
		bool ismoving = velocity.Length() > 100 * dt;
		float modelheight = this.walldistance;
		oldposition.Y += this.walldistance;
		newposition.Y += this.walldistance;
		Vector3IntRef oldpositioni = Vector3IntRef.Create(game.MathFloor(oldposition.X), game.MathFloor(oldposition.Z), game.MathFloor(oldposition.Y));
		float playerpositionX = newposition.X;
		float playerpositionY = newposition.Y;
		float playerpositionZ = newposition.Z;
		{
			float qnewpositionX = newposition.X;
			float qnewpositionY = newposition.Y;
			float qnewpositionZ = newposition.Z + this.walldistance;
			bool newempty = game.IsTileEmptyForPhysics(game.MathFloor(qnewpositionX), game.MathFloor(qnewpositionZ), game.MathFloor(qnewpositionY)) && game.IsTileEmptyForPhysics(game.MathFloor(qnewpositionX), game.MathFloor(qnewpositionZ), game.MathFloor(qnewpositionY) + 1);
			if (newposition.Z - oldposition.Z > 0) {
				if (!newempty) {
					velocity.Z = -velocity.Z;
					velocity.X *= this.bouncespeedmultiply;
					velocity.Y *= this.bouncespeedmultiply;
					velocity.Z *= this.bouncespeedmultiply;
					if (ismoving) {
						game.AudioPlayAt("grenadebounce.ogg", newposition.X, newposition.Y, newposition.Z);
					}
				}
			}
		}
		{
			float qnewpositionX = newposition.X + this.walldistance;
			float qnewpositionY = newposition.Y;
			float qnewpositionZ = newposition.Z;
			bool newempty = game.IsTileEmptyForPhysics(game.MathFloor(qnewpositionX), game.MathFloor(qnewpositionZ), game.MathFloor(qnewpositionY)) && game.IsTileEmptyForPhysics(game.MathFloor(qnewpositionX), game.MathFloor(qnewpositionZ), game.MathFloor(qnewpositionY) + 1);
			if (newposition.X - oldposition.X > 0) {
				if (!newempty) {
					velocity.X = -velocity.X;
					velocity.X *= this.bouncespeedmultiply;
					velocity.Y *= this.bouncespeedmultiply;
					velocity.Z *= this.bouncespeedmultiply;
					if (ismoving) {
						game.AudioPlayAt("grenadebounce.ogg", newposition.X, newposition.Y, newposition.Z);
					}
				}
			}
		}
		{
			float qnewpositionX = newposition.X;
			float qnewpositionY = newposition.Y - this.walldistance;
			float qnewpositionZ = newposition.Z;
			int x = game.MathFloor(qnewpositionX);
			int y = game.MathFloor(qnewpositionZ);
			int z = game.MathFloor(qnewpositionY);
			float a_ = this.walldistance;
			bool newfull = !game.IsTileEmptyForPhysics(x, y, z) || qnewpositionX - game.MathFloor(qnewpositionX) <= a_ && !game.IsTileEmptyForPhysics(x - 1, y, z) && game.IsTileEmptyForPhysics(x - 1, y, z + 1) || qnewpositionX - game.MathFloor(qnewpositionX) >= 1 - a_ && !game.IsTileEmptyForPhysics(x + 1, y, z) && game.IsTileEmptyForPhysics(x + 1, y, z + 1) || qnewpositionZ - game.MathFloor(qnewpositionZ) <= a_ && !game.IsTileEmptyForPhysics(x, y - 1, z) && game.IsTileEmptyForPhysics(x, y - 1, z + 1) || qnewpositionZ - game.MathFloor(qnewpositionZ) >= 1 - a_ && !game.IsTileEmptyForPhysics(x, y + 1, z) && game.IsTileEmptyForPhysics(x, y + 1, z + 1);
			if (newposition.Y - oldposition.Y < 0) {
				if (newfull) {
					velocity.Y = -velocity.Y;
					velocity.X *= this.bouncespeedmultiply;
					velocity.Y *= this.bouncespeedmultiply;
					velocity.Z *= this.bouncespeedmultiply;
					if (ismoving) {
						game.AudioPlayAt("grenadebounce.ogg", newposition.X, newposition.Y, newposition.Z);
					}
				}
			}
		}
		{
			float qnewpositionX = newposition.X;
			float qnewpositionY = newposition.Y;
			float qnewpositionZ = newposition.Z - this.walldistance;
			bool newempty = game.IsTileEmptyForPhysics(game.MathFloor(qnewpositionX), game.MathFloor(qnewpositionZ), game.MathFloor(qnewpositionY)) && game.IsTileEmptyForPhysics(game.MathFloor(qnewpositionX), game.MathFloor(qnewpositionZ), game.MathFloor(qnewpositionY) + 1);
			if (newposition.Z - oldposition.Z < 0) {
				if (!newempty) {
					velocity.Z = -velocity.Z;
					velocity.X *= this.bouncespeedmultiply;
					velocity.Y *= this.bouncespeedmultiply;
					velocity.Z *= this.bouncespeedmultiply;
					if (ismoving) {
						game.AudioPlayAt("grenadebounce.ogg", newposition.X, newposition.Y, newposition.Z);
					}
				}
			}
		}
		{
			float qnewpositionX = newposition.X - this.walldistance;
			float qnewpositionY = newposition.Y;
			float qnewpositionZ = newposition.Z;
			bool newempty = game.IsTileEmptyForPhysics(game.MathFloor(qnewpositionX), game.MathFloor(qnewpositionZ), game.MathFloor(qnewpositionY)) && game.IsTileEmptyForPhysics(game.MathFloor(qnewpositionX), game.MathFloor(qnewpositionZ), game.MathFloor(qnewpositionY) + 1);
			if (newposition.X - oldposition.X < 0) {
				if (!newempty) {
					velocity.X = -velocity.X;
					velocity.X *= this.bouncespeedmultiply;
					velocity.Y *= this.bouncespeedmultiply;
					velocity.Z *= this.bouncespeedmultiply;
					if (ismoving) {
						game.AudioPlayAt("grenadebounce.ogg", newposition.X, newposition.Y, newposition.Z);
					}
				}
			}
		}
		{
			float qnewpositionX = newposition.X;
			float qnewpositionY = newposition.Y + modelheight;
			float qnewpositionZ = newposition.Z;
			bool newempty = game.IsTileEmptyForPhysics(game.MathFloor(qnewpositionX), game.MathFloor(qnewpositionZ), game.MathFloor(qnewpositionY));
			if (newposition.Y - oldposition.Y > 0) {
				if (!newempty) {
					velocity.Y = -velocity.Y;
					velocity.X *= this.bouncespeedmultiply;
					velocity.Y *= this.bouncespeedmultiply;
					velocity.Z *= this.bouncespeedmultiply;
					if (ismoving) {
						game.AudioPlayAt("grenadebounce.ogg", newposition.X, newposition.Y, newposition.Z);
					}
				}
			}
		}
		playerpositionY -= this.walldistance;
		return Vector3Ref.Create(playerpositionX, playerpositionY, playerpositionZ);
	}

	public override void OnNewFrameFixed(Game game, NewFrameEventArgs args)
	{
		for (int i = 0; i < game.entitiesCount; i++) {
			Entity entity = game.entities[i];
			if (entity == null) {
				continue;
			}
			if (entity.grenade == null) {
				continue;
			}
			this.UpdateGrenade(game, i, args.GetDt());
		}
	}

	internal void UpdateGrenade(Game game, int grenadeEntityId, float dt)
	{
		float LocalPlayerPositionX = game.player.position.x;
		float LocalPlayerPositionY = game.player.position.y;
		float LocalPlayerPositionZ = game.player.position.z;
		Entity grenadeEntity = game.entities[grenadeEntityId];
		Sprite grenadeSprite = grenadeEntity.sprite;
		Grenade_ grenade = grenadeEntity.grenade;
		float oldposX = grenadeEntity.sprite.positionX;
		float oldposY = grenadeSprite.positionY;
		float oldposZ = grenadeSprite.positionZ;
		float newposX = grenadeSprite.positionX + grenade.velocityX * dt;
		float newposY = grenadeSprite.positionY + grenade.velocityY * dt;
		float newposZ = grenadeSprite.positionZ + grenade.velocityZ * dt;
		grenade.velocityY += -this.projectilegravity * dt;
		Vector3Ref velocity = Vector3Ref.Create(grenade.velocityX, grenade.velocityY, grenade.velocityZ);
		Vector3Ref bouncePosition = this.GrenadeBounce(game, Vector3Ref.Create(oldposX, oldposY, oldposZ), Vector3Ref.Create(newposX, newposY, newposZ), velocity, dt);
		grenade.velocityX = velocity.X;
		grenade.velocityY = velocity.Y;
		grenade.velocityZ = velocity.Z;
		grenadeSprite.positionX = bouncePosition.X;
		grenadeSprite.positionY = bouncePosition.Y;
		grenadeSprite.positionZ = bouncePosition.Z;
	}
	float bouncespeedmultiply;
	float one;
	float projectilegravity;
	float walldistance;
}

public class ModGuiChat : ClientMod
{
	public ModGuiChat()
	{
		this.one = 1;
		this.ChatFontSize = 11;
		this.ChatScreenExpireTimeSeconds = 20;
		this.ChatLinesMaxToDraw = 10;
		this.font = new FontCi();
		this.font.family = "Arial";
		this.font.size = this.ChatFontSize;
		this.chatlines2 = new Chatline[1024];
	}
	internal float ChatFontSize;
	internal int ChatLinesMaxToDraw;
	internal int ChatPageScroll;
	internal int ChatScreenExpireTimeSeconds;

	public string DoAutocomplete(string text)
	{
		if (!this.game.platform.StringEmpty(text)) {
			for (int i = 0; i < this.game.entitiesCount; i++) {
				Entity entity = this.game.entities[i];
				if (entity == null) {
					continue;
				}
				if (entity.drawName == null) {
					continue;
				}
				if (!entity.drawName.ClientAutoComplete) {
					continue;
				}
				DrawName p = entity.drawName;
				if (this.game.platform.StringStartsWithIgnoreCase(StringTools.StringSubstringToEnd(this.game.platform, p.Name, 2), text)) {
					return StringTools.StringSubstringToEnd(this.game.platform, p.Name, 2);
				}
			}
		}
		return "";
	}

	public void DrawChatLines(bool all)
	{
		this.chatlines2Count = 0;
		int timeNow = this.game.platform.TimeMillisecondsFromStart();
		int scroll;
		if (!all) {
			scroll = 0;
		}
		else {
			scroll = this.ChatPageScroll;
		}
		int first = this.game.ChatLinesCount - this.ChatLinesMaxToDraw * (scroll + 1);
		if (first < 0) {
			first = 0;
		}
		int count = this.game.ChatLinesCount;
		if (count > this.ChatLinesMaxToDraw) {
			count = this.ChatLinesMaxToDraw;
		}
		for (int i = first; i < first + count; i++) {
			Chatline c = this.game.ChatLines[i];
			if (all || this.one * (timeNow - c.timeMilliseconds) / 1000 < this.ChatScreenExpireTimeSeconds) {
				this.chatlines2[this.chatlines2Count++] = c;
			}
		}
		this.font.size = this.ChatFontSize * this.game.Scale();
		float dx = 20;
		for (int i = 0; i < this.chatlines2Count; i++) {
			if (this.chatlines2[i].clickable) {
				this.font.style = 3;
			}
			else {
				this.font.style = 1;
			}
			this.game.Draw2dText(this.chatlines2[i].text, this.font, dx * this.game.Scale(), (90 + i * 25) * this.game.Scale(), null, false);
		}
		if (this.ChatPageScroll != 0) {
			this.game.Draw2dText(this.game.platform.StringFormat("&7Page: {0}", this.game.platform.IntToString(this.ChatPageScroll)), this.font, dx * this.game.Scale(), 65 * this.game.Scale(), null, false);
		}
	}

	public void DrawTypingBuffer()
	{
		this.font.size = this.ChatFontSize * this.game.Scale();
		string s = this.game.GuiTypingBuffer;
		if (this.game.IsTeamchat) {
			s = this.game.platform.StringFormat("To team: {0}", s);
		}
		if (this.game.platform.IsSmallScreen()) {
			this.game.Draw2dText(this.game.platform.StringFormat("{0}_", s), this.font, 50 * this.game.Scale(), this.game.platform.GetCanvasHeight() / 2 - 100 * this.game.Scale(), null, true);
		}
		else {
			this.game.Draw2dText(this.game.platform.StringFormat("{0}_", s), this.font, 50 * this.game.Scale(), this.game.platform.GetCanvasHeight() - 100 * this.game.Scale(), null, true);
		}
	}

	public override void OnKeyDown(Game game_, KeyEventArgs args)
	{
		if (this.game.guistate != GuiState.Normal) {
			return;
		}
		int eKey = args.GetKeyCode();
		if (eKey == this.game.GetKey(116) && this.game.IsShiftPressed && this.game.GuiTyping == TypingState.None) {
			this.game.GuiTyping = TypingState.Typing;
			this.game.IsTyping = true;
			this.game.GuiTypingBuffer = "";
			this.game.IsTeamchat = false;
			args.SetHandled(true);
			return;
		}
		if (eKey == this.game.GetKey(56) && this.game.GuiTyping == TypingState.Typing) {
			this.ChatPageScroll++;
			args.SetHandled(true);
		}
		if (eKey == this.game.GetKey(57) && this.game.GuiTyping == TypingState.Typing) {
			this.ChatPageScroll--;
			args.SetHandled(true);
		}
		this.ChatPageScroll = MathCi.ClampInt(this.ChatPageScroll, 0, this.game.ChatLinesCount / this.ChatLinesMaxToDraw);
		if (eKey == this.game.GetKey(49) || eKey == this.game.GetKey(82)) {
			if (this.game.GuiTyping == TypingState.Typing) {
				this.game.typinglog[this.game.typinglogCount++] = this.game.GuiTypingBuffer;
				this.game.typinglogpos = this.game.typinglogCount;
				this.game.ClientCommand(this.game.GuiTypingBuffer);
				this.game.GuiTypingBuffer = "";
				this.game.IsTyping = false;
				this.game.GuiTyping = TypingState.None;
				this.game.platform.ShowKeyboard(false);
			}
			else if (this.game.GuiTyping == TypingState.None) {
				this.game.StartTyping();
			}
			else if (this.game.GuiTyping == TypingState.Ready) {
				this.game.platform.ConsoleWriteLine("Keyboard_KeyDown ready");
			}
			args.SetHandled(true);
			return;
		}
		if (this.game.GuiTyping == TypingState.Typing) {
			int key = eKey;
			if (key == this.game.GetKey(53)) {
				if (StringTools.StringLength(this.game.platform, this.game.GuiTypingBuffer) > 0) {
					this.game.GuiTypingBuffer = StringTools.StringSubstring(this.game.platform, this.game.GuiTypingBuffer, 0, StringTools.StringLength(this.game.platform, this.game.GuiTypingBuffer) - 1);
				}
				args.SetHandled(true);
				return;
			}
			if (this.game.keyboardStateRaw[this.game.GetKey(3)] || this.game.keyboardStateRaw[this.game.GetKey(4)]) {
				if (key == this.game.GetKey(104)) {
					if (this.game.platform.ClipboardContainsText()) {
						this.game.GuiTypingBuffer = StringTools.StringAppend(this.game.platform, this.game.GuiTypingBuffer, this.game.platform.ClipboardGetText());
					}
					args.SetHandled(true);
					return;
				}
			}
			if (key == this.game.GetKey(45)) {
				this.game.typinglogpos--;
				if (this.game.typinglogpos < 0) {
					this.game.typinglogpos = 0;
				}
				if (this.game.typinglogpos >= 0 && this.game.typinglogpos < this.game.typinglogCount) {
					this.game.GuiTypingBuffer = this.game.typinglog[this.game.typinglogpos];
				}
				args.SetHandled(true);
			}
			if (key == this.game.GetKey(46)) {
				this.game.typinglogpos++;
				if (this.game.typinglogpos > this.game.typinglogCount) {
					this.game.typinglogpos = this.game.typinglogCount;
				}
				if (this.game.typinglogpos >= 0 && this.game.typinglogpos < this.game.typinglogCount) {
					this.game.GuiTypingBuffer = this.game.typinglog[this.game.typinglogpos];
				}
				if (this.game.typinglogpos == this.game.typinglogCount) {
					this.game.GuiTypingBuffer = "";
				}
				args.SetHandled(true);
			}
			if (eKey == this.game.GetKey(52) && this.game.platform.StringTrim(this.game.GuiTypingBuffer) != "") {
				IntRef partsLength = new IntRef();
				string[] parts = this.game.platform.StringSplit(this.game.GuiTypingBuffer, " ", partsLength);
				string completed = this.DoAutocomplete(parts[partsLength.value - 1]);
				if (completed == "") {
					args.SetHandled(true);
					return;
				}
				else if (partsLength.value == 1) {
					this.game.GuiTypingBuffer = StringTools.StringAppend(this.game.platform, completed, ": ");
				}
				else {
					parts[partsLength.value - 1] = completed;
					this.game.GuiTypingBuffer = StringTools.StringAppend(this.game.platform, this.game.platform.StringJoin(parts, " "), " ");
				}
				args.SetHandled(true);
				return;
			}
			args.SetHandled(true);
			return;
		}
	}

	public override void OnKeyPress(Game game_, KeyPressEventArgs args)
	{
		if (this.game.guistate != GuiState.Normal) {
			return;
		}
		int eKeyChar = args.GetKeyChar();
		int chart = 116;
		int charT = 84;
		int chary = 121;
		int charY = 89;
		if ((eKeyChar == chart || eKeyChar == charT) && this.game.GuiTyping == TypingState.None) {
			this.game.GuiTyping = TypingState.Typing;
			this.game.GuiTypingBuffer = "";
			this.game.IsTeamchat = false;
			return;
		}
		if ((eKeyChar == chary || eKeyChar == charY) && this.game.GuiTyping == TypingState.None) {
			this.game.GuiTyping = TypingState.Typing;
			this.game.GuiTypingBuffer = "";
			this.game.IsTeamchat = true;
			return;
		}
		if (this.game.GuiTyping == TypingState.Typing) {
			int c = eKeyChar;
			if (this.game.platform.IsValidTypingChar(c)) {
				this.game.GuiTypingBuffer = StringTools.StringAppend(this.game.platform, this.game.GuiTypingBuffer, this.game.CharToString(c));
			}
		}
	}

	public override void OnMouseDown(Game game_, MouseEventArgs args)
	{
		for (int i = 0; i < this.chatlines2Count; i++) {
			float dx = 20;
			if (!this.game.platform.IsMousePointerLocked()) {
				dx += 100;
			}
			float chatlineStartX = dx * this.game.Scale();
			float chatlineStartY = (90 + i * 25) * this.game.Scale();
			float chatlineSizeX = 500 * this.game.Scale();
			float chatlineSizeY = 20 * this.game.Scale();
			if (args.GetX() > chatlineStartX && args.GetX() < chatlineStartX + chatlineSizeX) {
				if (args.GetY() > chatlineStartY && args.GetY() < chatlineStartY + chatlineSizeY) {
					if (this.chatlines2[i].clickable) {
						this.game.platform.OpenLinkInBrowser(this.chatlines2[i].linkTarget);
					}
				}
			}
		}
	}

	public override void OnNewFrameDraw2d(Game game_, float deltaTime)
	{
		this.game = game_;
		if (this.game.guistate == GuiState.MapLoading) {
			return;
		}
		this.DrawChatLines(this.game.GuiTyping == TypingState.Typing);
		if (this.game.GuiTyping == TypingState.Typing) {
			this.DrawTypingBuffer();
		}
	}
	Chatline[] chatlines2;
	int chatlines2Count;
	FontCi font;
	internal Game game;
	internal float one;
}

public class ModGuiCrafting : ClientMod
{
	public ModGuiCrafting()
	{
		this.handler = new PacketHandlerCraftingRecipes();
		this.handler.mod = this;
	}

	internal void CraftingMouse(Game game)
	{
		if (this.currentRecipes == null) {
			return;
		}
		int menustartx = game.xcenter(600);
		int menustarty = game.ycenter(this.currentRecipesCount * 80);
		if (game.mouseCurrentY >= menustarty && game.mouseCurrentY < menustarty + this.currentRecipesCount * 80) {
			this.craftingselectedrecipe = (game.mouseCurrentY - menustarty) / 80;
		}
		else {
		}
		if (game.mouseleftclick) {
			if (this.currentRecipesCount != 0) {
				this.CraftingRecipeSelected(game, this.craftingTableposx, this.craftingTableposy, this.craftingTableposz, IntRef.Create(this.currentRecipes[this.craftingselectedrecipe]));
			}
			game.mouseleftclick = false;
			game.GuiStateBackToGame();
		}
	}

	internal void CraftingRecipeSelected(Game game, int x, int y, int z, IntRef recipe)
	{
		if (recipe == null) {
			return;
		}
		game.SendPacketClient(ClientPackets.Craft(x, y, z, recipe.value));
	}

	internal void CraftingRecipesStart(Game game, Packet_CraftingRecipe[] recipes, int recipesCount, int[] blocks, int blocksCount, int posx, int posy, int posz)
	{
		this.craftingrecipes2 = recipes;
		this.craftingrecipes2Count = recipesCount;
		this.craftingblocks = blocks;
		this.craftingblocksCount = blocksCount;
		this.craftingTableposx = posx;
		this.craftingTableposy = posy;
		this.craftingTableposz = posz;
		game.guistate = GuiState.CraftingRecipes;
		game.menustate = new MenuState();
		game.SetFreeMouse(true);
	}

	internal void DrawCraftingRecipes(Game game)
	{
		this.currentRecipes = new int[1024];
		this.currentRecipesCount = 0;
		for (int i = 0; i < this.craftingrecipes2Count; i++) {
			Packet_CraftingRecipe r = this.craftingrecipes2[i];
			if (r == null) {
				continue;
			}
			bool next = false;
			for (int k = 0; k < r.IngredientsCount; k++) {
				Packet_Ingredient ingredient = r.Ingredients[k];
				if (ingredient == null) {
					continue;
				}
				if (this.craftingblocksFindAllCount(this.craftingblocks, this.craftingblocksCount, ingredient.Type) < ingredient.Amount) {
					next = true;
					break;
				}
			}
			if (!next) {
				this.currentRecipes[this.currentRecipesCount++] = i;
			}
		}
		int menustartx = game.xcenter(600);
		int menustarty = game.ycenter(this.currentRecipesCount * 80);
		if (this.currentRecipesCount == 0) {
			game.Draw2dText1(game.language.NoMaterialsForCrafting(), game.xcenter(200), game.ycenter(20), 12, null, false);
			return;
		}
		for (int i = 0; i < this.currentRecipesCount; i++) {
			Packet_CraftingRecipe r = this.craftingrecipes2[this.currentRecipes[i]];
			for (int ii = 0; ii < r.IngredientsCount; ii++) {
				int xx = menustartx + 20 + ii * 130;
				int yy = menustarty + i * 80;
				game.Draw2dTexture(game.d_TerrainTextures.terrainTexture(), xx, yy, 32, 32, IntRef.Create(game.TextureIdForInventory[r.Ingredients[ii].Type]), game.texturesPacked(), Game.ColorFromArgb(255, 255, 255, 255), false);
				game.Draw2dText1(game.platform.StringFormat2("{0} {1}", game.platform.IntToString(r.Ingredients[ii].Amount), game.blocktypes[r.Ingredients[ii].Type].Name), xx + 50, yy, 12, IntRef.Create(i == this.craftingselectedrecipe ? Game.ColorFromArgb(255, 255, 0, 0) : Game.ColorFromArgb(255, 255, 255, 255)), false);
			}
			{
				int xx = menustartx + 20 + 400;
				int yy = menustarty + i * 80;
				game.Draw2dTexture(game.d_TerrainTextures.terrainTexture(), xx, yy, 32, 32, IntRef.Create(game.TextureIdForInventory[r.Output.Type]), game.texturesPacked(), Game.ColorFromArgb(255, 255, 255, 255), false);
				game.Draw2dText1(game.platform.StringFormat2("{0} {1}", game.platform.IntToString(r.Output.Amount), game.blocktypes[r.Output.Type].Name), xx + 50, yy, 12, IntRef.Create(i == this.craftingselectedrecipe ? Game.ColorFromArgb(255, 255, 0, 0) : Game.ColorFromArgb(255, 255, 255, 255)), false);
			}
		}
	}

	public override void OnKeyDown(Game game, KeyEventArgs args)
	{
		int eKey = args.GetKeyCode();
		if (eKey == game.GetKey(87) && game.GuiTyping == TypingState.None) {
			if (!(game.SelectedBlockPositionX == -1 && game.SelectedBlockPositionY == -1 && game.SelectedBlockPositionZ == -1)) {
				int posx = game.SelectedBlockPositionX;
				int posy = game.SelectedBlockPositionZ;
				int posz = game.SelectedBlockPositionY;
				if (game.map.GetBlock(posx, posy, posz) == game.d_Data.BlockIdCraftingTable()) {
					IntRef tableCount = new IntRef();
					Vector3IntRef[] table = this.d_CraftingTableTool.GetTable(posx, posy, posz, tableCount);
					IntRef onTableCount = new IntRef();
					int[] onTable = this.d_CraftingTableTool.GetOnTable(table, tableCount.value, onTableCount);
					this.CraftingRecipesStart(game, this.d_CraftingRecipes, this.d_CraftingRecipesCount, onTable, onTableCount.value, posx, posy, posz);
					args.SetHandled(true);
				}
			}
		}
	}

	public override void OnNewFrameDraw2d(Game game, float deltaTime)
	{
		if (this.d_CraftingTableTool == null) {
			this.d_CraftingTableTool = new CraftingTableTool();
			this.d_CraftingTableTool.d_Map = MapStorage2.Create(game);
			this.d_CraftingTableTool.d_Data = game.d_Data;
		}
		game.packetHandlers[30] = this.handler;
		if (game.guistate != GuiState.CraftingRecipes) {
			return;
		}
		this.DrawCraftingRecipes(game);
	}

	public override void OnNewFrameFixed(Game game, NewFrameEventArgs args)
	{
		if (game.guistate != GuiState.CraftingRecipes) {
			return;
		}
		this.CraftingMouse(game);
	}
	internal int craftingTableposx;
	internal int craftingTableposy;
	internal int craftingTableposz;
	internal int[] craftingblocks;
	internal int craftingblocksCount;

	int craftingblocksFindAllCount(int[] craftingblocks_, int craftingblocksCount_, int p)
	{
		int count = 0;
		for (int i = 0; i < craftingblocksCount_; i++) {
			if (craftingblocks_[i] == p) {
				count++;
			}
		}
		return count;
	}
	internal Packet_CraftingRecipe[] craftingrecipes2;
	internal int craftingrecipes2Count;
	internal int craftingselectedrecipe;
	internal int[] currentRecipes;
	internal int currentRecipesCount;
	internal Packet_CraftingRecipe[] d_CraftingRecipes;
	internal int d_CraftingRecipesCount;
	internal CraftingTableTool d_CraftingTableTool;
	PacketHandlerCraftingRecipes handler;
}

public class ModGuiEscapeMenu : ClientMod
{
	public ModGuiEscapeMenu()
	{
		this.one = 1;
		this.fonts = new string[4];
		this.fonts[0] = "Nice";
		this.fonts[1] = "Simple";
		this.fonts[2] = "BlackBackground";
		this.fonts[3] = "Default";
		this.fontsLength = 4;
		this.fontValues = new int[4];
		this.fontValues[0] = 0;
		this.fontValues[1] = 1;
		this.fontValues[2] = 2;
		this.fontValues[3] = 3;
		this.widgets = new Button[1024];
		this.keyselectid = -1;
	}

	void AddWidget(Button b)
	{
		this.widgets[this.widgetsCount++] = b;
	}

	void EscapeMenuMouse1()
	{
		for (int i = 0; i < this.widgetsCount; i++) {
			Button w = this.widgets[i];
			w.selected = this.RectContains(w.x, w.y, w.width, w.height, this.game.mouseCurrentX, this.game.mouseCurrentY);
			if (w.selected && this.game.mouseleftclick) {
				this.HandleButtonClick(w);
				break;
			}
		}
	}

	string FontString()
	{
		return this.fonts[this.game.options.Font];
	}

	void GraphicsHandleClick(Button b)
	{
		OptionsCi options = this.game.options;
		if (b == this.graphicsOptionSmoothShadows) {
			options.Smoothshadows = !options.Smoothshadows;
			this.game.d_TerrainChunkTesselator.EnableSmoothLight = options.Smoothshadows;
			if (options.Smoothshadows) {
				options.BlockShadowSave = this.one * 7 / 10;
				this.game.d_TerrainChunkTesselator.BlockShadow = options.BlockShadowSave;
			}
			else {
				options.BlockShadowSave = this.one * 6 / 10;
				this.game.d_TerrainChunkTesselator.BlockShadow = options.BlockShadowSave;
			}
			this.game.RedrawAllBlocks();
		}
		if (b == this.graphicsOptionDarkenSides) {
			options.EnableBlockShadow = !options.EnableBlockShadow;
			this.game.d_TerrainChunkTesselator.option_DarkenBlockSides = options.EnableBlockShadow;
			this.game.RedrawAllBlocks();
		}
		if (b == this.graphicsViewDistanceOption) {
			this.game.ToggleFog();
		}
		if (b == this.graphicsOptionFramerate) {
			this.game.ToggleVsync();
		}
		if (b == this.graphicsOptionResolution) {
			this.ToggleResolution();
		}
		if (b == this.graphicsOptionFullscreen) {
			options.Fullscreen = !options.Fullscreen;
		}
		if (b == this.graphicsUseServerTexturesOption) {
			options.UseServerTextures = !options.UseServerTextures;
		}
		if (b == this.graphicsFontOption) {
			this.ToggleFont();
		}
		if (b == this.graphicsReturnToOptionsMenu) {
			this.UseFullscreen();
			this.UseResolution();
			this.SetEscapeMenuState(EscapeMenuState.Options);
		}
	}

	void GraphicsSet()
	{
		OptionsCi options = this.game.options;
		Language language = this.game.language;
		this.graphicsOptionSmoothShadows = new Button();
		this.graphicsOptionSmoothShadows.Text = this.game.platform.StringFormat(language.OptionSmoothShadows(), options.Smoothshadows ? language.On() : language.Off());
		this.graphicsOptionDarkenSides = new Button();
		this.graphicsOptionDarkenSides.Text = this.game.platform.StringFormat(language.Get("OptionDarkenSides"), options.EnableBlockShadow ? language.On() : language.Off());
		this.graphicsViewDistanceOption = new Button();
		this.graphicsViewDistanceOption.Text = this.game.platform.StringFormat(language.ViewDistanceOption(), this.game.platform.IntToString(this.game.platform.FloatToInt(this.game.d_Config3d.viewdistance)));
		this.graphicsOptionFramerate = new Button();
		this.graphicsOptionFramerate.Text = this.game.platform.StringFormat(language.OptionFramerate(), this.VsyncString());
		this.graphicsOptionResolution = new Button();
		this.graphicsOptionResolution.Text = this.game.platform.StringFormat(language.OptionResolution(), this.ResolutionString());
		this.graphicsOptionFullscreen = new Button();
		this.graphicsOptionFullscreen.Text = this.game.platform.StringFormat(language.OptionFullscreen(), options.Fullscreen ? language.On() : language.Off());
		this.graphicsUseServerTexturesOption = new Button();
		this.graphicsUseServerTexturesOption.Text = this.game.platform.StringFormat(language.UseServerTexturesOption(), options.UseServerTextures ? language.On() : language.Off());
		this.graphicsFontOption = new Button();
		this.graphicsFontOption.Text = this.game.platform.StringFormat(language.FontOption(), this.FontString());
		this.graphicsReturnToOptionsMenu = new Button();
		this.graphicsReturnToOptionsMenu.Text = language.ReturnToOptionsMenu();
		this.WidgetsClear();
		this.AddWidget(this.graphicsOptionSmoothShadows);
		this.AddWidget(this.graphicsOptionDarkenSides);
		this.AddWidget(this.graphicsViewDistanceOption);
		this.AddWidget(this.graphicsOptionFramerate);
		this.AddWidget(this.graphicsOptionResolution);
		this.AddWidget(this.graphicsOptionFullscreen);
		this.AddWidget(this.graphicsUseServerTexturesOption);
		this.AddWidget(this.graphicsFontOption);
		this.AddWidget(this.graphicsReturnToOptionsMenu);
	}

	void HandleButtonClick(Button w)
	{
		this.MainHandleClick(w);
		this.OptionsHandleClick(w);
		this.GraphicsHandleClick(w);
		this.OtherHandleClick(w);
		this.KeysHandleClick(w);
	}

	KeyHelp KeyHelpCreate(string text, int defaultKey)
	{
		KeyHelp h = new KeyHelp();
		h.Text = text;
		h.DefaultKey = defaultKey;
		return h;
	}

	string KeyName(int key)
	{
		return this.game.platform.KeyName(key);
	}

	void KeysHandleClick(Button b)
	{
		if (this.keyButtons != null) {
			for (int i = 0; i < 1024; i++) {
				if (this.keyButtons[i] == b) {
					this.keyselectid = i;
				}
			}
		}
		if (b == this.keysDefaultKeys) {
			this.game.options.Keys = new int[256];
		}
		if (b == this.keysReturnToOptionsMenu) {
			this.SetEscapeMenuState(EscapeMenuState.Options);
		}
	}

	void KeysSet()
	{
		Language language = this.game.language;
		this.keyButtons = new Button[1024];
		for (int i = 0; i < 1024; i++) {
			this.keyButtons[i] = null;
		}
		KeyHelp[] helps = this.keyhelps();
		for (int i = 0; i < 1024; i++) {
			if (helps[i] == null) {
				break;
			}
			int defaultkey = helps[i].DefaultKey;
			int key = defaultkey;
			if (this.game.options.Keys[defaultkey] != 0) {
				key = this.game.options.Keys[defaultkey];
			}
			this.keyButtons[i] = new Button();
			this.keyButtons[i].Text = this.game.platform.StringFormat2(language.KeyChange(), helps[i].Text, this.KeyName(key));
			this.AddWidget(this.keyButtons[i]);
		}
		this.keysDefaultKeys = new Button();
		this.keysDefaultKeys.Text = language.DefaultKeys();
		this.keysReturnToOptionsMenu = new Button();
		this.keysReturnToOptionsMenu.Text = language.ReturnToOptionsMenu();
		this.AddWidget(this.keysDefaultKeys);
		this.AddWidget(this.keysReturnToOptionsMenu);
	}

	public void LoadOptions()
	{
		OptionsCi o = this.LoadOptions_();
		if (o == null) {
			return;
		}
		this.game.options = o;
		OptionsCi options = o;
		this.game.Font = this.fontValues[options.Font];
		this.game.UpdateTextRendererFont();
		this.game.d_Config3d.viewdistance = options.DrawDistance;
		this.game.AudioEnabled = options.EnableSound;
		this.game.AutoJumpEnabled = options.EnableAutoJump;
		if (options.ClientLanguage != "") {
			this.game.language.OverrideLanguage = options.ClientLanguage;
		}
		this.game.d_TerrainChunkTesselator.EnableSmoothLight = options.Smoothshadows;
		this.game.d_TerrainChunkTesselator.BlockShadow = options.BlockShadowSave;
		this.game.d_TerrainChunkTesselator.option_DarkenBlockSides = options.EnableBlockShadow;
		this.game.ENABLE_LAG = options.Framerate;
		this.UseFullscreen();
		this.game.UseVsync();
		this.UseResolution();
	}

	OptionsCi LoadOptions_()
	{
		OptionsCi options = new OptionsCi();
		Preferences preferences = this.game.platform.GetPreferences();
		options.Shadows = preferences.GetBool("Shadows", true);
		options.Font = preferences.GetInt("Font", 0);
		options.DrawDistance = preferences.GetInt("DrawDistance", this.game.platform.IsFastSystem() ? 128 : 32);
		options.UseServerTextures = preferences.GetBool("UseServerTextures", true);
		options.EnableSound = preferences.GetBool("EnableSound", true);
		options.EnableAutoJump = preferences.GetBool("EnableAutoJump", false);
		options.ClientLanguage = preferences.GetString("ClientLanguage", "");
		options.Framerate = preferences.GetInt("Framerate", 0);
		options.Resolution = preferences.GetInt("Resolution", 0);
		options.Fullscreen = preferences.GetBool("Fullscreen", false);
		options.Smoothshadows = preferences.GetBool("Smoothshadows", true);
		options.BlockShadowSave = this.one * preferences.GetInt("BlockShadowSave", 70) / 100;
		options.EnableBlockShadow = preferences.GetBool("EnableBlockShadow", true);
		for (int i = 0; i < 256; i++) {
			string preferencesKey = StringTools.StringAppend(this.game.platform, "Key", this.game.platform.IntToString(i));
			int value = preferences.GetInt(preferencesKey, 0);
			if (value != 0) {
				options.Keys[i] = value;
			}
		}
		return options;
	}

	void MainHandleClick(Button b)
	{
		if (b == this.buttonMainReturnToGame) {
			this.game.GuiStateBackToGame();
		}
		if (b == this.buttonMainOptions) {
			this.SetEscapeMenuState(EscapeMenuState.Options);
		}
		if (b == this.buttonMainExit) {
			this.game.SendLeave(0);
			this.game.ExitToMainMenu_();
		}
	}

	void MainSet()
	{
		Language language = this.game.language;
		this.buttonMainReturnToGame = new Button();
		this.buttonMainReturnToGame.Text = language.ReturnToGame();
		this.buttonMainOptions = new Button();
		this.buttonMainOptions.Text = language.Options();
		this.buttonMainExit = new Button();
		this.buttonMainExit.Text = language.Exit();
		this.WidgetsClear();
		this.AddWidget(this.buttonMainReturnToGame);
		this.AddWidget(this.buttonMainOptions);
		this.AddWidget(this.buttonMainExit);
	}

	void MakeSimpleOptions(int fontsize, int textheight)
	{
		int starty = this.game.ycenter(this.widgetsCount * textheight);
		for (int i = 0; i < this.widgetsCount; i++) {
			string s = this.widgets[i].Text;
			float sizeWidth = this.game.TextSizeWidth(s, fontsize);
			float sizeHeight = this.game.TextSizeHeight(s, fontsize);
			int Width = this.game.platform.FloatToInt(sizeWidth) + 10;
			int Height = this.game.platform.FloatToInt(sizeHeight);
			int X = this.game.xcenter(sizeWidth);
			int Y = starty + textheight * i;
			this.widgets[i].x = X;
			this.widgets[i].y = Y;
			this.widgets[i].width = Width;
			this.widgets[i].height = Height;
			this.widgets[i].fontsize = fontsize;
			if (i == this.keyselectid) {
				this.widgets[i].fontcolor = Game.ColorFromArgb(255, 0, 255, 0);
				this.widgets[i].fontcolorselected = Game.ColorFromArgb(255, 0, 255, 0);
			}
		}
	}

	public override void OnKeyDown(Game game_, KeyEventArgs args)
	{
		int eKey = args.GetKeyCode();
		if (eKey == this.game.GetKey(50)) {
			if (this.escapemenustate == EscapeMenuState.Graphics || this.escapemenustate == EscapeMenuState.Keys || this.escapemenustate == EscapeMenuState.Other) {
				this.SetEscapeMenuState(EscapeMenuState.Options);
			}
			else if (this.escapemenustate == EscapeMenuState.Options) {
				this.SaveOptions();
				this.SetEscapeMenuState(EscapeMenuState.Main);
			}
			else {
				this.SetEscapeMenuState(EscapeMenuState.Main);
				this.game.GuiStateBackToGame();
			}
			args.SetHandled(true);
		}
		if (this.escapemenustate == EscapeMenuState.Keys) {
			if (this.keyselectid != -1) {
				this.game.options.Keys[this.keyhelps()[this.keyselectid].DefaultKey] = eKey;
				this.keyselectid = -1;
				args.SetHandled(true);
			}
		}
		if (eKey == this.game.GetKey(20)) {
			if (this.game.platform.GetWindowState() == WindowState.Fullscreen) {
				this.game.platform.SetWindowState(WindowState.Normal);
				this.RestoreResolution();
				this.SaveOptions();
			}
			else {
				this.game.platform.SetWindowState(WindowState.Fullscreen);
				this.UseResolution();
				this.SaveOptions();
			}
			args.SetHandled(true);
		}
	}

	public override void OnNewFrameDraw2d(Game game_, float deltaTime)
	{
		this.game = game_;
		if (!this.loaded) {
			this.loaded = true;
			this.LoadOptions();
		}
		if (this.game.escapeMenuRestart) {
			this.game.escapeMenuRestart = false;
			this.SetEscapeMenuState(EscapeMenuState.Main);
		}
		if (this.game.guistate != GuiState.EscapeMenu) {
			return;
		}
		this.SetEscapeMenuState(this.escapemenustate);
		this.EscapeMenuMouse1();
		for (int i = 0; i < this.widgetsCount; i++) {
			Button w = this.widgets[i];
			this.game.Draw2dText1(w.Text, w.x, w.y, w.fontsize, IntRef.Create(w.selected ? w.fontcolorselected : w.fontcolor), false);
		}
	}

	void OptionsHandleClick(Button b)
	{
		if (b == this.optionsGraphics) {
			this.SetEscapeMenuState(EscapeMenuState.Graphics);
		}
		if (b == this.optionsKeys) {
			this.SetEscapeMenuState(EscapeMenuState.Keys);
		}
		if (b == this.optionsOther) {
			this.SetEscapeMenuState(EscapeMenuState.Other);
		}
		if (b == this.optionsReturnToMainMenu) {
			this.SaveOptions();
			this.SetEscapeMenuState(EscapeMenuState.Main);
		}
	}

	void OptionsSet()
	{
		Language language = this.game.language;
		this.optionsGraphics = new Button();
		this.optionsGraphics.Text = language.Graphics();
		this.optionsKeys = new Button();
		this.optionsKeys.Text = language.Keys();
		this.optionsOther = new Button();
		this.optionsOther.Text = language.Other();
		this.optionsReturnToMainMenu = new Button();
		this.optionsReturnToMainMenu.Text = language.ReturnToMainMenu();
		this.WidgetsClear();
		this.AddWidget(this.optionsGraphics);
		this.AddWidget(this.optionsKeys);
		this.AddWidget(this.optionsOther);
		this.AddWidget(this.optionsReturnToMainMenu);
	}

	void OtherHandleClick(Button b)
	{
		if (b == this.otherSoundOption) {
			this.game.AudioEnabled = !this.game.AudioEnabled;
		}
		if (b == this.otherAutoJumpOption) {
			this.game.AutoJumpEnabled = !this.game.AutoJumpEnabled;
		}
		if (b == this.otherLanguageSetting) {
			this.game.language.NextLanguage();
		}
		if (b == this.otherReturnToOptionsMenu) {
			this.SetEscapeMenuState(EscapeMenuState.Options);
		}
	}

	void OtherSet()
	{
		Language language = this.game.language;
		this.otherSoundOption = new Button();
		this.otherSoundOption.Text = this.game.platform.StringFormat(language.SoundOption(), this.game.AudioEnabled ? language.On() : language.Off());
		this.otherAutoJumpOption = new Button();
		this.otherAutoJumpOption.Text = this.game.platform.StringFormat(language.AutoJumpOption(), this.game.AutoJumpEnabled ? language.On() : language.Off());
		this.otherLanguageSetting = new Button();
		this.otherLanguageSetting.Text = this.game.platform.StringFormat(language.ClientLanguageOption(), language.GetUsedLanguage());
		this.otherReturnToOptionsMenu = new Button();
		this.otherReturnToOptionsMenu.Text = language.ReturnToOptionsMenu();
		this.WidgetsClear();
		this.AddWidget(this.otherSoundOption);
		this.AddWidget(this.otherAutoJumpOption);
		this.AddWidget(this.otherLanguageSetting);
		this.AddWidget(this.otherReturnToOptionsMenu);
	}

	bool RectContains(int x, int y, int w, int h, int px, int py)
	{
		return px >= x && py >= y && px < x + w && py < y + h;
	}

	string ResolutionString()
	{
		IntRef resolutionsCount = new IntRef();
		DisplayResolutionCi res = this.game.platform.GetDisplayResolutions(resolutionsCount)[this.game.options.Resolution];
		return this.game.platform.StringFormat4("{0}x{1}, {2}, {3} Hz", this.game.platform.IntToString(res.Width), this.game.platform.IntToString(res.Height), this.game.platform.IntToString(res.BitsPerPixel), this.game.platform.IntToString(this.game.platform.FloatToInt(res.RefreshRate)));
	}

	public void RestoreResolution()
	{
		if (this.changedResolution) {
			this.game.platform.ChangeResolution(this.originalResolutionWidth, this.originalResolutionHeight, 32, -1);
			this.changedResolution = false;
		}
	}

	public void SaveOptions()
	{
		OptionsCi options = this.game.options;
		options.Font = this.game.Font;
		options.Shadows = true;
		options.DrawDistance = this.game.platform.FloatToInt(this.game.d_Config3d.viewdistance);
		options.EnableSound = this.game.AudioEnabled;
		options.EnableAutoJump = this.game.AutoJumpEnabled;
		if (this.game.language.OverrideLanguage != null) {
			options.ClientLanguage = this.game.language.OverrideLanguage;
		}
		options.Framerate = this.game.ENABLE_LAG;
		options.Fullscreen = this.game.platform.GetWindowState() == WindowState.Fullscreen;
		options.Smoothshadows = this.game.d_TerrainChunkTesselator.EnableSmoothLight;
		options.EnableBlockShadow = this.game.d_TerrainChunkTesselator.option_DarkenBlockSides;
		this.SaveOptions_(options);
	}

	void SaveOptions_(OptionsCi options)
	{
		Preferences preferences = this.game.platform.GetPreferences();
		preferences.SetBool("Shadows", options.Shadows);
		preferences.SetInt("Font", options.Font);
		preferences.SetInt("DrawDistance", options.DrawDistance);
		preferences.SetBool("UseServerTextures", options.UseServerTextures);
		preferences.SetBool("EnableSound", options.EnableSound);
		preferences.SetBool("EnableAutoJump", options.EnableAutoJump);
		if (options.ClientLanguage != "") {
			preferences.SetString("ClientLanguage", options.ClientLanguage);
		}
		preferences.SetInt("Framerate", options.Framerate);
		preferences.SetInt("Resolution", options.Resolution);
		preferences.SetBool("Fullscreen", options.Fullscreen);
		preferences.SetBool("Smoothshadows", options.Smoothshadows);
		preferences.SetInt("BlockShadowSave", this.game.platform.FloatToInt(options.BlockShadowSave * 100));
		preferences.SetBool("EnableBlockShadow", options.EnableBlockShadow);
		for (int i = 0; i < 256; i++) {
			int value = options.Keys[i];
			string preferencesKey = StringTools.StringAppend(this.game.platform, "Key", this.game.platform.IntToString(i));
			if (value != 0) {
				preferences.SetInt(preferencesKey, value);
			}
			else {
				preferences.Remove(preferencesKey);
			}
		}
		this.game.platform.SetPreferences(preferences);
	}

	void SetEscapeMenuState(EscapeMenuState state)
	{
		Language language = this.game.language;
		this.escapemenustate = state;
		this.WidgetsClear();
		if (state == EscapeMenuState.Main) {
			this.MainSet();
			this.MakeSimpleOptions(20, 50);
		}
		else if (state == EscapeMenuState.Options) {
			this.OptionsSet();
			this.MakeSimpleOptions(20, 50);
		}
		else if (state == EscapeMenuState.Graphics) {
			this.GraphicsSet();
			this.MakeSimpleOptions(20, 50);
		}
		else if (state == EscapeMenuState.Other) {
			this.OtherSet();
			this.MakeSimpleOptions(20, 50);
		}
		else if (state == EscapeMenuState.Keys) {
			this.KeysSet();
			int fontsize = 12;
			int textheight = 20;
			this.MakeSimpleOptions(fontsize, textheight);
		}
	}

	void ToggleFont()
	{
		OptionsCi options = this.game.options;
		options.Font++;
		if (options.Font >= this.fontsLength) {
			options.Font = 0;
		}
		this.game.Font = this.fontValues[options.Font];
		this.game.UpdateTextRendererFont();
		for (int i = 0; i < this.game.cachedTextTexturesMax; i++) {
			this.game.cachedTextTextures[i] = null;
		}
	}

	void ToggleResolution()
	{
		OptionsCi options = this.game.options;
		options.Resolution++;
		IntRef resolutionsCount = new IntRef();
		this.game.platform.GetDisplayResolutions(resolutionsCount);
		if (options.Resolution >= resolutionsCount.value) {
			options.Resolution = 0;
		}
	}

	void UseFullscreen()
	{
		if (this.game.options.Fullscreen) {
			if (!this.changedResolution) {
				this.originalResolutionWidth = this.game.platform.GetDisplayResolutionDefault().Width;
				this.originalResolutionHeight = this.game.platform.GetDisplayResolutionDefault().Height;
				this.changedResolution = true;
			}
			this.game.platform.SetWindowState(WindowState.Fullscreen);
			this.UseResolution();
		}
		else {
			this.game.platform.SetWindowState(WindowState.Normal);
			this.RestoreResolution();
		}
	}

	public void UseResolution()
	{
		OptionsCi options = this.game.options;
		IntRef resolutionsCount = new IntRef();
		DisplayResolutionCi[] resolutions = this.game.platform.GetDisplayResolutions(resolutionsCount);
		if (resolutions == null) {
			return;
		}
		if (options.Resolution >= resolutionsCount.value) {
			options.Resolution = 0;
		}
		DisplayResolutionCi res = resolutions[options.Resolution];
		if (this.game.platform.GetWindowState() == WindowState.Fullscreen) {
			this.game.platform.ChangeResolution(res.Width, res.Height, res.BitsPerPixel, res.RefreshRate);
			this.game.platform.SetWindowState(WindowState.Normal);
			this.game.platform.SetWindowState(WindowState.Fullscreen);
		}
		else {
		}
	}

	string VsyncString()
	{
		if (this.game.ENABLE_LAG == 0) {
			return "Vsync";
		}
		else if (this.game.ENABLE_LAG == 1) {
			return "Unlimited";
		}
		else if (this.game.ENABLE_LAG == 2) {
			return "Lag";
		}
		else
			return null;
	}

	void WidgetsClear()
	{
		this.widgetsCount = 0;
	}
	Button buttonMainExit;
	Button buttonMainOptions;
	Button buttonMainReturnToGame;
	bool changedResolution;
	EscapeMenuState escapemenustate;
	int[] fontValues;
	string[] fonts;
	int fontsLength;
	internal Game game;
	Button graphicsFontOption;
	Button graphicsOptionDarkenSides;
	Button graphicsOptionFramerate;
	Button graphicsOptionFullscreen;
	Button graphicsOptionResolution;
	Button graphicsOptionSmoothShadows;
	Button graphicsReturnToOptionsMenu;
	Button graphicsUseServerTexturesOption;
	Button graphicsViewDistanceOption;
	Button[] keyButtons;

	KeyHelp[] keyhelps()
	{
		int n = 1024;
		KeyHelp[] helps = new KeyHelp[n];
		for (int i = 0; i < n; i++) {
			helps[i] = null;
		}
		Language language = this.game.language;
		int count = 0;
		helps[count++] = this.KeyHelpCreate(language.KeyMoveFoward(), 105);
		helps[count++] = this.KeyHelpCreate(language.KeyMoveBack(), 101);
		helps[count++] = this.KeyHelpCreate(language.KeyMoveLeft(), 83);
		helps[count++] = this.KeyHelpCreate(language.KeyMoveRight(), 86);
		helps[count++] = this.KeyHelpCreate(language.KeyJump(), 51);
		helps[count++] = this.KeyHelpCreate(language.KeyShowMaterialSelector(), 84);
		helps[count++] = this.KeyHelpCreate(language.KeySetSpawnPosition(), 98);
		helps[count++] = this.KeyHelpCreate(language.KeyRespawn(), 97);
		helps[count++] = this.KeyHelpCreate(language.KeyReloadWeapon(), 100);
		helps[count++] = this.KeyHelpCreate(language.KeyToggleFogDistance(), 88);
		helps[count++] = this.KeyHelpCreate(this.game.platform.StringFormat(language.KeyMoveSpeed(), "1"), 10);
		helps[count++] = this.KeyHelpCreate(this.game.platform.StringFormat(language.KeyMoveSpeed(), "10"), 11);
		helps[count++] = this.KeyHelpCreate(language.KeyFreeMove(), 12);
		helps[count++] = this.KeyHelpCreate(language.KeyThirdPersonCamera(), 14);
		helps[count++] = this.KeyHelpCreate(language.KeyTextEditor(), 18);
		helps[count++] = this.KeyHelpCreate(language.KeyFullscreen(), 20);
		helps[count++] = this.KeyHelpCreate(language.KeyScreenshot(), 21);
		helps[count++] = this.KeyHelpCreate(language.KeyPlayersList(), 52);
		helps[count++] = this.KeyHelpCreate(language.KeyChat(), 102);
		helps[count++] = this.KeyHelpCreate(language.KeyTeamChat(), 107);
		helps[count++] = this.KeyHelpCreate(language.KeyCraft(), 85);
		helps[count++] = this.KeyHelpCreate(language.KeyBlockInfo(), 91);
		helps[count++] = this.KeyHelpCreate(language.KeyUse(), 87);
		helps[count++] = this.KeyHelpCreate(language.KeyReverseMinecart(), 99);
		return helps;
	}
	Button keysDefaultKeys;
	Button keysReturnToOptionsMenu;
	int keyselectid;
	bool loaded;
	float one;
	Button optionsGraphics;
	Button optionsKeys;
	Button optionsOther;
	Button optionsReturnToMainMenu;
	int originalResolutionHeight;
	int originalResolutionWidth;
	Button otherAutoJumpOption;
	Button otherLanguageSetting;
	Button otherReturnToOptionsMenu;
	Button otherSoundOption;
	Button[] widgets;
	int widgetsCount;
}

public class ModGuiInventory : ClientMod
{
	public ModGuiInventory()
	{
		this.wearPlaceStart = new PointRef[5];
		{
			this.wearPlaceStart[0] = PointRef.Create(34, 100);
			this.wearPlaceStart[1] = PointRef.Create(74, 100);
			this.wearPlaceStart[2] = PointRef.Create(194, 100);
			this.wearPlaceStart[3] = PointRef.Create(114, 100);
			this.wearPlaceStart[4] = PointRef.Create(154, 100);
		}
		this.wearPlaceCells = new PointRef[5];
		{
			this.wearPlaceCells[0] = PointRef.Create(1, 1);
			this.wearPlaceCells[1] = PointRef.Create(1, 1);
			this.wearPlaceCells[2] = PointRef.Create(1, 1);
			this.wearPlaceCells[3] = PointRef.Create(1, 1);
			this.wearPlaceCells[4] = PointRef.Create(1, 1);
		}
		this.CellCountInPageX = 12;
		this.CellCountInPageY = 7;
		this.CellCountTotalX = 12;
		this.CellCountTotalY = 42;
		this.CellDrawSize = 40;
	}

	public int ActiveMaterialCellSize()
	{
		return this.game.platform.FloatToInt(48 * this.game.Scale());
	}
	int CellCountInPageX;
	int CellCountInPageY;
	int CellCountTotalX;
	int CellCountTotalY;
	internal int CellDrawSize;

	public int CellsStartX()
	{
		return 33 + this.InventoryStartX();
	}

	public int CellsStartY()
	{
		return 180 + this.InventoryStartY();
	}

	void DrawItem(int screenposX, int screenposY, Packet_Item item, int drawsizeX, int drawsizeY)
	{
		if (item == null) {
			return;
		}
		int sizex = this.dataItems.ItemSizeX(item);
		int sizey = this.dataItems.ItemSizeY(item);
		if (drawsizeX == 0 || drawsizeX == -1) {
			drawsizeX = this.CellDrawSize * sizex;
			drawsizeY = this.CellDrawSize * sizey;
		}
		if (item.ItemClass == 0) {
			if (item.BlockId == 0) {
				return;
			}
			this.game.Draw2dTexture(this.game.terrainTexture, screenposX, screenposY, drawsizeX, drawsizeY, IntRef.Create(this.dataItems.TextureIdForInventory()[item.BlockId]), this.game.texturesPacked(), Game.ColorFromArgb(255, 255, 255, 255), false);
			if (item.BlockCount > 1) {
				FontCi font = new FontCi();
				font.size = 8;
				font.family = "Arial";
				this.game.Draw2dText(this.game.platform.IntToString(item.BlockCount), font, screenposX, screenposY, null, false);
			}
		}
		else {
			this.game.Draw2dBitmapFile(this.dataItems.ItemGraphics(item), screenposX, screenposY, drawsizeX, drawsizeY);
		}
	}

	public void DrawItemInfo(int screenposX, int screenposY, Packet_Item item)
	{
		int sizex = this.dataItems.ItemSizeX(item);
		int sizey = this.dataItems.ItemSizeY(item);
		IntRef tw = new IntRef();
		IntRef th = new IntRef();
		float one = 1;
		this.game.platform.TextSize(this.dataItems.ItemInfo(item), 11 + one / 2, tw, th);
		tw.value += 6;
		th.value += 4;
		int w = this.game.platform.FloatToInt(tw.value + this.CellDrawSize * sizex);
		int h = this.game.platform.FloatToInt(th.value < this.CellDrawSize * sizey ? this.CellDrawSize * sizey + 4 : th.value);
		if (screenposX < w + 20) {
			screenposX = w + 20;
		}
		if (screenposY < h + 20) {
			screenposY = h + 20;
		}
		if (screenposX > this.game.Width() - (w + 20)) {
			screenposX = this.game.Width() - (w + 20);
		}
		if (screenposY > this.game.Height() - (h + 20)) {
			screenposY = this.game.Height() - (h + 20);
		}
		this.game.Draw2dTexture(this.game.WhiteTexture(), screenposX - w, screenposY - h, w, h, null, 0, Game.ColorFromArgb(255, 0, 0, 0), false);
		this.game.Draw2dTexture(this.game.WhiteTexture(), screenposX - w + 2, screenposY - h + 2, w - 4, h - 4, null, 0, Game.ColorFromArgb(255, 105, 105, 105), false);
		FontCi font = new FontCi();
		font.family = "Arial";
		font.size = 10;
		this.game.Draw2dText(this.dataItems.ItemInfo(item), font, screenposX - tw.value + 4, screenposY - h + 2, null, false);
		Packet_Item item2 = new Packet_Item();
		item2.BlockId = item.BlockId;
		this.DrawItem(screenposX - w + 2, screenposY - h + 2, item2, 0, 0);
	}

	public void DrawMaterialSelector()
	{
		this.game.Draw2dBitmapFile("materials.png", this.MaterialSelectorBackgroundStartX(), this.MaterialSelectorBackgroundStartY(), this.game.platform.FloatToInt(1024 * this.game.Scale()), this.game.platform.FloatToInt(128 * this.game.Scale()));
		int materialSelectorStartX_ = this.MaterialSelectorStartX();
		int materialSelectorStartY_ = this.MaterialSelectorStartY();
		for (int i = 0; i < 10; i++) {
			Packet_Item item = this.game.d_Inventory.RightHand[i];
			if (item != null) {
				this.DrawItem(materialSelectorStartX_ + i * this.ActiveMaterialCellSize(), materialSelectorStartY_, item, this.ActiveMaterialCellSize(), this.ActiveMaterialCellSize());
			}
		}
		this.game.Draw2dBitmapFile("activematerial.png", this.MaterialSelectorStartX() + this.ActiveMaterialCellSize() * this.game.ActiveMaterial, this.MaterialSelectorStartY(), this.ActiveMaterialCellSize() * 64 / 48, this.ActiveMaterialCellSize() * 64 / 48);
	}

	Packet_Item GetItem(Packet_Inventory inventory, int x, int y)
	{
		for (int i = 0; i < inventory.ItemsCount; i++) {
			if (inventory.Items[i].X == x && inventory.Items[i].Y == y) {
				return inventory.Items[i].Value_;
			}
		}
		return null;
	}

	public int InventoryStartX()
	{
		return this.game.Width() / 2 - 280;
	}

	public int InventoryStartY()
	{
		return this.game.Height() / 2 - 300;
	}

	public bool IsMouseOverCells()
	{
		return this.SelectedCellOrScrollbar(this.game.mouseCurrentX, this.game.mouseCurrentY);
	}

	int MaterialSelectorBackgroundStartX()
	{
		return this.game.platform.FloatToInt(this.game.Width() / 2 - 256 * this.game.Scale());
	}

	int MaterialSelectorBackgroundStartY()
	{
		return this.game.platform.FloatToInt(this.game.Height() - 90 * this.game.Scale());
	}

	int MaterialSelectorStartX()
	{
		return this.game.platform.FloatToInt(this.MaterialSelectorBackgroundStartX() + 17 * this.game.Scale());
	}

	int MaterialSelectorStartY()
	{
		return this.game.platform.FloatToInt(this.MaterialSelectorBackgroundStartY() + 17 * this.game.Scale());
	}

	public override void OnKeyPress(Game game_, KeyPressEventArgs args)
	{
		if (this.game.guistate != GuiState.Inventory) {
			return;
		}
		int keyChar = args.GetKeyChar();
		if (keyChar == 49) {
			this.game.ActiveMaterial = 0;
		}
		if (keyChar == 50) {
			this.game.ActiveMaterial = 1;
		}
		if (keyChar == 51) {
			this.game.ActiveMaterial = 2;
		}
		if (keyChar == 52) {
			this.game.ActiveMaterial = 3;
		}
		if (keyChar == 53) {
			this.game.ActiveMaterial = 4;
		}
		if (keyChar == 54) {
			this.game.ActiveMaterial = 5;
		}
		if (keyChar == 55) {
			this.game.ActiveMaterial = 6;
		}
		if (keyChar == 56) {
			this.game.ActiveMaterial = 7;
		}
		if (keyChar == 57) {
			this.game.ActiveMaterial = 8;
		}
		if (keyChar == 48) {
			this.game.ActiveMaterial = 9;
		}
	}

	public override void OnMouseDown(Game game_, MouseEventArgs args)
	{
		if (this.game.guistate != GuiState.Inventory) {
			return;
		}
		PointRef scaledMouse = PointRef.Create(args.GetX(), args.GetY());
		if (this.SelectedMaterialSelectorSlot(scaledMouse) != null) {
			this.game.ActiveMaterial = this.SelectedMaterialSelectorSlot(scaledMouse).value;
			{
				Packet_InventoryPosition p = new Packet_InventoryPosition();
				p.Type = 2;
				p.MaterialId = this.game.ActiveMaterial;
				this.controller.InventoryClick(p);
			}
			args.SetHandled(true);
			return;
		}
		if (this.game.guistate != GuiState.Inventory) {
			return;
		}
		PointRef cellInPage = this.SelectedCell(scaledMouse);
		if (cellInPage != null) {
			if (args.GetButton() == 0) {
				Packet_InventoryPosition p = new Packet_InventoryPosition();
				p.Type = 0;
				p.AreaX = cellInPage.X;
				p.AreaY = cellInPage.Y + this.ScrollLine;
				this.controller.InventoryClick(p);
				args.SetHandled(true);
				return;
			}
			else {
				{
					Packet_InventoryPosition p = new Packet_InventoryPosition();
					p.Type = 0;
					p.AreaX = cellInPage.X;
					p.AreaY = cellInPage.Y + this.ScrollLine;
					this.controller.InventoryClick(p);
				}
				{
					Packet_InventoryPosition p = new Packet_InventoryPosition();
					p.Type = 3;
					p.WearPlace = 0;
					p.ActiveMaterial = this.game.ActiveMaterial;
					this.controller.InventoryClick(p);
				}
				{
					Packet_InventoryPosition p = new Packet_InventoryPosition();
					p.Type = 0;
					p.AreaX = cellInPage.X;
					p.AreaY = cellInPage.Y + this.ScrollLine;
					this.controller.InventoryClick(p);
				}
			}
			if (this.game.guistate == GuiState.Inventory) {
				args.SetHandled(true);
				return;
			}
		}
		if (this.SelectedWearPlace(scaledMouse) != null) {
			Packet_InventoryPosition p = new Packet_InventoryPosition();
			p.Type = 3;
			p.WearPlace = this.SelectedWearPlace(scaledMouse).value;
			p.ActiveMaterial = this.game.ActiveMaterial;
			this.controller.InventoryClick(p);
			args.SetHandled(true);
			return;
		}
		if (scaledMouse.X >= this.ScrollUpButtonX() && scaledMouse.X < this.ScrollUpButtonX() + this.ScrollButtonSize() && scaledMouse.Y >= this.ScrollUpButtonY() && scaledMouse.Y < this.ScrollUpButtonY() + this.ScrollButtonSize()) {
			this.ScrollUp();
			this.ScrollingUpTimeMilliseconds = this.game.platform.TimeMillisecondsFromStart();
			args.SetHandled(true);
			return;
		}
		if (scaledMouse.X >= this.ScrollDownButtonX() && scaledMouse.X < this.ScrollDownButtonX() + this.ScrollButtonSize() && scaledMouse.Y >= this.ScrollDownButtonY() && scaledMouse.Y < this.ScrollDownButtonY() + this.ScrollButtonSize()) {
			this.ScrollDown();
			this.ScrollingDownTimeMilliseconds = this.game.platform.TimeMillisecondsFromStart();
			args.SetHandled(true);
			return;
		}
		this.game.GuiStateBackToGame();
		return;
	}

	public override void OnMouseUp(Game game_, MouseEventArgs args)
	{
		if (this.game.guistate != GuiState.Inventory) {
			return;
		}
		this.ScrollingUpTimeMilliseconds = 0;
		this.ScrollingDownTimeMilliseconds = 0;
	}

	public override void OnMouseWheelChanged(Game game_, MouseWheelEventArgs args)
	{
		float delta = args.GetDeltaPrecise();
		if ((game_.guistate == GuiState.Normal || game_.guistate == GuiState.Inventory && !this.IsMouseOverCells()) && !game_.keyboardState[game_.GetKey(1)]) {
			game_.ActiveMaterial -= game_.platform.FloatToInt(delta);
			game_.ActiveMaterial = game_.ActiveMaterial % 10;
			while (game_.ActiveMaterial < 0) {
				game_.ActiveMaterial += 10;
			}
		}
		if (this.IsMouseOverCells() && this.game.guistate == GuiState.Inventory) {
			if (delta > 0) {
				this.ScrollUp();
			}
			if (delta < 0) {
				this.ScrollDown();
			}
		}
	}

	public override void OnNewFrameDraw2d(Game game_, float deltaTime)
	{
		this.game = game_;
		if (this.dataItems == null) {
			this.dataItems = new GameDataItemsClient();
			this.dataItems.game = game_;
			this.controller = ClientInventoryController.Create(game_);
			this.inventoryUtil = this.game.d_InventoryUtil;
		}
		if (this.game.guistate == GuiState.MapLoading) {
			return;
		}
		this.DrawMaterialSelector();
		if (this.game.guistate != GuiState.Inventory) {
			return;
		}
		if (this.ScrollingUpTimeMilliseconds != 0 && this.game.platform.TimeMillisecondsFromStart() - this.ScrollingUpTimeMilliseconds > 250) {
			this.ScrollingUpTimeMilliseconds = this.game.platform.TimeMillisecondsFromStart();
			this.ScrollUp();
		}
		if (this.ScrollingDownTimeMilliseconds != 0 && this.game.platform.TimeMillisecondsFromStart() - this.ScrollingDownTimeMilliseconds > 250) {
			this.ScrollingDownTimeMilliseconds = this.game.platform.TimeMillisecondsFromStart();
			this.ScrollDown();
		}
		PointRef scaledMouse = PointRef.Create(this.game.mouseCurrentX, this.game.mouseCurrentY);
		this.game.Draw2dBitmapFile("inventory.png", this.InventoryStartX(), this.InventoryStartY(), 1024, 1024);
		for (int i = 0; i < this.game.d_Inventory.ItemsCount; i++) {
			Packet_PositionItem k = this.game.d_Inventory.Items[i];
			if (k == null) {
				continue;
			}
			int screeny = k.Y - this.ScrollLine;
			if (screeny >= 0 && screeny < this.CellCountInPageY) {
				this.DrawItem(this.CellsStartX() + k.X * this.CellDrawSize, this.CellsStartY() + screeny * this.CellDrawSize, k.Value_, 0, 0);
			}
		}
		if (this.game.d_Inventory.DragDropItem != null) {
			PointRef selectedInPage = this.SelectedCell(scaledMouse);
			if (selectedInPage != null) {
				int x = selectedInPage.X * this.CellDrawSize + this.CellsStartX();
				int y = selectedInPage.Y * this.CellDrawSize + this.CellsStartY();
				int sizex = this.dataItems.ItemSizeX(this.game.d_Inventory.DragDropItem);
				int sizey = this.dataItems.ItemSizeY(this.game.d_Inventory.DragDropItem);
				if (selectedInPage.X + sizex <= this.CellCountInPageX && selectedInPage.Y + sizey <= this.CellCountInPageY) {
					int c;
					IntRef itemsAtAreaCount = new IntRef();
					PointRef[] itemsAtArea = this.inventoryUtil.ItemsAtArea(selectedInPage.X, selectedInPage.Y + this.ScrollLine, sizex, sizey, itemsAtAreaCount);
					if (itemsAtArea == null || itemsAtAreaCount.value > 1) {
						c = Game.ColorFromArgb(100, 255, 0, 0);
					}
					else {
						c = Game.ColorFromArgb(100, 0, 255, 0);
					}
					this.game.Draw2dTexture(this.game.WhiteTexture(), x, y, this.CellDrawSize * sizex, this.CellDrawSize * sizey, null, 0, c, false);
				}
			}
			IntRef selectedWear = this.SelectedWearPlace(scaledMouse);
			if (selectedWear != null) {
				PointRef p = PointRef.Create(this.wearPlaceStart[selectedWear.value].X + this.InventoryStartX(), this.wearPlaceStart[selectedWear.value].Y + this.InventoryStartY());
				PointRef size = this.wearPlaceCells[selectedWear.value];
				int c;
				Packet_Item itemsAtArea = this.inventoryUtil.ItemAtWearPlace(selectedWear.value, this.game.ActiveMaterial);
				if (!this.dataItems.CanWear(selectedWear.value, this.game.d_Inventory.DragDropItem)) {
					c = Game.ColorFromArgb(100, 255, 0, 0);
				}
				else {
					c = Game.ColorFromArgb(100, 0, 255, 0);
				}
				this.game.Draw2dTexture(this.game.WhiteTexture(), p.X, p.Y, this.CellDrawSize * size.X, this.CellDrawSize * size.Y, null, 0, c, false);
			}
		}
		this.DrawMaterialSelector();
		this.DrawItem(this.wearPlaceStart[0].X + this.InventoryStartX(), this.wearPlaceStart[0].Y + this.InventoryStartY(), this.game.d_Inventory.RightHand[this.game.ActiveMaterial], 0, 0);
		this.DrawItem(this.wearPlaceStart[1].X + this.InventoryStartX(), this.wearPlaceStart[1].Y + this.InventoryStartY(), this.game.d_Inventory.MainArmor, 0, 0);
		this.DrawItem(this.wearPlaceStart[2].X + this.InventoryStartX(), this.wearPlaceStart[2].Y + this.InventoryStartY(), this.game.d_Inventory.Boots, 0, 0);
		this.DrawItem(this.wearPlaceStart[3].X + this.InventoryStartX(), this.wearPlaceStart[3].Y + this.InventoryStartY(), this.game.d_Inventory.Helmet, 0, 0);
		this.DrawItem(this.wearPlaceStart[4].X + this.InventoryStartX(), this.wearPlaceStart[4].Y + this.InventoryStartY(), this.game.d_Inventory.Gauntlet, 0, 0);
		if (this.SelectedCell(scaledMouse) != null) {
			PointRef selected = this.SelectedCell(scaledMouse);
			selected.Y += this.ScrollLine;
			PointRef itemAtCell = this.inventoryUtil.ItemAtCell(selected);
			if (itemAtCell != null) {
				Packet_Item item = this.GetItem(this.game.d_Inventory, itemAtCell.X, itemAtCell.Y);
				if (item != null) {
					int x = selected.X * this.CellDrawSize + this.CellsStartX();
					int y = selected.Y * this.CellDrawSize + this.CellsStartY();
					this.DrawItemInfo(scaledMouse.X, scaledMouse.Y, item);
				}
			}
		}
		if (this.SelectedWearPlace(scaledMouse) != null) {
			int selected = this.SelectedWearPlace(scaledMouse).value;
			Packet_Item itemAtWearPlace = this.inventoryUtil.ItemAtWearPlace(selected, this.game.ActiveMaterial);
			if (itemAtWearPlace != null) {
				this.DrawItemInfo(scaledMouse.X, scaledMouse.Y, itemAtWearPlace);
			}
		}
		if (this.SelectedMaterialSelectorSlot(scaledMouse) != null) {
			int selected = this.SelectedMaterialSelectorSlot(scaledMouse).value;
			Packet_Item item = this.game.d_Inventory.RightHand[selected];
			if (item != null) {
				this.DrawItemInfo(scaledMouse.X, scaledMouse.Y, item);
			}
		}
		if (this.game.d_Inventory.DragDropItem != null) {
			this.DrawItem(scaledMouse.X, scaledMouse.Y, this.game.d_Inventory.DragDropItem, 0, 0);
		}
	}

	public override void OnTouchStart(Game game_, TouchEventArgs e)
	{
		MouseEventArgs args = new MouseEventArgs();
		args.SetX(e.GetX());
		args.SetY(e.GetY());
		this.OnMouseDown(game_, args);
		e.SetHandled(args.GetHandled());
	}

	int ScrollButtonSize()
	{
		return this.CellDrawSize;
	}

	public void ScrollDown()
	{
		this.ScrollLine++;
		int max = this.CellCountTotalY - this.CellCountInPageY;
		if (this.ScrollLine >= max) {
			this.ScrollLine = max;
		}
	}

	int ScrollDownButtonX()
	{
		return this.CellsStartX() + this.CellCountInPageX * this.CellDrawSize;
	}

	int ScrollDownButtonY()
	{
		return this.CellsStartY() + (this.CellCountInPageY - 1) * this.CellDrawSize;
	}
	internal int ScrollLine;

	public void ScrollUp()
	{
		this.ScrollLine--;
		if (this.ScrollLine < 0) {
			this.ScrollLine = 0;
		}
	}

	int ScrollUpButtonX()
	{
		return this.CellsStartX() + this.CellCountInPageX * this.CellDrawSize;
	}

	int ScrollUpButtonY()
	{
		return this.CellsStartY();
	}
	int ScrollingDownTimeMilliseconds;
	int ScrollingUpTimeMilliseconds;

	PointRef SelectedCell(PointRef scaledMouse)
	{
		if (scaledMouse.X < this.CellsStartX() || scaledMouse.Y < this.CellsStartY() || scaledMouse.X > this.CellsStartX() + this.CellCountInPageX * this.CellDrawSize || scaledMouse.Y > this.CellsStartY() + this.CellCountInPageY * this.CellDrawSize) {
			return null;
		}
		PointRef cell = PointRef.Create((scaledMouse.X - this.CellsStartX()) / this.CellDrawSize, (scaledMouse.Y - this.CellsStartY()) / this.CellDrawSize);
		return cell;
	}

	bool SelectedCellOrScrollbar(int scaledMouseX, int scaledMouseY)
	{
		if (scaledMouseX < this.CellsStartX() || scaledMouseY < this.CellsStartY() || scaledMouseX > this.CellsStartX() + (this.CellCountInPageX + 1) * this.CellDrawSize || scaledMouseY > this.CellsStartY() + this.CellCountInPageY * this.CellDrawSize) {
			return false;
		}
		return true;
	}

	IntRef SelectedMaterialSelectorSlot(PointRef scaledMouse)
	{
		if (scaledMouse.X >= this.MaterialSelectorStartX() && scaledMouse.Y >= this.MaterialSelectorStartY() && scaledMouse.X < this.MaterialSelectorStartX() + 10 * this.ActiveMaterialCellSize() && scaledMouse.Y < this.MaterialSelectorStartY() + 10 * this.ActiveMaterialCellSize()) {
			return IntRef.Create((scaledMouse.X - this.MaterialSelectorStartX()) / this.ActiveMaterialCellSize());
		}
		return null;
	}

	IntRef SelectedWearPlace(PointRef scaledMouse)
	{
		for (int i = 0; i < 5; i++) {
			PointRef p = this.wearPlaceStart[i];
			p.X += this.InventoryStartX();
			p.Y += this.InventoryStartY();
			PointRef cells = this.wearPlaceCells[i];
			if (scaledMouse.X >= p.X && scaledMouse.Y >= p.Y && scaledMouse.X < p.X + cells.X * this.CellDrawSize && scaledMouse.Y < p.Y + cells.Y * this.CellDrawSize) {
				return IntRef.Create(i);
			}
		}
		return null;
	}
	internal IInventoryController controller;
	internal GameDataItemsClient dataItems;
	internal Game game;
	internal InventoryUtilClient inventoryUtil;
	PointRef[] wearPlaceCells;
	PointRef[] wearPlaceStart;
}

public class ModGuiMapLoading : ClientMod
{

	void DrawBackground(Game game)
	{
		this.backgroundW = 512;
		this.backgroundH = 512;
		int countX = game.platform.FloatToInt(this.Width / this.backgroundW) + 1;
		int countY = game.platform.FloatToInt(this.Height / this.backgroundH) + 1;
		for (int x = 0; x < countX; x++) {
			for (int y = 0; y < countY; y++) {
				game.Draw2dTexture(game.GetTexture("background.png"), x * this.backgroundW, y * this.backgroundH, this.backgroundW, this.backgroundH, null, 0, Game.ColorFromArgb(255, 255, 255, 255), false);
			}
		}
	}
	int Height;

	public override void OnNewFrameDraw2d(Game game, float deltaTime)
	{
		if (game.guistate != GuiState.MapLoading) {
			return;
		}
		GamePlatform platform = game.platform;
		float one = 1;
		this.Width = platform.GetCanvasWidth();
		this.Height = platform.GetCanvasHeight();
		this.DrawBackground(game);
		string connecting = game.language.Connecting();
		if (game.issingleplayer && !platform.SinglePlayerServerLoaded()) {
			connecting = "Starting game...";
		}
		if (game.maploadingprogress.ProgressStatus != null) {
			connecting = game.maploadingprogress.ProgressStatus;
		}
		if (game.invalidVersionDrawMessage != null) {
			game.Draw2dText(game.invalidVersionDrawMessage, game.fontMapLoading, game.xcenter(game.TextSizeWidth(game.invalidVersionDrawMessage, 14)), this.Height / 2 - 50, null, false);
			string connect = "Click to connect";
			game.Draw2dText(connect, game.fontMapLoading, game.xcenter(game.TextSizeWidth(connect, 14)), this.Height / 2 + 50, null, false);
			return;
		}
		IntRef serverNameWidth = new IntRef();
		IntRef serverNameHeight = new IntRef();
		platform.TextSize(game.ServerInfo.ServerName, 14, serverNameWidth, serverNameHeight);
		game.Draw2dText(game.ServerInfo.ServerName, game.fontMapLoading, game.xcenter(serverNameWidth.value), this.Height / 2 - 150, null, false);
		if (game.ServerInfo.ServerMotd != null) {
			IntRef serverMotdWidth = new IntRef();
			IntRef serverMotdHeight = new IntRef();
			platform.TextSize(game.ServerInfo.ServerMotd, 14, serverMotdWidth, serverMotdHeight);
			game.Draw2dText(game.ServerInfo.ServerMotd, game.fontMapLoading, game.xcenter(serverMotdWidth.value), this.Height / 2 - 100, null, false);
		}
		IntRef connectingWidth = new IntRef();
		IntRef connectingHeight = new IntRef();
		platform.TextSize(connecting, 14, connectingWidth, connectingHeight);
		game.Draw2dText(connecting, game.fontMapLoading, game.xcenter(connectingWidth.value), this.Height / 2 - 50, null, false);
		string progress = platform.StringFormat(game.language.ConnectingProgressPercent(), platform.IntToString(game.maploadingprogress.ProgressPercent));
		string progress1 = platform.StringFormat(game.language.ConnectingProgressKilobytes(), platform.IntToString(game.maploadingprogress.ProgressBytes / 1024));
		if (game.maploadingprogress.ProgressPercent > 0) {
			IntRef progressWidth = new IntRef();
			IntRef progressHeight = new IntRef();
			platform.TextSize(progress, 14, progressWidth, progressHeight);
			game.Draw2dText(progress, game.fontMapLoading, game.xcenter(progressWidth.value), this.Height / 2 - 20, null, false);
			IntRef progress1Width = new IntRef();
			IntRef progress1Height = new IntRef();
			platform.TextSize(progress1, 14, progress1Width, progress1Height);
			game.Draw2dText(progress1, game.fontMapLoading, game.xcenter(progress1Width.value), this.Height / 2 + 10, null, false);
			float progressratio = one * game.maploadingprogress.ProgressPercent / 100;
			int sizex = 400;
			int sizey = 40;
			game.Draw2dTexture(game.WhiteTexture(), game.xcenter(sizex), this.Height / 2 + 70, sizex, sizey, null, 0, Game.ColorFromArgb(255, 0, 0, 0), false);
			int red = Game.ColorFromArgb(255, 255, 0, 0);
			int yellow = Game.ColorFromArgb(255, 255, 255, 0);
			int green = Game.ColorFromArgb(255, 0, 255, 0);
			int[] colors = new int[3];
			colors[0] = red;
			colors[1] = yellow;
			colors[2] = green;
			int c = InterpolationCi.InterpolateColor(platform, progressratio, colors, 3);
			game.Draw2dTexture(game.WhiteTexture(), game.xcenter(sizex), this.Height / 2 + 70, progressratio * sizex, sizey, null, 0, c, false);
		}
	}
	int Width;
	int backgroundH;
	int backgroundW;
}

public class ModGuiPlayerStats : ClientMod
{

	public void DrawPlayerHealth(Game game)
	{
		if (game.PlayerStats != null) {
			float progress = game.one * game.PlayerStats.CurrentHealth / game.PlayerStats.MaxHealth;
			game.Draw2dTexture(game.GetTexture("ui_bar_background.png"), this.healthPosX, this.healthPosY, 220, 32, null, 0, Game.ColorFromArgb(255, 255, 255, 255), false);
			game.Draw2dTexturePart(game.GetTexture("ui_bar_inner.png"), progress, 1, this.healthPosX, this.healthPosY, progress * 220, 32, Game.ColorFromArgb(255, 255, 0, 0), false);
		}
	}

	public void DrawPlayerOxygen(Game game)
	{
		if (game.PlayerStats != null) {
			if (game.PlayerStats.CurrentOxygen < game.PlayerStats.MaxOxygen) {
				float progress = game.one * game.PlayerStats.CurrentOxygen / game.PlayerStats.MaxOxygen;
				game.Draw2dTexture(game.GetTexture("ui_bar_background.png"), this.oxygenPosX, this.oxygenPosY, 220, 32, null, 0, Game.ColorFromArgb(255, 255, 255, 255), false);
				game.Draw2dTexturePart(game.GetTexture("ui_bar_inner.png"), progress, 1, this.oxygenPosX, this.oxygenPosY, progress * 220, 32, Game.ColorFromArgb(255, 0, 0, 255), false);
			}
		}
	}

	public override void OnNewFrameDraw2d(Game game, float deltaTime)
	{
		this.healthPosX = game.Width() / 2 - 220 - 20;
		this.healthPosY = game.Height() - 122;
		this.oxygenPosX = game.Width() / 2 + 20;
		this.oxygenPosY = game.Height() - 122;
		if (game.guistate != GuiState.MapLoading) {
			this.DrawPlayerHealth(game);
			this.DrawPlayerOxygen(game);
		}
	}
	int healthPosX;
	int healthPosY;
	int oxygenPosX;
	int oxygenPosY;
}

public class ModGuiTextEditor : GameScreen
{
	public ModGuiTextEditor()
	{
		this.buffer = new int[128][];
		for (int i = 0; i < 128; i++) {
			this.buffer[i] = new int[80];
		}
		this.startX = 100;
		this.startY = 100;
		this.charSize = 12;
		this.font = new FontCi();
		this.font.family = "Courier New";
		this.font.size = 12;
	}

	string BufferToString()
	{
		string s = "";
		for (int i = 0; i < 128; i++) {
			string line = this.LineToString(this.buffer[i]);
			s = StringTools.StringAppend(this.game.platform, s, line);
		}
		return s;
	}

	int LineLength(int[] line)
	{
		for (int i = 0; i < 80; i++) {
			if (line[i] == 0) {
				return i;
			}
		}
		return 80;
	}

	string LineToString(int[] line)
	{
		if (line == null) {
			return "";
		}
		return this.game.platform.CharArrayToString(line, this.LineLength(line));
	}

	public override void OnKeyDown(Game game_, KeyEventArgs e)
	{
		if (e.GetKeyCode() == this.game.GetKey(18)) {
			this.visible = !this.visible;
		}
		if (!this.visible) {
			return;
		}
		if (e.GetKeyCode() == 50) {
			this.visible = false;
		}
		if (e.GetKeyCode() == 47) {
			this.cursorColumn--;
		}
		if (e.GetKeyCode() == 48) {
			this.cursorColumn++;
		}
		if (e.GetKeyCode() == 45) {
			this.cursorLine--;
		}
		if (e.GetKeyCode() == 46) {
			this.cursorLine++;
		}
		if (e.GetKeyCode() == 53) {
			this.cursorColumn--;
			e.SetKeyCode(55);
		}
		if (this.cursorColumn < 0) {
			this.cursorColumn = 0;
		}
		if (this.cursorLine < 0) {
			this.cursorLine = 0;
		}
		if (this.cursorColumn >= 80) {
			this.cursorColumn = 80;
		}
		if (this.cursorLine > 128) {
			this.cursorLine = 128;
		}
		if (this.cursorColumn > this.LineLength(this.buffer[this.cursorLine])) {
			this.cursorColumn = this.LineLength(this.buffer[this.cursorLine]);
		}
		if (e.GetKeyCode() == 55) {
			for (int i = this.cursorColumn; i < 79; i++) {
				this.buffer[this.cursorLine][i] = this.buffer[this.cursorLine][i + 1];
			}
		}
		e.SetHandled(true);
	}

	public override void OnKeyPress(Game game_, KeyPressEventArgs e)
	{
		if (!this.visible) {
			return;
		}
		if (e.GetKeyChar() == 8) {
			return;
		}
		for (int i = 79; i > this.cursorColumn; i--) {
			this.buffer[this.cursorLine][i] = this.buffer[this.cursorLine][i - 1];
		}
		this.buffer[this.cursorLine][this.cursorColumn] = e.GetKeyChar();
		this.cursorColumn++;
		e.SetHandled(true);
	}

	public override void OnNewFrameDraw2d(Game game, float deltaTime)
	{
		float dt = deltaTime;
		if (!this.visible) {
			return;
		}
		game.Draw2dTexture(game.WhiteTexture(), this.startX, this.startY, 80 * this.charSize, 128 * this.charSize, null, 0, Game.ColorFromArgb(255, 100, 100, 100), false);
		for (int i = 0; i < 128; i++) {
			game.Draw2dText(this.LineToString(this.buffer[i]), this.font, this.startX, this.startY + this.charSize * i, null, false);
		}
		int[] spaces = new int[80];
		for (int i = 0; i < 80; i++) {
			spaces[i] = 32;
		}
		spaces[this.cursorColumn] = 95;
		string spacesString = game.platform.CharArrayToString(spaces, this.cursorColumn + 1);
		game.Draw2dText(spacesString, this.font, this.startX, this.startY + this.cursorLine * this.charSize, null, false);
	}
	int[][] buffer;
	int charSize;
	int cursorColumn;
	int cursorLine;
	FontCi font;
	int startX;
	int startY;
	bool visible;
}

public class ModGuiTouchButtons : GameScreen
{
	public ModGuiTouchButtons()
	{
		this.touchButtonsEnabled = false;
		this.buttonMenu = new MenuWidget();
		this.buttonMenu.image = "TouchMenu.png";
		this.buttonInventory = new MenuWidget();
		this.buttonInventory.image = "TouchInventory.png";
		this.buttonTalk = new MenuWidget();
		this.buttonTalk.image = "TouchTalk.png";
		this.buttonCamera = new MenuWidget();
		this.buttonCamera.image = "TouchCamera.png";
		this.widgets[0] = this.buttonMenu;
		this.widgets[1] = this.buttonInventory;
		this.widgets[2] = this.buttonTalk;
		this.widgets[3] = this.buttonCamera;
		this.touchIdMove = -1;
		this.touchIdRotate = -1;
	}

	public override void OnButton(MenuWidget w)
	{
		if (w == this.buttonMenu) {
			this.game.ShowEscapeMenu();
		}
		if (w == this.buttonInventory) {
			this.game.ShowInventory();
		}
		if (w == this.buttonTalk) {
			if (this.game.GuiTyping == TypingState.None) {
				this.game.StartTyping();
				this.game.platform.ShowKeyboard(true);
			}
			else {
				this.game.StopTyping();
				this.game.platform.ShowKeyboard(false);
			}
		}
		if (w == this.buttonCamera) {
			this.game.CameraChange();
		}
	}

	public override void OnNewFrameDraw2d(Game game_, float deltaTime)
	{
		if (!this.touchButtonsEnabled) {
			return;
		}
		this.game = game_;
		float dt = deltaTime;
		int buttonSize = 80;
		if (this.game.guistate != GuiState.Normal) {
			return;
		}
		this.buttonMenu.x = 16 * this.Scale();
		this.buttonMenu.y = 16 * this.Scale();
		this.buttonMenu.sizex = buttonSize * this.Scale();
		this.buttonMenu.sizey = buttonSize * this.Scale();
		this.buttonInventory.x = 16 * this.Scale();
		this.buttonInventory.y = 112 * this.Scale();
		this.buttonInventory.sizex = buttonSize * this.Scale();
		this.buttonInventory.sizey = buttonSize * this.Scale();
		this.buttonTalk.x = 16 * this.Scale();
		this.buttonTalk.y = 208 * this.Scale();
		this.buttonTalk.sizex = buttonSize * this.Scale();
		this.buttonTalk.sizey = buttonSize * this.Scale();
		this.buttonCamera.x = 16 * this.Scale();
		this.buttonCamera.y = 304 * this.Scale();
		this.buttonCamera.sizex = buttonSize * this.Scale();
		this.buttonCamera.sizey = buttonSize * this.Scale();
		if (!this.game.platform.IsMousePointerLocked()) {
			if (this.game.cameratype == CameraType.Fpp || this.game.cameratype == CameraType.Tpp) {
				this.game.Draw2dText1("Move", this.game.Width() * 5 / 100, this.game.Height() * 85 / 100, this.game.platform.FloatToInt(this.Scale() * 50), null, false);
				this.game.Draw2dText1("Look", this.game.Width() * 80 / 100, this.game.Height() * 85 / 100, this.game.platform.FloatToInt(this.Scale() * 50), null, false);
			}
			this.DrawWidgets();
		}
	}

	public override void OnTouchEnd(Game game_, TouchEventArgs e)
	{
		this.ScreenOnTouchEnd(e);
		if (e.GetHandled()) {
			return;
		}
		if (e.GetId() == this.touchIdMove) {
			this.touchIdMove = -1;
			this.game.touchMoveDx = 0;
			this.game.touchMoveDy = 0;
		}
		if (e.GetId() == this.touchIdRotate) {
			this.touchIdRotate = -1;
			this.game.touchOrientationDx = 0;
			this.game.touchOrientationDy = 0;
		}
	}

	public override void OnTouchMove(Game game, TouchEventArgs e)
	{
		float one = 1;
		if (e.GetId() == this.touchIdMove) {
			float range = game.Width() * one / 20;
			game.touchMoveDx = e.GetX() - this.touchMoveStartX;
			game.touchMoveDy = -(e.GetY() - 1 - this.touchMoveStartY);
			float length = game.Length(game.touchMoveDx, game.touchMoveDy, 0);
			if (e.GetY() < game.Height() * 50 / 100) {
				game.touchMoveDx = 0;
				game.touchMoveDy = 1;
			}
			else {
				if (length > 0) {
					game.touchMoveDx /= length;
					game.touchMoveDy /= length;
				}
			}
		}
		if (e.GetId() == this.touchIdRotate) {
			game.touchOrientationDx += (e.GetX() - this.touchRotateStartX) / (game.Width() * one / 40);
			game.touchOrientationDy += (e.GetY() - this.touchRotateStartY) / (game.Width() * one / 40);
			this.touchRotateStartX = e.GetX();
			this.touchRotateStartY = e.GetY();
		}
	}

	public override void OnTouchStart(Game game_, TouchEventArgs e)
	{
		this.touchButtonsEnabled = true;
		this.ScreenOnTouchStart(e);
		if (e.GetHandled()) {
			return;
		}
		if (e.GetX() <= this.game.Width() / 2) {
			if (this.touchIdMove == -1) {
				this.touchIdMove = e.GetId();
				this.touchMoveStartX = e.GetX();
				this.touchMoveStartY = e.GetY();
				this.game.touchMoveDx = 0;
				if (e.GetY() < this.game.Height() * 50 / 100) {
					this.game.touchMoveDy = 1;
				}
				else {
					this.game.touchMoveDy = 0;
				}
			}
		}
		if (this.touchIdMove != -1 && e.GetId() != this.touchIdMove || e.GetX() > this.game.Width() / 2) {
			if (this.touchIdRotate == -1) {
				this.touchIdRotate = e.GetId();
				this.touchRotateStartX = e.GetX();
				this.touchRotateStartY = e.GetY();
			}
		}
	}

	float Scale()
	{
		return this.game.Scale();
	}
	MenuWidget buttonCamera;
	MenuWidget buttonInventory;
	MenuWidget buttonMenu;
	MenuWidget buttonTalk;
	bool touchButtonsEnabled;
	int touchIdMove;
	int touchIdRotate;
	int touchMoveStartX;
	int touchMoveStartY;
	int touchRotateStartX;
	int touchRotateStartY;
}

public class ModInterpolatePositions : ClientMod
{

	internal void InterpolatePositions(Game game, float dt)
	{
		for (int i = 0; i < game.entitiesCount; i++) {
			Entity e = game.entities[i];
			if (e == null) {
				continue;
			}
			if (e.networkPosition == null) {
				continue;
			}
			if (i == game.LocalPlayerId) {
				continue;
			}
			if (!e.networkPosition.PositionLoaded) {
				continue;
			}
			if (e.playerDrawInfo == null) {
				e.playerDrawInfo = new PlayerDrawInfo();
			}
			if (e.playerDrawInfo.interpolation == null) {
				NetworkInterpolation n = new NetworkInterpolation();
				PlayerInterpolate playerInterpolate = new PlayerInterpolate();
				playerInterpolate.platform = game.platform;
				n.req = playerInterpolate;
				n.DELAYMILLISECONDS = 500;
				n.EXTRAPOLATE = false;
				n.EXTRAPOLATION_TIMEMILLISECONDS = 300;
				e.playerDrawInfo.interpolation = n;
			}
			e.playerDrawInfo.interpolation.DELAYMILLISECONDS = MathCi.MaxInt(100, game.ServerInfo.ServerPing.RoundtripTimeTotalMilliseconds());
			Entity p = e;
			PlayerDrawInfo info = p.playerDrawInfo;
			float networkposX = p.networkPosition.x;
			float networkposY = p.networkPosition.y;
			float networkposZ = p.networkPosition.z;
			if (!game.Vec3Equal(networkposX, networkposY, networkposZ, info.lastnetworkposX, info.lastnetworkposY, info.lastnetworkposZ) || p.networkPosition.rotx != info.lastnetworkrotx || p.networkPosition.roty != info.lastnetworkroty || p.networkPosition.rotz != info.lastnetworkrotz) {
				PlayerInterpolationState state = new PlayerInterpolationState();
				state.positionX = networkposX;
				state.positionY = networkposY;
				state.positionZ = networkposZ;
				state.rotx = p.networkPosition.rotx;
				state.roty = p.networkPosition.roty;
				state.rotz = p.networkPosition.rotz;
				info.interpolation.AddNetworkPacket(state, game.totaltimeMilliseconds);
			}
			PlayerInterpolationState curstate = game.platform.CastToPlayerInterpolationState(info.interpolation.InterpolatedState(game.totaltimeMilliseconds));
			if (curstate == null) {
				curstate = new PlayerInterpolationState();
			}
			if (game.EnablePlayerUpdatePositionContainsKey(i) && !game.EnablePlayerUpdatePosition(i)) {
				curstate.positionX = p.networkPosition.x;
				curstate.positionY = p.networkPosition.y;
				curstate.positionZ = p.networkPosition.z;
			}
			float curposX = curstate.positionX;
			float curposY = curstate.positionY;
			float curposZ = curstate.positionZ;
			info.velocityX = curposX - info.lastcurposX;
			info.velocityY = curposY - info.lastcurposY;
			info.velocityZ = curposZ - info.lastcurposZ;
			info.moves = !game.Vec3Equal(curposX, curposY, curposZ, info.lastcurposX, info.lastcurposY, info.lastcurposZ);
			info.lastcurposX = curposX;
			info.lastcurposY = curposY;
			info.lastcurposZ = curposZ;
			info.lastnetworkposX = networkposX;
			info.lastnetworkposY = networkposY;
			info.lastnetworkposZ = networkposZ;
			info.lastnetworkrotx = p.networkPosition.rotx;
			info.lastnetworkroty = p.networkPosition.roty;
			info.lastnetworkrotz = p.networkPosition.rotz;
			p.position.x = curposX;
			p.position.y = curposY;
			p.position.z = curposZ;
			p.position.rotx = curstate.rotx;
			p.position.roty = curstate.roty;
			p.position.rotz = curstate.rotz;
		}
	}

	public override void OnNewFrame(Game game, NewFrameEventArgs args)
	{
		this.InterpolatePositions(game, args.GetDt());
	}
}

public class ModLoadPlayerTextures : ClientMod
{

	internal void LoadPlayerTextures(Game game)
	{
		if (!game.issingleplayer) {
			if (this.skinserverResponse.done) {
				this.skinserver = game.platform.StringFromUtf8ByteArray(this.skinserverResponse.value, this.skinserverResponse.valueLength);
			}
			else if (this.skinserverResponse.error) {
				this.skinserver = null;
			}
			else {
				return;
			}
		}
		for (int i = 0; i < game.entitiesCount; i++) {
			Entity e = game.entities[i];
			if (e == null) {
				continue;
			}
			if (e.drawModel == null) {
				continue;
			}
			if (e.drawModel.CurrentTexture != -1) {
				continue;
			}
			if (!game.issingleplayer && e.drawModel.DownloadSkin && this.skinserver != null && e.drawModel.Texture_ == null) {
				if (e.drawModel.SkinDownloadResponse == null) {
					e.drawModel.SkinDownloadResponse = new HttpResponseCi();
					string url = StringTools.StringAppend(game.platform, this.skinserver, StringTools.StringSubstringToEnd(game.platform, e.drawName.Name, 2));
					url = StringTools.StringAppend(game.platform, url, ".png");
					game.platform.WebClientDownloadDataAsync(url, e.drawModel.SkinDownloadResponse);
					continue;
				}
				if (!e.drawModel.SkinDownloadResponse.error) {
					if (!e.drawModel.SkinDownloadResponse.done) {
						continue;
					}
					BitmapCi bmp_ = game.platform.BitmapCreateFromPng(e.drawModel.SkinDownloadResponse.value, e.drawModel.SkinDownloadResponse.valueLength);
					if (bmp_ != null) {
						e.drawModel.CurrentTexture = game.GetTextureOrLoad(e.drawName.Name, bmp_);
						game.platform.BitmapDelete(bmp_);
						continue;
					}
				}
			}
			if (e.drawModel.Texture_ == null) {
				e.drawModel.CurrentTexture = game.GetTexture("mineplayer.png");
				continue;
			}
			byte[] file = game.GetFile(e.drawModel.Texture_);
			if (file == null) {
				e.drawModel.CurrentTexture = 0;
				continue;
			}
			BitmapCi bmp = game.platform.BitmapCreateFromPng(file, game.platform.ByteArrayLength(file));
			if (bmp == null) {
				e.drawModel.CurrentTexture = 0;
				continue;
			}
			e.drawModel.CurrentTexture = game.GetTextureOrLoad(e.drawModel.Texture_, bmp);
			game.platform.BitmapDelete(bmp);
		}
	}

	public override void OnNewFrame(Game game, NewFrameEventArgs args)
	{
		if (game.guistate == GuiState.MapLoading) {
			return;
		}
		if (!this.started) {
			this.started = true;
			if (!game.issingleplayer) {
				this.skinserverResponse = new HttpResponseCi();
				game.platform.WebClientDownloadDataAsync("http://manicdigger.sourceforge.net/skinserver.txt", this.skinserverResponse);
			}
		}
		this.LoadPlayerTextures(game);
	}
	internal string skinserver;
	internal HttpResponseCi skinserverResponse;
	bool started;
}

public abstract class ModManagerSimple
{

	public abstract void AddToInventory(int player, string block, int amount);

	public abstract BlockTypeSimple CreateBlockType(string name);

	public abstract int GetBlockTypeId(string p);
}

public class ModManagerSimple1 : ModManagerSimple
{

	public override void AddToInventory(int player, string block, int amount)
	{
		Packet_Inventory inv = this.server.clients[player].inventory;
		for (int i = 0; i < 10; i++) {
			if (inv.RightHand[i].BlockId == 0) {
				inv.RightHand[i].BlockId = this.GetBlockTypeId(block);
				inv.RightHand[i].BlockCount = amount;
				break;
			}
		}
		this.server.clients[player].inventoryDirty = true;
	}

	public override BlockTypeSimple CreateBlockType(string name)
	{
		BlockTypeSimple b = new BlockTypeSimple();
		b.SetName(name);
		this.server.blockTypes[this.server.blockTypesCount++] = b.block;
		return b;
	}

	public override int GetBlockTypeId(string p)
	{
		for (int i = 0; i < this.server.blockTypesCount; i++) {
			if (this.server.blockTypes[i] == null) {
				continue;
			}
			if (Game.StringEquals(this.server.blockTypes[i].Name, p)) {
				return i;
			}
		}
		return -1;
	}

	public void Start(ServerSimple serverSimple)
	{
		this.server = serverSimple;
	}
	ServerSimple server;
}

public class ModNetworkEntity : ClientMod
{
	public ModNetworkEntity()
	{
		this.spawn = new ClientPacketHandlerEntitySpawn();
		this.position = new ClientPacketHandlerEntityPosition();
		this.despawn = new ClientPacketHandlerEntityDespawn();
	}

	public override void OnNewFrame(Game game, NewFrameEventArgs args)
	{
		game.packetHandlers[66] = this.spawn;
		game.packetHandlers[67] = this.position;
		game.packetHandlers[68] = this.despawn;
	}
	ClientPacketHandlerEntityDespawn despawn;
	ClientPacketHandlerEntityPosition position;
	ClientPacketHandlerEntitySpawn spawn;
}

public class ModNetworkProcess : ClientMod
{
	public ModNetworkProcess()
	{
		this.CurrentChunk = new byte[65536];
		this.CurrentChunkCount = 0;
		this.receivedchunk = new int[32768];
		this.decompressedchunk = new byte[65536];
	}
	internal byte[] CurrentChunk;
	internal int CurrentChunkCount;

	public void NetworkProcess()
	{
		this.game.currentTimeMilliseconds = this.game.platform.TimeMillisecondsFromStart();
		if (this.game.main == null) {
			return;
		}
		NetIncomingMessage msg;
		for (;;) {
			if (this.game.invalidVersionPacketIdentification != null) {
				break;
			}
			msg = this.game.main.ReadMessage();
			if (msg == null) {
				break;
			}
			this.TryReadPacket(msg.message, msg.messageLength);
		}
	}

	public override void OnReadOnlyBackgroundThread(Game game_, float dt)
	{
		this.game = game_;
		this.NetworkProcess();
	}

	void ProcessInBackground(Packet_Server packet)
	{
		switch (packet.Id) {
		case 57:
			byte[] arr = packet.ChunkPart.CompressedChunkPart;
			int arrLength = this.game.platform.ByteArrayLength(arr);
			for (int i = 0; i < arrLength; i++) {
				this.CurrentChunk[this.CurrentChunkCount++] = arr[i];
			}
			break;
		case 15:
			{
				Packet_ServerChunk p = packet.Chunk_;
				if (this.CurrentChunkCount != 0) {
					this.game.platform.GzipDecompress(this.CurrentChunk, this.CurrentChunkCount, this.decompressedchunk);
					{
						int i = 0;
						for (int zz = 0; zz < p.SizeZ; zz++) {
							for (int yy = 0; yy < p.SizeY; yy++) {
								for (int xx = 0; xx < p.SizeX; xx++) {
									int block = (this.decompressedchunk[i + 1] << 8) + this.decompressedchunk[i];
									if (block < 1024) {
										this.receivedchunk[(zz * p.SizeY + yy) * p.SizeX + xx] = block;
									}
									i += 2;
								}
							}
						}
					}
				}
				else {
					int size = p.SizeX * p.SizeY * p.SizeZ;
					for (int i = 0; i < size; i++) {
						this.receivedchunk[i] = 0;
					}
				}
				{
					this.game.map.SetMapPortion(p.X, p.Y, p.Z, this.receivedchunk, p.SizeX, p.SizeY, p.SizeZ);
					for (int xx = 0; xx < 2; xx++) {
						for (int yy = 0; yy < 2; yy++) {
							for (int zz = 0; zz < 2; zz++) {
							}
						}
					}
				}
				this.game.ReceivedMapLength += this.CurrentChunkCount;
				this.CurrentChunkCount = 0;
			}
			break;
		case 21:
			{
				Packet_ServerHeightmapChunk p = packet.HeightmapChunk;
				this.game.platform.GzipDecompress(p.CompressedHeightmap, this.game.platform.ByteArrayLength(p.CompressedHeightmap), this.decompressedchunk);
				int[] decompressedchunk1 = Game.ByteArrayToUshortArray(this.decompressedchunk, p.SizeX * p.SizeY * 2);
				for (int xx = 0; xx < p.SizeX; xx++) {
					for (int yy = 0; yy < p.SizeY; yy++) {
						int height = decompressedchunk1[MapUtilCi.Index2d(xx, yy, p.SizeX)];
						this.game.d_Heightmap.SetBlock(p.X + xx, p.Y + yy, height);
					}
				}
			}
			break;
		}
	}

	public void TryReadPacket(byte[] data, int dataLength)
	{
		Packet_Server packet = new Packet_Server();
		Packet_ServerSerializer.DeserializeBuffer(data, dataLength, packet);
		this.ProcessInBackground(packet);
		ProcessPacketTask task = new ProcessPacketTask();
		task.game = this.game;
		task.packet_ = packet;
		this.game.QueueActionCommit(task);
		this.game.LastReceivedMilliseconds = this.game.currentTimeMilliseconds;
	}
	byte[] decompressedchunk;
	Game game;
	int[] receivedchunk;
}

public class ModPicking : ClientMod
{
	public ModPicking()
	{
		this.unproject = new Unproject();
		this.tempViewport = new float[4];
		this.tempRay = new float[4];
		this.tempRayStartPoint = new float[4];
		this.fillarea = new DictionaryVector3Float();
	}

	internal float BuildDelay(Game game)
	{
		float default_ = 1f * 95 / 100 * 1 / game.basemovespeed;
		Packet_Item item = game.d_Inventory.RightHand[game.ActiveMaterial];
		if (item == null || item.ItemClass != 0) {
			return default_;
		}
		float delay = game.DeserializeFloat(game.blocktypes[item.BlockId].DelayFloat);
		if (delay == 0) {
			return default_;
		}
		return delay;
	}

	internal void ClearFillArea(Game game)
	{
		for (int i = 0; i < this.fillarea.itemsCount; i++) {
			Vector3Float k = this.fillarea.items[i];
			if (k == null) {
				continue;
			}
			game.SetBlock(k.x, k.y, k.z, game.platform.FloatToInt(k.value));
			game.RedrawBlock(k.x, k.y, k.z);
		}
		this.fillarea.Clear();
	}

	float CurrentPickDistance(Game game)
	{
		float pick_distance = game.PICK_DISTANCE;
		IntRef inHand = game.BlockInHand();
		if (inHand != null) {
			if (game.blocktypes[inHand.value].PickDistanceWhenUsedFloat > 0) {
				pick_distance = game.DeserializeFloat(game.blocktypes[inHand.value].PickDistanceWhenUsedFloat);
			}
		}
		if (game.cameratype == CameraType.Tpp) {
			pick_distance = game.tppcameradistance + game.PICK_DISTANCE;
		}
		if (game.cameratype == CameraType.Overhead) {
			if (game.platform.IsFastSystem()) {
				pick_distance = 100;
			}
			else {
				pick_distance = game.overheadcameradistance * 2;
			}
		}
		return pick_distance;
	}

	internal void FillFill(Game game, Vector3IntRef a_, Vector3IntRef b_)
	{
		int startx = MathCi.MinInt(a_.X, b_.X);
		int endx = MathCi.MaxInt(a_.X, b_.X);
		int starty = MathCi.MinInt(a_.Y, b_.Y);
		int endy = MathCi.MaxInt(a_.Y, b_.Y);
		int startz = MathCi.MinInt(a_.Z, b_.Z);
		int endz = MathCi.MaxInt(a_.Z, b_.Z);
		for (int x = startx; x <= endx; x++) {
			for (int y = starty; y <= endy; y++) {
				for (int z = startz; z <= endz; z++) {
					if (this.fillarea.Count() > game.fillAreaLimit) {
						this.ClearFillArea(game);
						return;
					}
					if (!game.IsFillBlock(game.map.GetBlock(x, y, z))) {
						this.fillarea.Set(x, y, z, game.map.GetBlock(x, y, z));
						game.SetBlock(x, y, z, game.d_Data.BlockIdFillArea());
						game.RedrawBlock(x, y, z);
					}
				}
			}
		}
	}

	internal PointFloatRef GetAim(Game game)
	{
		if (game.CurrentAimRadius() <= 1) {
			return PointFloatRef.Create(0, 0);
		}
		float half = 0.5f;
		float x;
		float y;
		for (;;) {
			x = (game.rnd.NextFloat() - half) * game.CurrentAimRadius() * 2;
			y = (game.rnd.NextFloat() - half) * game.CurrentAimRadius() * 2;
			float dist1 = game.platform.MathSqrt(x * x + y * y);
			if (dist1 <= game.CurrentAimRadius()) {
				break;
			}
		}
		return PointFloatRef.Create(x, y);
	}

	public void GetPickingLine(Game game, Line3D retPick, bool ispistolshoot)
	{
		int mouseX;
		int mouseY;
		if (game.cameratype == CameraType.Fpp || game.cameratype == CameraType.Tpp) {
			mouseX = game.Width() / 2;
			mouseY = game.Height() / 2;
		}
		else {
			mouseX = game.mouseCurrentX;
			mouseY = game.mouseCurrentY;
		}
		PointFloatRef aim = this.GetAim(game);
		if (ispistolshoot && (aim.X != 0 || aim.Y != 0)) {
			mouseX += game.platform.FloatToInt(aim.X);
			mouseY += game.platform.FloatToInt(aim.Y);
		}
		this.tempViewport[0] = 0;
		this.tempViewport[1] = 0;
		this.tempViewport[2] = game.Width();
		this.tempViewport[3] = game.Height();
		this.unproject.UnProject(mouseX, game.Height() - mouseY, 1, game.mvMatrix.Peek(), game.pMatrix.Peek(), this.tempViewport, this.tempRay);
		this.unproject.UnProject(mouseX, game.Height() - mouseY, 0, game.mvMatrix.Peek(), game.pMatrix.Peek(), this.tempViewport, this.tempRayStartPoint);
		float raydirX = this.tempRay[0] - this.tempRayStartPoint[0];
		float raydirY = this.tempRay[1] - this.tempRayStartPoint[1];
		float raydirZ = this.tempRay[2] - this.tempRayStartPoint[2];
		float raydirLength = game.Length(raydirX, raydirY, raydirZ);
		raydirX /= raydirLength;
		raydirY /= raydirLength;
		raydirZ /= raydirLength;
		retPick.Start = new float[3];
		retPick.Start[0] = this.tempRayStartPoint[0];
		retPick.Start[1] = this.tempRayStartPoint[1];
		retPick.Start[2] = this.tempRayStartPoint[2];
		float pickDistance1 = this.CurrentPickDistance(game) * (ispistolshoot ? 100 : 1);
		pickDistance1 += 1;
		retPick.End = new float[3];
		retPick.End[0] = this.tempRayStartPoint[0] + raydirX * pickDistance1;
		retPick.End[1] = this.tempRayStartPoint[1] + raydirY * pickDistance1;
		retPick.End[2] = this.tempRayStartPoint[2] + raydirZ * pickDistance1;
	}

	internal void NextBullet(Game game, int bulletsshot)
	{
		float one = 1;
		bool left = game.mouseLeft;
		bool middle = game.mouseMiddle;
		bool right = game.mouseRight;
		bool IsNextShot = bulletsshot != 0;
		if (!game.leftpressedpicking) {
			if (game.mouseleftclick) {
				game.leftpressedpicking = true;
			}
			else {
				left = false;
			}
		}
		else {
			if (game.mouseleftdeclick) {
				game.leftpressedpicking = false;
				left = false;
			}
		}
		if (!left) {
			game.currentAttackedBlock = null;
		}
		Packet_Item item = game.d_Inventory.RightHand[game.ActiveMaterial];
		bool ispistol = item != null && game.blocktypes[item.BlockId].IsPistol;
		bool ispistolshoot = ispistol && left;
		bool isgrenade = ispistol && game.blocktypes[item.BlockId].PistolType == 1;
		if (ispistol && isgrenade) {
			ispistolshoot = game.mouseleftdeclick;
		}
		if (game.mouseleftclick) {
			game.grenadecookingstartMilliseconds = game.platform.TimeMillisecondsFromStart();
			if (ispistol && isgrenade) {
				if (game.blocktypes[item.BlockId].Sounds.ShootCount > 0) {
					game.AudioPlay(game.platform.StringFormat("{0}.ogg", game.blocktypes[item.BlockId].Sounds.Shoot[0]));
				}
			}
		}
		float wait = one * (game.platform.TimeMillisecondsFromStart() - game.grenadecookingstartMilliseconds) / 1000;
		if (isgrenade && left) {
			if (wait >= game.grenadetime && isgrenade && game.grenadecookingstartMilliseconds != 0) {
				ispistolshoot = true;
				game.mouseleftdeclick = true;
			}
			else {
				return;
			}
		}
		else {
			game.grenadecookingstartMilliseconds = 0;
		}
		if (ispistol && game.mouserightclick && game.platform.TimeMillisecondsFromStart() - game.lastironsightschangeMilliseconds >= 500) {
			game.IronSights = !game.IronSights;
			game.lastironsightschangeMilliseconds = game.platform.TimeMillisecondsFromStart();
		}
		IntRef pick2count = new IntRef();
		Line3D pick = new Line3D();
		this.GetPickingLine(game, pick, ispistolshoot);
		BlockPosSide[] pick2 = game.Pick(game.s, pick, pick2count);
		if (left) {
			game.handSetAttackDestroy = true;
		}
		else if (right) {
			game.handSetAttackBuild = true;
		}
		if (game.overheadcamera && pick2count.value > 0 && left) {
			if (game.Follow == null) {
				game.playerdestination = Vector3Ref.Create(pick2[0].blockPos[0], pick2[0].blockPos[1] + 1, pick2[0].blockPos[2]);
			}
		}
		bool pickdistanceok = pick2count.value > 0;
		if (pickdistanceok) {
			if (game.Dist(pick2[0].blockPos[0] + one / 2, pick2[0].blockPos[1] + one / 2, pick2[0].blockPos[2] + one / 2, pick.Start[0], pick.Start[1], pick.Start[2]) > this.CurrentPickDistance(game)) {
				pickdistanceok = false;
			}
		}
		bool playertileempty = game.IsTileEmptyForPhysics(game.platform.FloatToInt(game.player.position.x), game.platform.FloatToInt(game.player.position.z), game.platform.FloatToInt(game.player.position.y + one / 2));
		bool playertileemptyclose = game.IsTileEmptyForPhysicsClose(game.platform.FloatToInt(game.player.position.x), game.platform.FloatToInt(game.player.position.z), game.platform.FloatToInt(game.player.position.y + one / 2));
		BlockPosSide pick0 = new BlockPosSide();
		if (pick2count.value > 0 && (pickdistanceok && (playertileempty || playertileemptyclose) || game.overheadcamera)) {
			game.SelectedBlockPositionX = game.platform.FloatToInt(pick2[0].Current()[0]);
			game.SelectedBlockPositionY = game.platform.FloatToInt(pick2[0].Current()[1]);
			game.SelectedBlockPositionZ = game.platform.FloatToInt(pick2[0].Current()[2]);
			pick0 = pick2[0];
		}
		else {
			game.SelectedBlockPositionX = -1;
			game.SelectedBlockPositionY = -1;
			game.SelectedBlockPositionZ = -1;
			pick0.blockPos = new float[3];
			pick0.blockPos[0] = -1;
			pick0.blockPos[1] = -1;
			pick0.blockPos[2] = -1;
		}
		this.PickEntity(game, pick, pick2, pick2count);
		if (game.cameratype == CameraType.Fpp || game.cameratype == CameraType.Tpp) {
			int ntileX = game.platform.FloatToInt(pick0.Current()[0]);
			int ntileY = game.platform.FloatToInt(pick0.Current()[1]);
			int ntileZ = game.platform.FloatToInt(pick0.Current()[2]);
			if (game.IsUsableBlock(game.map.GetBlock(ntileX, ntileZ, ntileY))) {
				game.currentAttackedBlock = Vector3IntRef.Create(ntileX, ntileZ, ntileY);
			}
		}
		if (game.GetFreeMouse()) {
			if (pick2count.value > 0) {
				this.OnPick_(pick0);
			}
			return;
		}
		if (one * (game.platform.TimeMillisecondsFromStart() - this.lastbuildMilliseconds) / 1000 >= this.BuildDelay(game) || IsNextShot) {
			if (left && game.d_Inventory.RightHand[game.ActiveMaterial] == null) {
				game.SendPacketClient(ClientPackets.MonsterHit(game.platform.FloatToInt(2 + game.rnd.NextFloat() * 4)));
			}
			if (left && !this.fastclicking) {
				this.fastclicking = false;
			}
			if ((left || right || middle) && !isgrenade) {
				this.lastbuildMilliseconds = game.platform.TimeMillisecondsFromStart();
			}
			if (isgrenade && game.mouseleftdeclick) {
				this.lastbuildMilliseconds = game.platform.TimeMillisecondsFromStart();
			}
			if (game.reloadstartMilliseconds != 0) {
				this.PickingEnd(left, right, middle, ispistol);
				return;
			}
			if (ispistolshoot) {
				if (!(game.LoadedAmmo[item.BlockId] > 0) || !(game.TotalAmmo[item.BlockId] > 0)) {
					game.AudioPlay("Dry Fire Gun-SoundBible.com-2053652037.ogg");
					this.PickingEnd(left, right, middle, ispistol);
					return;
				}
			}
			if (ispistolshoot) {
				float toX = pick.End[0];
				float toY = pick.End[1];
				float toZ = pick.End[2];
				if (pick2count.value > 0) {
					toX = pick2[0].blockPos[0];
					toY = pick2[0].blockPos[1];
					toZ = pick2[0].blockPos[2];
				}
				Packet_ClientShot shot = new Packet_ClientShot();
				shot.FromX = game.SerializeFloat(pick.Start[0]);
				shot.FromY = game.SerializeFloat(pick.Start[1]);
				shot.FromZ = game.SerializeFloat(pick.Start[2]);
				shot.ToX = game.SerializeFloat(toX);
				shot.ToY = game.SerializeFloat(toY);
				shot.ToZ = game.SerializeFloat(toZ);
				shot.HitPlayer = -1;
				for (int i = 0; i < game.entitiesCount; i++) {
					if (game.entities[i] == null) {
						continue;
					}
					if (game.entities[i].drawModel == null) {
						continue;
					}
					Entity p_ = game.entities[i];
					if (p_.networkPosition == null) {
						continue;
					}
					if (!p_.networkPosition.PositionLoaded) {
						continue;
					}
					float feetposX = p_.position.x;
					float feetposY = p_.position.y;
					float feetposZ = p_.position.z;
					Box3D bodybox = new Box3D();
					float headsize = (p_.drawModel.ModelHeight - p_.drawModel.eyeHeight) * 2;
					float h = p_.drawModel.ModelHeight - headsize;
					float r = one * 35 / 100;
					bodybox.AddPoint(feetposX - r, feetposY + 0, feetposZ - r);
					bodybox.AddPoint(feetposX - r, feetposY + 0, feetposZ + r);
					bodybox.AddPoint(feetposX + r, feetposY + 0, feetposZ - r);
					bodybox.AddPoint(feetposX + r, feetposY + 0, feetposZ + r);
					bodybox.AddPoint(feetposX - r, feetposY + h, feetposZ - r);
					bodybox.AddPoint(feetposX - r, feetposY + h, feetposZ + r);
					bodybox.AddPoint(feetposX + r, feetposY + h, feetposZ - r);
					bodybox.AddPoint(feetposX + r, feetposY + h, feetposZ + r);
					Box3D headbox = new Box3D();
					headbox.AddPoint(feetposX - r, feetposY + h, feetposZ - r);
					headbox.AddPoint(feetposX - r, feetposY + h, feetposZ + r);
					headbox.AddPoint(feetposX + r, feetposY + h, feetposZ - r);
					headbox.AddPoint(feetposX + r, feetposY + h, feetposZ + r);
					headbox.AddPoint(feetposX - r, feetposY + h + headsize, feetposZ - r);
					headbox.AddPoint(feetposX - r, feetposY + h + headsize, feetposZ + r);
					headbox.AddPoint(feetposX + r, feetposY + h + headsize, feetposZ - r);
					headbox.AddPoint(feetposX + r, feetposY + h + headsize, feetposZ + r);
					float[] p;
					float localeyeposX = game.EyesPosX();
					float localeyeposY = game.EyesPosY();
					float localeyeposZ = game.EyesPosZ();
					p = Intersection.CheckLineBoxExact(pick, headbox);
					if (p != null) {
						if (pick2count.value == 0 || game.Dist(pick2[0].blockPos[0], pick2[0].blockPos[1], pick2[0].blockPos[2], localeyeposX, localeyeposY, localeyeposZ) > game.Dist(p[0], p[1], p[2], localeyeposX, localeyeposY, localeyeposZ)) {
							if (!isgrenade) {
								Entity entity = new Entity();
								Sprite sprite = new Sprite();
								sprite.positionX = p[0];
								sprite.positionY = p[1];
								sprite.positionZ = p[2];
								sprite.image = "blood.png";
								entity.sprite = sprite;
								entity.expires = Expires.Create(one * 2 / 10);
								game.EntityAddLocal(entity);
							}
							shot.HitPlayer = i;
							shot.IsHitHead = 1;
						}
					}
					else {
						p = Intersection.CheckLineBoxExact(pick, bodybox);
						if (p != null) {
							if (pick2count.value == 0 || game.Dist(pick2[0].blockPos[0], pick2[0].blockPos[1], pick2[0].blockPos[2], localeyeposX, localeyeposY, localeyeposZ) > game.Dist(p[0], p[1], p[2], localeyeposX, localeyeposY, localeyeposZ)) {
								if (!isgrenade) {
									Entity entity = new Entity();
									Sprite sprite = new Sprite();
									sprite.positionX = p[0];
									sprite.positionY = p[1];
									sprite.positionZ = p[2];
									sprite.image = "blood.png";
									entity.sprite = sprite;
									entity.expires = Expires.Create(one * 2 / 10);
									game.EntityAddLocal(entity);
								}
								shot.HitPlayer = i;
								shot.IsHitHead = 0;
							}
						}
					}
				}
				shot.WeaponBlock = item.BlockId;
				game.LoadedAmmo[item.BlockId] = game.LoadedAmmo[item.BlockId] - 1;
				game.TotalAmmo[item.BlockId] = game.TotalAmmo[item.BlockId] - 1;
				float projectilespeed = game.DeserializeFloat(game.blocktypes[item.BlockId].ProjectileSpeedFloat);
				if (projectilespeed == 0) {
					{
						Entity entity = game.CreateBulletEntity(pick.Start[0], pick.Start[1], pick.Start[2], toX, toY, toZ, 150);
						game.EntityAddLocal(entity);
					}
				}
				else {
					float vX = toX - pick.Start[0];
					float vY = toY - pick.Start[1];
					float vZ = toZ - pick.Start[2];
					float vLength = game.Length(vX, vY, vZ);
					vX /= vLength;
					vY /= vLength;
					vZ /= vLength;
					vX *= projectilespeed;
					vY *= projectilespeed;
					vZ *= projectilespeed;
					shot.ExplodesAfter = game.SerializeFloat(game.grenadetime - wait);
					{
						Entity grenadeEntity = new Entity();
						Sprite sprite = new Sprite();
						sprite.image = "ChemicalGreen.png";
						sprite.size = 14;
						sprite.animationcount = 0;
						sprite.positionX = pick.Start[0];
						sprite.positionY = pick.Start[1];
						sprite.positionZ = pick.Start[2];
						grenadeEntity.sprite = sprite;
						Grenade_ projectile = new Grenade_();
						projectile.velocityX = vX;
						projectile.velocityY = vY;
						projectile.velocityZ = vZ;
						projectile.block = item.BlockId;
						projectile.sourcePlayer = game.LocalPlayerId;
						grenadeEntity.expires = Expires.Create(game.grenadetime - wait);
						grenadeEntity.grenade = projectile;
						game.EntityAddLocal(grenadeEntity);
					}
				}
				Packet_Client packet = new Packet_Client();
				packet.Id = 54;
				packet.Shot = shot;
				game.SendPacketClient(packet);
				if (game.blocktypes[item.BlockId].Sounds.ShootEndCount > 0) {
					game.pistolcycle = game.rnd.Next() % game.blocktypes[item.BlockId].Sounds.ShootEndCount;
					game.AudioPlay(game.platform.StringFormat("{0}.ogg", game.blocktypes[item.BlockId].Sounds.ShootEnd[game.pistolcycle]));
				}
				bulletsshot++;
				if (bulletsshot < game.DeserializeFloat(game.blocktypes[item.BlockId].BulletsPerShotFloat)) {
					this.NextBullet(game, bulletsshot);
				}
				game.player.position.rotx -= game.rnd.NextFloat() * game.CurrentRecoil();
				game.player.position.roty += game.rnd.NextFloat() * game.CurrentRecoil() * 2 - game.CurrentRecoil();
				this.PickingEnd(left, right, middle, ispistol);
				return;
			}
			if (ispistol && right) {
				this.PickingEnd(left, right, middle, ispistol);
				return;
			}
			if (pick2count.value > 0) {
				if (middle) {
					int newtileX = game.platform.FloatToInt(pick0.Current()[0]);
					int newtileY = game.platform.FloatToInt(pick0.Current()[1]);
					int newtileZ = game.platform.FloatToInt(pick0.Current()[2]);
					if (game.map.IsValidPos(newtileX, newtileZ, newtileY)) {
						int clonesource = game.map.GetBlock(newtileX, newtileZ, newtileY);
						int clonesource2 = game.d_Data.WhenPlayerPlacesGetsConvertedTo()[clonesource];
						bool gotoDone = false;
						for (int i = 0; i < 10; i++) {
							if (game.d_Inventory.RightHand[i] != null && game.d_Inventory.RightHand[i].ItemClass == 0 && game.d_Inventory.RightHand[i].BlockId == clonesource2) {
								game.ActiveMaterial = i;
								gotoDone = true;
							}
						}
						if (!gotoDone) {
							IntRef freehand = game.d_InventoryUtil.FreeHand(game.ActiveMaterial);
							for (int i = 0; i < game.d_Inventory.ItemsCount; i++) {
								Packet_PositionItem k = game.d_Inventory.Items[i];
								if (k == null) {
									continue;
								}
								if (k.Value_.ItemClass == 0 && k.Value_.BlockId == clonesource2) {
									if (freehand != null) {
										game.WearItem(game.InventoryPositionMainArea(k.X, k.Y), game.InventoryPositionMaterialSelector(freehand.value));
										break;
									}
									if (game.d_Inventory.RightHand[game.ActiveMaterial] != null && game.d_Inventory.RightHand[game.ActiveMaterial].ItemClass == 0) {
										game.MoveToInventory(game.InventoryPositionMaterialSelector(game.ActiveMaterial));
										game.WearItem(game.InventoryPositionMainArea(k.X, k.Y), game.InventoryPositionMaterialSelector(game.ActiveMaterial));
									}
								}
							}
						}
						string[] sound = game.d_Data.CloneSound()[clonesource];
						if (sound != null) {
							game.AudioPlay(sound[0]);
						}
					}
				}
				if (left || right) {
					BlockPosSide tile = pick0;
					int newtileX;
					int newtileY;
					int newtileZ;
					if (right) {
						newtileX = game.platform.FloatToInt(tile.Translated()[0]);
						newtileY = game.platform.FloatToInt(tile.Translated()[1]);
						newtileZ = game.platform.FloatToInt(tile.Translated()[2]);
					}
					else {
						newtileX = game.platform.FloatToInt(tile.Current()[0]);
						newtileY = game.platform.FloatToInt(tile.Current()[1]);
						newtileZ = game.platform.FloatToInt(tile.Current()[2]);
					}
					if (game.map.IsValidPos(newtileX, newtileZ, newtileY)) {
						if (!(pick0.blockPos[0] == -1 && pick0.blockPos[1] == -1 && pick0.blockPos[2] == -1)) {
							int blocktype;
							if (left) {
								blocktype = game.map.GetBlock(newtileX, newtileZ, newtileY);
							}
							else {
								blocktype = game.BlockInHand() == null ? 1 : game.BlockInHand().value;
							}
							if (left && blocktype == game.d_Data.BlockIdAdminium()) {
								this.PickingEnd(left, right, middle, ispistol);
								return;
							}
							string[] sound = left ? game.d_Data.BreakSound()[blocktype] : game.d_Data.BuildSound()[blocktype];
							if (sound != null) {
								game.AudioPlay(sound[0]);
							}
						}
						if (!right) {
							int posx = newtileX;
							int posy = newtileZ;
							int posz = newtileY;
							game.currentAttackedBlock = Vector3IntRef.Create(posx, posy, posz);
							if (!game.blockHealth.ContainsKey(posx, posy, posz)) {
								game.blockHealth.Set(posx, posy, posz, game.GetCurrentBlockHealth(posx, posy, posz));
							}
							game.blockHealth.Set(posx, posy, posz, game.blockHealth.Get(posx, posy, posz) - game.WeaponAttackStrength());
							float health = game.GetCurrentBlockHealth(posx, posy, posz);
							if (health <= 0) {
								if (game.currentAttackedBlock != null) {
									game.blockHealth.Remove(posx, posy, posz);
								}
								game.currentAttackedBlock = null;
								this.OnPick(game, game.platform.FloatToInt(newtileX), game.platform.FloatToInt(newtileZ), game.platform.FloatToInt(newtileY), game.platform.FloatToInt(tile.Current()[0]), game.platform.FloatToInt(tile.Current()[2]), game.platform.FloatToInt(tile.Current()[1]), tile.collisionPos, right);
							}
							this.PickingEnd(left, right, middle, ispistol);
							return;
						}
						if (!right) {
							game.particleEffectBlockBreak.StartParticleEffect(newtileX, newtileY, newtileZ);
						}
						if (!game.map.IsValidPos(newtileX, newtileZ, newtileY)) {
							game.platform.ThrowException("Error in picking - NextBullet()");
						}
						this.OnPick(game, game.platform.FloatToInt(newtileX), game.platform.FloatToInt(newtileZ), game.platform.FloatToInt(newtileY), game.platform.FloatToInt(tile.Current()[0]), game.platform.FloatToInt(tile.Current()[2]), game.platform.FloatToInt(tile.Current()[1]), tile.collisionPos, right);
					}
				}
			}
		}
		this.PickingEnd(left, right, middle, ispistol);
	}

	public override void OnMouseDown(Game game, MouseEventArgs args)
	{
		if (game.guistate == GuiState.Normal) {
			this.UpdatePicking(game);
			this.UpdateEntityHit(game);
		}
	}

	public override void OnMouseUp(Game game, MouseEventArgs args)
	{
		if (game.guistate == GuiState.Normal) {
			this.UpdatePicking(game);
		}
	}

	public override void OnNewFrameReadOnlyMainThread(Game game, float deltaTime)
	{
		if (game.guistate == GuiState.Normal) {
			this.UpdatePicking(game);
		}
	}

	internal void OnPick(Game game, int blockposX, int blockposY, int blockposZ, int blockposoldX, int blockposoldY, int blockposoldZ, float[] collisionPos, bool right)
	{
		float xfract = collisionPos[0] - game.MathFloor(collisionPos[0]);
		float zfract = collisionPos[2] - game.MathFloor(collisionPos[2]);
		int activematerial = game.MaterialSlots_(game.ActiveMaterial);
		int railstart = game.d_Data.BlockIdRailstart();
		if (activematerial == railstart + 3 || activematerial == railstart + 60) {
			RailDirection dirnew;
			if (activematerial == railstart + 3) {
				dirnew = this.PickHorizontalVertical(xfract, zfract);
			}
			else {
				dirnew = this.PickCorners(xfract, zfract);
			}
			int dir = game.d_Data.Rail()[game.map.GetBlock(blockposoldX, blockposoldY, blockposoldZ)];
			if (dir != 0) {
				blockposX = blockposoldX;
				blockposY = blockposoldY;
				blockposZ = blockposoldZ;
			}
			activematerial = railstart + (dir | DirectionUtils.ToRailDirectionFlags(dirnew));
		}
		int x = game.platform.FloatToInt(blockposX);
		int y = game.platform.FloatToInt(blockposY);
		int z = game.platform.FloatToInt(blockposZ);
		int mode = right ? 1 : 0;
		{
			if (game.IsAnyPlayerInPos(x, y, z) || activematerial == 151) {
				return;
			}
			Vector3IntRef v = Vector3IntRef.Create(x, y, z);
			Vector3IntRef oldfillstart = this.fillstart;
			Vector3IntRef oldfillend = this.fillend;
			if (mode == 1) {
				if (game.blocktypes[activematerial].IsTool) {
					this.OnPickUseWithTool(game, blockposX, blockposY, blockposZ);
					return;
				}
				if (activematerial == game.d_Data.BlockIdCuboid()) {
					this.ClearFillArea(game);
					if (this.fillstart != null) {
						Vector3IntRef f = this.fillstart;
						if (!game.IsFillBlock(game.map.GetBlock(f.X, f.Y, f.Z))) {
							this.fillarea.Set(f.X, f.Y, f.Z, game.map.GetBlock(f.X, f.Y, f.Z));
						}
						game.SetBlock(f.X, f.Y, f.Z, game.d_Data.BlockIdFillStart());
						this.FillFill(game, v, this.fillstart);
					}
					if (!game.IsFillBlock(game.map.GetBlock(v.X, v.Y, v.Z))) {
						this.fillarea.Set(v.X, v.Y, v.Z, game.map.GetBlock(v.X, v.Y, v.Z));
					}
					game.SetBlock(v.X, v.Y, v.Z, game.d_Data.BlockIdCuboid());
					this.fillend = v;
					game.RedrawBlock(v.X, v.Y, v.Z);
					return;
				}
				if (activematerial == game.d_Data.BlockIdFillStart()) {
					this.ClearFillArea(game);
					if (!game.IsFillBlock(game.map.GetBlock(v.X, v.Y, v.Z))) {
						this.fillarea.Set(v.X, v.Y, v.Z, game.map.GetBlock(v.X, v.Y, v.Z));
					}
					game.SetBlock(v.X, v.Y, v.Z, game.d_Data.BlockIdFillStart());
					this.fillstart = v;
					this.fillend = null;
					game.RedrawBlock(v.X, v.Y, v.Z);
					return;
				}
				if (this.fillarea.ContainsKey(v.X, v.Y, v.Z)) {
					game.SendFillArea(this.fillstart.X, this.fillstart.Y, this.fillstart.Z, this.fillend.X, this.fillend.Y, this.fillend.Z, activematerial);
					this.ClearFillArea(game);
					this.fillstart = null;
					this.fillend = null;
					return;
				}
			}
			else {
				if (game.blocktypes[activematerial].IsTool) {
					this.OnPickUseWithTool(game, blockposX, blockposY, blockposoldZ);
					return;
				}
				if (this.fillstart != null && this.fillstart.X == v.X && this.fillstart.Y == v.Y && this.fillstart.Z == v.Z) {
					this.ClearFillArea(game);
					this.fillstart = null;
					this.fillend = null;
					return;
				}
				if (this.fillend != null && this.fillend.X == v.X && this.fillend.Y == v.Y && this.fillend.Z == v.Z) {
					this.ClearFillArea(game);
					this.fillend = null;
					return;
				}
			}
			game.SendSetBlockAndUpdateSpeculative(activematerial, x, y, z, mode);
		}
	}

	internal void OnPickUseWithTool(Game game, int posX, int posY, int posZ)
	{
		game.SendSetBlock(posX, posY, posZ, 3, game.d_Inventory.RightHand[game.ActiveMaterial].BlockId, game.ActiveMaterial);
	}

	internal void OnPick_(BlockPosSide pick0)
	{
	}

	internal RailDirection PickCorners(float xfract, float zfract)
	{
		float half = 0.5f;
		if (xfract < half && zfract < half) {
			return RailDirection.UpLeft;
		}
		if (xfract >= half && zfract < half) {
			return RailDirection.UpRight;
		}
		if (xfract < half && zfract >= half) {
			return RailDirection.DownLeft;
		}
		return RailDirection.DownRight;
	}

	void PickEntity(Game game, Line3D pick, BlockPosSide[] pick2, IntRef pick2count)
	{
		game.SelectedEntityId = -1;
		game.currentlyAttackedEntity = -1;
		float one = 1;
		for (int i = 0; i < game.entitiesCount; i++) {
			if (game.entities[i] == null) {
				continue;
			}
			if (i == game.LocalPlayerId) {
				continue;
			}
			if (game.entities[i].drawModel == null) {
				continue;
			}
			Entity p_ = game.entities[i];
			if (p_.networkPosition == null) {
				continue;
			}
			if (!p_.networkPosition.PositionLoaded) {
				continue;
			}
			if (!p_.usable) {
				continue;
			}
			float feetposX = p_.position.x;
			float feetposY = p_.position.y;
			float feetposZ = p_.position.z;
			float dist = game.Dist(feetposX, feetposY, feetposZ, game.player.position.x, game.player.position.y, game.player.position.z);
			if (dist > 5) {
				continue;
			}
			Box3D bodybox = new Box3D();
			float h = p_.drawModel.ModelHeight;
			float r = one * 35 / 100;
			bodybox.AddPoint(feetposX - r, feetposY + 0, feetposZ - r);
			bodybox.AddPoint(feetposX - r, feetposY + 0, feetposZ + r);
			bodybox.AddPoint(feetposX + r, feetposY + 0, feetposZ - r);
			bodybox.AddPoint(feetposX + r, feetposY + 0, feetposZ + r);
			bodybox.AddPoint(feetposX - r, feetposY + h, feetposZ - r);
			bodybox.AddPoint(feetposX - r, feetposY + h, feetposZ + r);
			bodybox.AddPoint(feetposX + r, feetposY + h, feetposZ - r);
			bodybox.AddPoint(feetposX + r, feetposY + h, feetposZ + r);
			float[] p;
			float localeyeposX = game.EyesPosX();
			float localeyeposY = game.EyesPosY();
			float localeyeposZ = game.EyesPosZ();
			p = Intersection.CheckLineBoxExact(pick, bodybox);
			if (p != null) {
				if (pick2count.value == 0 || game.Dist(pick2[0].blockPos[0], pick2[0].blockPos[1], pick2[0].blockPos[2], localeyeposX, localeyeposY, localeyeposZ) > game.Dist(p[0], p[1], p[2], localeyeposX, localeyeposY, localeyeposZ)) {
					game.SelectedEntityId = i;
					if (game.cameratype == CameraType.Fpp || game.cameratype == CameraType.Tpp) {
						game.currentlyAttackedEntity = i;
					}
				}
			}
		}
	}

	internal RailDirection PickHorizontalVertical(float xfract, float yfract)
	{
		float x = xfract;
		float y = yfract;
		if (y >= x && y >= 1 - x) {
			return RailDirection.Vertical;
		}
		if (y < x && y < 1 - x) {
			return RailDirection.Vertical;
		}
		return RailDirection.Horizontal;
	}

	internal void PickingEnd(bool left, bool right, bool middle, bool ispistol)
	{
		this.fastclicking = false;
		if (!(left || right || middle) && !ispistol) {
			this.lastbuildMilliseconds = 0;
			this.fastclicking = true;
		}
	}

	void UpdateEntityHit(Game game)
	{
		if (game.currentlyAttackedEntity != -1 && game.mouseLeft) {
			for (int i = 0; i < game.clientmodsCount; i++) {
				if (game.clientmods[i] == null) {
					continue;
				}
				OnUseEntityArgs args = new OnUseEntityArgs();
				args.entityId = game.currentlyAttackedEntity;
				game.clientmods[i].OnHitEntity(game, args);
			}
			game.SendPacketClient(ClientPackets.HitEntity(game.currentlyAttackedEntity));
		}
	}

	internal void UpdatePicking(Game game)
	{
		if (game.FollowId() != null) {
			game.SelectedBlockPositionX = -1;
			game.SelectedBlockPositionY = -1;
			game.SelectedBlockPositionZ = -1;
			return;
		}
		this.NextBullet(game, 0);
	}
	internal bool fastclicking;
	internal DictionaryVector3Float fillarea;
	internal Vector3IntRef fillend;
	internal Vector3IntRef fillstart;
	internal int lastbuildMilliseconds;
	float[] tempRay;
	float[] tempRayStartPoint;
	float[] tempViewport;
	Unproject unproject;
}

public class ModPush : ClientMod
{

	public override void OnNewFrameFixed(Game game, NewFrameEventArgs args)
	{
		game.pushX = 0;
		game.pushY = 0;
		game.pushZ = 0;
		float LocalPlayerPositionX = game.player.position.x;
		float LocalPlayerPositionY = game.player.position.y;
		float LocalPlayerPositionZ = game.player.position.z;
		for (int i = 0; i < game.entitiesCount; i++) {
			Entity entity = game.entities[i];
			if (entity == null) {
				continue;
			}
			if (entity.push == null) {
				continue;
			}
			if (entity.networkPosition != null && !entity.networkPosition.PositionLoaded) {
				continue;
			}
			float kposX = game.DeserializeFloat(entity.push.XFloat);
			float kposY = game.DeserializeFloat(entity.push.ZFloat);
			float kposZ = game.DeserializeFloat(entity.push.YFloat);
			if (entity.push.IsRelativeToPlayerPosition != 0) {
				kposX += LocalPlayerPositionX;
				kposY += LocalPlayerPositionY;
				kposZ += LocalPlayerPositionZ;
			}
			float dist = game.Dist(kposX, kposY, kposZ, LocalPlayerPositionX, LocalPlayerPositionY, LocalPlayerPositionZ);
			if (dist < game.DeserializeFloat(entity.push.RangeFloat)) {
				float diffX = LocalPlayerPositionX - kposX;
				float diffY = LocalPlayerPositionY - kposY;
				float diffZ = LocalPlayerPositionZ - kposZ;
				game.pushX += diffX;
				game.pushY += diffY;
				game.pushZ += diffZ;
			}
		}
	}
}

public class ModRail : ClientMod
{
	public ModRail()
	{
		this.one = 1;
		this.railheight = this.one * 3 / 10;
	}

	internal VehicleDirection12 BestNewDirection(int dirVehicleDirection12Flags, bool turnleft, bool turnright, BoolRef retFound)
	{
		retFound.value = true;
		if (turnright) {
			if ((dirVehicleDirection12Flags & 2048) != 0) {
				return VehicleDirection12.DownRightRight;
			}
			if ((dirVehicleDirection12Flags & 64) != 0) {
				return VehicleDirection12.UpRightUp;
			}
			if ((dirVehicleDirection12Flags & 32) != 0) {
				return VehicleDirection12.UpLeftLeft;
			}
			if ((dirVehicleDirection12Flags & 256) != 0) {
				return VehicleDirection12.DownLeftDown;
			}
		}
		if (turnleft) {
			if ((dirVehicleDirection12Flags & 1024) != 0) {
				return VehicleDirection12.DownRightDown;
			}
			if ((dirVehicleDirection12Flags & 128) != 0) {
				return VehicleDirection12.UpRightRight;
			}
			if ((dirVehicleDirection12Flags & 16) != 0) {
				return VehicleDirection12.UpLeftUp;
			}
			if ((dirVehicleDirection12Flags & 512) != 0) {
				return VehicleDirection12.DownLeftLeft;
			}
		}
		if ((dirVehicleDirection12Flags & 8) != 0) {
			return VehicleDirection12.VerticalDown;
		}
		if ((dirVehicleDirection12Flags & 4) != 0) {
			return VehicleDirection12.VerticalUp;
		}
		if ((dirVehicleDirection12Flags & 1) != 0) {
			return VehicleDirection12.HorizontalLeft;
		}
		if ((dirVehicleDirection12Flags & 2) != 0) {
			return VehicleDirection12.HorizontalRight;
		}
		if ((dirVehicleDirection12Flags & 256) != 0) {
			return VehicleDirection12.DownLeftDown;
		}
		if ((dirVehicleDirection12Flags & 512) != 0) {
			return VehicleDirection12.DownLeftLeft;
		}
		if ((dirVehicleDirection12Flags & 1024) != 0) {
			return VehicleDirection12.DownRightDown;
		}
		if ((dirVehicleDirection12Flags & 2048) != 0) {
			return VehicleDirection12.DownRightRight;
		}
		if ((dirVehicleDirection12Flags & 32) != 0) {
			return VehicleDirection12.UpLeftLeft;
		}
		if ((dirVehicleDirection12Flags & 16) != 0) {
			return VehicleDirection12.UpLeftUp;
		}
		if ((dirVehicleDirection12Flags & 128) != 0) {
			return VehicleDirection12.UpRightRight;
		}
		if ((dirVehicleDirection12Flags & 64) != 0) {
			return VehicleDirection12.UpRightUp;
		}
		retFound.value = false;
		return VehicleDirection12.DownLeftDown;
	}

	internal Vector3Ref CurrentRailPos(Game game)
	{
		RailSlope slope = this.d_RailMapUtil.GetRailSlope(this.currentrailblockX, this.currentrailblockY, this.currentrailblockZ);
		float aX = this.currentrailblockX;
		float aY = this.currentrailblockY;
		float aZ = this.currentrailblockZ;
		float x_correction = 0;
		float y_correction = 0;
		float z_correction = 0;
		float half = this.one / 2;
		switch (this.currentdirection) {
		case VehicleDirection12.HorizontalRight:
			x_correction += this.currentrailblockprogress;
			y_correction += half;
			if (slope == RailSlope.TwoRightRaised)
				z_correction += this.currentrailblockprogress;
			if (slope == RailSlope.TwoLeftRaised)
				z_correction += 1 - this.currentrailblockprogress;
			break;
		case VehicleDirection12.HorizontalLeft:
			x_correction += 1 - this.currentrailblockprogress;
			y_correction += half;
			if (slope == RailSlope.TwoRightRaised)
				z_correction += 1 - this.currentrailblockprogress;
			if (slope == RailSlope.TwoLeftRaised)
				z_correction += this.currentrailblockprogress;
			break;
		case VehicleDirection12.VerticalDown:
			x_correction += half;
			y_correction += this.currentrailblockprogress;
			if (slope == RailSlope.TwoDownRaised)
				z_correction += this.currentrailblockprogress;
			if (slope == RailSlope.TwoUpRaised)
				z_correction += 1 - this.currentrailblockprogress;
			break;
		case VehicleDirection12.VerticalUp:
			x_correction += half;
			y_correction += 1 - this.currentrailblockprogress;
			if (slope == RailSlope.TwoDownRaised)
				z_correction += 1 - this.currentrailblockprogress;
			if (slope == RailSlope.TwoUpRaised)
				z_correction += this.currentrailblockprogress;
			break;
		case VehicleDirection12.UpLeftLeft:
			x_correction += half * (1 - this.currentrailblockprogress);
			y_correction += half * this.currentrailblockprogress;
			break;
		case VehicleDirection12.UpLeftUp:
			x_correction += half * this.currentrailblockprogress;
			y_correction += half - half * this.currentrailblockprogress;
			break;
		case VehicleDirection12.UpRightRight:
			x_correction += half + half * this.currentrailblockprogress;
			y_correction += half * this.currentrailblockprogress;
			break;
		case VehicleDirection12.UpRightUp:
			x_correction += 1 - half * this.currentrailblockprogress;
			y_correction += half - half * this.currentrailblockprogress;
			break;
		case VehicleDirection12.DownLeftLeft:
			x_correction += half * (1 - this.currentrailblockprogress);
			y_correction += 1 - half * this.currentrailblockprogress;
			break;
		case VehicleDirection12.DownLeftDown:
			x_correction += half * this.currentrailblockprogress;
			y_correction += half + half * this.currentrailblockprogress;
			break;
		case VehicleDirection12.DownRightRight:
			x_correction += half + half * this.currentrailblockprogress;
			y_correction += 1 - half * this.currentrailblockprogress;
			break;
		case VehicleDirection12.DownRightDown:
			x_correction += 1 - half * this.currentrailblockprogress;
			y_correction += half + half * this.currentrailblockprogress;
			break;
		}
		return Vector3Ref.Create(aX + x_correction, aZ + this.railheight + 1 + z_correction, aY + y_correction);
	}

	internal void ExitVehicle(Game game)
	{
		game.SetCharacterEyesHeight(this.originalmodelheight);
		this.railriding = false;
		game.controls.SetFreemove(0);
		game.enable_move = true;
	}

	internal int GetUpDownMove(Game game, int railblockX, int railblockY, int railblockZ, TileEnterDirection dir)
	{
		if (!game.map.IsValidPos(railblockX, railblockY, railblockZ)) {
			return 0;
		}
		RailSlope slope = this.d_RailMapUtil.GetRailSlope(railblockX, railblockY, railblockZ);
		if (slope == RailSlope.TwoDownRaised && dir == TileEnterDirection.Up) {
			return 1;
		}
		if (slope == RailSlope.TwoUpRaised && dir == TileEnterDirection.Down) {
			return 1;
		}
		if (slope == RailSlope.TwoLeftRaised && dir == TileEnterDirection.Right) {
			return 1;
		}
		if (slope == RailSlope.TwoRightRaised && dir == TileEnterDirection.Left) {
			return 1;
		}
		if (slope == RailSlope.TwoDownRaised && dir == TileEnterDirection.Down) {
			return 2;
		}
		if (slope == RailSlope.TwoUpRaised && dir == TileEnterDirection.Up) {
			return 2;
		}
		if (slope == RailSlope.TwoLeftRaised && dir == TileEnterDirection.Left) {
			return 2;
		}
		if (slope == RailSlope.TwoRightRaised && dir == TileEnterDirection.Right) {
			return 2;
		}
		return 0;
	}

	public static Vector3IntRef NextTile(VehicleDirection12 direction, int currentTileX, int currentTileY, int currentTileZ)
	{
		return ModRail.NextTile_(DirectionUtils.ResultExit(direction), currentTileX, currentTileY, currentTileZ);
	}

	public static Vector3IntRef NextTile_(TileExitDirection direction, int currentTileX, int currentTileY, int currentTileZ)
	{
		switch (direction) {
		case TileExitDirection.Left:
			return Vector3IntRef.Create(currentTileX - 1, currentTileY, currentTileZ);
		case TileExitDirection.Right:
			return Vector3IntRef.Create(currentTileX + 1, currentTileY, currentTileZ);
		case TileExitDirection.Up:
			return Vector3IntRef.Create(currentTileX, currentTileY - 1, currentTileZ);
		case TileExitDirection.Down:
			return Vector3IntRef.Create(currentTileX, currentTileY + 1, currentTileZ);
		default:
			return null;
		}
	}

	public override void OnNewFrameFixed(Game game, NewFrameEventArgs args)
	{
		if (this.d_RailMapUtil == null) {
			this.d_RailMapUtil = new RailMapUtil();
			this.d_RailMapUtil.game = game;
		}
		this.RailOnNewFrame(game, args.GetDt());
	}

	internal int PossibleRails(Game game, TileEnterData enter)
	{
		int possible_railsVehicleDirection12Flags = 0;
		if (game.map.IsValidPos(enter.BlockPositionX, enter.BlockPositionY, enter.BlockPositionZ)) {
			int newpositionrail = game.d_Data.Rail()[game.map.GetBlock(enter.BlockPositionX, enter.BlockPositionY, enter.BlockPositionZ)];
			VehicleDirection12[] all_possible_rails = new VehicleDirection12[3];
			int all_possible_railsCount = 0;
			VehicleDirection12[] possibleRails3 = DirectionUtils.PossibleNewRails3(enter.EnterDirection);
			for (int i = 0; i < 3; i++) {
				VehicleDirection12 z = possibleRails3[i];
				if ((newpositionrail & DirectionUtils.ToRailDirectionFlags(DirectionUtils.ToRailDirection(z))) != 0) {
					all_possible_rails[all_possible_railsCount++] = z;
				}
			}
			possible_railsVehicleDirection12Flags = DirectionUtils.ToVehicleDirection12Flags_(all_possible_rails, all_possible_railsCount);
		}
		return possible_railsVehicleDirection12Flags;
	}

	internal void RailOnNewFrame(Game game, float dt)
	{
		if (this.localMinecart == null) {
			this.localMinecart = new Entity();
			this.localMinecart.minecart = new Minecart();
			game.EntityAddLocal(this.localMinecart);
		}
		this.localMinecart.minecart.enabled = this.railriding;
		if (this.railriding) {
			Minecart m = this.localMinecart.minecart;
			m.positionX = game.player.position.x;
			m.positionY = game.player.position.y;
			m.positionZ = game.player.position.z;
			m.direction = this.currentdirection;
			m.lastdirection = this.lastdirection;
			m.progress = this.currentrailblockprogress;
		}
		game.localplayeranimationhint.InVehicle = this.railriding;
		game.localplayeranimationhint.DrawFixX = 0;
		game.localplayeranimationhint.DrawFixY = this.railriding ? -this.one * 7 / 10 : 0;
		game.localplayeranimationhint.DrawFixZ = 0;
		bool turnright = game.keyboardState[game.GetKey(86)];
		bool turnleft = game.keyboardState[game.GetKey(83)];
		this.RailSound(game);
		if (this.railriding) {
			game.controls.SetFreemove(1);
			game.enable_move = false;
			Vector3Ref railPos = this.CurrentRailPos(game);
			game.player.position.x = railPos.X;
			game.player.position.y = railPos.Y;
			game.player.position.z = railPos.Z;
			this.currentrailblockprogress += this.currentvehiclespeed * dt;
			if (this.currentrailblockprogress >= 1) {
				this.lastdirection = this.currentdirection;
				this.currentrailblockprogress = 0;
				TileEnterData newenter = new TileEnterData();
				Vector3IntRef nexttile = ModRail.NextTile(this.currentdirection, this.currentrailblockX, this.currentrailblockY, this.currentrailblockZ);
				newenter.BlockPositionX = nexttile.X;
				newenter.BlockPositionY = nexttile.Y;
				newenter.BlockPositionZ = nexttile.Z;
				if (this.GetUpDownMove(game, this.currentrailblockX, this.currentrailblockY, this.currentrailblockZ, DirectionUtils.ResultEnter(DirectionUtils.ResultExit(this.currentdirection))) == 1) {
					newenter.BlockPositionZ++;
				}
				if (this.GetUpDownMove(game, newenter.BlockPositionX, newenter.BlockPositionY, newenter.BlockPositionZ - 1, DirectionUtils.ResultEnter(DirectionUtils.ResultExit(this.currentdirection))) == 2) {
					newenter.BlockPositionZ--;
				}
				newenter.EnterDirection = DirectionUtils.ResultEnter(DirectionUtils.ResultExit(this.currentdirection));
				BoolRef newdirFound = new BoolRef();
				VehicleDirection12 newdir = this.BestNewDirection(this.PossibleRails(game, newenter), turnleft, turnright, newdirFound);
				if (!newdirFound.value) {
					this.currentdirection = DirectionUtils.Reverse(this.currentdirection);
				}
				else {
					this.currentdirection = newdir;
					this.currentrailblockX = game.platform.FloatToInt(newenter.BlockPositionX);
					this.currentrailblockY = game.platform.FloatToInt(newenter.BlockPositionY);
					this.currentrailblockZ = game.platform.FloatToInt(newenter.BlockPositionZ);
				}
			}
		}
		if (game.keyboardState[game.GetKey(105)] && game.GuiTyping != TypingState.Typing) {
			this.currentvehiclespeed += 1 * dt;
		}
		if (game.keyboardState[game.GetKey(101)] && game.GuiTyping != TypingState.Typing) {
			this.currentvehiclespeed -= 5 * dt;
		}
		if (this.currentvehiclespeed < 0) {
			this.currentvehiclespeed = 0;
		}
		if (!this.wasqpressed && game.keyboardState[game.GetKey(99)] && game.GuiTyping != TypingState.Typing) {
			this.Reverse();
		}
		if (!this.wasepressed && game.keyboardState[game.GetKey(87)] && !this.railriding && game.controls.GetFreemove() == 0 && game.GuiTyping != TypingState.Typing) {
			this.currentrailblockX = game.platform.FloatToInt(game.player.position.x);
			this.currentrailblockY = game.platform.FloatToInt(game.player.position.z);
			this.currentrailblockZ = game.platform.FloatToInt(game.player.position.y) - 1;
			if (!game.map.IsValidPos(this.currentrailblockX, this.currentrailblockY, this.currentrailblockZ)) {
				this.ExitVehicle(game);
			}
			else {
				int railunderplayer = game.d_Data.Rail()[game.map.GetBlock(this.currentrailblockX, this.currentrailblockY, this.currentrailblockZ)];
				this.railriding = true;
				this.originalmodelheight = game.GetCharacterEyesHeight();
				game.SetCharacterEyesHeight(this.minecartheight());
				this.currentvehiclespeed = 0;
				if ((railunderplayer & 1) != 0) {
					this.currentdirection = VehicleDirection12.HorizontalRight;
				}
				else if ((railunderplayer & 2) != 0) {
					this.currentdirection = VehicleDirection12.VerticalUp;
				}
				else if ((railunderplayer & 4) != 0) {
					this.currentdirection = VehicleDirection12.UpLeftUp;
				}
				else if ((railunderplayer & 8) != 0) {
					this.currentdirection = VehicleDirection12.UpRightUp;
				}
				else if ((railunderplayer & 16) != 0) {
					this.currentdirection = VehicleDirection12.DownLeftLeft;
				}
				else if ((railunderplayer & 32) != 0) {
					this.currentdirection = VehicleDirection12.DownRightRight;
				}
				else {
					this.ExitVehicle(game);
				}
				this.lastdirection = this.currentdirection;
			}
		}
		else if (!this.wasepressed && game.keyboardState[game.GetKey(87)] && this.railriding && game.GuiTyping != TypingState.Typing) {
			this.ExitVehicle(game);
			game.player.position.y += this.one * 7 / 10;
		}
		this.wasqpressed = game.keyboardState[game.GetKey(99)] && game.GuiTyping != TypingState.Typing;
		this.wasepressed = game.keyboardState[game.GetKey(87)] && game.GuiTyping != TypingState.Typing;
	}

	internal void RailSound(Game game)
	{
		float railsoundpersecond = this.currentvehiclespeed;
		if (railsoundpersecond > 10) {
			railsoundpersecond = 10;
		}
		game.AudioPlayLoop("railnoise.wav", this.railriding && railsoundpersecond > this.one * 1 / 10, false);
		if (!this.railriding) {
			return;
		}
		if (game.platform.TimeMillisecondsFromStart() - this.lastrailsoundtimeMilliseconds > 1000 / railsoundpersecond) {
			game.AudioPlay(game.platform.StringFormat("rail{0}.wav", game.platform.IntToString(this.lastrailsound + 1)));
			this.lastrailsoundtimeMilliseconds = game.platform.TimeMillisecondsFromStart();
			this.lastrailsound++;
			if (this.lastrailsound >= 4) {
				this.lastrailsound = 0;
			}
		}
	}

	internal void Reverse()
	{
		this.currentdirection = DirectionUtils.Reverse(this.currentdirection);
		this.currentrailblockprogress = 1 - this.currentrailblockprogress;
		this.lastdirection = this.currentdirection;
	}
	internal VehicleDirection12 currentdirection;
	internal int currentrailblockX;
	internal int currentrailblockY;
	internal int currentrailblockZ;
	internal float currentrailblockprogress;
	internal float currentvehiclespeed;
	internal RailMapUtil d_RailMapUtil;
	internal VehicleDirection12 lastdirection;
	int lastrailsound;
	int lastrailsoundtimeMilliseconds;
	internal Entity localMinecart;

	internal float minecartheight()
	{
		return this.one / 2;
	}
	float one;
	internal float originalmodelheight;
	internal float railheight;
	internal bool railriding;
	internal bool wasepressed;
	internal bool wasqpressed;
}

public class ModReloadAmmo : ClientMod
{

	public override void OnKeyDown(Game game, KeyEventArgs args)
	{
		if (!(game.guistate == GuiState.Normal && game.GuiTyping == TypingState.None)) {
			return;
		}
		int eKey = args.GetKeyCode();
		if (eKey == game.GetKey(100)) {
			Packet_Item item = game.d_Inventory.RightHand[game.ActiveMaterial];
			if (item != null && item.ItemClass == 0 && game.blocktypes[item.BlockId].IsPistol && game.reloadstartMilliseconds == 0) {
				int sound = game.rnd.Next() % game.blocktypes[item.BlockId].Sounds.ReloadCount;
				game.AudioPlay(StringTools.StringAppend(game.platform, game.blocktypes[item.BlockId].Sounds.Reload[sound], ".ogg"));
				game.reloadstartMilliseconds = game.platform.TimeMillisecondsFromStart();
				game.reloadblock = item.BlockId;
				game.SendPacketClient(ClientPackets.Reload());
			}
		}
	}

	public override void OnNewFrameFixed(Game game, NewFrameEventArgs args)
	{
		if (game.reloadstartMilliseconds != 0 && game.one * (game.platform.TimeMillisecondsFromStart() - game.reloadstartMilliseconds) / 1000 > game.DeserializeFloat(game.blocktypes[game.reloadblock].ReloadDelayFloat)) {
			{
				int loaded = game.TotalAmmo[game.reloadblock];
				loaded = MathCi.MinInt(game.blocktypes[game.reloadblock].AmmoMagazine, loaded);
				game.LoadedAmmo[game.reloadblock] = loaded;
				game.reloadstartMilliseconds = 0;
				game.reloadblock = -1;
			}
		}
	}
}

public class ModScreenshot : ClientMod
{
	public ModScreenshot()
	{
		this.takeScreenshot = false;
		this.screenshotFlashFramesLeft = 0;
	}

	internal void DrawScreenshotFlash(Game game)
	{
		game.Draw2dTexture(game.WhiteTexture(), 0, 0, game.platform.GetCanvasWidth(), game.platform.GetCanvasHeight(), null, 0, Game.ColorFromArgb(255, 255, 255, 255), false);
		string screenshottext = "&0Screenshot";
		IntRef textWidth = new IntRef();
		IntRef textHeight = new IntRef();
		game.platform.TextSize(screenshottext, 50, textWidth, textHeight);
		FontCi font = new FontCi();
		font.family = "Arial";
		font.size = 50;
		game.Draw2dText(screenshottext, font, game.xcenter(textWidth.value), game.ycenter(textHeight.value), null, false);
	}

	public override void OnKeyDown(Game game, KeyEventArgs args)
	{
		if (args.GetKeyCode() == game.GetKey(21)) {
			this.takeScreenshot = true;
			args.SetHandled(true);
		}
	}

	public override void OnNewFrameDraw2d(Game game, float deltaTime)
	{
		if (this.takeScreenshot) {
			this.takeScreenshot = false;
			game.platform.SaveScreenshot();
			this.screenshotFlashFramesLeft = 5;
		}
		if (this.screenshotFlashFramesLeft > 0) {
			this.DrawScreenshotFlash(game);
			this.screenshotFlashFramesLeft--;
		}
	}
	int screenshotFlashFramesLeft;
	bool takeScreenshot;
}

public class ModSendActiveMaterial : ClientMod
{

	public override void OnNewFrameFixed(Game game, NewFrameEventArgs args)
	{
		Packet_Item activeitem = game.d_Inventory.RightHand[game.ActiveMaterial];
		int activeblock = 0;
		if (activeitem != null) {
			activeblock = activeitem.BlockId;
		}
		if (activeblock != this.PreviousActiveMaterialBlock) {
			game.SendPacketClient(ClientPackets.ActiveMaterialSlot(game.ActiveMaterial));
		}
		this.PreviousActiveMaterialBlock = activeblock;
	}
	internal int PreviousActiveMaterialBlock;
}

public class ModSendPosition : ClientMod
{

	public override void OnNewFrame(Game game, NewFrameEventArgs args)
	{
		if (game.spawned && game.platform.TimeMillisecondsFromStart() - game.lastpositionsentMilliseconds > 100) {
			game.lastpositionsentMilliseconds = game.platform.TimeMillisecondsFromStart();
			game.SendPacketClient(ClientPackets.PositionAndOrientation(game, game.LocalPlayerId, game.player.position.x, game.player.position.y, game.player.position.z, game.player.position.rotx, game.player.position.roty, game.player.position.rotz, game.localstance));
		}
	}
}

public class ModServerSimple : ClientMod
{

	public override void OnReadOnlyBackgroundThread(Game game, float dt)
	{
		this.server.Update();
	}
	internal ServerSimple server;
}

public abstract class ModSimple
{

	public virtual void GenerateChunk(int cx, int cy, int cz, int[] chunk)
	{
	}

	public virtual int GetHeight()
	{
		return -1;
	}

	public virtual void OnPlayerJoin(int playerId)
	{
	}

	public abstract void Start(ModManagerSimple manager);
}

public class ModSimpleDefault : ModSimple
{

	public override void OnPlayerJoin(int playerId)
	{
		this.m.AddToInventory(playerId, "Dirt", 0);
		this.m.AddToInventory(playerId, "Stone", 0);
		this.m.AddToInventory(playerId, "Wood", 0);
		this.m.AddToInventory(playerId, "Brick", 0);
	}

	public override void Start(ModManagerSimple manager)
	{
		this.m = manager;
		BlockTypeSimple empty = manager.CreateBlockType("Empty");
		empty.SetDrawType(0);
		empty.SetWalkableType(0);
		BlockTypeSimple stone = manager.CreateBlockType("Stone");
		stone.SetDrawType(1);
		stone.SetWalkableType(2);
		stone.SetAllTextures("Stone");
		BlockTypeSimple dirt = manager.CreateBlockType("Dirt");
		dirt.SetDrawType(1);
		dirt.SetWalkableType(2);
		dirt.SetAllTextures("Dirt");
		BlockTypeSimple grass = manager.CreateBlockType("Grass");
		grass.SetDrawType(1);
		grass.SetWalkableType(2);
		grass.SetTextureTop("Grass");
		grass.SetTextureBack("GrassSide");
		grass.SetTextureFront("GrassSide");
		grass.SetTextureLeft("GrassSide");
		grass.SetTextureRight("GrassSide");
		grass.SetTextureBottom("Dirt");
		BlockTypeSimple wood = manager.CreateBlockType("Wood");
		wood.SetDrawType(1);
		wood.SetWalkableType(2);
		wood.SetAllTextures("OakWood");
		BlockTypeSimple brick = manager.CreateBlockType("Brick");
		brick.SetDrawType(1);
		brick.SetWalkableType(2);
		brick.SetAllTextures("Brick");
		manager.CreateBlockType("Sponge");
		manager.CreateBlockType("Trampoline");
		BlockTypeSimple adminium = manager.CreateBlockType("Adminium");
		adminium.SetDrawType(1);
		adminium.SetWalkableType(2);
		adminium.SetAllTextures("Adminium");
		manager.CreateBlockType("Compass");
		manager.CreateBlockType("Ladder");
		manager.CreateBlockType("EmptyHand");
		manager.CreateBlockType("CraftingTable");
		manager.CreateBlockType("Lava");
		manager.CreateBlockType("StationaryLava");
		manager.CreateBlockType("FillStart");
		manager.CreateBlockType("Cuboid");
		manager.CreateBlockType("FillArea");
		manager.CreateBlockType("Minecart");
		manager.CreateBlockType("Rail0");
	}
	ModManagerSimple m;
}

public class ModSimpleWorldGenerator : ModSimple
{

	public override void GenerateChunk(int cx, int cy, int cz, int[] chunk)
	{
		int grass = this.m.GetBlockTypeId("Grass");
		int dirt = this.m.GetBlockTypeId("Dirt");
		int stone = this.m.GetBlockTypeId("Stone");
		int adminium = this.m.GetBlockTypeId("Adminium");
		for (int xx = 0; xx < 32; xx++) {
			for (int yy = 0; yy < 32; yy++) {
				for (int zz = 0; zz < 32; zz++) {
					int z = cz * 32 + zz;
					int height = 32;
					int block = 0;
					if (z > height) {
						block = 0;
					}
					else if (z == height) {
						block = grass;
					}
					else if (z > height - 5) {
						block = dirt;
					}
					else {
						block = stone;
					}
					if (z == 0) {
						block = adminium;
					}
					chunk[(zz * 32 + yy) * 32 + xx] = block;
				}
			}
		}
	}

	public override int GetHeight()
	{
		return 33;
	}

	public override void Start(ModManagerSimple manager)
	{
		this.m = manager;
	}
	ModManagerSimple m;
}

public class ModSkySphereAnimated : ClientMod
{
	public ModSkySphereAnimated()
	{
		this.stars = new ModSkySphereStatic();
	}

	public void Draw(Game game, float fov)
	{
		int size = 1000;
		if (game.fancySkysphere) {
			this.skymodel = this.GetSphereModelData2(this.skymodel, game.platform, size, size, 64, 64, this.skyPixels, this.glowPixels, game.sunPositionX, game.sunPositionY, game.sunPositionZ);
		}
		else {
			this.skymodel = this.GetSphereModelData2(this.skymodel, game.platform, size, size, 20, 20, this.skyPixels, this.glowPixels, game.sunPositionX, game.sunPositionY, game.sunPositionZ);
		}
		game.Set3dProjection(size * 2, fov);
		game.GLMatrixModeModelView();
		game.GLPushMatrix();
		game.GLTranslate(game.player.position.x, game.player.position.y, game.player.position.z);
		game.platform.BindTexture2d(0);
		game.DrawModelData(this.skymodel);
		game.GLPopMatrix();
		game.Set3dProjection(game.zfar(), fov);
	}

	internal void DrawSkySphere(Game game)
	{
		if (!this.started) {
			this.started = true;
			BitmapCi skyBmp = game.platform.BitmapCreateFromPng(game.GetFile("sky.png"), game.GetFileLength("sky.png"));
			BitmapCi glowBmp = game.platform.BitmapCreateFromPng(game.GetFile("glow.png"), game.GetFileLength("glow.png"));
			this.skyPixels = new int[1048576];
			this.glowPixels = new int[1048576];
			game.platform.BitmapGetPixelsArgb(skyBmp, this.skyPixels);
			game.platform.BitmapGetPixelsArgb(glowBmp, this.glowPixels);
			game.platform.BitmapDelete(skyBmp);
			game.platform.BitmapDelete(glowBmp);
		}
		game.platform.GLDisableAlphaTest();
		game.platform.GlDisableDepthTest();
		this.Draw(game, game.currentfov());
		game.platform.GLEnableAlphaTest();
		game.platform.GlEnableDepthTest();
	}

	public ModelData GetSphereModelData2(ModelData data, GamePlatform platform, float radius, float height, int segments, int rings, int[] skyPixels_, int[] glowPixels_, float sunX, float sunY, float sunZ)
	{
		int i = 0;
		if (data == null) {
			data = new ModelData();
			data.xyz = new float[rings * segments * 3];
			data.uv = new float[rings * segments * 2];
			data.rgba = new byte[rings * segments * 4];
			data.SetVerticesCount(segments * rings);
			data.SetIndicesCount(segments * rings * 6);
			data.setIndices(SphereModelData.CalculateElements(radius, height, segments, rings));
		}
		for (int y = 0; y < rings; y++) {
			float yFloat = y;
			float phiFloat = yFloat / (rings - 1) * Game.GetPi();
			for (int x = 0; x < segments; x++) {
				float xFloat = x;
				float theta = xFloat / (segments - 1) * 2 * Game.GetPi();
				float vx = radius * Platform.Sin(phiFloat) * Platform.Cos(theta);
				float vy = height * Platform.Cos(phiFloat);
				float vz = radius * Platform.Sin(phiFloat) * Platform.Sin(theta);
				float u = xFloat / (segments - 1);
				float v = yFloat / (rings - 1);
				data.xyz[i * 3 + 0] = vx;
				data.xyz[i * 3 + 1] = vy;
				data.xyz[i * 3 + 2] = vz;
				data.uv[i * 2 + 0] = u;
				data.uv[i * 2 + 1] = v;
				float vertexLength = platform.MathSqrt(vx * vx + vy * vy + vz * vz);
				float vertexXNormalized = vx / vertexLength;
				float vertexYNormalized = vy / vertexLength;
				float vertexZNormalized = vz / vertexLength;
				float sunLength = platform.MathSqrt(sunX * sunX + sunY * sunY + sunZ * sunZ);
				if (sunLength == 0) {
					sunLength = 1;
				}
				float sunXNormalized = sunX / sunLength;
				float sunYNormalized = sunY / sunLength;
				float sunZNormalized = sunZ / sunLength;
				float dx = vertexXNormalized - sunXNormalized;
				float dy = vertexYNormalized - sunYNormalized;
				float dz = vertexZNormalized - sunZNormalized;
				float proximityToSun = 1 - platform.MathSqrt(dx * dx + dy * dy + dz * dz) / 2;
				float one = 1;
				int skyColor = ModSkySphereAnimated.Texture2d(platform, skyPixels_, (sunYNormalized + 2) / 4, 1 - (vertexYNormalized + 1) / 2);
				float skyColorA = one * Game.ColorA(skyColor) / 255;
				float skyColorR = one * Game.ColorR(skyColor) / 255;
				float skyColorG = one * Game.ColorG(skyColor) / 255;
				float skyColorB = one * Game.ColorB(skyColor) / 255;
				int glowColor = ModSkySphereAnimated.Texture2d(platform, glowPixels_, (sunYNormalized + one) / 2, 1 - proximityToSun);
				float glowColorA = one * Game.ColorA(glowColor) / 255;
				float glowColorR = one * Game.ColorR(glowColor) / 255;
				float glowColorG = one * Game.ColorG(glowColor) / 255;
				float glowColorB = one * Game.ColorB(glowColor) / 255;
				float colorR = skyColorR + glowColorR * glowColorA;
				float colorG = skyColorG + glowColorG * glowColorA;
				float colorB = skyColorB + glowColorB * glowColorA;
				float colorA = skyColorA;
				if (colorR > 1) {
					colorR = 1;
				}
				if (colorG > 1) {
					colorG = 1;
				}
				if (colorB > 1) {
					colorB = 1;
				}
				if (colorA > 1) {
					colorA = 1;
				}
				data.rgba[i * 4 + 0] = Game.IntToByte(platform.FloatToInt(colorR * 255));
				data.rgba[i * 4 + 1] = Game.IntToByte(platform.FloatToInt(colorG * 255));
				data.rgba[i * 4 + 2] = Game.IntToByte(platform.FloatToInt(colorB * 255));
				data.rgba[i * 4 + 3] = Game.IntToByte(platform.FloatToInt(colorA * 255));
				i++;
			}
		}
		return data;
	}

	public override void OnNewFrameDraw3d(Game game, float deltaTime)
	{
		game.SkySphereNight = true;
		this.stars.OnNewFrameDraw3d(game, deltaTime);
		game.platform.GlDisableFog();
		this.DrawSkySphere(game);
		game.SetFog();
	}

	static int Texture2d(GamePlatform platform, int[] pixelsArgb, float x, float y)
	{
		int px = platform.FloatToInt(x * 511);
		int py = platform.FloatToInt(y * 511);
		px = ModSkySphereAnimated.positive_modulo(px, 511);
		py = ModSkySphereAnimated.positive_modulo(py, 511);
		return pixelsArgb[MapUtilCi.Index2d(px, py, 512)];
	}
	int[] glowPixels;

	static int positive_modulo(int i, int n)
	{
		return (i % n + n) % n;
	}
	int[] skyPixels;
	ModelData skymodel;
	ClientMod stars;
	internal bool started;
}

public class ModSkySphereStatic : ClientMod
{
	public ModSkySphereStatic()
	{
		this.SkyTexture = -1;
		this.skyspheretexture = -1;
		this.skyspherenighttexture = -1;
	}

	public void Draw(Game game, float fov)
	{
		if (this.SkyTexture == -1) {
			game.platform.ThrowException("InvalidOperationException");
		}
		int size = 1000;
		if (this.skymodel == null) {
			this.skymodel = game.platform.CreateModel(SphereModelData.GetSphereModelData(size, size, 20, 20));
		}
		game.Set3dProjection(size * 2, fov);
		game.GLMatrixModeModelView();
		game.GLPushMatrix();
		game.GLTranslate(game.player.position.x, game.player.position.y, game.player.position.z);
		game.platform.BindTexture2d(this.SkyTexture);
		game.DrawModel(this.skymodel);
		game.GLPopMatrix();
		game.Set3dProjection(game.zfar(), fov);
	}

	internal void DrawSkySphere(Game game)
	{
		if (this.skyspheretexture == -1) {
			BitmapCi skysphereBmp = game.platform.BitmapCreateFromPng(game.GetFile("skysphere.png"), game.GetFileLength("skysphere.png"));
			BitmapCi skysphereNightBmp = game.platform.BitmapCreateFromPng(game.GetFile("skyspherenight.png"), game.GetFileLength("skyspherenight.png"));
			this.skyspheretexture = game.platform.LoadTextureFromBitmap(skysphereBmp);
			this.skyspherenighttexture = game.platform.LoadTextureFromBitmap(skysphereNightBmp);
			game.platform.BitmapDelete(skysphereBmp);
			game.platform.BitmapDelete(skysphereNightBmp);
		}
		int texture = game.SkySphereNight ? this.skyspherenighttexture : this.skyspheretexture;
		if (game.shadowssimple) {
			texture = this.skyspheretexture;
		}
		this.SkyTexture = texture;
		this.Draw(game, game.currentfov());
	}

	public override void OnNewFrameDraw3d(Game game, float deltaTime)
	{
		game.platform.GlDisableFog();
		this.DrawSkySphere(game);
		game.SetFog();
	}
	internal int SkyTexture;
	Model skymodel;
	internal int skyspherenighttexture;
	internal int skyspheretexture;
}

public class ModUnloadRendererChunks : ClientMod
{
	public ModUnloadRendererChunks()
	{
		this.unloadxyztemp = new Vector3IntRef();
	}

	public override void OnReadOnlyBackgroundThread(Game game_, float dt)
	{
		this.game = game_;
		this.chunksize = 16;
		this.mapsizexchunks = this.game.map.MapSizeX / this.chunksize;
		this.mapsizeychunks = this.game.map.MapSizeY / this.chunksize;
		this.mapsizezchunks = this.game.map.MapSizeZ / this.chunksize;
		int px = this.game.platform.FloatToInt(this.game.player.position.x) / this.chunksize;
		int py = this.game.platform.FloatToInt(this.game.player.position.z) / this.chunksize;
		int pz = this.game.platform.FloatToInt(this.game.player.position.y) / this.chunksize;
		int chunksxy = this.mapAreaSize() / this.chunksize / 2;
		int chunksz = this.mapAreaSizeZ() / this.chunksize / 2;
		int startx = px - chunksxy;
		int endx = px + chunksxy;
		int starty = py - chunksxy;
		int endy = py + chunksxy;
		int startz = pz - chunksz;
		int endz = pz + chunksz;
		if (startx < 0) {
			startx = 0;
		}
		if (starty < 0) {
			starty = 0;
		}
		if (startz < 0) {
			startz = 0;
		}
		if (endx >= this.mapsizexchunks) {
			endx = this.mapsizexchunks - 1;
		}
		if (endy >= this.mapsizeychunks) {
			endy = this.mapsizeychunks - 1;
		}
		if (endz >= this.mapsizezchunks) {
			endz = this.mapsizezchunks - 1;
		}
		int mapsizexchunks_ = this.mapsizexchunks;
		int mapsizeychunks_ = this.mapsizeychunks;
		int mapsizezchunks_ = this.mapsizezchunks;
		int count;
		if (this.game.platform.IsFastSystem()) {
			count = 1000;
		}
		else {
			count = 250;
		}
		for (int i = 0; i < count; i++) {
			this.unloadIterationXy++;
			if (this.unloadIterationXy >= mapsizexchunks_ * mapsizeychunks_ * mapsizezchunks_) {
				this.unloadIterationXy = 0;
			}
			MapUtilCi.PosInt(this.unloadIterationXy, mapsizexchunks_, mapsizeychunks_, this.unloadxyztemp);
			int x = this.unloadxyztemp.X;
			int y = this.unloadxyztemp.Y;
			int z = this.unloadxyztemp.Z;
			int pos = MapUtilCi.Index3d(x, y, z, mapsizexchunks_, mapsizeychunks_);
			bool unloaded = false;
			Chunk c = this.game.map.chunks[pos];
			if (c == null || c.rendered == null || c.rendered.ids == null) {
				continue;
			}
			if (x < startx || y < starty || z < startz || x > endx || y > endy || z > endz) {
				int unloadChunkPos = pos;
				UnloadRendererChunksCommit commit = new UnloadRendererChunksCommit();
				commit.game = this.game;
				commit.unloadChunkPos = unloadChunkPos;
				this.game.QueueActionCommit(commit);
			}
			unloaded = true;
			if (unloaded) {
				break;
			}
		}
	}

	int centerAreaSize()
	{
		return this.game.platform.FloatToInt(this.game.d_Config3d.viewdistance) / 2;
	}
	int chunksize;
	Game game;

	int mapAreaSize()
	{
		return this.game.platform.FloatToInt(this.game.d_Config3d.viewdistance) * 2;
	}

	int mapAreaSizeZ()
	{
		return this.mapAreaSize();
	}
	int mapsizexchunks;
	int mapsizeychunks;
	int mapsizezchunks;
	int unloadIterationXy;
	Vector3IntRef unloadxyztemp;
}

public class ModUpdateMain : ClientMod
{

	public override void OnReadOnlyMainThread(Game game, float dt)
	{
		game.Update(dt);
	}
}

public class ModWalkSound : ClientMod
{
	public ModWalkSound()
	{
		this.one = 1;
		this.walksoundtimer = 0;
		this.lastwalksound = 0;
		this.stepsoundduration = this.one * 4 / 10;
	}

	internal int GetSoundCount(string[] soundwalk)
	{
		int count = 0;
		for (int i = 0; i < 8; i++) {
			if (soundwalk[i] != null) {
				count++;
			}
		}
		return count;
	}

	public override void OnNewFrameFixed(Game game, NewFrameEventArgs args)
	{
		if (game.FollowId() == null) {
			if (game.soundnow.value) {
				this.UpdateWalkSound(game, -1);
			}
			if (game.isplayeronground && game.controls.movedx != 0 || game.controls.movedy != 0) {
				this.UpdateWalkSound(game, args.GetDt());
			}
		}
	}

	internal void UpdateWalkSound(Game game, float dt)
	{
		if (dt == -1) {
			dt = this.stepsoundduration / 2;
		}
		this.walksoundtimer += dt;
		string[] soundwalk = this.soundwalkcurrent(game);
		if (this.GetSoundCount(soundwalk) == 0) {
			return;
		}
		if (this.walksoundtimer >= this.stepsoundduration) {
			this.walksoundtimer = 0;
			this.lastwalksound++;
			if (this.lastwalksound >= this.GetSoundCount(soundwalk)) {
				this.lastwalksound = 0;
			}
			if (game.rnd.Next() % 100 < 40) {
				this.lastwalksound = game.rnd.Next() % this.GetSoundCount(soundwalk);
			}
			game.AudioPlay(soundwalk[this.lastwalksound]);
		}
	}
	internal int lastwalksound;
	float one;

	internal string[] soundwalkcurrent(Game game)
	{
		int b = game.BlockUnderPlayer();
		if (b != -1) {
			return game.d_Data.WalkSound()[b];
		}
		return game.d_Data.WalkSound()[0];
	}
	internal float stepsoundduration;
	internal float walksoundtimer;
}

public class Model
{
}

public class ModelData
{

	public int GetIndicesCount()
	{
		return this.indicesCount;
	}

	public int GetRgbaCount()
	{
		return this.verticesCount * 4;
	}

	public int GetUvCount()
	{
		return this.verticesCount * 2;
	}

	public int GetVerticesCount()
	{
		return this.verticesCount;
	}

	public int GetXyzCount()
	{
		return this.verticesCount * 3;
	}

	public void SetIndicesCount(int value)
	{
		this.indicesCount = value;
	}

	public void SetVerticesCount(int value)
	{
		this.verticesCount = value;
	}

	public int[] getIndices()
	{
		return this.indices;
	}

	public int getMode()
	{
		return this.mode;
	}

	public byte[] getRgba()
	{
		return this.rgba;
	}

	public float[] getUv()
	{
		return this.uv;
	}

	public float[] getXyz()
	{
		return this.xyz;
	}
	internal int[] indices;
	internal int indicesCount;
	internal int indicesMax;
	internal int mode;
	internal byte[] rgba;

	public void setIndices(int[] p)
	{
		this.indices = p;
	}

	public void setMode(int p)
	{
		this.mode = p;
	}

	public void setRgba(byte[] p)
	{
		this.rgba = p;
	}

	public void setUv(float[] p)
	{
		this.uv = p;
	}

	public void setXyz(float[] p)
	{
		this.xyz = p;
	}
	internal float[] uv;
	internal int verticesCount;
	internal int verticesMax;
	internal float[] xyz;
}

public class ModelDataTool
{

	internal static void AddIndex(ModelData model, int index)
	{
		if (model.indicesCount >= model.indicesMax) {
			int indicesCount = model.indicesCount;
			int[] indices = new int[indicesCount * 2];
			for (int i = 0; i < indicesCount; i++) {
				indices[i] = model.indices[i];
			}
			model.indices = indices;
			model.indicesMax = model.indicesMax * 2;
		}
		model.indices[model.indicesCount++] = index;
	}

	public static void AddVertex(ModelData model, float x, float y, float z, float u, float v, int color)
	{
		if (model.verticesCount >= model.verticesMax) {
			int xyzCount = model.GetXyzCount();
			float[] xyz = new float[xyzCount * 2];
			for (int i = 0; i < xyzCount; i++) {
				xyz[i] = model.xyz[i];
			}
			int uvCount = model.GetUvCount();
			float[] uv = new float[uvCount * 2];
			for (int i = 0; i < uvCount; i++) {
				uv[i] = model.uv[i];
			}
			int rgbaCount = model.GetRgbaCount();
			byte[] rgba = new byte[rgbaCount * 2];
			for (int i = 0; i < rgbaCount; i++) {
				rgba[i] = model.rgba[i];
			}
			model.xyz = xyz;
			model.uv = uv;
			model.rgba = rgba;
			model.verticesMax = model.verticesMax * 2;
		}
		model.xyz[model.GetXyzCount() + 0] = x;
		model.xyz[model.GetXyzCount() + 1] = y;
		model.xyz[model.GetXyzCount() + 2] = z;
		model.uv[model.GetUvCount() + 0] = u;
		model.uv[model.GetUvCount() + 1] = v;
		model.rgba[model.GetRgbaCount() + 0] = Game.IntToByte(Game.ColorR(color));
		model.rgba[model.GetRgbaCount() + 1] = Game.IntToByte(Game.ColorG(color));
		model.rgba[model.GetRgbaCount() + 2] = Game.IntToByte(Game.ColorB(color));
		model.rgba[model.GetRgbaCount() + 3] = Game.IntToByte(Game.ColorA(color));
		model.verticesCount++;
	}
}

public class MonitorObject
{
}

public class MouseButtonEnum
{
	public const int Left = 0;
	public const int Middle = 1;
	public const int Right = 2;
}

public class MouseEventArgs
{

	public int GetButton()
	{
		return this.button;
	}

	public bool GetEmulated()
	{
		return this.emulated;
	}

	public bool GetForceUsage()
	{
		return this.forceUsage;
	}

	public bool GetHandled()
	{
		return this.handled;
	}

	public int GetMovementX()
	{
		return this.movementX;
	}

	public int GetMovementY()
	{
		return this.movementY;
	}

	public int GetX()
	{
		return this.x;
	}

	public int GetY()
	{
		return this.y;
	}

	public void SetButton(int value)
	{
		this.button = value;
	}

	public void SetEmulated(bool value)
	{
		this.emulated = value;
	}

	public void SetForceUsage(bool value)
	{
		this.forceUsage = value;
	}

	public void SetHandled(bool value)
	{
		this.handled = value;
	}

	public void SetMovementX(int value)
	{
		this.movementX = value;
	}

	public void SetMovementY(int value)
	{
		this.movementY = value;
	}

	public void SetX(int value)
	{
		this.x = value;
	}

	public void SetY(int value)
	{
		this.y = value;
	}
	int button;
	bool emulated;
	bool forceUsage;
	bool handled;
	int movementX;
	int movementY;
	int x;
	int y;
}

public abstract class MouseEventHandler
{

	public abstract void OnMouseDown(MouseEventArgs e);

	public abstract void OnMouseMove(MouseEventArgs e);

	public abstract void OnMouseUp(MouseEventArgs e);

	public abstract void OnMouseWheel(MouseWheelEventArgs e);
}

public class MouseWheelEventArgs
{

	public int GetDelta()
	{
		return this.delta;
	}

	public float GetDeltaPrecise()
	{
		return this.deltaPrecise;
	}

	public void SetDelta(int value)
	{
		this.delta = value;
	}

	public void SetDeltaPrecise(float value)
	{
		this.deltaPrecise = value;
	}
	int delta;
	float deltaPrecise;
}

public enum MyNetDeliveryMethod
{
	Unknown,
	Unreliable,
	UnreliableSequenced,
	ReliableUnordered,
	ReliableSequenced,
	ReliableOrdered
}

public abstract class NetClient
{

	public abstract NetConnection Connect(string ip, int port);

	public abstract NetIncomingMessage ReadMessage();

	public abstract void SendMessage(INetOutgoingMessage message, MyNetDeliveryMethod method);

	public abstract void Start();
}

public abstract class NetConnection
{

	public abstract bool EqualsConnection(NetConnection connection);

	public abstract IPEndPointCi RemoteEndPoint();

	public abstract void SendMessage(INetOutgoingMessage msg, MyNetDeliveryMethod method, int sequenceChannel);

	public abstract void Update();
}

public class NetIncomingMessage
{
	internal NetConnection SenderConnection;
	internal NetworkMessageType Type;
	internal byte[] message;
	internal int messageLength;
}

public abstract class NetServer
{

	public abstract NetIncomingMessage ReadMessage();

	public abstract void SetPort(int port);

	public abstract void Start();
}

public class NetworkInterpolation : INetworkInterpolation
{
	public NetworkInterpolation()
	{
		this.received = new Packet_[128];
		this.DELAYMILLISECONDS = 200;
		this.EXTRAPOLATION_TIMEMILLISECONDS = 200;
	}

	public override void AddNetworkPacket(InterpolatedObject c, int timeMilliseconds)
	{
		Packet_ p = new Packet_();
		p.content = c;
		p.timestampMilliseconds = timeMilliseconds;
		int max = 100;
		if (this.receivedCount >= max) {
			for (int i = 0; i < max - 1; i++) {
				this.received[i] = this.received[i + 1];
			}
			this.receivedCount = max - 1;
		}
		this.received[this.receivedCount++] = p;
	}
	internal int DELAYMILLISECONDS;
	internal bool EXTRAPOLATE;
	internal int EXTRAPOLATION_TIMEMILLISECONDS;

	public override InterpolatedObject InterpolatedState(int timeMilliseconds)
	{
		int curtimeMilliseconds = timeMilliseconds;
		int interpolationtimeMilliseconds = curtimeMilliseconds - this.DELAYMILLISECONDS;
		int p1;
		int p2;
		if (this.receivedCount == 0) {
			return null;
		}
		InterpolatedObject result;
		if (this.receivedCount > 0 && interpolationtimeMilliseconds < this.received[0].timestampMilliseconds) {
			p1 = 0;
			p2 = 0;
		}
		else if (this.EXTRAPOLATE && this.receivedCount >= 2 && interpolationtimeMilliseconds > this.received[this.receivedCount - 1].timestampMilliseconds) {
			p1 = this.receivedCount - 2;
			p2 = this.receivedCount - 1;
			interpolationtimeMilliseconds = MathCi.MinInt(interpolationtimeMilliseconds, this.received[this.receivedCount - 1].timestampMilliseconds + this.EXTRAPOLATION_TIMEMILLISECONDS);
		}
		else {
			p1 = 0;
			for (int i = 0; i < this.receivedCount; i++) {
				if (this.received[i].timestampMilliseconds <= interpolationtimeMilliseconds) {
					p1 = i;
				}
			}
			p2 = p1;
			if (this.receivedCount - 1 > p1) {
				p2++;
			}
		}
		if (p1 == p2) {
			result = this.received[p1].content;
		}
		else {
			float one = 1;
			result = this.req.Interpolate(this.received[p1].content, this.received[p2].content, one * (interpolationtimeMilliseconds - this.received[p1].timestampMilliseconds) / (this.received[p2].timestampMilliseconds - this.received[p1].timestampMilliseconds));
		}
		return result;
	}
	Packet_[] received;
	int receivedCount;
	internal IInterpolation req;
}

public enum NetworkMessageType
{
	Data,
	Connect,
	Disconnect
}

public class NewFrameEventArgs
{

	public float GetDt()
	{
		return this.dt;
	}

	public void SetDt(float p)
	{
		this.dt = p;
	}
	float dt;
}

public abstract class NewFrameHandler
{

	public abstract void OnNewFrame(NewFrameEventArgs args);
}

public class Node
{
	internal float head;
	internal string name;
	internal string parentName;
	internal float pivotx;
	internal float pivoty;
	internal float pivotz;
	internal float posx;
	internal float posy;
	internal float posz;
	internal float rotatex;
	internal float rotatey;
	internal float rotatez;
	internal float scalex;
	internal float scaley;
	internal float scalez;
	internal float sizex;
	internal float sizey;
	internal float sizez;
	internal float u;
	internal float v;
}

internal class NotifyMapAction : Action_
{

	void LoadAndSendChunk(int x, int y, int z)
	{
		ClientSimple c = this.server.clients[this.clientId];
		int pos = MapUtilCi.Index2d(x, y, this.server.MapSizeX / 32);
		if (c.chunksseen[pos] == null) {
			c.chunksseen[pos] = new bool[this.server.MapSizeZ / 32];
		}
		c.chunksseen[pos][z] = true;
		int[] chunk = new int[32768];
		for (int i = 0; i < this.server.modsCount; i++) {
			this.server.mods[i].GenerateChunk(x, y, z, chunk);
		}
		byte[] chunkBytes = MiscCi.UshortArrayToByteArray(chunk, 32768);
		IntRef compressedLength = new IntRef();
		byte[] chunkCompressed = this.server.platform.GzipCompress(chunkBytes, 65536, compressedLength);
		this.server.QueueMainThreadAction(SendPacketAction.Create(this.server, this.clientId, ServerPackets.ChunkPart(chunkCompressed)));
		this.server.QueueMainThreadAction(SendPacketAction.Create(this.server, this.clientId, ServerPackets.Chunk_(x * 32, y * 32, z * 32, 32)));
	}

	void NearestDirty(int clientid, int playerx, int playery, int playerz, int[] retNearest)
	{
		int nearestdist = 2147483647;
		retNearest[0] = -1;
		retNearest[1] = -1;
		retNearest[2] = -1;
		int px = playerx / 32;
		int py = playery / 32;
		int pz = playerz / 32;
		int chunksxy = this.mapAreaSize() / 32 / 2;
		int chunksz = this.mapAreaSizeZ() / 32 / 2;
		int startx = px - chunksxy;
		int endx = px + chunksxy;
		int starty = py - chunksxy;
		int endy = py + chunksxy;
		int startz = pz - chunksz;
		int endz = pz + chunksz;
		if (startx < 0) {
			startx = 0;
		}
		if (starty < 0) {
			starty = 0;
		}
		if (startz < 0) {
			startz = 0;
		}
		if (endx >= this.mapsizexchunks()) {
			endx = this.mapsizexchunks() - 1;
		}
		if (endy >= this.mapsizeychunks()) {
			endy = this.mapsizeychunks() - 1;
		}
		if (endz >= this.mapsizezchunks()) {
			endz = this.mapsizezchunks() - 1;
		}
		ClientSimple client = this.server.clients[clientid];
		for (int x = startx; x <= endx; x++) {
			for (int y = starty; y <= endy; y++) {
				int pos = MapUtilCi.Index2d(x, y, this.server.MapSizeX / 32);
				if (client.chunksseen[pos] == null) {
					client.chunksseen[pos] = new bool[this.server.MapSizeZ / 32];
				}
				for (int z = startz; z <= endz; z++) {
					bool[] column = client.chunksseen[pos];
					if (column[z]) {
						continue;
					}
					{
						int dx = px - x;
						int dy = py - y;
						int dz = pz - z;
						int dist = dx * dx + dy * dy + dz * dz;
						if (dist < nearestdist) {
							nearestdist = dist;
							retNearest[0] = x;
							retNearest[1] = y;
							retNearest[2] = z;
						}
					}
				}
			}
		}
	}

	public override void Run()
	{
		int[] nearest = new int[3];
		ClientSimple client = this.server.clients[this.clientId];
		int x = this.server.platform.FloatToInt(client.glX);
		int y = this.server.platform.FloatToInt(client.glZ);
		int z = this.server.platform.FloatToInt(client.glY);
		this.NearestDirty(this.clientId, x, y, z, nearest);
		if (nearest[0] != -1) {
			this.LoadAndSendChunk(nearest[0], nearest[1], nearest[2]);
		}
		this.server.clients[this.clientId].notifyMapAction = null;
	}
	internal int clientId;

	int mapAreaSize()
	{
		return this.server.chunkdrawdistance * 32 * 2;
	}

	int mapAreaSizeZ()
	{
		return this.mapAreaSize();
	}

	int mapsizexchunks()
	{
		return this.server.MapSizeX / 32;
	}

	int mapsizeychunks()
	{
		return this.server.MapSizeY / 32;
	}

	int mapsizezchunks()
	{
		return this.server.MapSizeZ / 32;
	}
	internal ServerSimple server;
}

public class OnCrashHandler
{

	public virtual void OnCrash()
	{
	}
}

public class OnCrashHandlerLeave : OnCrashHandler
{

	public static OnCrashHandlerLeave Create(Game game)
	{
		OnCrashHandlerLeave oncrash = new OnCrashHandlerLeave();
		oncrash.g = game;
		return oncrash;
	}

	public override void OnCrash()
	{
		this.g.SendLeave(1);
	}
	Game g;
}

public class OnUseEntityArgs
{
	internal int entityId;
}

public class OptionsCi
{
	public OptionsCi()
	{
		float one = 1;
		this.Shadows = false;
		this.Font = 0;
		this.DrawDistance = 32;
		this.UseServerTextures = true;
		this.EnableSound = true;
		this.EnableAutoJump = false;
		this.ClientLanguage = "";
		this.Framerate = 0;
		this.Resolution = 0;
		this.Fullscreen = false;
		this.Smoothshadows = true;
		this.BlockShadowSave = one * 6 / 10;
		this.EnableBlockShadow = true;
		this.Keys = new int[256];
	}
	internal float BlockShadowSave;
	internal string ClientLanguage;
	internal int DrawDistance;
	internal bool EnableAutoJump;
	internal bool EnableBlockShadow;
	internal bool EnableSound;
	internal int Font;
	internal int Framerate;
	internal bool Fullscreen;
	internal int[] Keys;
	internal int Resolution;
	internal bool Shadows;
	internal bool Smoothshadows;
	internal bool UseServerTextures;
}

public class PacketHandlerCraftingRecipes : ClientPacketHandler
{

	public override void Handle(Game game, Packet_Server packet)
	{
		this.mod.d_CraftingRecipes = packet.CraftingRecipes.CraftingRecipes;
		this.mod.d_CraftingRecipesCount = packet.CraftingRecipes.CraftingRecipesCount;
	}
	internal ModGuiCrafting mod;
}

public class Packet_
{
	internal InterpolatedObject content;
	internal int timestampMilliseconds;
}

public class Packet_BlockSetModeEnum
{
	public const int Create = 1;
	public const int Destroy = 0;
	public const int Use = 2;
	/// <summary>&lt;summary&gt;open doors, use crafting table, etc.&lt;/summary&gt;</summary>
	public const int UseWithTool = 3;
}

public class Packet_BlockType
{
	internal int AimRadiusFloat;
	internal int AmmoMagazine;
	internal int AmmoTotal;
	internal int BulletsPerShotFloat;
	internal int DamageBodyFloat;
	internal int DamageHeadFloat;
	internal int DamageToPlayer;
	internal int DelayFloat;
	internal int DrawType;
	internal int ExplosionRangeFloat;
	internal int ExplosionTimeFloat;

	public int GetAimRadiusFloat()
	{
		return this.AimRadiusFloat;
	}

	public int GetAmmoMagazine()
	{
		return this.AmmoMagazine;
	}

	public int GetAmmoTotal()
	{
		return this.AmmoTotal;
	}

	public int GetBulletsPerShotFloat()
	{
		return this.BulletsPerShotFloat;
	}

	public int GetDamageBodyFloat()
	{
		return this.DamageBodyFloat;
	}

	public int GetDamageHeadFloat()
	{
		return this.DamageHeadFloat;
	}

	public int GetDamageToPlayer()
	{
		return this.DamageToPlayer;
	}

	public int GetDelayFloat()
	{
		return this.DelayFloat;
	}

	public int GetDrawType()
	{
		return this.DrawType;
	}

	public int GetExplosionRangeFloat()
	{
		return this.ExplosionRangeFloat;
	}

	public int GetExplosionTimeFloat()
	{
		return this.ExplosionTimeFloat;
	}

	public string GetHandimage()
	{
		return this.Handimage;
	}

	public int GetIronSightsAimRadiusFloat()
	{
		return this.IronSightsAimRadiusFloat;
	}

	public bool GetIronSightsEnabled()
	{
		return this.IronSightsEnabled;
	}

	public int GetIronSightsFovFloat()
	{
		return this.IronSightsFovFloat;
	}

	public string GetIronSightsImage()
	{
		return this.IronSightsImage;
	}

	public int GetIronSightsMoveSpeedFloat()
	{
		return this.IronSightsMoveSpeedFloat;
	}

	public bool GetIsBuildable()
	{
		return this.IsBuildable;
	}

	public bool GetIsPistol()
	{
		return this.IsPistol;
	}

	public bool GetIsSlipperyWalk()
	{
		return this.IsSlipperyWalk;
	}

	public bool GetIsTool()
	{
		return this.IsTool;
	}

	public bool GetIsUsable()
	{
		return this.IsUsable;
	}

	public int GetLightRadius()
	{
		return this.LightRadius;
	}

	public string GetName()
	{
		return this.Name;
	}

	public int GetPickDistanceWhenUsedFloat()
	{
		return this.PickDistanceWhenUsedFloat;
	}

	public int GetPistolType()
	{
		return this.PistolType;
	}

	public bool GetProjectileBounce()
	{
		return this.ProjectileBounce;
	}

	public int GetProjectileSpeedFloat()
	{
		return this.ProjectileSpeedFloat;
	}

	public int GetRail()
	{
		return this.Rail;
	}

	public int GetRecoilFloat()
	{
		return this.RecoilFloat;
	}

	public int GetReloadDelayFloat()
	{
		return this.ReloadDelayFloat;
	}

	public Packet_SoundSet GetSounds()
	{
		return this.Sounds;
	}

	public int GetStartInventoryAmount()
	{
		return this.StartInventoryAmount;
	}

	public int GetStrength()
	{
		return this.Strength;
	}

	public string GetTextureIdBack()
	{
		return this.TextureIdBack;
	}

	public string GetTextureIdBottom()
	{
		return this.TextureIdBottom;
	}

	public string GetTextureIdForInventory()
	{
		return this.TextureIdForInventory;
	}

	public string GetTextureIdFront()
	{
		return this.TextureIdFront;
	}

	public string GetTextureIdLeft()
	{
		return this.TextureIdLeft;
	}

	public string GetTextureIdRight()
	{
		return this.TextureIdRight;
	}

	public string GetTextureIdTop()
	{
		return this.TextureIdTop;
	}

	public int GetWalkSpeedFloat()
	{
		return this.WalkSpeedFloat;
	}

	public int GetWalkSpeedWhenUsedFloat()
	{
		return this.WalkSpeedWhenUsedFloat;
	}

	public int GetWalkableType()
	{
		return this.WalkableType;
	}

	public int GetWhenPlacedGetsConvertedTo()
	{
		return this.WhenPlacedGetsConvertedTo;
	}
	internal string Handimage;
	internal int IronSightsAimRadiusFloat;
	internal bool IronSightsEnabled;
	internal int IronSightsFovFloat;
	internal string IronSightsImage;
	internal int IronSightsMoveSpeedFloat;
	internal bool IsBuildable;
	internal bool IsPistol;
	internal bool IsSlipperyWalk;
	internal bool IsTool;
	internal bool IsUsable;
	internal int LightRadius;
	internal string Name;
	internal int PickDistanceWhenUsedFloat;
	internal int PistolType;
	/// <summary>&lt;summary&gt; 0 is infinite&lt;/summary&gt;</summary>
	internal bool ProjectileBounce;
	internal int ProjectileSpeedFloat;
	internal int Rail;
	internal int RecoilFloat;
	internal int ReloadDelayFloat;

	public void SetAimRadiusFloat(int value)
	{
		this.AimRadiusFloat = value;
	}

	public void SetAmmoMagazine(int value)
	{
		this.AmmoMagazine = value;
	}

	public void SetAmmoTotal(int value)
	{
		this.AmmoTotal = value;
	}

	public void SetBulletsPerShotFloat(int value)
	{
		this.BulletsPerShotFloat = value;
	}

	public void SetDamageBodyFloat(int value)
	{
		this.DamageBodyFloat = value;
	}

	public void SetDamageHeadFloat(int value)
	{
		this.DamageHeadFloat = value;
	}

	public void SetDamageToPlayer(int value)
	{
		this.DamageToPlayer = value;
	}

	public void SetDelayFloat(int value)
	{
		this.DelayFloat = value;
	}

	public void SetDrawType(int value)
	{
		this.DrawType = value;
	}

	public void SetExplosionRangeFloat(int value)
	{
		this.ExplosionRangeFloat = value;
	}

	public void SetExplosionTimeFloat(int value)
	{
		this.ExplosionTimeFloat = value;
	}

	public void SetHandimage(string value)
	{
		this.Handimage = value;
	}

	public void SetIronSightsAimRadiusFloat(int value)
	{
		this.IronSightsAimRadiusFloat = value;
	}

	public void SetIronSightsEnabled(bool value)
	{
		this.IronSightsEnabled = value;
	}

	public void SetIronSightsFovFloat(int value)
	{
		this.IronSightsFovFloat = value;
	}

	public void SetIronSightsImage(string value)
	{
		this.IronSightsImage = value;
	}

	public void SetIronSightsMoveSpeedFloat(int value)
	{
		this.IronSightsMoveSpeedFloat = value;
	}

	public void SetIsBuildable(bool value)
	{
		this.IsBuildable = value;
	}

	public void SetIsPistol(bool value)
	{
		this.IsPistol = value;
	}

	public void SetIsSlipperyWalk(bool value)
	{
		this.IsSlipperyWalk = value;
	}

	public void SetIsTool(bool value)
	{
		this.IsTool = value;
	}

	public void SetIsUsable(bool value)
	{
		this.IsUsable = value;
	}

	public void SetLightRadius(int value)
	{
		this.LightRadius = value;
	}

	public void SetName(string value)
	{
		this.Name = value;
	}

	public void SetPickDistanceWhenUsedFloat(int value)
	{
		this.PickDistanceWhenUsedFloat = value;
	}

	public void SetPistolType(int value)
	{
		this.PistolType = value;
	}

	public void SetProjectileBounce(bool value)
	{
		this.ProjectileBounce = value;
	}

	public void SetProjectileSpeedFloat(int value)
	{
		this.ProjectileSpeedFloat = value;
	}

	public void SetRail(int value)
	{
		this.Rail = value;
	}

	public void SetRecoilFloat(int value)
	{
		this.RecoilFloat = value;
	}

	public void SetReloadDelayFloat(int value)
	{
		this.ReloadDelayFloat = value;
	}

	public void SetSounds(Packet_SoundSet value)
	{
		this.Sounds = value;
	}

	public void SetStartInventoryAmount(int value)
	{
		this.StartInventoryAmount = value;
	}

	public void SetStrength(int value)
	{
		this.Strength = value;
	}

	public void SetTextureIdBack(string value)
	{
		this.TextureIdBack = value;
	}

	public void SetTextureIdBottom(string value)
	{
		this.TextureIdBottom = value;
	}

	public void SetTextureIdForInventory(string value)
	{
		this.TextureIdForInventory = value;
	}

	public void SetTextureIdFront(string value)
	{
		this.TextureIdFront = value;
	}

	public void SetTextureIdLeft(string value)
	{
		this.TextureIdLeft = value;
	}

	public void SetTextureIdRight(string value)
	{
		this.TextureIdRight = value;
	}

	public void SetTextureIdTop(string value)
	{
		this.TextureIdTop = value;
	}

	public void SetWalkSpeedFloat(int value)
	{
		this.WalkSpeedFloat = value;
	}

	public void SetWalkSpeedWhenUsedFloat(int value)
	{
		this.WalkSpeedWhenUsedFloat = value;
	}

	public void SetWalkableType(int value)
	{
		this.WalkableType = value;
	}

	public void SetWhenPlacedGetsConvertedTo(int value)
	{
		this.WhenPlacedGetsConvertedTo = value;
	}
	internal Packet_SoundSet Sounds;
	internal int StartInventoryAmount;
	internal int Strength;
	internal string TextureIdBack;
	internal string TextureIdBottom;
	internal string TextureIdForInventory;
	internal string TextureIdFront;
	internal string TextureIdLeft;
	internal string TextureIdRight;
	internal string TextureIdTop;
	internal int WalkSpeedFloat;
	internal int WalkSpeedWhenUsedFloat;
	internal int WalkableType;
	internal int WhenPlacedGetsConvertedTo;
}

public class Packet_BlockTypeSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_BlockType Deserialize(CitoStream stream, Packet_BlockType instance)
	{
		instance.DrawType = 0;
		instance.WalkableType = 0;
		instance.PistolType = 0;
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.TextureIdTop = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.TextureIdBottom = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.TextureIdFront = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.TextureIdBack = ProtocolParser.ReadString(stream);
				continue;
			case 42:
				instance.TextureIdLeft = ProtocolParser.ReadString(stream);
				continue;
			case 50:
				instance.TextureIdRight = ProtocolParser.ReadString(stream);
				continue;
			case 58:
				instance.TextureIdForInventory = ProtocolParser.ReadString(stream);
				continue;
			case 64:
				instance.DrawType = ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.WalkableType = ProtocolParser.ReadUInt64(stream);
				continue;
			case 80:
				instance.Rail = ProtocolParser.ReadUInt64(stream);
				continue;
			case 88:
				instance.WalkSpeedFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 96:
				instance.IsSlipperyWalk = ProtocolParser.ReadBool(stream);
				continue;
			case 106:
				if (instance.Sounds == null)
					instance.Sounds = Packet_SoundSetSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_SoundSetSerializer.DeserializeLengthDelimited(stream, instance.Sounds);
				continue;
			case 112:
				instance.LightRadius = ProtocolParser.ReadUInt64(stream);
				continue;
			case 120:
				instance.StartInventoryAmount = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			case 16:
				if (key.GetWireType() != 0)
					break;
				instance.Strength = ProtocolParser.ReadUInt64(stream);
				continue;
			case 17:
				if (key.GetWireType() != 2)
					break;
				instance.Name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				if (key.GetWireType() != 0)
					break;
				instance.IsBuildable = ProtocolParser.ReadBool(stream);
				continue;
			case 19:
				if (key.GetWireType() != 0)
					break;
				instance.IsUsable = ProtocolParser.ReadBool(stream);
				continue;
			case 20:
				if (key.GetWireType() != 0)
					break;
				instance.IsTool = ProtocolParser.ReadBool(stream);
				continue;
			case 21:
				if (key.GetWireType() != 2)
					break;
				instance.Handimage = ProtocolParser.ReadString(stream);
				continue;
			case 22:
				if (key.GetWireType() != 0)
					break;
				instance.IsPistol = ProtocolParser.ReadBool(stream);
				continue;
			case 23:
				if (key.GetWireType() != 0)
					break;
				instance.AimRadiusFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				if (key.GetWireType() != 0)
					break;
				instance.RecoilFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 25:
				if (key.GetWireType() != 0)
					break;
				instance.DelayFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				if (key.GetWireType() != 0)
					break;
				instance.BulletsPerShotFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 27:
				if (key.GetWireType() != 0)
					break;
				instance.WalkSpeedWhenUsedFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 28:
				if (key.GetWireType() != 0)
					break;
				instance.IronSightsEnabled = ProtocolParser.ReadBool(stream);
				continue;
			case 29:
				if (key.GetWireType() != 0)
					break;
				instance.IronSightsMoveSpeedFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 30:
				if (key.GetWireType() != 2)
					break;
				instance.IronSightsImage = ProtocolParser.ReadString(stream);
				continue;
			case 31:
				if (key.GetWireType() != 0)
					break;
				instance.IronSightsAimRadiusFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				if (key.GetWireType() != 0)
					break;
				instance.IronSightsFovFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 33:
				if (key.GetWireType() != 0)
					break;
				instance.AmmoMagazine = ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				if (key.GetWireType() != 0)
					break;
				instance.AmmoTotal = ProtocolParser.ReadUInt64(stream);
				continue;
			case 35:
				if (key.GetWireType() != 0)
					break;
				instance.ReloadDelayFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 36:
				if (key.GetWireType() != 0)
					break;
				instance.ExplosionRangeFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				if (key.GetWireType() != 0)
					break;
				instance.ExplosionTimeFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 38:
				if (key.GetWireType() != 0)
					break;
				instance.ProjectileSpeedFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 39:
				if (key.GetWireType() != 0)
					break;
				instance.ProjectileBounce = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				if (key.GetWireType() != 0)
					break;
				instance.DamageBodyFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 41:
				if (key.GetWireType() != 0)
					break;
				instance.DamageHeadFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				if (key.GetWireType() != 0)
					break;
				instance.PistolType = ProtocolParser.ReadUInt64(stream);
				continue;
			case 43:
				if (key.GetWireType() != 0)
					break;
				instance.DamageToPlayer = ProtocolParser.ReadUInt64(stream);
				continue;
			case 44:
				if (key.GetWireType() != 0)
					break;
				instance.WhenPlacedGetsConvertedTo = ProtocolParser.ReadUInt64(stream);
				continue;
			case 45:
				if (key.GetWireType() != 0)
					break;
				instance.PickDistanceWhenUsedFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_BlockType DeserializeBuffer(byte[] buffer, int length, Packet_BlockType instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_BlockTypeSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_BlockType DeserializeLength(CitoStream stream, int length, Packet_BlockType instance)
	{
		instance.DrawType = 0;
		instance.WalkableType = 0;
		instance.PistolType = 0;
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.TextureIdTop = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.TextureIdBottom = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.TextureIdFront = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.TextureIdBack = ProtocolParser.ReadString(stream);
				continue;
			case 42:
				instance.TextureIdLeft = ProtocolParser.ReadString(stream);
				continue;
			case 50:
				instance.TextureIdRight = ProtocolParser.ReadString(stream);
				continue;
			case 58:
				instance.TextureIdForInventory = ProtocolParser.ReadString(stream);
				continue;
			case 64:
				instance.DrawType = ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.WalkableType = ProtocolParser.ReadUInt64(stream);
				continue;
			case 80:
				instance.Rail = ProtocolParser.ReadUInt64(stream);
				continue;
			case 88:
				instance.WalkSpeedFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 96:
				instance.IsSlipperyWalk = ProtocolParser.ReadBool(stream);
				continue;
			case 106:
				if (instance.Sounds == null)
					instance.Sounds = Packet_SoundSetSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_SoundSetSerializer.DeserializeLengthDelimited(stream, instance.Sounds);
				continue;
			case 112:
				instance.LightRadius = ProtocolParser.ReadUInt64(stream);
				continue;
			case 120:
				instance.StartInventoryAmount = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			case 16:
				if (key.GetWireType() != 0)
					break;
				instance.Strength = ProtocolParser.ReadUInt64(stream);
				continue;
			case 17:
				if (key.GetWireType() != 2)
					break;
				instance.Name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				if (key.GetWireType() != 0)
					break;
				instance.IsBuildable = ProtocolParser.ReadBool(stream);
				continue;
			case 19:
				if (key.GetWireType() != 0)
					break;
				instance.IsUsable = ProtocolParser.ReadBool(stream);
				continue;
			case 20:
				if (key.GetWireType() != 0)
					break;
				instance.IsTool = ProtocolParser.ReadBool(stream);
				continue;
			case 21:
				if (key.GetWireType() != 2)
					break;
				instance.Handimage = ProtocolParser.ReadString(stream);
				continue;
			case 22:
				if (key.GetWireType() != 0)
					break;
				instance.IsPistol = ProtocolParser.ReadBool(stream);
				continue;
			case 23:
				if (key.GetWireType() != 0)
					break;
				instance.AimRadiusFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				if (key.GetWireType() != 0)
					break;
				instance.RecoilFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 25:
				if (key.GetWireType() != 0)
					break;
				instance.DelayFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				if (key.GetWireType() != 0)
					break;
				instance.BulletsPerShotFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 27:
				if (key.GetWireType() != 0)
					break;
				instance.WalkSpeedWhenUsedFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 28:
				if (key.GetWireType() != 0)
					break;
				instance.IronSightsEnabled = ProtocolParser.ReadBool(stream);
				continue;
			case 29:
				if (key.GetWireType() != 0)
					break;
				instance.IronSightsMoveSpeedFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 30:
				if (key.GetWireType() != 2)
					break;
				instance.IronSightsImage = ProtocolParser.ReadString(stream);
				continue;
			case 31:
				if (key.GetWireType() != 0)
					break;
				instance.IronSightsAimRadiusFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				if (key.GetWireType() != 0)
					break;
				instance.IronSightsFovFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 33:
				if (key.GetWireType() != 0)
					break;
				instance.AmmoMagazine = ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				if (key.GetWireType() != 0)
					break;
				instance.AmmoTotal = ProtocolParser.ReadUInt64(stream);
				continue;
			case 35:
				if (key.GetWireType() != 0)
					break;
				instance.ReloadDelayFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 36:
				if (key.GetWireType() != 0)
					break;
				instance.ExplosionRangeFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				if (key.GetWireType() != 0)
					break;
				instance.ExplosionTimeFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 38:
				if (key.GetWireType() != 0)
					break;
				instance.ProjectileSpeedFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 39:
				if (key.GetWireType() != 0)
					break;
				instance.ProjectileBounce = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				if (key.GetWireType() != 0)
					break;
				instance.DamageBodyFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 41:
				if (key.GetWireType() != 0)
					break;
				instance.DamageHeadFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				if (key.GetWireType() != 0)
					break;
				instance.PistolType = ProtocolParser.ReadUInt64(stream);
				continue;
			case 43:
				if (key.GetWireType() != 0)
					break;
				instance.DamageToPlayer = ProtocolParser.ReadUInt64(stream);
				continue;
			case 44:
				if (key.GetWireType() != 0)
					break;
				instance.WhenPlacedGetsConvertedTo = ProtocolParser.ReadUInt64(stream);
				continue;
			case 45:
				if (key.GetWireType() != 0)
					break;
				instance.PickDistanceWhenUsedFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_BlockType DeserializeLengthDelimited(CitoStream stream, Packet_BlockType instance)
	{
		instance.DrawType = 0;
		instance.WalkableType = 0;
		instance.PistolType = 0;
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.TextureIdTop = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.TextureIdBottom = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.TextureIdFront = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.TextureIdBack = ProtocolParser.ReadString(stream);
				continue;
			case 42:
				instance.TextureIdLeft = ProtocolParser.ReadString(stream);
				continue;
			case 50:
				instance.TextureIdRight = ProtocolParser.ReadString(stream);
				continue;
			case 58:
				instance.TextureIdForInventory = ProtocolParser.ReadString(stream);
				continue;
			case 64:
				instance.DrawType = ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.WalkableType = ProtocolParser.ReadUInt64(stream);
				continue;
			case 80:
				instance.Rail = ProtocolParser.ReadUInt64(stream);
				continue;
			case 88:
				instance.WalkSpeedFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 96:
				instance.IsSlipperyWalk = ProtocolParser.ReadBool(stream);
				continue;
			case 106:
				if (instance.Sounds == null)
					instance.Sounds = Packet_SoundSetSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_SoundSetSerializer.DeserializeLengthDelimited(stream, instance.Sounds);
				continue;
			case 112:
				instance.LightRadius = ProtocolParser.ReadUInt64(stream);
				continue;
			case 120:
				instance.StartInventoryAmount = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			case 16:
				if (key.GetWireType() != 0)
					break;
				instance.Strength = ProtocolParser.ReadUInt64(stream);
				continue;
			case 17:
				if (key.GetWireType() != 2)
					break;
				instance.Name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				if (key.GetWireType() != 0)
					break;
				instance.IsBuildable = ProtocolParser.ReadBool(stream);
				continue;
			case 19:
				if (key.GetWireType() != 0)
					break;
				instance.IsUsable = ProtocolParser.ReadBool(stream);
				continue;
			case 20:
				if (key.GetWireType() != 0)
					break;
				instance.IsTool = ProtocolParser.ReadBool(stream);
				continue;
			case 21:
				if (key.GetWireType() != 2)
					break;
				instance.Handimage = ProtocolParser.ReadString(stream);
				continue;
			case 22:
				if (key.GetWireType() != 0)
					break;
				instance.IsPistol = ProtocolParser.ReadBool(stream);
				continue;
			case 23:
				if (key.GetWireType() != 0)
					break;
				instance.AimRadiusFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				if (key.GetWireType() != 0)
					break;
				instance.RecoilFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 25:
				if (key.GetWireType() != 0)
					break;
				instance.DelayFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				if (key.GetWireType() != 0)
					break;
				instance.BulletsPerShotFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 27:
				if (key.GetWireType() != 0)
					break;
				instance.WalkSpeedWhenUsedFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 28:
				if (key.GetWireType() != 0)
					break;
				instance.IronSightsEnabled = ProtocolParser.ReadBool(stream);
				continue;
			case 29:
				if (key.GetWireType() != 0)
					break;
				instance.IronSightsMoveSpeedFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 30:
				if (key.GetWireType() != 2)
					break;
				instance.IronSightsImage = ProtocolParser.ReadString(stream);
				continue;
			case 31:
				if (key.GetWireType() != 0)
					break;
				instance.IronSightsAimRadiusFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				if (key.GetWireType() != 0)
					break;
				instance.IronSightsFovFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 33:
				if (key.GetWireType() != 0)
					break;
				instance.AmmoMagazine = ProtocolParser.ReadUInt64(stream);
				continue;
			case 34:
				if (key.GetWireType() != 0)
					break;
				instance.AmmoTotal = ProtocolParser.ReadUInt64(stream);
				continue;
			case 35:
				if (key.GetWireType() != 0)
					break;
				instance.ReloadDelayFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 36:
				if (key.GetWireType() != 0)
					break;
				instance.ExplosionRangeFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				if (key.GetWireType() != 0)
					break;
				instance.ExplosionTimeFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 38:
				if (key.GetWireType() != 0)
					break;
				instance.ProjectileSpeedFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 39:
				if (key.GetWireType() != 0)
					break;
				instance.ProjectileBounce = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				if (key.GetWireType() != 0)
					break;
				instance.DamageBodyFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 41:
				if (key.GetWireType() != 0)
					break;
				instance.DamageHeadFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				if (key.GetWireType() != 0)
					break;
				instance.PistolType = ProtocolParser.ReadUInt64(stream);
				continue;
			case 43:
				if (key.GetWireType() != 0)
					break;
				instance.DamageToPlayer = ProtocolParser.ReadUInt64(stream);
				continue;
			case 44:
				if (key.GetWireType() != 0)
					break;
				instance.WhenPlacedGetsConvertedTo = ProtocolParser.ReadUInt64(stream);
				continue;
			case 45:
				if (key.GetWireType() != 0)
					break;
				instance.PickDistanceWhenUsedFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_BlockType DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_BlockType instance = new Packet_BlockType();
		Packet_BlockTypeSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_BlockType instance)
	{
		if (instance.TextureIdTop != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(10));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.TextureIdTop));
		}
		if (instance.TextureIdBottom != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(18));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.TextureIdBottom));
		}
		if (instance.TextureIdFront != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(26));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.TextureIdFront));
		}
		if (instance.TextureIdBack != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(34));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.TextureIdBack));
		}
		if (instance.TextureIdLeft != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(42));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.TextureIdLeft));
		}
		if (instance.TextureIdRight != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(50));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.TextureIdRight));
		}
		if (instance.TextureIdForInventory != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(58));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.TextureIdForInventory));
		}
		if (instance.DrawType != 0) {
			stream.WriteByte(ProtoPlatform.IntToByte(64));
			ProtocolParser.WriteUInt64(stream, instance.DrawType);
		}
		if (instance.WalkableType != 0) {
			stream.WriteByte(ProtoPlatform.IntToByte(72));
			ProtocolParser.WriteUInt64(stream, instance.WalkableType);
		}
		stream.WriteByte(ProtoPlatform.IntToByte(80));
		ProtocolParser.WriteUInt64(stream, instance.Rail);
		stream.WriteByte(ProtoPlatform.IntToByte(88));
		ProtocolParser.WriteUInt64(stream, instance.WalkSpeedFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(96));
		ProtocolParser.WriteBool(stream, instance.IsSlipperyWalk);
		if (instance.Sounds != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(106));
			CitoMemoryStream ms13 = new CitoMemoryStream();
			Packet_SoundSetSerializer.Serialize(ms13, instance.Sounds);
			int ms13Length = ms13.Length();
			ProtocolParser.WriteUInt32_(stream, ms13Length);
			stream.Write(ms13.GetBuffer(), 0, ms13Length);
		}
		stream.WriteByte(ProtoPlatform.IntToByte(112));
		ProtocolParser.WriteUInt64(stream, instance.LightRadius);
		stream.WriteByte(ProtoPlatform.IntToByte(120));
		ProtocolParser.WriteUInt64(stream, instance.StartInventoryAmount);
		stream.WriteByte(ProtoPlatform.IntToByte(128));
		stream.WriteByte(ProtoPlatform.IntToByte(1));
		ProtocolParser.WriteUInt64(stream, instance.Strength);
		if (instance.Name != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(138));
			stream.WriteByte(ProtoPlatform.IntToByte(1));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.Name));
		}
		stream.WriteByte(ProtoPlatform.IntToByte(144));
		stream.WriteByte(ProtoPlatform.IntToByte(1));
		ProtocolParser.WriteBool(stream, instance.IsBuildable);
		stream.WriteByte(ProtoPlatform.IntToByte(152));
		stream.WriteByte(ProtoPlatform.IntToByte(1));
		ProtocolParser.WriteBool(stream, instance.IsUsable);
		stream.WriteByte(ProtoPlatform.IntToByte(160));
		stream.WriteByte(ProtoPlatform.IntToByte(1));
		ProtocolParser.WriteBool(stream, instance.IsTool);
		if (instance.Handimage != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(170));
			stream.WriteByte(ProtoPlatform.IntToByte(1));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.Handimage));
		}
		stream.WriteByte(ProtoPlatform.IntToByte(176));
		stream.WriteByte(ProtoPlatform.IntToByte(1));
		ProtocolParser.WriteBool(stream, instance.IsPistol);
		stream.WriteByte(ProtoPlatform.IntToByte(184));
		stream.WriteByte(ProtoPlatform.IntToByte(1));
		ProtocolParser.WriteUInt64(stream, instance.AimRadiusFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(192));
		stream.WriteByte(ProtoPlatform.IntToByte(1));
		ProtocolParser.WriteUInt64(stream, instance.RecoilFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(200));
		stream.WriteByte(ProtoPlatform.IntToByte(1));
		ProtocolParser.WriteUInt64(stream, instance.DelayFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(208));
		stream.WriteByte(ProtoPlatform.IntToByte(1));
		ProtocolParser.WriteUInt64(stream, instance.BulletsPerShotFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(216));
		stream.WriteByte(ProtoPlatform.IntToByte(1));
		ProtocolParser.WriteUInt64(stream, instance.WalkSpeedWhenUsedFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(224));
		stream.WriteByte(ProtoPlatform.IntToByte(1));
		ProtocolParser.WriteBool(stream, instance.IronSightsEnabled);
		stream.WriteByte(ProtoPlatform.IntToByte(232));
		stream.WriteByte(ProtoPlatform.IntToByte(1));
		ProtocolParser.WriteUInt64(stream, instance.IronSightsMoveSpeedFloat);
		if (instance.IronSightsImage != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(242));
			stream.WriteByte(ProtoPlatform.IntToByte(1));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.IronSightsImage));
		}
		stream.WriteByte(ProtoPlatform.IntToByte(248));
		stream.WriteByte(ProtoPlatform.IntToByte(1));
		ProtocolParser.WriteUInt64(stream, instance.IronSightsAimRadiusFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(128));
		stream.WriteByte(ProtoPlatform.IntToByte(2));
		ProtocolParser.WriteUInt64(stream, instance.IronSightsFovFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(136));
		stream.WriteByte(ProtoPlatform.IntToByte(2));
		ProtocolParser.WriteUInt64(stream, instance.AmmoMagazine);
		stream.WriteByte(ProtoPlatform.IntToByte(144));
		stream.WriteByte(ProtoPlatform.IntToByte(2));
		ProtocolParser.WriteUInt64(stream, instance.AmmoTotal);
		stream.WriteByte(ProtoPlatform.IntToByte(152));
		stream.WriteByte(ProtoPlatform.IntToByte(2));
		ProtocolParser.WriteUInt64(stream, instance.ReloadDelayFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(160));
		stream.WriteByte(ProtoPlatform.IntToByte(2));
		ProtocolParser.WriteUInt64(stream, instance.ExplosionRangeFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(168));
		stream.WriteByte(ProtoPlatform.IntToByte(2));
		ProtocolParser.WriteUInt64(stream, instance.ExplosionTimeFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(176));
		stream.WriteByte(ProtoPlatform.IntToByte(2));
		ProtocolParser.WriteUInt64(stream, instance.ProjectileSpeedFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(184));
		stream.WriteByte(ProtoPlatform.IntToByte(2));
		ProtocolParser.WriteBool(stream, instance.ProjectileBounce);
		stream.WriteByte(ProtoPlatform.IntToByte(192));
		stream.WriteByte(ProtoPlatform.IntToByte(2));
		ProtocolParser.WriteUInt64(stream, instance.DamageBodyFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(200));
		stream.WriteByte(ProtoPlatform.IntToByte(2));
		ProtocolParser.WriteUInt64(stream, instance.DamageHeadFloat);
		if (instance.PistolType != 0) {
			stream.WriteByte(ProtoPlatform.IntToByte(208));
			stream.WriteByte(ProtoPlatform.IntToByte(2));
			ProtocolParser.WriteUInt64(stream, instance.PistolType);
		}
		stream.WriteByte(ProtoPlatform.IntToByte(216));
		stream.WriteByte(ProtoPlatform.IntToByte(2));
		ProtocolParser.WriteUInt64(stream, instance.DamageToPlayer);
		stream.WriteByte(ProtoPlatform.IntToByte(224));
		stream.WriteByte(ProtoPlatform.IntToByte(2));
		ProtocolParser.WriteUInt64(stream, instance.WhenPlacedGetsConvertedTo);
		stream.WriteByte(ProtoPlatform.IntToByte(232));
		stream.WriteByte(ProtoPlatform.IntToByte(2));
		ProtocolParser.WriteUInt64(stream, instance.PickDistanceWhenUsedFloat);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_BlockType instance)
	{
		byte[] data = Packet_BlockTypeSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_BlockType instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_BlockTypeSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_Client
{
	internal Packet_ClientActiveMaterialSlot ActiveMaterialSlot;
	internal Packet_ClientCraft Craft;
	internal Packet_ClientDeath Death;
	internal Packet_ClientDialogClick DialogClick_;
	internal Packet_ClientEntityInteraction EntityInteraction;
	internal Packet_ClientFillArea FillArea;
	internal Packet_ClientGameResolution GameResolution;

	public Packet_ClientActiveMaterialSlot GetActiveMaterialSlot()
	{
		return this.ActiveMaterialSlot;
	}

	public Packet_ClientCraft GetCraft()
	{
		return this.Craft;
	}

	public Packet_ClientDeath GetDeath()
	{
		return this.Death;
	}

	public Packet_ClientDialogClick GetDialogClick_()
	{
		return this.DialogClick_;
	}

	public Packet_ClientEntityInteraction GetEntityInteraction()
	{
		return this.EntityInteraction;
	}

	public Packet_ClientFillArea GetFillArea()
	{
		return this.FillArea;
	}

	public Packet_ClientGameResolution GetGameResolution()
	{
		return this.GameResolution;
	}

	public Packet_ClientHealth GetHealth()
	{
		return this.Health;
	}

	public int GetId()
	{
		return this.Id;
	}

	public Packet_ClientIdentification GetIdentification()
	{
		return this.Identification;
	}

	public Packet_ClientInventoryAction GetInventoryAction()
	{
		return this.InventoryAction;
	}

	public Packet_ClientLeave GetLeave()
	{
		return this.Leave;
	}

	public Packet_ClientMessage GetMessage()
	{
		return this.Message;
	}

	public Packet_ClientOxygen GetOxygen()
	{
		return this.Oxygen;
	}

	public Packet_ClientPingReply GetPingReply()
	{
		return this.PingReply;
	}

	public Packet_ClientPositionAndOrientation GetPositionAndOrientation()
	{
		return this.PositionAndOrientation;
	}

	public Packet_ClientServerQuery GetQuery()
	{
		return this.Query;
	}

	public Packet_ClientReload GetReload()
	{
		return this.Reload;
	}

	public Packet_ClientRequestBlob GetRequestBlob()
	{
		return this.RequestBlob;
	}

	public Packet_ClientSetBlock GetSetBlock()
	{
		return this.SetBlock;
	}

	public Packet_ClientShot GetShot()
	{
		return this.Shot;
	}

	public Packet_ClientSpecialKey GetSpecialKey_()
	{
		return this.SpecialKey_;
	}
	internal Packet_ClientHealth Health;
	internal int Id;
	internal Packet_ClientIdentification Identification;
	internal Packet_ClientInventoryAction InventoryAction;
	internal Packet_ClientLeave Leave;
	internal Packet_ClientMessage Message;
	internal Packet_ClientOxygen Oxygen;
	internal Packet_ClientPingReply PingReply;
	internal Packet_ClientPositionAndOrientation PositionAndOrientation;
	internal Packet_ClientServerQuery Query;
	internal Packet_ClientReload Reload;
	internal Packet_ClientRequestBlob RequestBlob;

	public void SetActiveMaterialSlot(Packet_ClientActiveMaterialSlot value)
	{
		this.ActiveMaterialSlot = value;
	}
	internal Packet_ClientSetBlock SetBlock;

	public void SetCraft(Packet_ClientCraft value)
	{
		this.Craft = value;
	}

	public void SetDeath(Packet_ClientDeath value)
	{
		this.Death = value;
	}

	public void SetDialogClick_(Packet_ClientDialogClick value)
	{
		this.DialogClick_ = value;
	}

	public void SetEntityInteraction(Packet_ClientEntityInteraction value)
	{
		this.EntityInteraction = value;
	}

	public void SetFillArea(Packet_ClientFillArea value)
	{
		this.FillArea = value;
	}

	public void SetGameResolution(Packet_ClientGameResolution value)
	{
		this.GameResolution = value;
	}

	public void SetHealth(Packet_ClientHealth value)
	{
		this.Health = value;
	}

	public void SetId(int value)
	{
		this.Id = value;
	}

	public void SetIdentification(Packet_ClientIdentification value)
	{
		this.Identification = value;
	}

	public void SetInventoryAction(Packet_ClientInventoryAction value)
	{
		this.InventoryAction = value;
	}

	public void SetLeave(Packet_ClientLeave value)
	{
		this.Leave = value;
	}

	public void SetMessage(Packet_ClientMessage value)
	{
		this.Message = value;
	}

	public void SetOxygen(Packet_ClientOxygen value)
	{
		this.Oxygen = value;
	}

	public void SetPingReply(Packet_ClientPingReply value)
	{
		this.PingReply = value;
	}

	public void SetPositionAndOrientation(Packet_ClientPositionAndOrientation value)
	{
		this.PositionAndOrientation = value;
	}

	public void SetQuery(Packet_ClientServerQuery value)
	{
		this.Query = value;
	}

	public void SetReload(Packet_ClientReload value)
	{
		this.Reload = value;
	}

	public void SetRequestBlob(Packet_ClientRequestBlob value)
	{
		this.RequestBlob = value;
	}

	public void SetSetBlock(Packet_ClientSetBlock value)
	{
		this.SetBlock = value;
	}

	public void SetShot(Packet_ClientShot value)
	{
		this.Shot = value;
	}

	public void SetSpecialKey_(Packet_ClientSpecialKey value)
	{
		this.SpecialKey_ = value;
	}
	internal Packet_ClientShot Shot;
	internal Packet_ClientSpecialKey SpecialKey_;
}

public class Packet_ClientActiveMaterialSlot
{
	internal int ActiveMaterialSlot;

	public int GetActiveMaterialSlot()
	{
		return this.ActiveMaterialSlot;
	}

	public void SetActiveMaterialSlot(int value)
	{
		this.ActiveMaterialSlot = value;
	}
}

public class Packet_ClientActiveMaterialSlotSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientActiveMaterialSlot Deserialize(CitoStream stream, Packet_ClientActiveMaterialSlot instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.ActiveMaterialSlot = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ClientActiveMaterialSlot DeserializeBuffer(byte[] buffer, int length, Packet_ClientActiveMaterialSlot instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ClientActiveMaterialSlotSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientActiveMaterialSlot DeserializeLength(CitoStream stream, int length, Packet_ClientActiveMaterialSlot instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.ActiveMaterialSlot = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientActiveMaterialSlot DeserializeLengthDelimited(CitoStream stream, Packet_ClientActiveMaterialSlot instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.ActiveMaterialSlot = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ClientActiveMaterialSlot DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ClientActiveMaterialSlot instance = new Packet_ClientActiveMaterialSlot();
		Packet_ClientActiveMaterialSlotSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ClientActiveMaterialSlot instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.ActiveMaterialSlot);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ClientActiveMaterialSlot instance)
	{
		byte[] data = Packet_ClientActiveMaterialSlotSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ClientActiveMaterialSlot instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ClientActiveMaterialSlotSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ClientCraft
{

	public int GetRecipeId()
	{
		return this.RecipeId;
	}

	public int GetX()
	{
		return this.X;
	}

	public int GetY()
	{
		return this.Y;
	}

	public int GetZ()
	{
		return this.Z;
	}
	internal int RecipeId;

	public void SetRecipeId(int value)
	{
		this.RecipeId = value;
	}

	public void SetX(int value)
	{
		this.X = value;
	}

	public void SetY(int value)
	{
		this.Y = value;
	}

	public void SetZ(int value)
	{
		this.Z = value;
	}
	internal int X;
	internal int Y;
	internal int Z;
}

public class Packet_ClientCraftSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientCraft Deserialize(CitoStream stream, Packet_ClientCraft instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.RecipeId = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ClientCraft DeserializeBuffer(byte[] buffer, int length, Packet_ClientCraft instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ClientCraftSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientCraft DeserializeLength(CitoStream stream, int length, Packet_ClientCraft instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.RecipeId = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientCraft DeserializeLengthDelimited(CitoStream stream, Packet_ClientCraft instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.RecipeId = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ClientCraft DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ClientCraft instance = new Packet_ClientCraft();
		Packet_ClientCraftSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ClientCraft instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.X);
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.Y);
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteUInt64(stream, instance.Z);
		stream.WriteByte(ProtoPlatform.IntToByte(32));
		ProtocolParser.WriteUInt64(stream, instance.RecipeId);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ClientCraft instance)
	{
		byte[] data = Packet_ClientCraftSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ClientCraft instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ClientCraftSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ClientDeath
{

	public int GetReason()
	{
		return this.Reason;
	}

	public int GetSourcePlayer()
	{
		return this.SourcePlayer;
	}
	internal int Reason;

	public void SetReason(int value)
	{
		this.Reason = value;
	}

	public void SetSourcePlayer(int value)
	{
		this.SourcePlayer = value;
	}
	internal int SourcePlayer;
}

public class Packet_ClientDeathSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientDeath Deserialize(CitoStream stream, Packet_ClientDeath instance)
	{
		instance.Reason = 0;
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.Reason = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.SourcePlayer = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ClientDeath DeserializeBuffer(byte[] buffer, int length, Packet_ClientDeath instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ClientDeathSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientDeath DeserializeLength(CitoStream stream, int length, Packet_ClientDeath instance)
	{
		instance.Reason = 0;
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Reason = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.SourcePlayer = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientDeath DeserializeLengthDelimited(CitoStream stream, Packet_ClientDeath instance)
	{
		instance.Reason = 0;
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Reason = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.SourcePlayer = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ClientDeath DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ClientDeath instance = new Packet_ClientDeath();
		Packet_ClientDeathSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ClientDeath instance)
	{
		if (instance.Reason != 0) {
			stream.WriteByte(ProtoPlatform.IntToByte(8));
			ProtocolParser.WriteUInt64(stream, instance.Reason);
		}
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.SourcePlayer);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ClientDeath instance)
	{
		byte[] data = Packet_ClientDeathSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ClientDeath instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ClientDeathSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ClientDialogClick
{

	public string[] GetTextBoxValue()
	{
		return this.TextBoxValue;
	}

	public int GetTextBoxValueCount()
	{
		return this.TextBoxValueCount;
	}

	public int GetTextBoxValueLength()
	{
		return this.TextBoxValueLength;
	}

	public string GetWidgetId()
	{
		return this.WidgetId;
	}

	public void SetTextBoxValue(string[] value, int count, int length)
	{
		this.TextBoxValue = value;
		this.TextBoxValueCount = count;
		this.TextBoxValueLength = length;
	}

	public void SetWidgetId(string value)
	{
		this.WidgetId = value;
	}
	internal string[] TextBoxValue;

	public void TextBoxValueAdd(string value)
	{
		if (this.TextBoxValueCount >= this.TextBoxValueLength) {
			string[] TextBoxValue2 = new string[this.TextBoxValueLength * 2];
			this.TextBoxValueLength = this.TextBoxValueLength * 2;
			for (int i = 0; i < this.TextBoxValueCount; i++) {
				TextBoxValue2[i] = this.TextBoxValue[i];
			}
			this.TextBoxValue = TextBoxValue2;
		}
		this.TextBoxValue[this.TextBoxValueCount] = value;
		this.TextBoxValueCount++;
	}
	internal int TextBoxValueCount;
	internal int TextBoxValueLength;
	internal string WidgetId;
}

public class Packet_ClientDialogClickSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientDialogClick Deserialize(CitoStream stream, Packet_ClientDialogClick instance)
	{
		if (instance.TextBoxValue == null) {
			instance.TextBoxValue = new string[1];
			instance.TextBoxValueCount = 0;
			instance.TextBoxValueLength = 1;
		}
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.WidgetId = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.TextBoxValueAdd(ProtocolParser.ReadString(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ClientDialogClick DeserializeBuffer(byte[] buffer, int length, Packet_ClientDialogClick instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ClientDialogClickSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientDialogClick DeserializeLength(CitoStream stream, int length, Packet_ClientDialogClick instance)
	{
		if (instance.TextBoxValue == null) {
			instance.TextBoxValue = new string[1];
			instance.TextBoxValueCount = 0;
			instance.TextBoxValueLength = 1;
		}
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.WidgetId = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.TextBoxValueAdd(ProtocolParser.ReadString(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientDialogClick DeserializeLengthDelimited(CitoStream stream, Packet_ClientDialogClick instance)
	{
		if (instance.TextBoxValue == null) {
			instance.TextBoxValue = new string[1];
			instance.TextBoxValueCount = 0;
			instance.TextBoxValueLength = 1;
		}
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.WidgetId = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.TextBoxValueAdd(ProtocolParser.ReadString(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ClientDialogClick DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ClientDialogClick instance = new Packet_ClientDialogClick();
		Packet_ClientDialogClickSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ClientDialogClick instance)
	{
		if (instance.WidgetId != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(10));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.WidgetId));
		}
		if (instance.TextBoxValue != null) {
			for (int k = 0; k < instance.TextBoxValueCount; k++) {
				string i3 = instance.TextBoxValue[k];
				stream.WriteByte(ProtoPlatform.IntToByte(26));
				ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(i3));
			}
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ClientDialogClick instance)
	{
		byte[] data = Packet_ClientDialogClickSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ClientDialogClick instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ClientDialogClickSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ClientEntityInteraction
{
	internal int EntityId;

	public int GetEntityId()
	{
		return this.EntityId;
	}

	public int GetInteractionType()
	{
		return this.InteractionType;
	}
	internal int InteractionType;

	public void SetEntityId(int value)
	{
		this.EntityId = value;
	}

	public void SetInteractionType(int value)
	{
		this.InteractionType = value;
	}
}

public class Packet_ClientEntityInteractionSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientEntityInteraction Deserialize(CitoStream stream, Packet_ClientEntityInteraction instance)
	{
		instance.InteractionType = 0;
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.EntityId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.InteractionType = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ClientEntityInteraction DeserializeBuffer(byte[] buffer, int length, Packet_ClientEntityInteraction instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ClientEntityInteractionSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientEntityInteraction DeserializeLength(CitoStream stream, int length, Packet_ClientEntityInteraction instance)
	{
		instance.InteractionType = 0;
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.EntityId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.InteractionType = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientEntityInteraction DeserializeLengthDelimited(CitoStream stream, Packet_ClientEntityInteraction instance)
	{
		instance.InteractionType = 0;
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.EntityId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.InteractionType = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ClientEntityInteraction DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ClientEntityInteraction instance = new Packet_ClientEntityInteraction();
		Packet_ClientEntityInteractionSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ClientEntityInteraction instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.EntityId);
		if (instance.InteractionType != 0) {
			stream.WriteByte(ProtoPlatform.IntToByte(16));
			ProtocolParser.WriteUInt64(stream, instance.InteractionType);
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ClientEntityInteraction instance)
	{
		byte[] data = Packet_ClientEntityInteractionSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ClientEntityInteraction instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ClientEntityInteractionSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ClientFillArea
{
	internal int BlockType;

	public int GetBlockType()
	{
		return this.BlockType;
	}

	public int GetMaterialSlot()
	{
		return this.MaterialSlot;
	}

	public int GetX1()
	{
		return this.X1;
	}

	public int GetX2()
	{
		return this.X2;
	}

	public int GetY1()
	{
		return this.Y1;
	}

	public int GetY2()
	{
		return this.Y2;
	}

	public int GetZ1()
	{
		return this.Z1;
	}

	public int GetZ2()
	{
		return this.Z2;
	}
	internal int MaterialSlot;

	public void SetBlockType(int value)
	{
		this.BlockType = value;
	}

	public void SetMaterialSlot(int value)
	{
		this.MaterialSlot = value;
	}

	public void SetX1(int value)
	{
		this.X1 = value;
	}

	public void SetX2(int value)
	{
		this.X2 = value;
	}

	public void SetY1(int value)
	{
		this.Y1 = value;
	}

	public void SetY2(int value)
	{
		this.Y2 = value;
	}

	public void SetZ1(int value)
	{
		this.Z1 = value;
	}

	public void SetZ2(int value)
	{
		this.Z2 = value;
	}
	internal int X1;
	internal int X2;
	internal int Y1;
	internal int Y2;
	internal int Z1;
	internal int Z2;
}

public class Packet_ClientFillAreaSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientFillArea Deserialize(CitoStream stream, Packet_ClientFillArea instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.X1 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.X2 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Y1 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Y2 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.Z1 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.Z2 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.BlockType = ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.MaterialSlot = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ClientFillArea DeserializeBuffer(byte[] buffer, int length, Packet_ClientFillArea instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ClientFillAreaSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientFillArea DeserializeLength(CitoStream stream, int length, Packet_ClientFillArea instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.X1 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.X2 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Y1 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Y2 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.Z1 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.Z2 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.BlockType = ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.MaterialSlot = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientFillArea DeserializeLengthDelimited(CitoStream stream, Packet_ClientFillArea instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.X1 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.X2 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Y1 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Y2 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.Z1 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.Z2 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.BlockType = ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.MaterialSlot = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ClientFillArea DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ClientFillArea instance = new Packet_ClientFillArea();
		Packet_ClientFillAreaSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ClientFillArea instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.X1);
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.X2);
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteUInt64(stream, instance.Y1);
		stream.WriteByte(ProtoPlatform.IntToByte(32));
		ProtocolParser.WriteUInt64(stream, instance.Y2);
		stream.WriteByte(ProtoPlatform.IntToByte(40));
		ProtocolParser.WriteUInt64(stream, instance.Z1);
		stream.WriteByte(ProtoPlatform.IntToByte(48));
		ProtocolParser.WriteUInt64(stream, instance.Z2);
		stream.WriteByte(ProtoPlatform.IntToByte(56));
		ProtocolParser.WriteUInt64(stream, instance.BlockType);
		stream.WriteByte(ProtoPlatform.IntToByte(64));
		ProtocolParser.WriteUInt64(stream, instance.MaterialSlot);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ClientFillArea instance)
	{
		byte[] data = Packet_ClientFillAreaSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ClientFillArea instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ClientFillAreaSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ClientGameResolution
{

	public int GetHeight()
	{
		return this.Height;
	}

	public int GetWidth()
	{
		return this.Width;
	}
	internal int Height;

	public void SetHeight(int value)
	{
		this.Height = value;
	}

	public void SetWidth(int value)
	{
		this.Width = value;
	}
	internal int Width;
}

public class Packet_ClientGameResolutionSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientGameResolution Deserialize(CitoStream stream, Packet_ClientGameResolution instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.Width = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Height = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ClientGameResolution DeserializeBuffer(byte[] buffer, int length, Packet_ClientGameResolution instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ClientGameResolutionSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientGameResolution DeserializeLength(CitoStream stream, int length, Packet_ClientGameResolution instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Width = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Height = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientGameResolution DeserializeLengthDelimited(CitoStream stream, Packet_ClientGameResolution instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Width = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Height = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ClientGameResolution DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ClientGameResolution instance = new Packet_ClientGameResolution();
		Packet_ClientGameResolutionSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ClientGameResolution instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.Width);
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.Height);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ClientGameResolution instance)
	{
		byte[] data = Packet_ClientGameResolutionSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ClientGameResolution instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ClientGameResolutionSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

/// <summary>&lt;summary&gt;
/// &lt;para&gt;Temporary, for client-side health.&lt;/para&gt;
/// &lt;para&gt;Todo fix because it allows cheating.&lt;/para&gt;
/// &lt;/summary&gt;</summary>
public class Packet_ClientHealth
{
	internal int CurrentHealth;

	public int GetCurrentHealth()
	{
		return this.CurrentHealth;
	}

	public void SetCurrentHealth(int value)
	{
		this.CurrentHealth = value;
	}
}

public class Packet_ClientHealthSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientHealth Deserialize(CitoStream stream, Packet_ClientHealth instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.CurrentHealth = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ClientHealth DeserializeBuffer(byte[] buffer, int length, Packet_ClientHealth instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ClientHealthSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientHealth DeserializeLength(CitoStream stream, int length, Packet_ClientHealth instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.CurrentHealth = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientHealth DeserializeLengthDelimited(CitoStream stream, Packet_ClientHealth instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.CurrentHealth = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ClientHealth DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ClientHealth instance = new Packet_ClientHealth();
		Packet_ClientHealthSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ClientHealth instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.CurrentHealth);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ClientHealth instance)
	{
		byte[] data = Packet_ClientHealthSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ClientHealth instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ClientHealthSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ClientIdEnum
{
	public const int ActiveMaterialSlot = 56;
	public const int Craft = 9;
	public const int Death = 60;
	public const int DialogClick = 14;
	public const int EntityInteraction = 61;
	public const int ExtendedPacketCommand = 100;
	public const int FillArea = 510;
	public const int GameResolution = 10;
	public const int Health = 52;
	public const int InventoryAction = 51;
	public const int Leave = 57;
	public const int Message = 13;
	public const int MonsterHit = 53;
	public const int Oxygen = 59;
	public const int PingReply = 1;
	public const int PlayerIdentification = 0;
	public const int PositionandOrientation = 8;
	public const int Reload = 58;
	public const int RequestBlob = 50;
	public const int ServerQuery = 64;
	public const int SetBlock = 5;
	public const int Shot = 54;
	public const int SpecialKey = 55;
}

public class Packet_ClientIdentification
{

	public string GetMdProtocolVersion()
	{
		return this.MdProtocolVersion;
	}

	public Packet_PositionAndOrientation GetRequestPosition()
	{
		return this.RequestPosition;
	}

	public string GetServerPassword()
	{
		return this.ServerPassword;
	}

	public string GetUsername()
	{
		return this.Username;
	}

	public string GetVerificationKey()
	{
		return this.VerificationKey;
	}
	internal string MdProtocolVersion;
	internal Packet_PositionAndOrientation RequestPosition;
	internal string ServerPassword;

	public void SetMdProtocolVersion(string value)
	{
		this.MdProtocolVersion = value;
	}

	public void SetRequestPosition(Packet_PositionAndOrientation value)
	{
		this.RequestPosition = value;
	}

	public void SetServerPassword(string value)
	{
		this.ServerPassword = value;
	}

	public void SetUsername(string value)
	{
		this.Username = value;
	}

	public void SetVerificationKey(string value)
	{
		this.VerificationKey = value;
	}
	internal string Username;
	internal string VerificationKey;
}

public class Packet_ClientIdentificationSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientIdentification Deserialize(CitoStream stream, Packet_ClientIdentification instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.MdProtocolVersion = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.Username = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.VerificationKey = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.ServerPassword = ProtocolParser.ReadString(stream);
				continue;
			case 42:
				if (instance.RequestPosition == null)
					instance.RequestPosition = Packet_PositionAndOrientationSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_PositionAndOrientationSerializer.DeserializeLengthDelimited(stream, instance.RequestPosition);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ClientIdentification DeserializeBuffer(byte[] buffer, int length, Packet_ClientIdentification instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ClientIdentificationSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientIdentification DeserializeLength(CitoStream stream, int length, Packet_ClientIdentification instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.MdProtocolVersion = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.Username = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.VerificationKey = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.ServerPassword = ProtocolParser.ReadString(stream);
				continue;
			case 42:
				if (instance.RequestPosition == null)
					instance.RequestPosition = Packet_PositionAndOrientationSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_PositionAndOrientationSerializer.DeserializeLengthDelimited(stream, instance.RequestPosition);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientIdentification DeserializeLengthDelimited(CitoStream stream, Packet_ClientIdentification instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.MdProtocolVersion = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.Username = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.VerificationKey = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.ServerPassword = ProtocolParser.ReadString(stream);
				continue;
			case 42:
				if (instance.RequestPosition == null)
					instance.RequestPosition = Packet_PositionAndOrientationSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_PositionAndOrientationSerializer.DeserializeLengthDelimited(stream, instance.RequestPosition);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ClientIdentification DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ClientIdentification instance = new Packet_ClientIdentification();
		Packet_ClientIdentificationSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ClientIdentification instance)
	{
		if (instance.MdProtocolVersion != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(10));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.MdProtocolVersion));
		}
		if (instance.Username != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(18));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.Username));
		}
		if (instance.VerificationKey != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(26));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.VerificationKey));
		}
		if (instance.ServerPassword != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(34));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.ServerPassword));
		}
		if (instance.RequestPosition != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(42));
			CitoMemoryStream ms5 = new CitoMemoryStream();
			Packet_PositionAndOrientationSerializer.Serialize(ms5, instance.RequestPosition);
			int ms5Length = ms5.Length();
			ProtocolParser.WriteUInt32_(stream, ms5Length);
			stream.Write(ms5.GetBuffer(), 0, ms5Length);
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ClientIdentification instance)
	{
		byte[] data = Packet_ClientIdentificationSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ClientIdentification instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ClientIdentificationSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ClientInventoryAction
{
	internal Packet_InventoryPosition A;
	internal int Action;
	internal Packet_InventoryPosition B;

	public Packet_InventoryPosition GetA()
	{
		return this.A;
	}

	public int GetAction()
	{
		return this.Action;
	}

	public Packet_InventoryPosition GetB()
	{
		return this.B;
	}

	public void SetA(Packet_InventoryPosition value)
	{
		this.A = value;
	}

	public void SetAction(int value)
	{
		this.Action = value;
	}

	public void SetB(Packet_InventoryPosition value)
	{
		this.B = value;
	}
}

public class Packet_ClientInventoryActionSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientInventoryAction Deserialize(CitoStream stream, Packet_ClientInventoryAction instance)
	{
		instance.Action = 0;
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.Action = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				if (instance.A == null)
					instance.A = Packet_InventoryPositionSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_InventoryPositionSerializer.DeserializeLengthDelimited(stream, instance.A);
				continue;
			case 26:
				if (instance.B == null)
					instance.B = Packet_InventoryPositionSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_InventoryPositionSerializer.DeserializeLengthDelimited(stream, instance.B);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ClientInventoryAction DeserializeBuffer(byte[] buffer, int length, Packet_ClientInventoryAction instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ClientInventoryActionSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientInventoryAction DeserializeLength(CitoStream stream, int length, Packet_ClientInventoryAction instance)
	{
		instance.Action = 0;
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Action = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				if (instance.A == null)
					instance.A = Packet_InventoryPositionSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_InventoryPositionSerializer.DeserializeLengthDelimited(stream, instance.A);
				continue;
			case 26:
				if (instance.B == null)
					instance.B = Packet_InventoryPositionSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_InventoryPositionSerializer.DeserializeLengthDelimited(stream, instance.B);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientInventoryAction DeserializeLengthDelimited(CitoStream stream, Packet_ClientInventoryAction instance)
	{
		instance.Action = 0;
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Action = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				if (instance.A == null)
					instance.A = Packet_InventoryPositionSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_InventoryPositionSerializer.DeserializeLengthDelimited(stream, instance.A);
				continue;
			case 26:
				if (instance.B == null)
					instance.B = Packet_InventoryPositionSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_InventoryPositionSerializer.DeserializeLengthDelimited(stream, instance.B);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ClientInventoryAction DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ClientInventoryAction instance = new Packet_ClientInventoryAction();
		Packet_ClientInventoryActionSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ClientInventoryAction instance)
	{
		if (instance.Action != 0) {
			stream.WriteByte(ProtoPlatform.IntToByte(8));
			ProtocolParser.WriteUInt64(stream, instance.Action);
		}
		if (instance.A != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(18));
			CitoMemoryStream ms2 = new CitoMemoryStream();
			Packet_InventoryPositionSerializer.Serialize(ms2, instance.A);
			int ms2Length = ms2.Length();
			ProtocolParser.WriteUInt32_(stream, ms2Length);
			stream.Write(ms2.GetBuffer(), 0, ms2Length);
		}
		if (instance.B != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(26));
			CitoMemoryStream ms3 = new CitoMemoryStream();
			Packet_InventoryPositionSerializer.Serialize(ms3, instance.B);
			int ms3Length = ms3.Length();
			ProtocolParser.WriteUInt32_(stream, ms3Length);
			stream.Write(ms3.GetBuffer(), 0, ms3Length);
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ClientInventoryAction instance)
	{
		byte[] data = Packet_ClientInventoryActionSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ClientInventoryAction instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ClientInventoryActionSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ClientLeave
{

	public int GetReason()
	{
		return this.Reason;
	}
	internal int Reason;

	public void SetReason(int value)
	{
		this.Reason = value;
	}
}

public class Packet_ClientLeaveSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientLeave Deserialize(CitoStream stream, Packet_ClientLeave instance)
	{
		instance.Reason = 0;
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.Reason = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ClientLeave DeserializeBuffer(byte[] buffer, int length, Packet_ClientLeave instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ClientLeaveSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientLeave DeserializeLength(CitoStream stream, int length, Packet_ClientLeave instance)
	{
		instance.Reason = 0;
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Reason = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientLeave DeserializeLengthDelimited(CitoStream stream, Packet_ClientLeave instance)
	{
		instance.Reason = 0;
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Reason = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ClientLeave DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ClientLeave instance = new Packet_ClientLeave();
		Packet_ClientLeaveSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ClientLeave instance)
	{
		if (instance.Reason != 0) {
			stream.WriteByte(ProtoPlatform.IntToByte(8));
			ProtocolParser.WriteUInt64(stream, instance.Reason);
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ClientLeave instance)
	{
		byte[] data = Packet_ClientLeaveSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ClientLeave instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ClientLeaveSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ClientMessage
{

	public int GetIsTeamchat()
	{
		return this.IsTeamchat;
	}

	public string GetMessage()
	{
		return this.Message;
	}
	internal int IsTeamchat;
	internal string Message;

	public void SetIsTeamchat(int value)
	{
		this.IsTeamchat = value;
	}

	public void SetMessage(string value)
	{
		this.Message = value;
	}
}

public class Packet_ClientMessageSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientMessage Deserialize(CitoStream stream, Packet_ClientMessage instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.Message = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.IsTeamchat = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ClientMessage DeserializeBuffer(byte[] buffer, int length, Packet_ClientMessage instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ClientMessageSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientMessage DeserializeLength(CitoStream stream, int length, Packet_ClientMessage instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.Message = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.IsTeamchat = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientMessage DeserializeLengthDelimited(CitoStream stream, Packet_ClientMessage instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.Message = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.IsTeamchat = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ClientMessage DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ClientMessage instance = new Packet_ClientMessage();
		Packet_ClientMessageSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ClientMessage instance)
	{
		if (instance.Message != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(10));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.Message));
		}
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.IsTeamchat);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ClientMessage instance)
	{
		byte[] data = Packet_ClientMessageSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ClientMessage instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ClientMessageSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ClientOxygen
{
	internal int CurrentOxygen;

	public int GetCurrentOxygen()
	{
		return this.CurrentOxygen;
	}

	public void SetCurrentOxygen(int value)
	{
		this.CurrentOxygen = value;
	}
}

public class Packet_ClientOxygenSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientOxygen Deserialize(CitoStream stream, Packet_ClientOxygen instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.CurrentOxygen = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ClientOxygen DeserializeBuffer(byte[] buffer, int length, Packet_ClientOxygen instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ClientOxygenSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientOxygen DeserializeLength(CitoStream stream, int length, Packet_ClientOxygen instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.CurrentOxygen = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientOxygen DeserializeLengthDelimited(CitoStream stream, Packet_ClientOxygen instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.CurrentOxygen = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ClientOxygen DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ClientOxygen instance = new Packet_ClientOxygen();
		Packet_ClientOxygenSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ClientOxygen instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.CurrentOxygen);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ClientOxygen instance)
	{
		byte[] data = Packet_ClientOxygenSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ClientOxygen instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ClientOxygenSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ClientPingReply
{
}

public class Packet_ClientPingReplySerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientPingReply Deserialize(CitoStream stream, Packet_ClientPingReply instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ClientPingReply DeserializeBuffer(byte[] buffer, int length, Packet_ClientPingReply instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ClientPingReplySerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientPingReply DeserializeLength(CitoStream stream, int length, Packet_ClientPingReply instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientPingReply DeserializeLengthDelimited(CitoStream stream, Packet_ClientPingReply instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ClientPingReply DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ClientPingReply instance = new Packet_ClientPingReply();
		Packet_ClientPingReplySerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ClientPingReply instance)
	{
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ClientPingReply instance)
	{
		byte[] data = Packet_ClientPingReplySerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ClientPingReply instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ClientPingReplySerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ClientPositionAndOrientation
{

	public int GetHeading()
	{
		return this.Heading;
	}

	public int GetPitch()
	{
		return this.Pitch;
	}

	public int GetPlayerId()
	{
		return this.PlayerId;
	}

	public int GetStance()
	{
		return this.Stance;
	}

	public int GetX()
	{
		return this.X;
	}

	public int GetY()
	{
		return this.Y;
	}

	public int GetZ()
	{
		return this.Z;
	}
	internal int Heading;
	internal int Pitch;
	internal int PlayerId;

	public void SetHeading(int value)
	{
		this.Heading = value;
	}

	public void SetPitch(int value)
	{
		this.Pitch = value;
	}

	public void SetPlayerId(int value)
	{
		this.PlayerId = value;
	}

	public void SetStance(int value)
	{
		this.Stance = value;
	}

	public void SetX(int value)
	{
		this.X = value;
	}

	public void SetY(int value)
	{
		this.Y = value;
	}

	public void SetZ(int value)
	{
		this.Z = value;
	}
	internal int Stance;
	internal int X;
	internal int Y;
	internal int Z;
}

public class Packet_ClientPositionAndOrientationSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientPositionAndOrientation Deserialize(CitoStream stream, Packet_ClientPositionAndOrientation instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.PlayerId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.Heading = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.Pitch = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.Stance = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ClientPositionAndOrientation DeserializeBuffer(byte[] buffer, int length, Packet_ClientPositionAndOrientation instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ClientPositionAndOrientationSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientPositionAndOrientation DeserializeLength(CitoStream stream, int length, Packet_ClientPositionAndOrientation instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.PlayerId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.Heading = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.Pitch = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.Stance = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientPositionAndOrientation DeserializeLengthDelimited(CitoStream stream, Packet_ClientPositionAndOrientation instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.PlayerId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.Heading = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.Pitch = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.Stance = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ClientPositionAndOrientation DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ClientPositionAndOrientation instance = new Packet_ClientPositionAndOrientation();
		Packet_ClientPositionAndOrientationSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ClientPositionAndOrientation instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.PlayerId);
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.X);
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteUInt64(stream, instance.Y);
		stream.WriteByte(ProtoPlatform.IntToByte(32));
		ProtocolParser.WriteUInt64(stream, instance.Z);
		stream.WriteByte(ProtoPlatform.IntToByte(40));
		ProtocolParser.WriteUInt64(stream, instance.Heading);
		stream.WriteByte(ProtoPlatform.IntToByte(48));
		ProtocolParser.WriteUInt64(stream, instance.Pitch);
		stream.WriteByte(ProtoPlatform.IntToByte(56));
		ProtocolParser.WriteUInt64(stream, instance.Stance);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ClientPositionAndOrientation instance)
	{
		byte[] data = Packet_ClientPositionAndOrientationSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ClientPositionAndOrientation instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ClientPositionAndOrientationSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ClientReload
{
}

public class Packet_ClientReloadSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientReload Deserialize(CitoStream stream, Packet_ClientReload instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ClientReload DeserializeBuffer(byte[] buffer, int length, Packet_ClientReload instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ClientReloadSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientReload DeserializeLength(CitoStream stream, int length, Packet_ClientReload instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientReload DeserializeLengthDelimited(CitoStream stream, Packet_ClientReload instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ClientReload DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ClientReload instance = new Packet_ClientReload();
		Packet_ClientReloadSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ClientReload instance)
	{
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ClientReload instance)
	{
		byte[] data = Packet_ClientReloadSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ClientReload instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ClientReloadSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ClientRequestBlob
{

	public Packet_StringList GetRequestedMd5()
	{
		return this.RequestedMd5;
	}
	internal Packet_StringList RequestedMd5;

	public void SetRequestedMd5(Packet_StringList value)
	{
		this.RequestedMd5 = value;
	}
}

public class Packet_ClientRequestBlobSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientRequestBlob Deserialize(CitoStream stream, Packet_ClientRequestBlob instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				if (instance.RequestedMd5 == null)
					instance.RequestedMd5 = Packet_StringListSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_StringListSerializer.DeserializeLengthDelimited(stream, instance.RequestedMd5);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ClientRequestBlob DeserializeBuffer(byte[] buffer, int length, Packet_ClientRequestBlob instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ClientRequestBlobSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientRequestBlob DeserializeLength(CitoStream stream, int length, Packet_ClientRequestBlob instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				if (instance.RequestedMd5 == null)
					instance.RequestedMd5 = Packet_StringListSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_StringListSerializer.DeserializeLengthDelimited(stream, instance.RequestedMd5);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientRequestBlob DeserializeLengthDelimited(CitoStream stream, Packet_ClientRequestBlob instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				if (instance.RequestedMd5 == null)
					instance.RequestedMd5 = Packet_StringListSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_StringListSerializer.DeserializeLengthDelimited(stream, instance.RequestedMd5);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ClientRequestBlob DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ClientRequestBlob instance = new Packet_ClientRequestBlob();
		Packet_ClientRequestBlobSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ClientRequestBlob instance)
	{
		if (instance.RequestedMd5 != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(10));
			CitoMemoryStream ms1 = new CitoMemoryStream();
			Packet_StringListSerializer.Serialize(ms1, instance.RequestedMd5);
			int ms1Length = ms1.Length();
			ProtocolParser.WriteUInt32_(stream, ms1Length);
			stream.Write(ms1.GetBuffer(), 0, ms1Length);
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ClientRequestBlob instance)
	{
		byte[] data = Packet_ClientRequestBlobSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ClientRequestBlob instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ClientRequestBlobSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ClientSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_Client Deserialize(CitoStream stream, Packet_Client instance)
	{
		instance.Id = 0;
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.Id = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				if (instance.Identification == null)
					instance.Identification = Packet_ClientIdentificationSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientIdentificationSerializer.DeserializeLengthDelimited(stream, instance.Identification);
				continue;
			case 26:
				if (instance.SetBlock == null)
					instance.SetBlock = Packet_ClientSetBlockSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientSetBlockSerializer.DeserializeLengthDelimited(stream, instance.SetBlock);
				continue;
			case 34:
				if (instance.PositionAndOrientation == null)
					instance.PositionAndOrientation = Packet_ClientPositionAndOrientationSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientPositionAndOrientationSerializer.DeserializeLengthDelimited(stream, instance.PositionAndOrientation);
				continue;
			case 42:
				if (instance.Message == null)
					instance.Message = Packet_ClientMessageSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientMessageSerializer.DeserializeLengthDelimited(stream, instance.Message);
				continue;
			case 50:
				if (instance.Craft == null)
					instance.Craft = Packet_ClientCraftSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientCraftSerializer.DeserializeLengthDelimited(stream, instance.Craft);
				continue;
			case 58:
				if (instance.RequestBlob == null)
					instance.RequestBlob = Packet_ClientRequestBlobSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientRequestBlobSerializer.DeserializeLengthDelimited(stream, instance.RequestBlob);
				continue;
			case 66:
				if (instance.InventoryAction == null)
					instance.InventoryAction = Packet_ClientInventoryActionSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientInventoryActionSerializer.DeserializeLengthDelimited(stream, instance.InventoryAction);
				continue;
			case 74:
				if (instance.Health == null)
					instance.Health = Packet_ClientHealthSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientHealthSerializer.DeserializeLengthDelimited(stream, instance.Health);
				continue;
			case 82:
				if (instance.PingReply == null)
					instance.PingReply = Packet_ClientPingReplySerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientPingReplySerializer.DeserializeLengthDelimited(stream, instance.PingReply);
				continue;
			case 90:
				if (instance.DialogClick_ == null)
					instance.DialogClick_ = Packet_ClientDialogClickSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientDialogClickSerializer.DeserializeLengthDelimited(stream, instance.DialogClick_);
				continue;
			case 98:
				if (instance.Shot == null)
					instance.Shot = Packet_ClientShotSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientShotSerializer.DeserializeLengthDelimited(stream, instance.Shot);
				continue;
			case 106:
				if (instance.SpecialKey_ == null)
					instance.SpecialKey_ = Packet_ClientSpecialKeySerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientSpecialKeySerializer.DeserializeLengthDelimited(stream, instance.SpecialKey_);
				continue;
			case 114:
				if (instance.ActiveMaterialSlot == null)
					instance.ActiveMaterialSlot = Packet_ClientActiveMaterialSlotSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientActiveMaterialSlotSerializer.DeserializeLengthDelimited(stream, instance.ActiveMaterialSlot);
				continue;
			case 122:
				if (instance.Leave == null)
					instance.Leave = Packet_ClientLeaveSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientLeaveSerializer.DeserializeLengthDelimited(stream, instance.Leave);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			case 31:
				if (key.GetWireType() != 2)
					break;
				if (instance.FillArea == null)
					instance.FillArea = Packet_ClientFillAreaSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientFillAreaSerializer.DeserializeLengthDelimited(stream, instance.FillArea);
				continue;
			case 16:
				if (key.GetWireType() != 2)
					break;
				if (instance.Reload == null)
					instance.Reload = Packet_ClientReloadSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientReloadSerializer.DeserializeLengthDelimited(stream, instance.Reload);
				continue;
			case 17:
				if (key.GetWireType() != 2)
					break;
				if (instance.Oxygen == null)
					instance.Oxygen = Packet_ClientOxygenSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientOxygenSerializer.DeserializeLengthDelimited(stream, instance.Oxygen);
				continue;
			case 18:
				if (key.GetWireType() != 2)
					break;
				if (instance.Death == null)
					instance.Death = Packet_ClientDeathSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientDeathSerializer.DeserializeLengthDelimited(stream, instance.Death);
				continue;
			case 19:
				if (key.GetWireType() != 2)
					break;
				if (instance.Query == null)
					instance.Query = Packet_ClientServerQuerySerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientServerQuerySerializer.DeserializeLengthDelimited(stream, instance.Query);
				continue;
			case 20:
				if (key.GetWireType() != 2)
					break;
				if (instance.GameResolution == null)
					instance.GameResolution = Packet_ClientGameResolutionSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientGameResolutionSerializer.DeserializeLengthDelimited(stream, instance.GameResolution);
				continue;
			case 21:
				if (key.GetWireType() != 2)
					break;
				if (instance.EntityInteraction == null)
					instance.EntityInteraction = Packet_ClientEntityInteractionSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientEntityInteractionSerializer.DeserializeLengthDelimited(stream, instance.EntityInteraction);
				continue;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_Client DeserializeBuffer(byte[] buffer, int length, Packet_Client instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ClientSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_Client DeserializeLength(CitoStream stream, int length, Packet_Client instance)
	{
		instance.Id = 0;
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Id = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				if (instance.Identification == null)
					instance.Identification = Packet_ClientIdentificationSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientIdentificationSerializer.DeserializeLengthDelimited(stream, instance.Identification);
				continue;
			case 26:
				if (instance.SetBlock == null)
					instance.SetBlock = Packet_ClientSetBlockSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientSetBlockSerializer.DeserializeLengthDelimited(stream, instance.SetBlock);
				continue;
			case 34:
				if (instance.PositionAndOrientation == null)
					instance.PositionAndOrientation = Packet_ClientPositionAndOrientationSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientPositionAndOrientationSerializer.DeserializeLengthDelimited(stream, instance.PositionAndOrientation);
				continue;
			case 42:
				if (instance.Message == null)
					instance.Message = Packet_ClientMessageSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientMessageSerializer.DeserializeLengthDelimited(stream, instance.Message);
				continue;
			case 50:
				if (instance.Craft == null)
					instance.Craft = Packet_ClientCraftSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientCraftSerializer.DeserializeLengthDelimited(stream, instance.Craft);
				continue;
			case 58:
				if (instance.RequestBlob == null)
					instance.RequestBlob = Packet_ClientRequestBlobSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientRequestBlobSerializer.DeserializeLengthDelimited(stream, instance.RequestBlob);
				continue;
			case 66:
				if (instance.InventoryAction == null)
					instance.InventoryAction = Packet_ClientInventoryActionSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientInventoryActionSerializer.DeserializeLengthDelimited(stream, instance.InventoryAction);
				continue;
			case 74:
				if (instance.Health == null)
					instance.Health = Packet_ClientHealthSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientHealthSerializer.DeserializeLengthDelimited(stream, instance.Health);
				continue;
			case 82:
				if (instance.PingReply == null)
					instance.PingReply = Packet_ClientPingReplySerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientPingReplySerializer.DeserializeLengthDelimited(stream, instance.PingReply);
				continue;
			case 90:
				if (instance.DialogClick_ == null)
					instance.DialogClick_ = Packet_ClientDialogClickSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientDialogClickSerializer.DeserializeLengthDelimited(stream, instance.DialogClick_);
				continue;
			case 98:
				if (instance.Shot == null)
					instance.Shot = Packet_ClientShotSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientShotSerializer.DeserializeLengthDelimited(stream, instance.Shot);
				continue;
			case 106:
				if (instance.SpecialKey_ == null)
					instance.SpecialKey_ = Packet_ClientSpecialKeySerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientSpecialKeySerializer.DeserializeLengthDelimited(stream, instance.SpecialKey_);
				continue;
			case 114:
				if (instance.ActiveMaterialSlot == null)
					instance.ActiveMaterialSlot = Packet_ClientActiveMaterialSlotSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientActiveMaterialSlotSerializer.DeserializeLengthDelimited(stream, instance.ActiveMaterialSlot);
				continue;
			case 122:
				if (instance.Leave == null)
					instance.Leave = Packet_ClientLeaveSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientLeaveSerializer.DeserializeLengthDelimited(stream, instance.Leave);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			case 31:
				if (key.GetWireType() != 2)
					break;
				if (instance.FillArea == null)
					instance.FillArea = Packet_ClientFillAreaSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientFillAreaSerializer.DeserializeLengthDelimited(stream, instance.FillArea);
				continue;
			case 16:
				if (key.GetWireType() != 2)
					break;
				if (instance.Reload == null)
					instance.Reload = Packet_ClientReloadSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientReloadSerializer.DeserializeLengthDelimited(stream, instance.Reload);
				continue;
			case 17:
				if (key.GetWireType() != 2)
					break;
				if (instance.Oxygen == null)
					instance.Oxygen = Packet_ClientOxygenSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientOxygenSerializer.DeserializeLengthDelimited(stream, instance.Oxygen);
				continue;
			case 18:
				if (key.GetWireType() != 2)
					break;
				if (instance.Death == null)
					instance.Death = Packet_ClientDeathSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientDeathSerializer.DeserializeLengthDelimited(stream, instance.Death);
				continue;
			case 19:
				if (key.GetWireType() != 2)
					break;
				if (instance.Query == null)
					instance.Query = Packet_ClientServerQuerySerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientServerQuerySerializer.DeserializeLengthDelimited(stream, instance.Query);
				continue;
			case 20:
				if (key.GetWireType() != 2)
					break;
				if (instance.GameResolution == null)
					instance.GameResolution = Packet_ClientGameResolutionSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientGameResolutionSerializer.DeserializeLengthDelimited(stream, instance.GameResolution);
				continue;
			case 21:
				if (key.GetWireType() != 2)
					break;
				if (instance.EntityInteraction == null)
					instance.EntityInteraction = Packet_ClientEntityInteractionSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientEntityInteractionSerializer.DeserializeLengthDelimited(stream, instance.EntityInteraction);
				continue;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_Client DeserializeLengthDelimited(CitoStream stream, Packet_Client instance)
	{
		instance.Id = 0;
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Id = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				if (instance.Identification == null)
					instance.Identification = Packet_ClientIdentificationSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientIdentificationSerializer.DeserializeLengthDelimited(stream, instance.Identification);
				continue;
			case 26:
				if (instance.SetBlock == null)
					instance.SetBlock = Packet_ClientSetBlockSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientSetBlockSerializer.DeserializeLengthDelimited(stream, instance.SetBlock);
				continue;
			case 34:
				if (instance.PositionAndOrientation == null)
					instance.PositionAndOrientation = Packet_ClientPositionAndOrientationSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientPositionAndOrientationSerializer.DeserializeLengthDelimited(stream, instance.PositionAndOrientation);
				continue;
			case 42:
				if (instance.Message == null)
					instance.Message = Packet_ClientMessageSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientMessageSerializer.DeserializeLengthDelimited(stream, instance.Message);
				continue;
			case 50:
				if (instance.Craft == null)
					instance.Craft = Packet_ClientCraftSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientCraftSerializer.DeserializeLengthDelimited(stream, instance.Craft);
				continue;
			case 58:
				if (instance.RequestBlob == null)
					instance.RequestBlob = Packet_ClientRequestBlobSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientRequestBlobSerializer.DeserializeLengthDelimited(stream, instance.RequestBlob);
				continue;
			case 66:
				if (instance.InventoryAction == null)
					instance.InventoryAction = Packet_ClientInventoryActionSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientInventoryActionSerializer.DeserializeLengthDelimited(stream, instance.InventoryAction);
				continue;
			case 74:
				if (instance.Health == null)
					instance.Health = Packet_ClientHealthSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientHealthSerializer.DeserializeLengthDelimited(stream, instance.Health);
				continue;
			case 82:
				if (instance.PingReply == null)
					instance.PingReply = Packet_ClientPingReplySerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientPingReplySerializer.DeserializeLengthDelimited(stream, instance.PingReply);
				continue;
			case 90:
				if (instance.DialogClick_ == null)
					instance.DialogClick_ = Packet_ClientDialogClickSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientDialogClickSerializer.DeserializeLengthDelimited(stream, instance.DialogClick_);
				continue;
			case 98:
				if (instance.Shot == null)
					instance.Shot = Packet_ClientShotSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientShotSerializer.DeserializeLengthDelimited(stream, instance.Shot);
				continue;
			case 106:
				if (instance.SpecialKey_ == null)
					instance.SpecialKey_ = Packet_ClientSpecialKeySerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientSpecialKeySerializer.DeserializeLengthDelimited(stream, instance.SpecialKey_);
				continue;
			case 114:
				if (instance.ActiveMaterialSlot == null)
					instance.ActiveMaterialSlot = Packet_ClientActiveMaterialSlotSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientActiveMaterialSlotSerializer.DeserializeLengthDelimited(stream, instance.ActiveMaterialSlot);
				continue;
			case 122:
				if (instance.Leave == null)
					instance.Leave = Packet_ClientLeaveSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientLeaveSerializer.DeserializeLengthDelimited(stream, instance.Leave);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			case 31:
				if (key.GetWireType() != 2)
					break;
				if (instance.FillArea == null)
					instance.FillArea = Packet_ClientFillAreaSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientFillAreaSerializer.DeserializeLengthDelimited(stream, instance.FillArea);
				continue;
			case 16:
				if (key.GetWireType() != 2)
					break;
				if (instance.Reload == null)
					instance.Reload = Packet_ClientReloadSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientReloadSerializer.DeserializeLengthDelimited(stream, instance.Reload);
				continue;
			case 17:
				if (key.GetWireType() != 2)
					break;
				if (instance.Oxygen == null)
					instance.Oxygen = Packet_ClientOxygenSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientOxygenSerializer.DeserializeLengthDelimited(stream, instance.Oxygen);
				continue;
			case 18:
				if (key.GetWireType() != 2)
					break;
				if (instance.Death == null)
					instance.Death = Packet_ClientDeathSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientDeathSerializer.DeserializeLengthDelimited(stream, instance.Death);
				continue;
			case 19:
				if (key.GetWireType() != 2)
					break;
				if (instance.Query == null)
					instance.Query = Packet_ClientServerQuerySerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientServerQuerySerializer.DeserializeLengthDelimited(stream, instance.Query);
				continue;
			case 20:
				if (key.GetWireType() != 2)
					break;
				if (instance.GameResolution == null)
					instance.GameResolution = Packet_ClientGameResolutionSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientGameResolutionSerializer.DeserializeLengthDelimited(stream, instance.GameResolution);
				continue;
			case 21:
				if (key.GetWireType() != 2)
					break;
				if (instance.EntityInteraction == null)
					instance.EntityInteraction = Packet_ClientEntityInteractionSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ClientEntityInteractionSerializer.DeserializeLengthDelimited(stream, instance.EntityInteraction);
				continue;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_Client DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_Client instance = new Packet_Client();
		Packet_ClientSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_Client instance)
	{
		if (instance.Id != 0) {
			stream.WriteByte(ProtoPlatform.IntToByte(8));
			ProtocolParser.WriteUInt64(stream, instance.Id);
		}
		if (instance.Identification != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(18));
			CitoMemoryStream ms2 = new CitoMemoryStream();
			Packet_ClientIdentificationSerializer.Serialize(ms2, instance.Identification);
			int ms2Length = ms2.Length();
			ProtocolParser.WriteUInt32_(stream, ms2Length);
			stream.Write(ms2.GetBuffer(), 0, ms2Length);
		}
		if (instance.SetBlock != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(26));
			CitoMemoryStream ms3 = new CitoMemoryStream();
			Packet_ClientSetBlockSerializer.Serialize(ms3, instance.SetBlock);
			int ms3Length = ms3.Length();
			ProtocolParser.WriteUInt32_(stream, ms3Length);
			stream.Write(ms3.GetBuffer(), 0, ms3Length);
		}
		if (instance.FillArea != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(250));
			stream.WriteByte(ProtoPlatform.IntToByte(1));
			CitoMemoryStream ms31 = new CitoMemoryStream();
			Packet_ClientFillAreaSerializer.Serialize(ms31, instance.FillArea);
			int ms31Length = ms31.Length();
			ProtocolParser.WriteUInt32_(stream, ms31Length);
			stream.Write(ms31.GetBuffer(), 0, ms31Length);
		}
		if (instance.PositionAndOrientation != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(34));
			CitoMemoryStream ms4 = new CitoMemoryStream();
			Packet_ClientPositionAndOrientationSerializer.Serialize(ms4, instance.PositionAndOrientation);
			int ms4Length = ms4.Length();
			ProtocolParser.WriteUInt32_(stream, ms4Length);
			stream.Write(ms4.GetBuffer(), 0, ms4Length);
		}
		if (instance.Message != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(42));
			CitoMemoryStream ms5 = new CitoMemoryStream();
			Packet_ClientMessageSerializer.Serialize(ms5, instance.Message);
			int ms5Length = ms5.Length();
			ProtocolParser.WriteUInt32_(stream, ms5Length);
			stream.Write(ms5.GetBuffer(), 0, ms5Length);
		}
		if (instance.Craft != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(50));
			CitoMemoryStream ms6 = new CitoMemoryStream();
			Packet_ClientCraftSerializer.Serialize(ms6, instance.Craft);
			int ms6Length = ms6.Length();
			ProtocolParser.WriteUInt32_(stream, ms6Length);
			stream.Write(ms6.GetBuffer(), 0, ms6Length);
		}
		if (instance.RequestBlob != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(58));
			CitoMemoryStream ms7 = new CitoMemoryStream();
			Packet_ClientRequestBlobSerializer.Serialize(ms7, instance.RequestBlob);
			int ms7Length = ms7.Length();
			ProtocolParser.WriteUInt32_(stream, ms7Length);
			stream.Write(ms7.GetBuffer(), 0, ms7Length);
		}
		if (instance.InventoryAction != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(66));
			CitoMemoryStream ms8 = new CitoMemoryStream();
			Packet_ClientInventoryActionSerializer.Serialize(ms8, instance.InventoryAction);
			int ms8Length = ms8.Length();
			ProtocolParser.WriteUInt32_(stream, ms8Length);
			stream.Write(ms8.GetBuffer(), 0, ms8Length);
		}
		if (instance.Health != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(74));
			CitoMemoryStream ms9 = new CitoMemoryStream();
			Packet_ClientHealthSerializer.Serialize(ms9, instance.Health);
			int ms9Length = ms9.Length();
			ProtocolParser.WriteUInt32_(stream, ms9Length);
			stream.Write(ms9.GetBuffer(), 0, ms9Length);
		}
		if (instance.PingReply != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(82));
			CitoMemoryStream ms10 = new CitoMemoryStream();
			Packet_ClientPingReplySerializer.Serialize(ms10, instance.PingReply);
			int ms10Length = ms10.Length();
			ProtocolParser.WriteUInt32_(stream, ms10Length);
			stream.Write(ms10.GetBuffer(), 0, ms10Length);
		}
		if (instance.DialogClick_ != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(90));
			CitoMemoryStream ms11 = new CitoMemoryStream();
			Packet_ClientDialogClickSerializer.Serialize(ms11, instance.DialogClick_);
			int ms11Length = ms11.Length();
			ProtocolParser.WriteUInt32_(stream, ms11Length);
			stream.Write(ms11.GetBuffer(), 0, ms11Length);
		}
		if (instance.Shot != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(98));
			CitoMemoryStream ms12 = new CitoMemoryStream();
			Packet_ClientShotSerializer.Serialize(ms12, instance.Shot);
			int ms12Length = ms12.Length();
			ProtocolParser.WriteUInt32_(stream, ms12Length);
			stream.Write(ms12.GetBuffer(), 0, ms12Length);
		}
		if (instance.SpecialKey_ != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(106));
			CitoMemoryStream ms13 = new CitoMemoryStream();
			Packet_ClientSpecialKeySerializer.Serialize(ms13, instance.SpecialKey_);
			int ms13Length = ms13.Length();
			ProtocolParser.WriteUInt32_(stream, ms13Length);
			stream.Write(ms13.GetBuffer(), 0, ms13Length);
		}
		if (instance.ActiveMaterialSlot != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(114));
			CitoMemoryStream ms14 = new CitoMemoryStream();
			Packet_ClientActiveMaterialSlotSerializer.Serialize(ms14, instance.ActiveMaterialSlot);
			int ms14Length = ms14.Length();
			ProtocolParser.WriteUInt32_(stream, ms14Length);
			stream.Write(ms14.GetBuffer(), 0, ms14Length);
		}
		if (instance.Leave != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(122));
			CitoMemoryStream ms15 = new CitoMemoryStream();
			Packet_ClientLeaveSerializer.Serialize(ms15, instance.Leave);
			int ms15Length = ms15.Length();
			ProtocolParser.WriteUInt32_(stream, ms15Length);
			stream.Write(ms15.GetBuffer(), 0, ms15Length);
		}
		if (instance.Reload != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(130));
			stream.WriteByte(ProtoPlatform.IntToByte(1));
			CitoMemoryStream ms16 = new CitoMemoryStream();
			Packet_ClientReloadSerializer.Serialize(ms16, instance.Reload);
			int ms16Length = ms16.Length();
			ProtocolParser.WriteUInt32_(stream, ms16Length);
			stream.Write(ms16.GetBuffer(), 0, ms16Length);
		}
		if (instance.Oxygen != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(138));
			stream.WriteByte(ProtoPlatform.IntToByte(1));
			CitoMemoryStream ms17 = new CitoMemoryStream();
			Packet_ClientOxygenSerializer.Serialize(ms17, instance.Oxygen);
			int ms17Length = ms17.Length();
			ProtocolParser.WriteUInt32_(stream, ms17Length);
			stream.Write(ms17.GetBuffer(), 0, ms17Length);
		}
		if (instance.Death != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(146));
			stream.WriteByte(ProtoPlatform.IntToByte(1));
			CitoMemoryStream ms18 = new CitoMemoryStream();
			Packet_ClientDeathSerializer.Serialize(ms18, instance.Death);
			int ms18Length = ms18.Length();
			ProtocolParser.WriteUInt32_(stream, ms18Length);
			stream.Write(ms18.GetBuffer(), 0, ms18Length);
		}
		if (instance.Query != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(154));
			stream.WriteByte(ProtoPlatform.IntToByte(1));
			CitoMemoryStream ms19 = new CitoMemoryStream();
			Packet_ClientServerQuerySerializer.Serialize(ms19, instance.Query);
			int ms19Length = ms19.Length();
			ProtocolParser.WriteUInt32_(stream, ms19Length);
			stream.Write(ms19.GetBuffer(), 0, ms19Length);
		}
		if (instance.GameResolution != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(162));
			stream.WriteByte(ProtoPlatform.IntToByte(1));
			CitoMemoryStream ms20 = new CitoMemoryStream();
			Packet_ClientGameResolutionSerializer.Serialize(ms20, instance.GameResolution);
			int ms20Length = ms20.Length();
			ProtocolParser.WriteUInt32_(stream, ms20Length);
			stream.Write(ms20.GetBuffer(), 0, ms20Length);
		}
		if (instance.EntityInteraction != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(170));
			stream.WriteByte(ProtoPlatform.IntToByte(1));
			CitoMemoryStream ms21 = new CitoMemoryStream();
			Packet_ClientEntityInteractionSerializer.Serialize(ms21, instance.EntityInteraction);
			int ms21Length = ms21.Length();
			ProtocolParser.WriteUInt32_(stream, ms21Length);
			stream.Write(ms21.GetBuffer(), 0, ms21Length);
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_Client instance)
	{
		byte[] data = Packet_ClientSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_Client instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ClientSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ClientServerQuery
{
}

public class Packet_ClientServerQuerySerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientServerQuery Deserialize(CitoStream stream, Packet_ClientServerQuery instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ClientServerQuery DeserializeBuffer(byte[] buffer, int length, Packet_ClientServerQuery instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ClientServerQuerySerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientServerQuery DeserializeLength(CitoStream stream, int length, Packet_ClientServerQuery instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientServerQuery DeserializeLengthDelimited(CitoStream stream, Packet_ClientServerQuery instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ClientServerQuery DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ClientServerQuery instance = new Packet_ClientServerQuery();
		Packet_ClientServerQuerySerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ClientServerQuery instance)
	{
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ClientServerQuery instance)
	{
		byte[] data = Packet_ClientServerQuerySerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ClientServerQuery instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ClientServerQuerySerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ClientSetBlock
{
	internal int BlockType;

	public int GetBlockType()
	{
		return this.BlockType;
	}

	public int GetMaterialSlot()
	{
		return this.MaterialSlot;
	}

	public int GetMode()
	{
		return this.Mode;
	}

	public int GetX()
	{
		return this.X;
	}

	public int GetY()
	{
		return this.Y;
	}

	public int GetZ()
	{
		return this.Z;
	}
	/// <summary>&lt;summary&gt; obsolete&lt;/summary&gt;</summary>
	internal int MaterialSlot;
	internal int Mode;

	public void SetBlockType(int value)
	{
		this.BlockType = value;
	}

	public void SetMaterialSlot(int value)
	{
		this.MaterialSlot = value;
	}

	public void SetMode(int value)
	{
		this.Mode = value;
	}

	public void SetX(int value)
	{
		this.X = value;
	}

	public void SetY(int value)
	{
		this.Y = value;
	}

	public void SetZ(int value)
	{
		this.Z = value;
	}
	internal int X;
	internal int Y;
	internal int Z;
}

public class Packet_ClientSetBlockSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientSetBlock Deserialize(CitoStream stream, Packet_ClientSetBlock instance)
	{
		instance.Mode = 0;
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Mode = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.BlockType = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.MaterialSlot = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ClientSetBlock DeserializeBuffer(byte[] buffer, int length, Packet_ClientSetBlock instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ClientSetBlockSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientSetBlock DeserializeLength(CitoStream stream, int length, Packet_ClientSetBlock instance)
	{
		instance.Mode = 0;
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Mode = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.BlockType = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.MaterialSlot = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientSetBlock DeserializeLengthDelimited(CitoStream stream, Packet_ClientSetBlock instance)
	{
		instance.Mode = 0;
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Mode = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.BlockType = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.MaterialSlot = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ClientSetBlock DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ClientSetBlock instance = new Packet_ClientSetBlock();
		Packet_ClientSetBlockSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ClientSetBlock instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.X);
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.Y);
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteUInt64(stream, instance.Z);
		if (instance.Mode != 0) {
			stream.WriteByte(ProtoPlatform.IntToByte(32));
			ProtocolParser.WriteUInt64(stream, instance.Mode);
		}
		stream.WriteByte(ProtoPlatform.IntToByte(40));
		ProtocolParser.WriteUInt64(stream, instance.BlockType);
		stream.WriteByte(ProtoPlatform.IntToByte(48));
		ProtocolParser.WriteUInt64(stream, instance.MaterialSlot);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ClientSetBlock instance)
	{
		byte[] data = Packet_ClientSetBlockSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ClientSetBlock instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ClientSetBlockSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ClientShot
{
	internal int ExplodesAfter;
	internal int FromX;
	internal int FromY;
	internal int FromZ;

	public int GetExplodesAfter()
	{
		return this.ExplodesAfter;
	}

	public int GetFromX()
	{
		return this.FromX;
	}

	public int GetFromY()
	{
		return this.FromY;
	}

	public int GetFromZ()
	{
		return this.FromZ;
	}

	public int GetHitPlayer()
	{
		return this.HitPlayer;
	}

	public int GetIsHitHead()
	{
		return this.IsHitHead;
	}

	public int GetToX()
	{
		return this.ToX;
	}

	public int GetToY()
	{
		return this.ToY;
	}

	public int GetToZ()
	{
		return this.ToZ;
	}

	public int GetWeaponBlock()
	{
		return this.WeaponBlock;
	}
	internal int HitPlayer;
	internal int IsHitHead;

	public void SetExplodesAfter(int value)
	{
		this.ExplodesAfter = value;
	}

	public void SetFromX(int value)
	{
		this.FromX = value;
	}

	public void SetFromY(int value)
	{
		this.FromY = value;
	}

	public void SetFromZ(int value)
	{
		this.FromZ = value;
	}

	public void SetHitPlayer(int value)
	{
		this.HitPlayer = value;
	}

	public void SetIsHitHead(int value)
	{
		this.IsHitHead = value;
	}

	public void SetToX(int value)
	{
		this.ToX = value;
	}

	public void SetToY(int value)
	{
		this.ToY = value;
	}

	public void SetToZ(int value)
	{
		this.ToZ = value;
	}

	public void SetWeaponBlock(int value)
	{
		this.WeaponBlock = value;
	}
	internal int ToX;
	internal int ToY;
	internal int ToZ;
	internal int WeaponBlock;
}

public class Packet_ClientShotSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientShot Deserialize(CitoStream stream, Packet_ClientShot instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.FromX = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.FromY = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.FromZ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.ToX = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.ToY = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.ToZ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.WeaponBlock = ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.HitPlayer = ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.IsHitHead = ProtocolParser.ReadUInt64(stream);
				continue;
			case 80:
				instance.ExplodesAfter = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ClientShot DeserializeBuffer(byte[] buffer, int length, Packet_ClientShot instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ClientShotSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientShot DeserializeLength(CitoStream stream, int length, Packet_ClientShot instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.FromX = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.FromY = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.FromZ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.ToX = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.ToY = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.ToZ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.WeaponBlock = ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.HitPlayer = ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.IsHitHead = ProtocolParser.ReadUInt64(stream);
				continue;
			case 80:
				instance.ExplodesAfter = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientShot DeserializeLengthDelimited(CitoStream stream, Packet_ClientShot instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.FromX = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.FromY = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.FromZ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.ToX = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.ToY = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.ToZ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.WeaponBlock = ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.HitPlayer = ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.IsHitHead = ProtocolParser.ReadUInt64(stream);
				continue;
			case 80:
				instance.ExplodesAfter = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ClientShot DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ClientShot instance = new Packet_ClientShot();
		Packet_ClientShotSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ClientShot instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.FromX);
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.FromY);
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteUInt64(stream, instance.FromZ);
		stream.WriteByte(ProtoPlatform.IntToByte(32));
		ProtocolParser.WriteUInt64(stream, instance.ToX);
		stream.WriteByte(ProtoPlatform.IntToByte(40));
		ProtocolParser.WriteUInt64(stream, instance.ToY);
		stream.WriteByte(ProtoPlatform.IntToByte(48));
		ProtocolParser.WriteUInt64(stream, instance.ToZ);
		stream.WriteByte(ProtoPlatform.IntToByte(56));
		ProtocolParser.WriteUInt64(stream, instance.WeaponBlock);
		stream.WriteByte(ProtoPlatform.IntToByte(64));
		ProtocolParser.WriteUInt64(stream, instance.HitPlayer);
		stream.WriteByte(ProtoPlatform.IntToByte(72));
		ProtocolParser.WriteUInt64(stream, instance.IsHitHead);
		stream.WriteByte(ProtoPlatform.IntToByte(80));
		ProtocolParser.WriteUInt64(stream, instance.ExplodesAfter);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ClientShot instance)
	{
		byte[] data = Packet_ClientShotSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ClientShot instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ClientShotSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ClientSpecialKey
{

	public int GetKey_()
	{
		return this.Key_;
	}
	internal int Key_;

	public void SetKey_(int value)
	{
		this.Key_ = value;
	}
}

public class Packet_ClientSpecialKeySerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientSpecialKey Deserialize(CitoStream stream, Packet_ClientSpecialKey instance)
	{
		instance.Key_ = 0;
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.Key_ = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ClientSpecialKey DeserializeBuffer(byte[] buffer, int length, Packet_ClientSpecialKey instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ClientSpecialKeySerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientSpecialKey DeserializeLength(CitoStream stream, int length, Packet_ClientSpecialKey instance)
	{
		instance.Key_ = 0;
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Key_ = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ClientSpecialKey DeserializeLengthDelimited(CitoStream stream, Packet_ClientSpecialKey instance)
	{
		instance.Key_ = 0;
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Key_ = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ClientSpecialKey DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ClientSpecialKey instance = new Packet_ClientSpecialKey();
		Packet_ClientSpecialKeySerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ClientSpecialKey instance)
	{
		if (instance.Key_ != 0) {
			stream.WriteByte(ProtoPlatform.IntToByte(8));
			ProtocolParser.WriteUInt64(stream, instance.Key_);
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ClientSpecialKey instance)
	{
		byte[] data = Packet_ClientSpecialKeySerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ClientSpecialKey instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ClientSpecialKeySerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_CraftingRecipe
{

	public Packet_Ingredient[] GetIngredients()
	{
		return this.Ingredients;
	}

	public int GetIngredientsCount()
	{
		return this.IngredientsCount;
	}

	public int GetIngredientsLength()
	{
		return this.IngredientsLength;
	}

	public Packet_Ingredient GetOutput()
	{
		return this.Output;
	}
	internal Packet_Ingredient[] Ingredients;

	public void IngredientsAdd(Packet_Ingredient value)
	{
		if (this.IngredientsCount >= this.IngredientsLength) {
			Packet_Ingredient[] Ingredients2 = new Packet_Ingredient[this.IngredientsLength * 2];
			this.IngredientsLength = this.IngredientsLength * 2;
			for (int i = 0; i < this.IngredientsCount; i++) {
				Ingredients2[i] = this.Ingredients[i];
			}
			this.Ingredients = Ingredients2;
		}
		this.Ingredients[this.IngredientsCount] = value;
		this.IngredientsCount++;
	}
	internal int IngredientsCount;
	internal int IngredientsLength;
	internal Packet_Ingredient Output;

	public void SetIngredients(Packet_Ingredient[] value, int count, int length)
	{
		this.Ingredients = value;
		this.IngredientsCount = count;
		this.IngredientsLength = length;
	}

	public void SetOutput(Packet_Ingredient value)
	{
		this.Output = value;
	}
}

public class Packet_CraftingRecipeSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_CraftingRecipe Deserialize(CitoStream stream, Packet_CraftingRecipe instance)
	{
		if (instance.Ingredients == null) {
			instance.Ingredients = new Packet_Ingredient[1];
			instance.IngredientsCount = 0;
			instance.IngredientsLength = 1;
		}
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.IngredientsAdd(Packet_IngredientSerializer.DeserializeLengthDelimitedNew(stream));
				continue;
			case 18:
				if (instance.Output == null)
					instance.Output = Packet_IngredientSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_IngredientSerializer.DeserializeLengthDelimited(stream, instance.Output);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_CraftingRecipe DeserializeBuffer(byte[] buffer, int length, Packet_CraftingRecipe instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_CraftingRecipeSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_CraftingRecipe DeserializeLength(CitoStream stream, int length, Packet_CraftingRecipe instance)
	{
		if (instance.Ingredients == null) {
			instance.Ingredients = new Packet_Ingredient[1];
			instance.IngredientsCount = 0;
			instance.IngredientsLength = 1;
		}
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.IngredientsAdd(Packet_IngredientSerializer.DeserializeLengthDelimitedNew(stream));
				continue;
			case 18:
				if (instance.Output == null)
					instance.Output = Packet_IngredientSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_IngredientSerializer.DeserializeLengthDelimited(stream, instance.Output);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_CraftingRecipe DeserializeLengthDelimited(CitoStream stream, Packet_CraftingRecipe instance)
	{
		if (instance.Ingredients == null) {
			instance.Ingredients = new Packet_Ingredient[1];
			instance.IngredientsCount = 0;
			instance.IngredientsLength = 1;
		}
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.IngredientsAdd(Packet_IngredientSerializer.DeserializeLengthDelimitedNew(stream));
				continue;
			case 18:
				if (instance.Output == null)
					instance.Output = Packet_IngredientSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_IngredientSerializer.DeserializeLengthDelimited(stream, instance.Output);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_CraftingRecipe DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_CraftingRecipe instance = new Packet_CraftingRecipe();
		Packet_CraftingRecipeSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_CraftingRecipe instance)
	{
		if (instance.Ingredients != null) {
			for (int k = 0; k < instance.IngredientsCount; k++) {
				Packet_Ingredient i1 = instance.Ingredients[k];
				stream.WriteByte(ProtoPlatform.IntToByte(10));
				CitoMemoryStream ms1 = new CitoMemoryStream();
				Packet_IngredientSerializer.Serialize(ms1, i1);
				int ms1Length = ms1.Length();
				ProtocolParser.WriteUInt32_(stream, ms1Length);
				stream.Write(ms1.GetBuffer(), 0, ms1Length);
			}
		}
		if (instance.Output != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(18));
			CitoMemoryStream ms2 = new CitoMemoryStream();
			Packet_IngredientSerializer.Serialize(ms2, instance.Output);
			int ms2Length = ms2.Length();
			ProtocolParser.WriteUInt32_(stream, ms2Length);
			stream.Write(ms2.GetBuffer(), 0, ms2Length);
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_CraftingRecipe instance)
	{
		byte[] data = Packet_CraftingRecipeSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_CraftingRecipe instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_CraftingRecipeSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_DeathReasonEnum
{
	public const int BlockDamage = 1;
	public const int Drowning = 2;
	public const int Explosion = 3;
	public const int FallDamage = 0;
}

public class Packet_Dialog
{

	public int GetHeight_()
	{
		return this.Height_;
	}

	public int GetIsModal()
	{
		return this.IsModal;
	}

	public Packet_Widget[] GetWidgets()
	{
		return this.Widgets;
	}

	public int GetWidgetsCount()
	{
		return this.WidgetsCount;
	}

	public int GetWidgetsLength()
	{
		return this.WidgetsLength;
	}

	public int GetWidth()
	{
		return this.Width;
	}
	internal int Height_;
	internal int IsModal;

	public void SetHeight_(int value)
	{
		this.Height_ = value;
	}

	public void SetIsModal(int value)
	{
		this.IsModal = value;
	}

	public void SetWidgets(Packet_Widget[] value, int count, int length)
	{
		this.Widgets = value;
		this.WidgetsCount = count;
		this.WidgetsLength = length;
	}

	public void SetWidth(int value)
	{
		this.Width = value;
	}
	internal Packet_Widget[] Widgets;

	public void WidgetsAdd(Packet_Widget value)
	{
		if (this.WidgetsCount >= this.WidgetsLength) {
			Packet_Widget[] Widgets2 = new Packet_Widget[this.WidgetsLength * 2];
			this.WidgetsLength = this.WidgetsLength * 2;
			for (int i = 0; i < this.WidgetsCount; i++) {
				Widgets2[i] = this.Widgets[i];
			}
			this.Widgets = Widgets2;
		}
		this.Widgets[this.WidgetsCount] = value;
		this.WidgetsCount++;
	}
	internal int WidgetsCount;
	internal int WidgetsLength;
	internal int Width;
}

public class Packet_DialogFont
{
	internal string FamilyName;
	internal int FontStyle;

	public string GetFamilyName()
	{
		return this.FamilyName;
	}

	public int GetFontStyle()
	{
		return this.FontStyle;
	}

	public int GetSizeFloat()
	{
		return this.SizeFloat;
	}

	public void SetFamilyName(string value)
	{
		this.FamilyName = value;
	}

	public void SetFontStyle(int value)
	{
		this.FontStyle = value;
	}

	public void SetSizeFloat(int value)
	{
		this.SizeFloat = value;
	}
	internal int SizeFloat;
}

public class Packet_DialogFontSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_DialogFont Deserialize(CitoStream stream, Packet_DialogFont instance)
	{
		instance.FontStyle = 0;
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.FamilyName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.SizeFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.FontStyle = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_DialogFont DeserializeBuffer(byte[] buffer, int length, Packet_DialogFont instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_DialogFontSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_DialogFont DeserializeLength(CitoStream stream, int length, Packet_DialogFont instance)
	{
		instance.FontStyle = 0;
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.FamilyName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.SizeFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.FontStyle = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_DialogFont DeserializeLengthDelimited(CitoStream stream, Packet_DialogFont instance)
	{
		instance.FontStyle = 0;
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.FamilyName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.SizeFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.FontStyle = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_DialogFont DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_DialogFont instance = new Packet_DialogFont();
		Packet_DialogFontSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_DialogFont instance)
	{
		if (instance.FamilyName != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(10));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.FamilyName));
		}
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.SizeFloat);
		if (instance.FontStyle != 0) {
			stream.WriteByte(ProtoPlatform.IntToByte(24));
			ProtocolParser.WriteUInt64(stream, instance.FontStyle);
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_DialogFont instance)
	{
		byte[] data = Packet_DialogFontSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_DialogFont instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_DialogFontSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_DialogFontStyleEnum
{
	public const int Bold = 1;
	public const int Italic = 2;
	public const int Regular = 0;
	public const int Strikeout = 8;
	public const int Underline = 4;
}

public class Packet_DialogSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_Dialog Deserialize(CitoStream stream, Packet_Dialog instance)
	{
		if (instance.Widgets == null) {
			instance.Widgets = new Packet_Widget[1];
			instance.WidgetsCount = 0;
			instance.WidgetsLength = 1;
		}
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.WidgetsAdd(Packet_WidgetSerializer.DeserializeLengthDelimitedNew(stream));
				continue;
			case 16:
				instance.Width = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Height_ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.IsModal = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_Dialog DeserializeBuffer(byte[] buffer, int length, Packet_Dialog instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_DialogSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_Dialog DeserializeLength(CitoStream stream, int length, Packet_Dialog instance)
	{
		if (instance.Widgets == null) {
			instance.Widgets = new Packet_Widget[1];
			instance.WidgetsCount = 0;
			instance.WidgetsLength = 1;
		}
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.WidgetsAdd(Packet_WidgetSerializer.DeserializeLengthDelimitedNew(stream));
				continue;
			case 16:
				instance.Width = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Height_ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.IsModal = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_Dialog DeserializeLengthDelimited(CitoStream stream, Packet_Dialog instance)
	{
		if (instance.Widgets == null) {
			instance.Widgets = new Packet_Widget[1];
			instance.WidgetsCount = 0;
			instance.WidgetsLength = 1;
		}
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.WidgetsAdd(Packet_WidgetSerializer.DeserializeLengthDelimitedNew(stream));
				continue;
			case 16:
				instance.Width = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Height_ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.IsModal = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_Dialog DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_Dialog instance = new Packet_Dialog();
		Packet_DialogSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_Dialog instance)
	{
		if (instance.Widgets != null) {
			for (int k = 0; k < instance.WidgetsCount; k++) {
				Packet_Widget i1 = instance.Widgets[k];
				stream.WriteByte(ProtoPlatform.IntToByte(10));
				CitoMemoryStream ms1 = new CitoMemoryStream();
				Packet_WidgetSerializer.Serialize(ms1, i1);
				int ms1Length = ms1.Length();
				ProtocolParser.WriteUInt32_(stream, ms1Length);
				stream.Write(ms1.GetBuffer(), 0, ms1Length);
			}
		}
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.Width);
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteUInt64(stream, instance.Height_);
		stream.WriteByte(ProtoPlatform.IntToByte(32));
		ProtocolParser.WriteUInt64(stream, instance.IsModal);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_Dialog instance)
	{
		byte[] data = Packet_DialogSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_Dialog instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_DialogSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_DrawTypeEnum
{
	public const int Cactus = 13;
	public const int ClosedDoor = 8;
	public const int Empty = 0;
	public const int Fence = 10;
	public const int Flat = 12;
	public const int Fluid = 3;
	public const int HalfHeight = 11;
	public const int Ladder = 9;
	public const int OpenDoorLeft = 6;
	public const int OpenDoorRight = 7;
	public const int Plant = 5;
	public const int Solid = 1;
	public const int Torch = 4;
	public const int Transparent = 2;
}

public class Packet_EntityInteractionTypeEnum
{
	public const int Hit = 1;
	public const int Use = 0;
}

public class Packet_Ingredient
{
	internal int Amount;

	public int GetAmount()
	{
		return this.Amount;
	}

	public int GetType()
	{
		return this.Type;
	}

	public void SetAmount(int value)
	{
		this.Amount = value;
	}

	public void SetType(int value)
	{
		this.Type = value;
	}
	internal int Type;
}

public class Packet_IngredientSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_Ingredient Deserialize(CitoStream stream, Packet_Ingredient instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.Type = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Amount = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_Ingredient DeserializeBuffer(byte[] buffer, int length, Packet_Ingredient instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_IngredientSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_Ingredient DeserializeLength(CitoStream stream, int length, Packet_Ingredient instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Type = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Amount = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_Ingredient DeserializeLengthDelimited(CitoStream stream, Packet_Ingredient instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Type = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Amount = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_Ingredient DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_Ingredient instance = new Packet_Ingredient();
		Packet_IngredientSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_Ingredient instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.Type);
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.Amount);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_Ingredient instance)
	{
		byte[] data = Packet_IngredientSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_Ingredient instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_IngredientSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_IntInt
{

	public int GetKey_()
	{
		return this.Key_;
	}

	public int GetValue_()
	{
		return this.Value_;
	}
	internal int Key_;

	public void SetKey_(int value)
	{
		this.Key_ = value;
	}

	public void SetValue_(int value)
	{
		this.Value_ = value;
	}
	internal int Value_;
}

public class Packet_IntIntSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_IntInt Deserialize(CitoStream stream, Packet_IntInt instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.Key_ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Value_ = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_IntInt DeserializeBuffer(byte[] buffer, int length, Packet_IntInt instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_IntIntSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_IntInt DeserializeLength(CitoStream stream, int length, Packet_IntInt instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Key_ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Value_ = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_IntInt DeserializeLengthDelimited(CitoStream stream, Packet_IntInt instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Key_ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Value_ = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_IntInt DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_IntInt instance = new Packet_IntInt();
		Packet_IntIntSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_IntInt instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.Key_);
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.Value_);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_IntInt instance)
	{
		byte[] data = Packet_IntIntSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_IntInt instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_IntIntSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_IntString
{

	public int GetKey_()
	{
		return this.Key_;
	}

	public string GetValue_()
	{
		return this.Value_;
	}
	internal int Key_;

	public void SetKey_(int value)
	{
		this.Key_ = value;
	}

	public void SetValue_(string value)
	{
		this.Value_ = value;
	}
	internal string Value_;
}

public class Packet_IntStringSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_IntString Deserialize(CitoStream stream, Packet_IntString instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.Key_ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.Value_ = ProtocolParser.ReadString(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_IntString DeserializeBuffer(byte[] buffer, int length, Packet_IntString instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_IntStringSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_IntString DeserializeLength(CitoStream stream, int length, Packet_IntString instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Key_ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.Value_ = ProtocolParser.ReadString(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_IntString DeserializeLengthDelimited(CitoStream stream, Packet_IntString instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Key_ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.Value_ = ProtocolParser.ReadString(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_IntString DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_IntString instance = new Packet_IntString();
		Packet_IntStringSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_IntString instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.Key_);
		if (instance.Value_ != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(18));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.Value_));
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_IntString instance)
	{
		byte[] data = Packet_IntStringSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_IntString instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_IntStringSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_Inventory
{
	internal Packet_Item Boots;
	internal Packet_Item DragDropItem;
	internal Packet_Item Gauntlet;

	public Packet_Item GetBoots()
	{
		return this.Boots;
	}

	public Packet_Item GetDragDropItem()
	{
		return this.DragDropItem;
	}

	public Packet_Item GetGauntlet()
	{
		return this.Gauntlet;
	}

	public Packet_Item GetHelmet()
	{
		return this.Helmet;
	}

	public Packet_PositionItem[] GetItems()
	{
		return this.Items;
	}

	public int GetItemsCount()
	{
		return this.ItemsCount;
	}

	public int GetItemsLength()
	{
		return this.ItemsLength;
	}

	public Packet_Item GetMainArmor()
	{
		return this.MainArmor;
	}

	public Packet_Item[] GetRightHand()
	{
		return this.RightHand;
	}

	public int GetRightHandCount()
	{
		return this.RightHandCount;
	}

	public int GetRightHandLength()
	{
		return this.RightHandLength;
	}
	internal Packet_Item Helmet;
	internal Packet_PositionItem[] Items;

	public void ItemsAdd(Packet_PositionItem value)
	{
		if (this.ItemsCount >= this.ItemsLength) {
			Packet_PositionItem[] Items2 = new Packet_PositionItem[this.ItemsLength * 2];
			this.ItemsLength = this.ItemsLength * 2;
			for (int i = 0; i < this.ItemsCount; i++) {
				Items2[i] = this.Items[i];
			}
			this.Items = Items2;
		}
		this.Items[this.ItemsCount] = value;
		this.ItemsCount++;
	}
	internal int ItemsCount;
	internal int ItemsLength;
	internal Packet_Item MainArmor;
	internal Packet_Item[] RightHand;

	public void RightHandAdd(Packet_Item value)
	{
		if (this.RightHandCount >= this.RightHandLength) {
			Packet_Item[] RightHand2 = new Packet_Item[this.RightHandLength * 2];
			this.RightHandLength = this.RightHandLength * 2;
			for (int i = 0; i < this.RightHandCount; i++) {
				RightHand2[i] = this.RightHand[i];
			}
			this.RightHand = RightHand2;
		}
		this.RightHand[this.RightHandCount] = value;
		this.RightHandCount++;
	}
	internal int RightHandCount;
	internal int RightHandLength;

	public void SetBoots(Packet_Item value)
	{
		this.Boots = value;
	}

	public void SetDragDropItem(Packet_Item value)
	{
		this.DragDropItem = value;
	}

	public void SetGauntlet(Packet_Item value)
	{
		this.Gauntlet = value;
	}

	public void SetHelmet(Packet_Item value)
	{
		this.Helmet = value;
	}

	public void SetItems(Packet_PositionItem[] value, int count, int length)
	{
		this.Items = value;
		this.ItemsCount = count;
		this.ItemsLength = length;
	}

	public void SetMainArmor(Packet_Item value)
	{
		this.MainArmor = value;
	}

	public void SetRightHand(Packet_Item[] value, int count, int length)
	{
		this.RightHand = value;
		this.RightHandCount = count;
		this.RightHandLength = length;
	}
}

public class Packet_InventoryActionTypeEnum
{
	public const int Click = 0;
	public const int MoveToInventory = 2;
	public const int WearItem = 1;
}

public class Packet_InventoryPosition
{
	internal int ActiveMaterial;
	internal int AreaX;
	internal int AreaY;

	public int GetActiveMaterial()
	{
		return this.ActiveMaterial;
	}

	public int GetAreaX()
	{
		return this.AreaX;
	}

	public int GetAreaY()
	{
		return this.AreaY;
	}

	public int GetGroundPositionX()
	{
		return this.GroundPositionX;
	}

	public int GetGroundPositionY()
	{
		return this.GroundPositionY;
	}

	public int GetGroundPositionZ()
	{
		return this.GroundPositionZ;
	}

	public int GetMaterialId()
	{
		return this.MaterialId;
	}

	public int GetType()
	{
		return this.Type;
	}

	public int GetWearPlace()
	{
		return this.WearPlace;
	}
	internal int GroundPositionX;
	internal int GroundPositionY;
	internal int GroundPositionZ;
	internal int MaterialId;

	public void SetActiveMaterial(int value)
	{
		this.ActiveMaterial = value;
	}

	public void SetAreaX(int value)
	{
		this.AreaX = value;
	}

	public void SetAreaY(int value)
	{
		this.AreaY = value;
	}

	public void SetGroundPositionX(int value)
	{
		this.GroundPositionX = value;
	}

	public void SetGroundPositionY(int value)
	{
		this.GroundPositionY = value;
	}

	public void SetGroundPositionZ(int value)
	{
		this.GroundPositionZ = value;
	}

	public void SetMaterialId(int value)
	{
		this.MaterialId = value;
	}

	public void SetType(int value)
	{
		this.Type = value;
	}

	public void SetWearPlace(int value)
	{
		this.WearPlace = value;
	}
	internal int Type;
	/// <summary>&lt;summary&gt;WearPlace&lt;/summary&gt;</summary>
	internal int WearPlace;
}

public class Packet_InventoryPositionSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_InventoryPosition Deserialize(CitoStream stream, Packet_InventoryPosition instance)
	{
		instance.Type = 0;
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.Type = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.AreaX = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.AreaY = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.MaterialId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.WearPlace = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.ActiveMaterial = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.GroundPositionX = ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.GroundPositionY = ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.GroundPositionZ = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_InventoryPosition DeserializeBuffer(byte[] buffer, int length, Packet_InventoryPosition instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_InventoryPositionSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_InventoryPosition DeserializeLength(CitoStream stream, int length, Packet_InventoryPosition instance)
	{
		instance.Type = 0;
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Type = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.AreaX = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.AreaY = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.MaterialId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.WearPlace = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.ActiveMaterial = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.GroundPositionX = ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.GroundPositionY = ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.GroundPositionZ = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_InventoryPosition DeserializeLengthDelimited(CitoStream stream, Packet_InventoryPosition instance)
	{
		instance.Type = 0;
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Type = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.AreaX = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.AreaY = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.MaterialId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.WearPlace = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.ActiveMaterial = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.GroundPositionX = ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.GroundPositionY = ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.GroundPositionZ = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_InventoryPosition DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_InventoryPosition instance = new Packet_InventoryPosition();
		Packet_InventoryPositionSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_InventoryPosition instance)
	{
		if (instance.Type != 0) {
			stream.WriteByte(ProtoPlatform.IntToByte(8));
			ProtocolParser.WriteUInt64(stream, instance.Type);
		}
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.AreaX);
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteUInt64(stream, instance.AreaY);
		stream.WriteByte(ProtoPlatform.IntToByte(32));
		ProtocolParser.WriteUInt64(stream, instance.MaterialId);
		stream.WriteByte(ProtoPlatform.IntToByte(40));
		ProtocolParser.WriteUInt64(stream, instance.WearPlace);
		stream.WriteByte(ProtoPlatform.IntToByte(48));
		ProtocolParser.WriteUInt64(stream, instance.ActiveMaterial);
		stream.WriteByte(ProtoPlatform.IntToByte(56));
		ProtocolParser.WriteUInt64(stream, instance.GroundPositionX);
		stream.WriteByte(ProtoPlatform.IntToByte(64));
		ProtocolParser.WriteUInt64(stream, instance.GroundPositionY);
		stream.WriteByte(ProtoPlatform.IntToByte(72));
		ProtocolParser.WriteUInt64(stream, instance.GroundPositionZ);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_InventoryPosition instance)
	{
		byte[] data = Packet_InventoryPositionSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_InventoryPosition instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_InventoryPositionSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_InventoryPositionTypeEnum
{
	public const int Ground = 1;
	public const int MainArea = 0;
	public const int MaterialSelector = 2;
	public const int WearPlace = 3;
}

public class Packet_InventorySerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_Inventory Deserialize(CitoStream stream, Packet_Inventory instance)
	{
		if (instance.Items == null) {
			instance.Items = new Packet_PositionItem[1];
			instance.ItemsCount = 0;
			instance.ItemsLength = 1;
		}
		if (instance.RightHand == null) {
			instance.RightHand = new Packet_Item[1];
			instance.RightHandCount = 0;
			instance.RightHandLength = 1;
		}
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 26:
				if (instance.MainArmor == null)
					instance.MainArmor = Packet_ItemSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ItemSerializer.DeserializeLengthDelimited(stream, instance.MainArmor);
				continue;
			case 34:
				if (instance.Boots == null)
					instance.Boots = Packet_ItemSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ItemSerializer.DeserializeLengthDelimited(stream, instance.Boots);
				continue;
			case 42:
				if (instance.Helmet == null)
					instance.Helmet = Packet_ItemSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ItemSerializer.DeserializeLengthDelimited(stream, instance.Helmet);
				continue;
			case 50:
				if (instance.Gauntlet == null)
					instance.Gauntlet = Packet_ItemSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ItemSerializer.DeserializeLengthDelimited(stream, instance.Gauntlet);
				continue;
			case 58:
				instance.ItemsAdd(Packet_PositionItemSerializer.DeserializeLengthDelimitedNew(stream));
				continue;
			case 66:
				if (instance.DragDropItem == null)
					instance.DragDropItem = Packet_ItemSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ItemSerializer.DeserializeLengthDelimited(stream, instance.DragDropItem);
				continue;
			case 74:
				instance.RightHandAdd(Packet_ItemSerializer.DeserializeLengthDelimitedNew(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_Inventory DeserializeBuffer(byte[] buffer, int length, Packet_Inventory instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_InventorySerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_Inventory DeserializeLength(CitoStream stream, int length, Packet_Inventory instance)
	{
		if (instance.Items == null) {
			instance.Items = new Packet_PositionItem[1];
			instance.ItemsCount = 0;
			instance.ItemsLength = 1;
		}
		if (instance.RightHand == null) {
			instance.RightHand = new Packet_Item[1];
			instance.RightHandCount = 0;
			instance.RightHandLength = 1;
		}
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 26:
				if (instance.MainArmor == null)
					instance.MainArmor = Packet_ItemSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ItemSerializer.DeserializeLengthDelimited(stream, instance.MainArmor);
				continue;
			case 34:
				if (instance.Boots == null)
					instance.Boots = Packet_ItemSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ItemSerializer.DeserializeLengthDelimited(stream, instance.Boots);
				continue;
			case 42:
				if (instance.Helmet == null)
					instance.Helmet = Packet_ItemSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ItemSerializer.DeserializeLengthDelimited(stream, instance.Helmet);
				continue;
			case 50:
				if (instance.Gauntlet == null)
					instance.Gauntlet = Packet_ItemSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ItemSerializer.DeserializeLengthDelimited(stream, instance.Gauntlet);
				continue;
			case 58:
				instance.ItemsAdd(Packet_PositionItemSerializer.DeserializeLengthDelimitedNew(stream));
				continue;
			case 66:
				if (instance.DragDropItem == null)
					instance.DragDropItem = Packet_ItemSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ItemSerializer.DeserializeLengthDelimited(stream, instance.DragDropItem);
				continue;
			case 74:
				instance.RightHandAdd(Packet_ItemSerializer.DeserializeLengthDelimitedNew(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_Inventory DeserializeLengthDelimited(CitoStream stream, Packet_Inventory instance)
	{
		if (instance.Items == null) {
			instance.Items = new Packet_PositionItem[1];
			instance.ItemsCount = 0;
			instance.ItemsLength = 1;
		}
		if (instance.RightHand == null) {
			instance.RightHand = new Packet_Item[1];
			instance.RightHandCount = 0;
			instance.RightHandLength = 1;
		}
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 26:
				if (instance.MainArmor == null)
					instance.MainArmor = Packet_ItemSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ItemSerializer.DeserializeLengthDelimited(stream, instance.MainArmor);
				continue;
			case 34:
				if (instance.Boots == null)
					instance.Boots = Packet_ItemSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ItemSerializer.DeserializeLengthDelimited(stream, instance.Boots);
				continue;
			case 42:
				if (instance.Helmet == null)
					instance.Helmet = Packet_ItemSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ItemSerializer.DeserializeLengthDelimited(stream, instance.Helmet);
				continue;
			case 50:
				if (instance.Gauntlet == null)
					instance.Gauntlet = Packet_ItemSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ItemSerializer.DeserializeLengthDelimited(stream, instance.Gauntlet);
				continue;
			case 58:
				instance.ItemsAdd(Packet_PositionItemSerializer.DeserializeLengthDelimitedNew(stream));
				continue;
			case 66:
				if (instance.DragDropItem == null)
					instance.DragDropItem = Packet_ItemSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ItemSerializer.DeserializeLengthDelimited(stream, instance.DragDropItem);
				continue;
			case 74:
				instance.RightHandAdd(Packet_ItemSerializer.DeserializeLengthDelimitedNew(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_Inventory DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_Inventory instance = new Packet_Inventory();
		Packet_InventorySerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_Inventory instance)
	{
		if (instance.MainArmor != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(26));
			CitoMemoryStream ms3 = new CitoMemoryStream();
			Packet_ItemSerializer.Serialize(ms3, instance.MainArmor);
			int ms3Length = ms3.Length();
			ProtocolParser.WriteUInt32_(stream, ms3Length);
			stream.Write(ms3.GetBuffer(), 0, ms3Length);
		}
		if (instance.Boots != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(34));
			CitoMemoryStream ms4 = new CitoMemoryStream();
			Packet_ItemSerializer.Serialize(ms4, instance.Boots);
			int ms4Length = ms4.Length();
			ProtocolParser.WriteUInt32_(stream, ms4Length);
			stream.Write(ms4.GetBuffer(), 0, ms4Length);
		}
		if (instance.Helmet != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(42));
			CitoMemoryStream ms5 = new CitoMemoryStream();
			Packet_ItemSerializer.Serialize(ms5, instance.Helmet);
			int ms5Length = ms5.Length();
			ProtocolParser.WriteUInt32_(stream, ms5Length);
			stream.Write(ms5.GetBuffer(), 0, ms5Length);
		}
		if (instance.Gauntlet != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(50));
			CitoMemoryStream ms6 = new CitoMemoryStream();
			Packet_ItemSerializer.Serialize(ms6, instance.Gauntlet);
			int ms6Length = ms6.Length();
			ProtocolParser.WriteUInt32_(stream, ms6Length);
			stream.Write(ms6.GetBuffer(), 0, ms6Length);
		}
		if (instance.Items != null) {
			for (int k = 0; k < instance.ItemsCount; k++) {
				Packet_PositionItem i7 = instance.Items[k];
				stream.WriteByte(ProtoPlatform.IntToByte(58));
				CitoMemoryStream ms7 = new CitoMemoryStream();
				Packet_PositionItemSerializer.Serialize(ms7, i7);
				int ms7Length = ms7.Length();
				ProtocolParser.WriteUInt32_(stream, ms7Length);
				stream.Write(ms7.GetBuffer(), 0, ms7Length);
			}
		}
		if (instance.DragDropItem != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(66));
			CitoMemoryStream ms8 = new CitoMemoryStream();
			Packet_ItemSerializer.Serialize(ms8, instance.DragDropItem);
			int ms8Length = ms8.Length();
			ProtocolParser.WriteUInt32_(stream, ms8Length);
			stream.Write(ms8.GetBuffer(), 0, ms8Length);
		}
		if (instance.RightHand != null) {
			for (int k = 0; k < instance.RightHandCount; k++) {
				Packet_Item i9 = instance.RightHand[k];
				stream.WriteByte(ProtoPlatform.IntToByte(74));
				CitoMemoryStream ms9 = new CitoMemoryStream();
				Packet_ItemSerializer.Serialize(ms9, i9);
				int ms9Length = ms9.Length();
				ProtocolParser.WriteUInt32_(stream, ms9Length);
				stream.Write(ms9.GetBuffer(), 0, ms9Length);
			}
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_Inventory instance)
	{
		byte[] data = Packet_InventorySerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_Inventory instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_InventorySerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_Item
{
	internal int BlockCount;
	internal int BlockId;

	public int GetBlockCount()
	{
		return this.BlockCount;
	}

	public int GetBlockId()
	{
		return this.BlockId;
	}

	public int GetItemClass()
	{
		return this.ItemClass;
	}

	public string GetItemId()
	{
		return this.ItemId;
	}
	internal int ItemClass;
	internal string ItemId;

	public void SetBlockCount(int value)
	{
		this.BlockCount = value;
	}

	public void SetBlockId(int value)
	{
		this.BlockId = value;
	}

	public void SetItemClass(int value)
	{
		this.ItemClass = value;
	}

	public void SetItemId(string value)
	{
		this.ItemId = value;
	}
}

public class Packet_ItemClassEnum
{
	public const int Block = 0;
	public const int Boots = 3;
	public const int Gauntlet = 5;
	public const int Helmet = 4;
	public const int MainArmor = 2;
	public const int Other = 7;
	public const int Shield = 6;
	public const int Weapon = 1;
}

public class Packet_ItemSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_Item Deserialize(CitoStream stream, Packet_Item instance)
	{
		instance.ItemClass = 0;
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.ItemClass = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.ItemId = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.BlockId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.BlockCount = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_Item DeserializeBuffer(byte[] buffer, int length, Packet_Item instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ItemSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_Item DeserializeLength(CitoStream stream, int length, Packet_Item instance)
	{
		instance.ItemClass = 0;
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.ItemClass = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.ItemId = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.BlockId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.BlockCount = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_Item DeserializeLengthDelimited(CitoStream stream, Packet_Item instance)
	{
		instance.ItemClass = 0;
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.ItemClass = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.ItemId = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.BlockId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.BlockCount = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_Item DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_Item instance = new Packet_Item();
		Packet_ItemSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_Item instance)
	{
		if (instance.ItemClass != 0) {
			stream.WriteByte(ProtoPlatform.IntToByte(8));
			ProtocolParser.WriteUInt64(stream, instance.ItemClass);
		}
		if (instance.ItemId != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(18));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.ItemId));
		}
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteUInt64(stream, instance.BlockId);
		stream.WriteByte(ProtoPlatform.IntToByte(32));
		ProtocolParser.WriteUInt64(stream, instance.BlockCount);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_Item instance)
	{
		byte[] data = Packet_ItemSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_Item instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ItemSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_LeaveReasonEnum
{
	public const int Crash = 1;
	public const int Leave = 0;
}

public class Packet_PistolTypeEnum
{
	public const int Grenade = 1;
	public const int Normal = 0;
}

public class Packet_PositionAndOrientation
{

	public int GetHeading()
	{
		return this.Heading;
	}

	public int GetPitch()
	{
		return this.Pitch;
	}

	public int GetStance()
	{
		return this.Stance;
	}

	public int GetX()
	{
		return this.X;
	}

	public int GetY()
	{
		return this.Y;
	}

	public int GetZ()
	{
		return this.Z;
	}
	internal int Heading;
	internal int Pitch;

	public void SetHeading(int value)
	{
		this.Heading = value;
	}

	public void SetPitch(int value)
	{
		this.Pitch = value;
	}

	public void SetStance(int value)
	{
		this.Stance = value;
	}

	public void SetX(int value)
	{
		this.X = value;
	}

	public void SetY(int value)
	{
		this.Y = value;
	}

	public void SetZ(int value)
	{
		this.Z = value;
	}
	internal int Stance;
	internal int X;
	internal int Y;
	internal int Z;
}

public class Packet_PositionAndOrientationSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_PositionAndOrientation Deserialize(CitoStream stream, Packet_PositionAndOrientation instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Heading = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.Pitch = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.Stance = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_PositionAndOrientation DeserializeBuffer(byte[] buffer, int length, Packet_PositionAndOrientation instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_PositionAndOrientationSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_PositionAndOrientation DeserializeLength(CitoStream stream, int length, Packet_PositionAndOrientation instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Heading = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.Pitch = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.Stance = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_PositionAndOrientation DeserializeLengthDelimited(CitoStream stream, Packet_PositionAndOrientation instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Heading = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.Pitch = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.Stance = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_PositionAndOrientation DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_PositionAndOrientation instance = new Packet_PositionAndOrientation();
		Packet_PositionAndOrientationSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_PositionAndOrientation instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.X);
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.Y);
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteUInt64(stream, instance.Z);
		stream.WriteByte(ProtoPlatform.IntToByte(32));
		ProtocolParser.WriteUInt64(stream, instance.Heading);
		stream.WriteByte(ProtoPlatform.IntToByte(40));
		ProtocolParser.WriteUInt64(stream, instance.Pitch);
		stream.WriteByte(ProtoPlatform.IntToByte(48));
		ProtocolParser.WriteUInt64(stream, instance.Stance);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_PositionAndOrientation instance)
	{
		byte[] data = Packet_PositionAndOrientationSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_PositionAndOrientation instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_PositionAndOrientationSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_PositionItem
{

	public string GetKey_()
	{
		return this.Key_;
	}

	public Packet_Item GetValue_()
	{
		return this.Value_;
	}

	public int GetX()
	{
		return this.X;
	}

	public int GetY()
	{
		return this.Y;
	}
	internal string Key_;

	public void SetKey_(string value)
	{
		this.Key_ = value;
	}

	public void SetValue_(Packet_Item value)
	{
		this.Value_ = value;
	}

	public void SetX(int value)
	{
		this.X = value;
	}

	public void SetY(int value)
	{
		this.Y = value;
	}
	internal Packet_Item Value_;
	internal int X;
	internal int Y;
}

public class Packet_PositionItemSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_PositionItem Deserialize(CitoStream stream, Packet_PositionItem instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.Key_ = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				if (instance.Value_ == null)
					instance.Value_ = Packet_ItemSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ItemSerializer.DeserializeLengthDelimited(stream, instance.Value_);
				continue;
			case 24:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_PositionItem DeserializeBuffer(byte[] buffer, int length, Packet_PositionItem instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_PositionItemSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_PositionItem DeserializeLength(CitoStream stream, int length, Packet_PositionItem instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.Key_ = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				if (instance.Value_ == null)
					instance.Value_ = Packet_ItemSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ItemSerializer.DeserializeLengthDelimited(stream, instance.Value_);
				continue;
			case 24:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_PositionItem DeserializeLengthDelimited(CitoStream stream, Packet_PositionItem instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.Key_ = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				if (instance.Value_ == null)
					instance.Value_ = Packet_ItemSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ItemSerializer.DeserializeLengthDelimited(stream, instance.Value_);
				continue;
			case 24:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_PositionItem DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_PositionItem instance = new Packet_PositionItem();
		Packet_PositionItemSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_PositionItem instance)
	{
		if (instance.Key_ != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(10));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.Key_));
		}
		if (instance.Value_ != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(18));
			CitoMemoryStream ms2 = new CitoMemoryStream();
			Packet_ItemSerializer.Serialize(ms2, instance.Value_);
			int ms2Length = ms2.Length();
			ProtocolParser.WriteUInt32_(stream, ms2Length);
			stream.Write(ms2.GetBuffer(), 0, ms2Length);
		}
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteUInt64(stream, instance.X);
		stream.WriteByte(ProtoPlatform.IntToByte(32));
		ProtocolParser.WriteUInt64(stream, instance.Y);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_PositionItem instance)
	{
		byte[] data = Packet_PositionItemSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_PositionItem instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_PositionItemSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_Server
{
	internal Packet_ServerAmmo Ammo;
	internal Packet_ServerBlobFinalize BlobFinalize;
	internal Packet_ServerBlobInitialize BlobInitialize;
	internal Packet_ServerBlobPart BlobPart;
	internal Packet_ServerBlockType BlockType;
	internal Packet_ServerBlockTypes BlockTypes;
	internal Packet_ServerBullet Bullet;
	internal Packet_ServerChunkPart ChunkPart;
	internal Packet_ServerChunk Chunk_;
	internal Packet_ServerCraftingRecipes CraftingRecipes;
	internal Packet_ServerDialog Dialog;
	internal Packet_ServerDisconnectPlayer DisconnectPlayer;
	internal Packet_ServerEntityDespawn EntityDespawn;
	internal Packet_ServerEntityPositionAndOrientation EntityPosition;
	internal Packet_ServerEntitySpawn EntitySpawn;
	internal Packet_ServerExplosion Explosion;
	internal Packet_ServerFillArea FillArea;
	internal Packet_ServerFillAreaLimit FillAreaLimit;
	internal Packet_ServerFollow Follow;
	internal Packet_ServerFreemove Freemove;

	public Packet_ServerAmmo GetAmmo()
	{
		return this.Ammo;
	}

	public Packet_ServerBlobFinalize GetBlobFinalize()
	{
		return this.BlobFinalize;
	}

	public Packet_ServerBlobInitialize GetBlobInitialize()
	{
		return this.BlobInitialize;
	}

	public Packet_ServerBlobPart GetBlobPart()
	{
		return this.BlobPart;
	}

	public Packet_ServerBlockType GetBlockType()
	{
		return this.BlockType;
	}

	public Packet_ServerBlockTypes GetBlockTypes()
	{
		return this.BlockTypes;
	}

	public Packet_ServerBullet GetBullet()
	{
		return this.Bullet;
	}

	public Packet_ServerChunkPart GetChunkPart()
	{
		return this.ChunkPart;
	}

	public Packet_ServerChunk GetChunk_()
	{
		return this.Chunk_;
	}

	public Packet_ServerCraftingRecipes GetCraftingRecipes()
	{
		return this.CraftingRecipes;
	}

	public Packet_ServerDialog GetDialog()
	{
		return this.Dialog;
	}

	public Packet_ServerDisconnectPlayer GetDisconnectPlayer()
	{
		return this.DisconnectPlayer;
	}

	public Packet_ServerEntityDespawn GetEntityDespawn()
	{
		return this.EntityDespawn;
	}

	public Packet_ServerEntityPositionAndOrientation GetEntityPosition()
	{
		return this.EntityPosition;
	}

	public Packet_ServerEntitySpawn GetEntitySpawn()
	{
		return this.EntitySpawn;
	}

	public Packet_ServerExplosion GetExplosion()
	{
		return this.Explosion;
	}

	public Packet_ServerFillArea GetFillArea()
	{
		return this.FillArea;
	}

	public Packet_ServerFillAreaLimit GetFillAreaLimit()
	{
		return this.FillAreaLimit;
	}

	public Packet_ServerFollow GetFollow()
	{
		return this.Follow;
	}

	public Packet_ServerFreemove GetFreemove()
	{
		return this.Freemove;
	}

	public Packet_ServerHeightmapChunk GetHeightmapChunk()
	{
		return this.HeightmapChunk;
	}

	public int GetId()
	{
		return this.Id;
	}

	public Packet_ServerIdentification GetIdentification()
	{
		return this.Identification;
	}

	public Packet_ServerInventory GetInventory()
	{
		return this.Inventory;
	}

	public Packet_ServerLevelProgress GetLevelDataChunk()
	{
		return this.LevelDataChunk;
	}

	public Packet_ServerLevelFinalize GetLevelFinalize()
	{
		return this.LevelFinalize;
	}

	public Packet_ServerLevelInitialize GetLevelInitialize()
	{
		return this.LevelInitialize;
	}

	public Packet_ServerLightLevels GetLightLevels()
	{
		return this.LightLevels;
	}

	public Packet_ServerMessage GetMessage()
	{
		return this.Message;
	}

	public Packet_ServerMonsters GetMonster()
	{
		return this.Monster;
	}

	public Packet_ServerPing GetPing()
	{
		return this.Ping;
	}

	public Packet_ServerPlayerPing GetPlayerPing()
	{
		return this.PlayerPing;
	}

	public Packet_ServerPlayerSpawnPosition GetPlayerSpawnPosition()
	{
		return this.PlayerSpawnPosition;
	}

	public Packet_ServerPlayerStats GetPlayerStats()
	{
		return this.PlayerStats;
	}

	public Packet_ServerProjectile GetProjectile()
	{
		return this.Projectile;
	}

	public Packet_ServerQueryAnswer GetQueryAnswer()
	{
		return this.QueryAnswer;
	}

	public Packet_ServerRedirect GetRedirect()
	{
		return this.Redirect;
	}

	public Packet_ServerSeason GetSeason()
	{
		return this.Season;
	}

	public Packet_ServerSetBlock GetSetBlock()
	{
		return this.SetBlock;
	}

	public Packet_ServerSound GetSound()
	{
		return this.Sound;
	}

	public Packet_ServerSunLevels GetSunLevels()
	{
		return this.SunLevels;
	}

	public Packet_ServerTranslatedString GetTranslation()
	{
		return this.Translation;
	}
	internal Packet_ServerHeightmapChunk HeightmapChunk;
	internal int Id;
	internal Packet_ServerIdentification Identification;
	internal Packet_ServerInventory Inventory;
	internal Packet_ServerLevelProgress LevelDataChunk;
	internal Packet_ServerLevelFinalize LevelFinalize;
	internal Packet_ServerLevelInitialize LevelInitialize;
	internal Packet_ServerLightLevels LightLevels;
	internal Packet_ServerMessage Message;
	internal Packet_ServerMonsters Monster;
	internal Packet_ServerPing Ping;
	internal Packet_ServerPlayerPing PlayerPing;
	internal Packet_ServerPlayerSpawnPosition PlayerSpawnPosition;
	internal Packet_ServerPlayerStats PlayerStats;
	internal Packet_ServerProjectile Projectile;
	internal Packet_ServerQueryAnswer QueryAnswer;
	internal Packet_ServerRedirect Redirect;
	internal Packet_ServerSeason Season;

	public void SetAmmo(Packet_ServerAmmo value)
	{
		this.Ammo = value;
	}

	public void SetBlobFinalize(Packet_ServerBlobFinalize value)
	{
		this.BlobFinalize = value;
	}

	public void SetBlobInitialize(Packet_ServerBlobInitialize value)
	{
		this.BlobInitialize = value;
	}

	public void SetBlobPart(Packet_ServerBlobPart value)
	{
		this.BlobPart = value;
	}
	internal Packet_ServerSetBlock SetBlock;

	public void SetBlockType(Packet_ServerBlockType value)
	{
		this.BlockType = value;
	}

	public void SetBlockTypes(Packet_ServerBlockTypes value)
	{
		this.BlockTypes = value;
	}

	public void SetBullet(Packet_ServerBullet value)
	{
		this.Bullet = value;
	}

	public void SetChunkPart(Packet_ServerChunkPart value)
	{
		this.ChunkPart = value;
	}

	public void SetChunk_(Packet_ServerChunk value)
	{
		this.Chunk_ = value;
	}

	public void SetCraftingRecipes(Packet_ServerCraftingRecipes value)
	{
		this.CraftingRecipes = value;
	}

	public void SetDialog(Packet_ServerDialog value)
	{
		this.Dialog = value;
	}

	public void SetDisconnectPlayer(Packet_ServerDisconnectPlayer value)
	{
		this.DisconnectPlayer = value;
	}

	public void SetEntityDespawn(Packet_ServerEntityDespawn value)
	{
		this.EntityDespawn = value;
	}

	public void SetEntityPosition(Packet_ServerEntityPositionAndOrientation value)
	{
		this.EntityPosition = value;
	}

	public void SetEntitySpawn(Packet_ServerEntitySpawn value)
	{
		this.EntitySpawn = value;
	}

	public void SetExplosion(Packet_ServerExplosion value)
	{
		this.Explosion = value;
	}

	public void SetFillArea(Packet_ServerFillArea value)
	{
		this.FillArea = value;
	}

	public void SetFillAreaLimit(Packet_ServerFillAreaLimit value)
	{
		this.FillAreaLimit = value;
	}

	public void SetFollow(Packet_ServerFollow value)
	{
		this.Follow = value;
	}

	public void SetFreemove(Packet_ServerFreemove value)
	{
		this.Freemove = value;
	}

	public void SetHeightmapChunk(Packet_ServerHeightmapChunk value)
	{
		this.HeightmapChunk = value;
	}

	public void SetId(int value)
	{
		this.Id = value;
	}

	public void SetIdentification(Packet_ServerIdentification value)
	{
		this.Identification = value;
	}

	public void SetInventory(Packet_ServerInventory value)
	{
		this.Inventory = value;
	}

	public void SetLevelDataChunk(Packet_ServerLevelProgress value)
	{
		this.LevelDataChunk = value;
	}

	public void SetLevelFinalize(Packet_ServerLevelFinalize value)
	{
		this.LevelFinalize = value;
	}

	public void SetLevelInitialize(Packet_ServerLevelInitialize value)
	{
		this.LevelInitialize = value;
	}

	public void SetLightLevels(Packet_ServerLightLevels value)
	{
		this.LightLevels = value;
	}

	public void SetMessage(Packet_ServerMessage value)
	{
		this.Message = value;
	}

	public void SetMonster(Packet_ServerMonsters value)
	{
		this.Monster = value;
	}

	public void SetPing(Packet_ServerPing value)
	{
		this.Ping = value;
	}

	public void SetPlayerPing(Packet_ServerPlayerPing value)
	{
		this.PlayerPing = value;
	}

	public void SetPlayerSpawnPosition(Packet_ServerPlayerSpawnPosition value)
	{
		this.PlayerSpawnPosition = value;
	}

	public void SetPlayerStats(Packet_ServerPlayerStats value)
	{
		this.PlayerStats = value;
	}

	public void SetProjectile(Packet_ServerProjectile value)
	{
		this.Projectile = value;
	}

	public void SetQueryAnswer(Packet_ServerQueryAnswer value)
	{
		this.QueryAnswer = value;
	}

	public void SetRedirect(Packet_ServerRedirect value)
	{
		this.Redirect = value;
	}

	public void SetSeason(Packet_ServerSeason value)
	{
		this.Season = value;
	}

	public void SetSetBlock(Packet_ServerSetBlock value)
	{
		this.SetBlock = value;
	}

	public void SetSound(Packet_ServerSound value)
	{
		this.Sound = value;
	}

	public void SetSunLevels(Packet_ServerSunLevels value)
	{
		this.SunLevels = value;
	}

	public void SetTranslation(Packet_ServerTranslatedString value)
	{
		this.Translation = value;
	}
	internal Packet_ServerSound Sound;
	internal Packet_ServerSunLevels SunLevels;
	internal Packet_ServerTranslatedString Translation;
}

public class Packet_ServerAmmo
{

	public Packet_IntInt[] GetTotalAmmo()
	{
		return this.TotalAmmo;
	}

	public int GetTotalAmmoCount()
	{
		return this.TotalAmmoCount;
	}

	public int GetTotalAmmoLength()
	{
		return this.TotalAmmoLength;
	}

	public void SetTotalAmmo(Packet_IntInt[] value, int count, int length)
	{
		this.TotalAmmo = value;
		this.TotalAmmoCount = count;
		this.TotalAmmoLength = length;
	}
	internal Packet_IntInt[] TotalAmmo;

	public void TotalAmmoAdd(Packet_IntInt value)
	{
		if (this.TotalAmmoCount >= this.TotalAmmoLength) {
			Packet_IntInt[] TotalAmmo2 = new Packet_IntInt[this.TotalAmmoLength * 2];
			this.TotalAmmoLength = this.TotalAmmoLength * 2;
			for (int i = 0; i < this.TotalAmmoCount; i++) {
				TotalAmmo2[i] = this.TotalAmmo[i];
			}
			this.TotalAmmo = TotalAmmo2;
		}
		this.TotalAmmo[this.TotalAmmoCount] = value;
		this.TotalAmmoCount++;
	}
	internal int TotalAmmoCount;
	internal int TotalAmmoLength;
}

public class Packet_ServerAmmoSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerAmmo Deserialize(CitoStream stream, Packet_ServerAmmo instance)
	{
		if (instance.TotalAmmo == null) {
			instance.TotalAmmo = new Packet_IntInt[1];
			instance.TotalAmmoCount = 0;
			instance.TotalAmmoLength = 1;
		}
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.TotalAmmoAdd(Packet_IntIntSerializer.DeserializeLengthDelimitedNew(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerAmmo DeserializeBuffer(byte[] buffer, int length, Packet_ServerAmmo instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerAmmoSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerAmmo DeserializeLength(CitoStream stream, int length, Packet_ServerAmmo instance)
	{
		if (instance.TotalAmmo == null) {
			instance.TotalAmmo = new Packet_IntInt[1];
			instance.TotalAmmoCount = 0;
			instance.TotalAmmoLength = 1;
		}
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.TotalAmmoAdd(Packet_IntIntSerializer.DeserializeLengthDelimitedNew(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerAmmo DeserializeLengthDelimited(CitoStream stream, Packet_ServerAmmo instance)
	{
		if (instance.TotalAmmo == null) {
			instance.TotalAmmo = new Packet_IntInt[1];
			instance.TotalAmmoCount = 0;
			instance.TotalAmmoLength = 1;
		}
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.TotalAmmoAdd(Packet_IntIntSerializer.DeserializeLengthDelimitedNew(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerAmmo DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerAmmo instance = new Packet_ServerAmmo();
		Packet_ServerAmmoSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerAmmo instance)
	{
		if (instance.TotalAmmo != null) {
			for (int k = 0; k < instance.TotalAmmoCount; k++) {
				Packet_IntInt i1 = instance.TotalAmmo[k];
				stream.WriteByte(ProtoPlatform.IntToByte(10));
				CitoMemoryStream ms1 = new CitoMemoryStream();
				Packet_IntIntSerializer.Serialize(ms1, i1);
				int ms1Length = ms1.Length();
				ProtocolParser.WriteUInt32_(stream, ms1Length);
				stream.Write(ms1.GetBuffer(), 0, ms1Length);
			}
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerAmmo instance)
	{
		byte[] data = Packet_ServerAmmoSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerAmmo instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerAmmoSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerBlobFinalize
{
}

public class Packet_ServerBlobFinalizeSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerBlobFinalize Deserialize(CitoStream stream, Packet_ServerBlobFinalize instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerBlobFinalize DeserializeBuffer(byte[] buffer, int length, Packet_ServerBlobFinalize instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerBlobFinalizeSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerBlobFinalize DeserializeLength(CitoStream stream, int length, Packet_ServerBlobFinalize instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerBlobFinalize DeserializeLengthDelimited(CitoStream stream, Packet_ServerBlobFinalize instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerBlobFinalize DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerBlobFinalize instance = new Packet_ServerBlobFinalize();
		Packet_ServerBlobFinalizeSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerBlobFinalize instance)
	{
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerBlobFinalize instance)
	{
		byte[] data = Packet_ServerBlobFinalizeSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerBlobFinalize instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerBlobFinalizeSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerBlobInitialize
{

	public string GetMd5()
	{
		return this.Md5;
	}

	public string GetName()
	{
		return this.Name;
	}
	internal string Md5;
	/// <summary>&lt;summary&gt;
	/// &lt;para&gt;[ProtoMember(1, IsRequired = false)]&lt;/para&gt;
	/// &lt;para&gt;optional byte[] hash; //todo, currently ignored.&lt;/para&gt;
	/// &lt;/summary&gt;</summary>
	internal string Name;

	public void SetMd5(string value)
	{
		this.Md5 = value;
	}

	public void SetName(string value)
	{
		this.Name = value;
	}
}

public class Packet_ServerBlobInitializeSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerBlobInitialize Deserialize(CitoStream stream, Packet_ServerBlobInitialize instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 18:
				instance.Name = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.Md5 = ProtocolParser.ReadString(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerBlobInitialize DeserializeBuffer(byte[] buffer, int length, Packet_ServerBlobInitialize instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerBlobInitializeSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerBlobInitialize DeserializeLength(CitoStream stream, int length, Packet_ServerBlobInitialize instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 18:
				instance.Name = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.Md5 = ProtocolParser.ReadString(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerBlobInitialize DeserializeLengthDelimited(CitoStream stream, Packet_ServerBlobInitialize instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 18:
				instance.Name = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.Md5 = ProtocolParser.ReadString(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerBlobInitialize DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerBlobInitialize instance = new Packet_ServerBlobInitialize();
		Packet_ServerBlobInitializeSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerBlobInitialize instance)
	{
		if (instance.Name != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(18));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.Name));
		}
		if (instance.Md5 != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(26));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.Md5));
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerBlobInitialize instance)
	{
		byte[] data = Packet_ServerBlobInitializeSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerBlobInitialize instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerBlobInitializeSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerBlobPart
{
	internal byte[] Data;

	public byte[] GetData()
	{
		return this.Data;
	}

	public int GetIslastpart()
	{
		return this.Islastpart;
	}
	internal int Islastpart;

	public void SetData(byte[] value)
	{
		this.Data = value;
	}

	public void SetIslastpart(int value)
	{
		this.Islastpart = value;
	}
}

public class Packet_ServerBlobPartSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerBlobPart Deserialize(CitoStream stream, Packet_ServerBlobPart instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.Data = ProtocolParser.ReadBytes(stream);
				continue;
			case 16:
				instance.Islastpart = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerBlobPart DeserializeBuffer(byte[] buffer, int length, Packet_ServerBlobPart instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerBlobPartSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerBlobPart DeserializeLength(CitoStream stream, int length, Packet_ServerBlobPart instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.Data = ProtocolParser.ReadBytes(stream);
				continue;
			case 16:
				instance.Islastpart = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerBlobPart DeserializeLengthDelimited(CitoStream stream, Packet_ServerBlobPart instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.Data = ProtocolParser.ReadBytes(stream);
				continue;
			case 16:
				instance.Islastpart = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerBlobPart DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerBlobPart instance = new Packet_ServerBlobPart();
		Packet_ServerBlobPartSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerBlobPart instance)
	{
		if (instance.Data != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(10));
			ProtocolParser.WriteBytes(stream, instance.Data);
		}
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.Islastpart);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerBlobPart instance)
	{
		byte[] data = Packet_ServerBlobPartSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerBlobPart instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerBlobPartSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerBlockType
{
	internal Packet_BlockType Blocktype;

	public Packet_BlockType GetBlocktype()
	{
		return this.Blocktype;
	}

	public int GetId()
	{
		return this.Id;
	}
	internal int Id;

	public void SetBlocktype(Packet_BlockType value)
	{
		this.Blocktype = value;
	}

	public void SetId(int value)
	{
		this.Id = value;
	}
}

public class Packet_ServerBlockTypeSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerBlockType Deserialize(CitoStream stream, Packet_ServerBlockType instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.Id = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				if (instance.Blocktype == null)
					instance.Blocktype = Packet_BlockTypeSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_BlockTypeSerializer.DeserializeLengthDelimited(stream, instance.Blocktype);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerBlockType DeserializeBuffer(byte[] buffer, int length, Packet_ServerBlockType instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerBlockTypeSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerBlockType DeserializeLength(CitoStream stream, int length, Packet_ServerBlockType instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Id = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				if (instance.Blocktype == null)
					instance.Blocktype = Packet_BlockTypeSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_BlockTypeSerializer.DeserializeLengthDelimited(stream, instance.Blocktype);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerBlockType DeserializeLengthDelimited(CitoStream stream, Packet_ServerBlockType instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Id = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				if (instance.Blocktype == null)
					instance.Blocktype = Packet_BlockTypeSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_BlockTypeSerializer.DeserializeLengthDelimited(stream, instance.Blocktype);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerBlockType DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerBlockType instance = new Packet_ServerBlockType();
		Packet_ServerBlockTypeSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerBlockType instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.Id);
		if (instance.Blocktype != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(18));
			CitoMemoryStream ms2 = new CitoMemoryStream();
			Packet_BlockTypeSerializer.Serialize(ms2, instance.Blocktype);
			int ms2Length = ms2.Length();
			ProtocolParser.WriteUInt32_(stream, ms2Length);
			stream.Write(ms2.GetBuffer(), 0, ms2Length);
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerBlockType instance)
	{
		byte[] data = Packet_ServerBlockTypeSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerBlockType instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerBlockTypeSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerBlockTypes
{
}

public class Packet_ServerBlockTypesSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerBlockTypes Deserialize(CitoStream stream, Packet_ServerBlockTypes instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerBlockTypes DeserializeBuffer(byte[] buffer, int length, Packet_ServerBlockTypes instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerBlockTypesSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerBlockTypes DeserializeLength(CitoStream stream, int length, Packet_ServerBlockTypes instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerBlockTypes DeserializeLengthDelimited(CitoStream stream, Packet_ServerBlockTypes instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerBlockTypes DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerBlockTypes instance = new Packet_ServerBlockTypes();
		Packet_ServerBlockTypesSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerBlockTypes instance)
	{
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerBlockTypes instance)
	{
		byte[] data = Packet_ServerBlockTypesSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerBlockTypes instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerBlockTypesSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerBullet
{
	internal int FromXFloat;
	internal int FromYFloat;
	internal int FromZFloat;

	public int GetFromXFloat()
	{
		return this.FromXFloat;
	}

	public int GetFromYFloat()
	{
		return this.FromYFloat;
	}

	public int GetFromZFloat()
	{
		return this.FromZFloat;
	}

	public int GetSpeedFloat()
	{
		return this.SpeedFloat;
	}

	public int GetToXFloat()
	{
		return this.ToXFloat;
	}

	public int GetToYFloat()
	{
		return this.ToYFloat;
	}

	public int GetToZFloat()
	{
		return this.ToZFloat;
	}

	public void SetFromXFloat(int value)
	{
		this.FromXFloat = value;
	}

	public void SetFromYFloat(int value)
	{
		this.FromYFloat = value;
	}

	public void SetFromZFloat(int value)
	{
		this.FromZFloat = value;
	}

	public void SetSpeedFloat(int value)
	{
		this.SpeedFloat = value;
	}

	public void SetToXFloat(int value)
	{
		this.ToXFloat = value;
	}

	public void SetToYFloat(int value)
	{
		this.ToYFloat = value;
	}

	public void SetToZFloat(int value)
	{
		this.ToZFloat = value;
	}
	internal int SpeedFloat;
	internal int ToXFloat;
	internal int ToYFloat;
	internal int ToZFloat;
}

public class Packet_ServerBulletSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerBullet Deserialize(CitoStream stream, Packet_ServerBullet instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.FromXFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.FromYFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.FromZFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.ToXFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.ToYFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.ToZFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.SpeedFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerBullet DeserializeBuffer(byte[] buffer, int length, Packet_ServerBullet instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerBulletSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerBullet DeserializeLength(CitoStream stream, int length, Packet_ServerBullet instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.FromXFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.FromYFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.FromZFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.ToXFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.ToYFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.ToZFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.SpeedFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerBullet DeserializeLengthDelimited(CitoStream stream, Packet_ServerBullet instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.FromXFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.FromYFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.FromZFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.ToXFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.ToYFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.ToZFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.SpeedFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerBullet DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerBullet instance = new Packet_ServerBullet();
		Packet_ServerBulletSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerBullet instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.FromXFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.FromYFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteUInt64(stream, instance.FromZFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(32));
		ProtocolParser.WriteUInt64(stream, instance.ToXFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(40));
		ProtocolParser.WriteUInt64(stream, instance.ToYFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(48));
		ProtocolParser.WriteUInt64(stream, instance.ToZFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(56));
		ProtocolParser.WriteUInt64(stream, instance.SpeedFloat);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerBullet instance)
	{
		byte[] data = Packet_ServerBulletSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerBullet instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerBulletSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerChunk
{

	public int GetSizeX()
	{
		return this.SizeX;
	}

	public int GetSizeY()
	{
		return this.SizeY;
	}

	public int GetSizeZ()
	{
		return this.SizeZ;
	}

	public int GetX()
	{
		return this.X;
	}

	public int GetY()
	{
		return this.Y;
	}

	public int GetZ()
	{
		return this.Z;
	}

	public void SetSizeX(int value)
	{
		this.SizeX = value;
	}

	public void SetSizeY(int value)
	{
		this.SizeY = value;
	}

	public void SetSizeZ(int value)
	{
		this.SizeZ = value;
	}

	public void SetX(int value)
	{
		this.X = value;
	}

	public void SetY(int value)
	{
		this.Y = value;
	}

	public void SetZ(int value)
	{
		this.Z = value;
	}
	internal int SizeX;
	internal int SizeY;
	internal int SizeZ;
	internal int X;
	internal int Y;
	internal int Z;
}

public class Packet_ServerChunkPart
{
	internal byte[] CompressedChunkPart;

	public byte[] GetCompressedChunkPart()
	{
		return this.CompressedChunkPart;
	}

	public void SetCompressedChunkPart(byte[] value)
	{
		this.CompressedChunkPart = value;
	}
}

public class Packet_ServerChunkPartSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerChunkPart Deserialize(CitoStream stream, Packet_ServerChunkPart instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.CompressedChunkPart = ProtocolParser.ReadBytes(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerChunkPart DeserializeBuffer(byte[] buffer, int length, Packet_ServerChunkPart instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerChunkPartSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerChunkPart DeserializeLength(CitoStream stream, int length, Packet_ServerChunkPart instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.CompressedChunkPart = ProtocolParser.ReadBytes(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerChunkPart DeserializeLengthDelimited(CitoStream stream, Packet_ServerChunkPart instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.CompressedChunkPart = ProtocolParser.ReadBytes(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerChunkPart DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerChunkPart instance = new Packet_ServerChunkPart();
		Packet_ServerChunkPartSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerChunkPart instance)
	{
		if (instance.CompressedChunkPart != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(10));
			ProtocolParser.WriteBytes(stream, instance.CompressedChunkPart);
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerChunkPart instance)
	{
		byte[] data = Packet_ServerChunkPartSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerChunkPart instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerChunkPartSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerChunkSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerChunk Deserialize(CitoStream stream, Packet_ServerChunk instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.SizeX = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.SizeY = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.SizeZ = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerChunk DeserializeBuffer(byte[] buffer, int length, Packet_ServerChunk instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerChunkSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerChunk DeserializeLength(CitoStream stream, int length, Packet_ServerChunk instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.SizeX = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.SizeY = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.SizeZ = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerChunk DeserializeLengthDelimited(CitoStream stream, Packet_ServerChunk instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.SizeX = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.SizeY = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.SizeZ = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerChunk DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerChunk instance = new Packet_ServerChunk();
		Packet_ServerChunkSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerChunk instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.X);
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.Y);
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteUInt64(stream, instance.Z);
		stream.WriteByte(ProtoPlatform.IntToByte(32));
		ProtocolParser.WriteUInt64(stream, instance.SizeX);
		stream.WriteByte(ProtoPlatform.IntToByte(40));
		ProtocolParser.WriteUInt64(stream, instance.SizeY);
		stream.WriteByte(ProtoPlatform.IntToByte(48));
		ProtocolParser.WriteUInt64(stream, instance.SizeZ);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerChunk instance)
	{
		byte[] data = Packet_ServerChunkSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerChunk instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerChunkSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerCraftingRecipes
{
	internal Packet_CraftingRecipe[] CraftingRecipes;

	public void CraftingRecipesAdd(Packet_CraftingRecipe value)
	{
		if (this.CraftingRecipesCount >= this.CraftingRecipesLength) {
			Packet_CraftingRecipe[] CraftingRecipes2 = new Packet_CraftingRecipe[this.CraftingRecipesLength * 2];
			this.CraftingRecipesLength = this.CraftingRecipesLength * 2;
			for (int i = 0; i < this.CraftingRecipesCount; i++) {
				CraftingRecipes2[i] = this.CraftingRecipes[i];
			}
			this.CraftingRecipes = CraftingRecipes2;
		}
		this.CraftingRecipes[this.CraftingRecipesCount] = value;
		this.CraftingRecipesCount++;
	}
	internal int CraftingRecipesCount;
	internal int CraftingRecipesLength;

	public Packet_CraftingRecipe[] GetCraftingRecipes()
	{
		return this.CraftingRecipes;
	}

	public int GetCraftingRecipesCount()
	{
		return this.CraftingRecipesCount;
	}

	public int GetCraftingRecipesLength()
	{
		return this.CraftingRecipesLength;
	}

	public void SetCraftingRecipes(Packet_CraftingRecipe[] value, int count, int length)
	{
		this.CraftingRecipes = value;
		this.CraftingRecipesCount = count;
		this.CraftingRecipesLength = length;
	}
}

public class Packet_ServerCraftingRecipesSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerCraftingRecipes Deserialize(CitoStream stream, Packet_ServerCraftingRecipes instance)
	{
		if (instance.CraftingRecipes == null) {
			instance.CraftingRecipes = new Packet_CraftingRecipe[1];
			instance.CraftingRecipesCount = 0;
			instance.CraftingRecipesLength = 1;
		}
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.CraftingRecipesAdd(Packet_CraftingRecipeSerializer.DeserializeLengthDelimitedNew(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerCraftingRecipes DeserializeBuffer(byte[] buffer, int length, Packet_ServerCraftingRecipes instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerCraftingRecipesSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerCraftingRecipes DeserializeLength(CitoStream stream, int length, Packet_ServerCraftingRecipes instance)
	{
		if (instance.CraftingRecipes == null) {
			instance.CraftingRecipes = new Packet_CraftingRecipe[1];
			instance.CraftingRecipesCount = 0;
			instance.CraftingRecipesLength = 1;
		}
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.CraftingRecipesAdd(Packet_CraftingRecipeSerializer.DeserializeLengthDelimitedNew(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerCraftingRecipes DeserializeLengthDelimited(CitoStream stream, Packet_ServerCraftingRecipes instance)
	{
		if (instance.CraftingRecipes == null) {
			instance.CraftingRecipes = new Packet_CraftingRecipe[1];
			instance.CraftingRecipesCount = 0;
			instance.CraftingRecipesLength = 1;
		}
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.CraftingRecipesAdd(Packet_CraftingRecipeSerializer.DeserializeLengthDelimitedNew(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerCraftingRecipes DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerCraftingRecipes instance = new Packet_ServerCraftingRecipes();
		Packet_ServerCraftingRecipesSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerCraftingRecipes instance)
	{
		if (instance.CraftingRecipes != null) {
			for (int k = 0; k < instance.CraftingRecipesCount; k++) {
				Packet_CraftingRecipe i1 = instance.CraftingRecipes[k];
				stream.WriteByte(ProtoPlatform.IntToByte(10));
				CitoMemoryStream ms1 = new CitoMemoryStream();
				Packet_CraftingRecipeSerializer.Serialize(ms1, i1);
				int ms1Length = ms1.Length();
				ProtocolParser.WriteUInt32_(stream, ms1Length);
				stream.Write(ms1.GetBuffer(), 0, ms1Length);
			}
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerCraftingRecipes instance)
	{
		byte[] data = Packet_ServerCraftingRecipesSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerCraftingRecipes instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerCraftingRecipesSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerDialog
{
	internal Packet_Dialog Dialog;
	internal string DialogId;

	public Packet_Dialog GetDialog()
	{
		return this.Dialog;
	}

	public string GetDialogId()
	{
		return this.DialogId;
	}

	public void SetDialog(Packet_Dialog value)
	{
		this.Dialog = value;
	}

	public void SetDialogId(string value)
	{
		this.DialogId = value;
	}
}

public class Packet_ServerDialogSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerDialog Deserialize(CitoStream stream, Packet_ServerDialog instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.DialogId = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				if (instance.Dialog == null)
					instance.Dialog = Packet_DialogSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_DialogSerializer.DeserializeLengthDelimited(stream, instance.Dialog);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerDialog DeserializeBuffer(byte[] buffer, int length, Packet_ServerDialog instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerDialogSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerDialog DeserializeLength(CitoStream stream, int length, Packet_ServerDialog instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.DialogId = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				if (instance.Dialog == null)
					instance.Dialog = Packet_DialogSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_DialogSerializer.DeserializeLengthDelimited(stream, instance.Dialog);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerDialog DeserializeLengthDelimited(CitoStream stream, Packet_ServerDialog instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.DialogId = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				if (instance.Dialog == null)
					instance.Dialog = Packet_DialogSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_DialogSerializer.DeserializeLengthDelimited(stream, instance.Dialog);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerDialog DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerDialog instance = new Packet_ServerDialog();
		Packet_ServerDialogSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerDialog instance)
	{
		if (instance.DialogId != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(10));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.DialogId));
		}
		if (instance.Dialog != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(18));
			CitoMemoryStream ms2 = new CitoMemoryStream();
			Packet_DialogSerializer.Serialize(ms2, instance.Dialog);
			int ms2Length = ms2.Length();
			ProtocolParser.WriteUInt32_(stream, ms2Length);
			stream.Write(ms2.GetBuffer(), 0, ms2Length);
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerDialog instance)
	{
		byte[] data = Packet_ServerDialogSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerDialog instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerDialogSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerDisconnectPlayer
{
	internal string DisconnectReason;

	public string GetDisconnectReason()
	{
		return this.DisconnectReason;
	}

	public void SetDisconnectReason(string value)
	{
		this.DisconnectReason = value;
	}
}

public class Packet_ServerDisconnectPlayerSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerDisconnectPlayer Deserialize(CitoStream stream, Packet_ServerDisconnectPlayer instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.DisconnectReason = ProtocolParser.ReadString(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerDisconnectPlayer DeserializeBuffer(byte[] buffer, int length, Packet_ServerDisconnectPlayer instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerDisconnectPlayerSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerDisconnectPlayer DeserializeLength(CitoStream stream, int length, Packet_ServerDisconnectPlayer instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.DisconnectReason = ProtocolParser.ReadString(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerDisconnectPlayer DeserializeLengthDelimited(CitoStream stream, Packet_ServerDisconnectPlayer instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.DisconnectReason = ProtocolParser.ReadString(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerDisconnectPlayer DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerDisconnectPlayer instance = new Packet_ServerDisconnectPlayer();
		Packet_ServerDisconnectPlayerSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerDisconnectPlayer instance)
	{
		if (instance.DisconnectReason != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(10));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.DisconnectReason));
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerDisconnectPlayer instance)
	{
		byte[] data = Packet_ServerDisconnectPlayerSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerDisconnectPlayer instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerDisconnectPlayerSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerEntity
{
	internal Packet_ServerEntityDrawArea DrawArea;
	internal Packet_ServerEntityDrawBlock DrawBlock;
	internal Packet_ServerEntityAnimatedModel DrawModel;
	internal Packet_ServerEntityDrawName DrawName_;
	internal Packet_ServerEntityDrawText DrawText;

	public Packet_ServerEntityDrawArea GetDrawArea()
	{
		return this.DrawArea;
	}

	public Packet_ServerEntityDrawBlock GetDrawBlock()
	{
		return this.DrawBlock;
	}

	public Packet_ServerEntityAnimatedModel GetDrawModel()
	{
		return this.DrawModel;
	}

	public Packet_ServerEntityDrawName GetDrawName_()
	{
		return this.DrawName_;
	}

	public Packet_ServerEntityDrawText GetDrawText()
	{
		return this.DrawText;
	}

	public Packet_ServerPlayerStats GetPlayerStats()
	{
		return this.PlayerStats;
	}

	public Packet_PositionAndOrientation GetPosition()
	{
		return this.Position;
	}

	public Packet_ServerEntityPush GetPush()
	{
		return this.Push;
	}

	public bool GetUsable()
	{
		return this.Usable;
	}
	internal Packet_ServerPlayerStats PlayerStats;
	internal Packet_PositionAndOrientation Position;
	internal Packet_ServerEntityPush Push;

	public void SetDrawArea(Packet_ServerEntityDrawArea value)
	{
		this.DrawArea = value;
	}

	public void SetDrawBlock(Packet_ServerEntityDrawBlock value)
	{
		this.DrawBlock = value;
	}

	public void SetDrawModel(Packet_ServerEntityAnimatedModel value)
	{
		this.DrawModel = value;
	}

	public void SetDrawName_(Packet_ServerEntityDrawName value)
	{
		this.DrawName_ = value;
	}

	public void SetDrawText(Packet_ServerEntityDrawText value)
	{
		this.DrawText = value;
	}

	public void SetPlayerStats(Packet_ServerPlayerStats value)
	{
		this.PlayerStats = value;
	}

	public void SetPosition(Packet_PositionAndOrientation value)
	{
		this.Position = value;
	}

	public void SetPush(Packet_ServerEntityPush value)
	{
		this.Push = value;
	}

	public void SetUsable(bool value)
	{
		this.Usable = value;
	}
	internal bool Usable;
}

public class Packet_ServerEntityAnimatedModel
{
	internal int DownloadSkin;
	internal int EyeHeight;

	public int GetDownloadSkin()
	{
		return this.DownloadSkin;
	}

	public int GetEyeHeight()
	{
		return this.EyeHeight;
	}

	public int GetModelHeight()
	{
		return this.ModelHeight;
	}

	public string GetModel_()
	{
		return this.Model_;
	}

	public string GetTexture_()
	{
		return this.Texture_;
	}
	internal int ModelHeight;
	internal string Model_;

	public void SetDownloadSkin(int value)
	{
		this.DownloadSkin = value;
	}

	public void SetEyeHeight(int value)
	{
		this.EyeHeight = value;
	}

	public void SetModelHeight(int value)
	{
		this.ModelHeight = value;
	}

	public void SetModel_(string value)
	{
		this.Model_ = value;
	}

	public void SetTexture_(string value)
	{
		this.Texture_ = value;
	}
	internal string Texture_;
}

public class Packet_ServerEntityAnimatedModelSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntityAnimatedModel Deserialize(CitoStream stream, Packet_ServerEntityAnimatedModel instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.Model_ = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.Texture_ = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.EyeHeight = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.ModelHeight = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.DownloadSkin = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerEntityAnimatedModel DeserializeBuffer(byte[] buffer, int length, Packet_ServerEntityAnimatedModel instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerEntityAnimatedModelSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntityAnimatedModel DeserializeLength(CitoStream stream, int length, Packet_ServerEntityAnimatedModel instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.Model_ = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.Texture_ = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.EyeHeight = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.ModelHeight = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.DownloadSkin = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntityAnimatedModel DeserializeLengthDelimited(CitoStream stream, Packet_ServerEntityAnimatedModel instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.Model_ = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.Texture_ = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.EyeHeight = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.ModelHeight = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.DownloadSkin = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerEntityAnimatedModel DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerEntityAnimatedModel instance = new Packet_ServerEntityAnimatedModel();
		Packet_ServerEntityAnimatedModelSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerEntityAnimatedModel instance)
	{
		if (instance.Model_ != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(10));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.Model_));
		}
		if (instance.Texture_ != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(18));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.Texture_));
		}
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteUInt64(stream, instance.EyeHeight);
		stream.WriteByte(ProtoPlatform.IntToByte(32));
		ProtocolParser.WriteUInt64(stream, instance.ModelHeight);
		stream.WriteByte(ProtoPlatform.IntToByte(40));
		ProtocolParser.WriteUInt64(stream, instance.DownloadSkin);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerEntityAnimatedModel instance)
	{
		byte[] data = Packet_ServerEntityAnimatedModelSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerEntityAnimatedModel instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerEntityAnimatedModelSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerEntityDespawn
{

	public int GetId()
	{
		return this.Id;
	}
	internal int Id;

	public void SetId(int value)
	{
		this.Id = value;
	}
}

public class Packet_ServerEntityDespawnSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntityDespawn Deserialize(CitoStream stream, Packet_ServerEntityDespawn instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.Id = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerEntityDespawn DeserializeBuffer(byte[] buffer, int length, Packet_ServerEntityDespawn instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerEntityDespawnSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntityDespawn DeserializeLength(CitoStream stream, int length, Packet_ServerEntityDespawn instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Id = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntityDespawn DeserializeLengthDelimited(CitoStream stream, Packet_ServerEntityDespawn instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Id = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerEntityDespawn DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerEntityDespawn instance = new Packet_ServerEntityDespawn();
		Packet_ServerEntityDespawnSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerEntityDespawn instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.Id);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerEntityDespawn instance)
	{
		byte[] data = Packet_ServerEntityDespawnSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerEntityDespawn instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerEntityDespawnSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerEntityDrawArea
{

	public int GetSizex()
	{
		return this.Sizex;
	}

	public int GetSizey()
	{
		return this.Sizey;
	}

	public int GetSizez()
	{
		return this.Sizez;
	}

	public int GetVisibleToClientId()
	{
		return this.VisibleToClientId;
	}

	public int GetX()
	{
		return this.X;
	}

	public int GetY()
	{
		return this.Y;
	}

	public int GetZ()
	{
		return this.Z;
	}

	public void SetSizex(int value)
	{
		this.Sizex = value;
	}

	public void SetSizey(int value)
	{
		this.Sizey = value;
	}

	public void SetSizez(int value)
	{
		this.Sizez = value;
	}

	public void SetVisibleToClientId(int value)
	{
		this.VisibleToClientId = value;
	}

	public void SetX(int value)
	{
		this.X = value;
	}

	public void SetY(int value)
	{
		this.Y = value;
	}

	public void SetZ(int value)
	{
		this.Z = value;
	}
	internal int Sizex;
	internal int Sizey;
	internal int Sizez;
	internal int VisibleToClientId;
	internal int X;
	internal int Y;
	internal int Z;
}

public class Packet_ServerEntityDrawAreaSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntityDrawArea Deserialize(CitoStream stream, Packet_ServerEntityDrawArea instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Sizex = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.Sizey = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.Sizez = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.VisibleToClientId = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerEntityDrawArea DeserializeBuffer(byte[] buffer, int length, Packet_ServerEntityDrawArea instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerEntityDrawAreaSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntityDrawArea DeserializeLength(CitoStream stream, int length, Packet_ServerEntityDrawArea instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Sizex = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.Sizey = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.Sizez = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.VisibleToClientId = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntityDrawArea DeserializeLengthDelimited(CitoStream stream, Packet_ServerEntityDrawArea instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Sizex = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.Sizey = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.Sizez = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.VisibleToClientId = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerEntityDrawArea DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerEntityDrawArea instance = new Packet_ServerEntityDrawArea();
		Packet_ServerEntityDrawAreaSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerEntityDrawArea instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.X);
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.Y);
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteUInt64(stream, instance.Z);
		stream.WriteByte(ProtoPlatform.IntToByte(32));
		ProtocolParser.WriteUInt64(stream, instance.Sizex);
		stream.WriteByte(ProtoPlatform.IntToByte(40));
		ProtocolParser.WriteUInt64(stream, instance.Sizey);
		stream.WriteByte(ProtoPlatform.IntToByte(48));
		ProtocolParser.WriteUInt64(stream, instance.Sizez);
		stream.WriteByte(ProtoPlatform.IntToByte(56));
		ProtocolParser.WriteUInt64(stream, instance.VisibleToClientId);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerEntityDrawArea instance)
	{
		byte[] data = Packet_ServerEntityDrawAreaSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerEntityDrawArea instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerEntityDrawAreaSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerEntityDrawBlock
{
	internal int BlockType;

	public int GetBlockType()
	{
		return this.BlockType;
	}

	public void SetBlockType(int value)
	{
		this.BlockType = value;
	}
}

public class Packet_ServerEntityDrawBlockSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntityDrawBlock Deserialize(CitoStream stream, Packet_ServerEntityDrawBlock instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.BlockType = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerEntityDrawBlock DeserializeBuffer(byte[] buffer, int length, Packet_ServerEntityDrawBlock instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerEntityDrawBlockSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntityDrawBlock DeserializeLength(CitoStream stream, int length, Packet_ServerEntityDrawBlock instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.BlockType = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntityDrawBlock DeserializeLengthDelimited(CitoStream stream, Packet_ServerEntityDrawBlock instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.BlockType = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerEntityDrawBlock DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerEntityDrawBlock instance = new Packet_ServerEntityDrawBlock();
		Packet_ServerEntityDrawBlockSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerEntityDrawBlock instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.BlockType);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerEntityDrawBlock instance)
	{
		byte[] data = Packet_ServerEntityDrawBlockSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerEntityDrawBlock instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerEntityDrawBlockSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerEntityDrawName
{
	internal bool ClientAutoComplete;
	internal string Color;

	public bool GetClientAutoComplete()
	{
		return this.ClientAutoComplete;
	}

	public string GetColor()
	{
		return this.Color;
	}

	public string GetName()
	{
		return this.Name;
	}

	public bool GetOnlyWhenSelected()
	{
		return this.OnlyWhenSelected;
	}
	internal string Name;
	internal bool OnlyWhenSelected;

	public void SetClientAutoComplete(bool value)
	{
		this.ClientAutoComplete = value;
	}

	public void SetColor(string value)
	{
		this.Color = value;
	}

	public void SetName(string value)
	{
		this.Name = value;
	}

	public void SetOnlyWhenSelected(bool value)
	{
		this.OnlyWhenSelected = value;
	}
}

public class Packet_ServerEntityDrawNameSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntityDrawName Deserialize(CitoStream stream, Packet_ServerEntityDrawName instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.Name = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.OnlyWhenSelected = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.ClientAutoComplete = ProtocolParser.ReadBool(stream);
				continue;
			case 34:
				instance.Color = ProtocolParser.ReadString(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerEntityDrawName DeserializeBuffer(byte[] buffer, int length, Packet_ServerEntityDrawName instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerEntityDrawNameSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntityDrawName DeserializeLength(CitoStream stream, int length, Packet_ServerEntityDrawName instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.Name = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.OnlyWhenSelected = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.ClientAutoComplete = ProtocolParser.ReadBool(stream);
				continue;
			case 34:
				instance.Color = ProtocolParser.ReadString(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntityDrawName DeserializeLengthDelimited(CitoStream stream, Packet_ServerEntityDrawName instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.Name = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.OnlyWhenSelected = ProtocolParser.ReadBool(stream);
				continue;
			case 24:
				instance.ClientAutoComplete = ProtocolParser.ReadBool(stream);
				continue;
			case 34:
				instance.Color = ProtocolParser.ReadString(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerEntityDrawName DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerEntityDrawName instance = new Packet_ServerEntityDrawName();
		Packet_ServerEntityDrawNameSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerEntityDrawName instance)
	{
		if (instance.Name != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(10));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.Name));
		}
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteBool(stream, instance.OnlyWhenSelected);
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteBool(stream, instance.ClientAutoComplete);
		if (instance.Color != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(34));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.Color));
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerEntityDrawName instance)
	{
		byte[] data = Packet_ServerEntityDrawNameSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerEntityDrawName instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerEntityDrawNameSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerEntityDrawText
{
	internal int Dx;
	internal int Dy;
	internal int Dz;

	public int GetDx()
	{
		return this.Dx;
	}

	public int GetDy()
	{
		return this.Dy;
	}

	public int GetDz()
	{
		return this.Dz;
	}

	public int GetRotx()
	{
		return this.Rotx;
	}

	public int GetRoty()
	{
		return this.Roty;
	}

	public int GetRotz()
	{
		return this.Rotz;
	}

	public string GetText()
	{
		return this.Text;
	}
	internal int Rotx;
	internal int Roty;
	internal int Rotz;

	public void SetDx(int value)
	{
		this.Dx = value;
	}

	public void SetDy(int value)
	{
		this.Dy = value;
	}

	public void SetDz(int value)
	{
		this.Dz = value;
	}

	public void SetRotx(int value)
	{
		this.Rotx = value;
	}

	public void SetRoty(int value)
	{
		this.Roty = value;
	}

	public void SetRotz(int value)
	{
		this.Rotz = value;
	}

	public void SetText(string value)
	{
		this.Text = value;
	}
	internal string Text;
}

public class Packet_ServerEntityDrawTextSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntityDrawText Deserialize(CitoStream stream, Packet_ServerEntityDrawText instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.Text = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.Dx = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Dy = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Dz = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.Rotx = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.Roty = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.Rotz = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerEntityDrawText DeserializeBuffer(byte[] buffer, int length, Packet_ServerEntityDrawText instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerEntityDrawTextSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntityDrawText DeserializeLength(CitoStream stream, int length, Packet_ServerEntityDrawText instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.Text = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.Dx = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Dy = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Dz = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.Rotx = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.Roty = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.Rotz = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntityDrawText DeserializeLengthDelimited(CitoStream stream, Packet_ServerEntityDrawText instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.Text = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.Dx = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Dy = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Dz = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.Rotx = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.Roty = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.Rotz = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerEntityDrawText DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerEntityDrawText instance = new Packet_ServerEntityDrawText();
		Packet_ServerEntityDrawTextSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerEntityDrawText instance)
	{
		if (instance.Text != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(10));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.Text));
		}
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.Dx);
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteUInt64(stream, instance.Dy);
		stream.WriteByte(ProtoPlatform.IntToByte(32));
		ProtocolParser.WriteUInt64(stream, instance.Dz);
		stream.WriteByte(ProtoPlatform.IntToByte(40));
		ProtocolParser.WriteUInt64(stream, instance.Rotx);
		stream.WriteByte(ProtoPlatform.IntToByte(48));
		ProtocolParser.WriteUInt64(stream, instance.Roty);
		stream.WriteByte(ProtoPlatform.IntToByte(56));
		ProtocolParser.WriteUInt64(stream, instance.Rotz);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerEntityDrawText instance)
	{
		byte[] data = Packet_ServerEntityDrawTextSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerEntityDrawText instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerEntityDrawTextSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerEntityPositionAndOrientation
{

	public int GetId()
	{
		return this.Id;
	}

	public Packet_PositionAndOrientation GetPositionAndOrientation()
	{
		return this.PositionAndOrientation;
	}
	internal int Id;
	internal Packet_PositionAndOrientation PositionAndOrientation;

	public void SetId(int value)
	{
		this.Id = value;
	}

	public void SetPositionAndOrientation(Packet_PositionAndOrientation value)
	{
		this.PositionAndOrientation = value;
	}
}

public class Packet_ServerEntityPositionAndOrientationSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntityPositionAndOrientation Deserialize(CitoStream stream, Packet_ServerEntityPositionAndOrientation instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.Id = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				if (instance.PositionAndOrientation == null)
					instance.PositionAndOrientation = Packet_PositionAndOrientationSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_PositionAndOrientationSerializer.DeserializeLengthDelimited(stream, instance.PositionAndOrientation);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerEntityPositionAndOrientation DeserializeBuffer(byte[] buffer, int length, Packet_ServerEntityPositionAndOrientation instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerEntityPositionAndOrientationSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntityPositionAndOrientation DeserializeLength(CitoStream stream, int length, Packet_ServerEntityPositionAndOrientation instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Id = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				if (instance.PositionAndOrientation == null)
					instance.PositionAndOrientation = Packet_PositionAndOrientationSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_PositionAndOrientationSerializer.DeserializeLengthDelimited(stream, instance.PositionAndOrientation);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntityPositionAndOrientation DeserializeLengthDelimited(CitoStream stream, Packet_ServerEntityPositionAndOrientation instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Id = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				if (instance.PositionAndOrientation == null)
					instance.PositionAndOrientation = Packet_PositionAndOrientationSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_PositionAndOrientationSerializer.DeserializeLengthDelimited(stream, instance.PositionAndOrientation);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerEntityPositionAndOrientation DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerEntityPositionAndOrientation instance = new Packet_ServerEntityPositionAndOrientation();
		Packet_ServerEntityPositionAndOrientationSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerEntityPositionAndOrientation instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.Id);
		if (instance.PositionAndOrientation != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(18));
			CitoMemoryStream ms2 = new CitoMemoryStream();
			Packet_PositionAndOrientationSerializer.Serialize(ms2, instance.PositionAndOrientation);
			int ms2Length = ms2.Length();
			ProtocolParser.WriteUInt32_(stream, ms2Length);
			stream.Write(ms2.GetBuffer(), 0, ms2Length);
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerEntityPositionAndOrientation instance)
	{
		byte[] data = Packet_ServerEntityPositionAndOrientationSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerEntityPositionAndOrientation instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerEntityPositionAndOrientationSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerEntityPush
{

	public int GetRangeFloat()
	{
		return this.RangeFloat;
	}
	internal int RangeFloat;

	public void SetRangeFloat(int value)
	{
		this.RangeFloat = value;
	}
}

public class Packet_ServerEntityPushSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntityPush Deserialize(CitoStream stream, Packet_ServerEntityPush instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.RangeFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerEntityPush DeserializeBuffer(byte[] buffer, int length, Packet_ServerEntityPush instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerEntityPushSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntityPush DeserializeLength(CitoStream stream, int length, Packet_ServerEntityPush instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.RangeFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntityPush DeserializeLengthDelimited(CitoStream stream, Packet_ServerEntityPush instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.RangeFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerEntityPush DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerEntityPush instance = new Packet_ServerEntityPush();
		Packet_ServerEntityPushSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerEntityPush instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.RangeFloat);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerEntityPush instance)
	{
		byte[] data = Packet_ServerEntityPushSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerEntityPush instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerEntityPushSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerEntitySerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntity Deserialize(CitoStream stream, Packet_ServerEntity instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				if (instance.Position == null)
					instance.Position = Packet_PositionAndOrientationSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_PositionAndOrientationSerializer.DeserializeLengthDelimited(stream, instance.Position);
				continue;
			case 18:
				if (instance.DrawModel == null)
					instance.DrawModel = Packet_ServerEntityAnimatedModelSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntityAnimatedModelSerializer.DeserializeLengthDelimited(stream, instance.DrawModel);
				continue;
			case 26:
				if (instance.DrawName_ == null)
					instance.DrawName_ = Packet_ServerEntityDrawNameSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntityDrawNameSerializer.DeserializeLengthDelimited(stream, instance.DrawName_);
				continue;
			case 34:
				if (instance.DrawText == null)
					instance.DrawText = Packet_ServerEntityDrawTextSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntityDrawTextSerializer.DeserializeLengthDelimited(stream, instance.DrawText);
				continue;
			case 42:
				if (instance.DrawBlock == null)
					instance.DrawBlock = Packet_ServerEntityDrawBlockSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntityDrawBlockSerializer.DeserializeLengthDelimited(stream, instance.DrawBlock);
				continue;
			case 50:
				if (instance.Push == null)
					instance.Push = Packet_ServerEntityPushSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntityPushSerializer.DeserializeLengthDelimited(stream, instance.Push);
				continue;
			case 56:
				instance.Usable = ProtocolParser.ReadBool(stream);
				continue;
			case 66:
				if (instance.PlayerStats == null)
					instance.PlayerStats = Packet_ServerPlayerStatsSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerPlayerStatsSerializer.DeserializeLengthDelimited(stream, instance.PlayerStats);
				continue;
			case 74:
				if (instance.DrawArea == null)
					instance.DrawArea = Packet_ServerEntityDrawAreaSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntityDrawAreaSerializer.DeserializeLengthDelimited(stream, instance.DrawArea);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerEntity DeserializeBuffer(byte[] buffer, int length, Packet_ServerEntity instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerEntitySerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntity DeserializeLength(CitoStream stream, int length, Packet_ServerEntity instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				if (instance.Position == null)
					instance.Position = Packet_PositionAndOrientationSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_PositionAndOrientationSerializer.DeserializeLengthDelimited(stream, instance.Position);
				continue;
			case 18:
				if (instance.DrawModel == null)
					instance.DrawModel = Packet_ServerEntityAnimatedModelSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntityAnimatedModelSerializer.DeserializeLengthDelimited(stream, instance.DrawModel);
				continue;
			case 26:
				if (instance.DrawName_ == null)
					instance.DrawName_ = Packet_ServerEntityDrawNameSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntityDrawNameSerializer.DeserializeLengthDelimited(stream, instance.DrawName_);
				continue;
			case 34:
				if (instance.DrawText == null)
					instance.DrawText = Packet_ServerEntityDrawTextSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntityDrawTextSerializer.DeserializeLengthDelimited(stream, instance.DrawText);
				continue;
			case 42:
				if (instance.DrawBlock == null)
					instance.DrawBlock = Packet_ServerEntityDrawBlockSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntityDrawBlockSerializer.DeserializeLengthDelimited(stream, instance.DrawBlock);
				continue;
			case 50:
				if (instance.Push == null)
					instance.Push = Packet_ServerEntityPushSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntityPushSerializer.DeserializeLengthDelimited(stream, instance.Push);
				continue;
			case 56:
				instance.Usable = ProtocolParser.ReadBool(stream);
				continue;
			case 66:
				if (instance.PlayerStats == null)
					instance.PlayerStats = Packet_ServerPlayerStatsSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerPlayerStatsSerializer.DeserializeLengthDelimited(stream, instance.PlayerStats);
				continue;
			case 74:
				if (instance.DrawArea == null)
					instance.DrawArea = Packet_ServerEntityDrawAreaSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntityDrawAreaSerializer.DeserializeLengthDelimited(stream, instance.DrawArea);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntity DeserializeLengthDelimited(CitoStream stream, Packet_ServerEntity instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				if (instance.Position == null)
					instance.Position = Packet_PositionAndOrientationSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_PositionAndOrientationSerializer.DeserializeLengthDelimited(stream, instance.Position);
				continue;
			case 18:
				if (instance.DrawModel == null)
					instance.DrawModel = Packet_ServerEntityAnimatedModelSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntityAnimatedModelSerializer.DeserializeLengthDelimited(stream, instance.DrawModel);
				continue;
			case 26:
				if (instance.DrawName_ == null)
					instance.DrawName_ = Packet_ServerEntityDrawNameSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntityDrawNameSerializer.DeserializeLengthDelimited(stream, instance.DrawName_);
				continue;
			case 34:
				if (instance.DrawText == null)
					instance.DrawText = Packet_ServerEntityDrawTextSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntityDrawTextSerializer.DeserializeLengthDelimited(stream, instance.DrawText);
				continue;
			case 42:
				if (instance.DrawBlock == null)
					instance.DrawBlock = Packet_ServerEntityDrawBlockSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntityDrawBlockSerializer.DeserializeLengthDelimited(stream, instance.DrawBlock);
				continue;
			case 50:
				if (instance.Push == null)
					instance.Push = Packet_ServerEntityPushSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntityPushSerializer.DeserializeLengthDelimited(stream, instance.Push);
				continue;
			case 56:
				instance.Usable = ProtocolParser.ReadBool(stream);
				continue;
			case 66:
				if (instance.PlayerStats == null)
					instance.PlayerStats = Packet_ServerPlayerStatsSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerPlayerStatsSerializer.DeserializeLengthDelimited(stream, instance.PlayerStats);
				continue;
			case 74:
				if (instance.DrawArea == null)
					instance.DrawArea = Packet_ServerEntityDrawAreaSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntityDrawAreaSerializer.DeserializeLengthDelimited(stream, instance.DrawArea);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerEntity DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerEntity instance = new Packet_ServerEntity();
		Packet_ServerEntitySerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerEntity instance)
	{
		if (instance.Position != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(10));
			CitoMemoryStream ms1 = new CitoMemoryStream();
			Packet_PositionAndOrientationSerializer.Serialize(ms1, instance.Position);
			int ms1Length = ms1.Length();
			ProtocolParser.WriteUInt32_(stream, ms1Length);
			stream.Write(ms1.GetBuffer(), 0, ms1Length);
		}
		if (instance.DrawModel != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(18));
			CitoMemoryStream ms2 = new CitoMemoryStream();
			Packet_ServerEntityAnimatedModelSerializer.Serialize(ms2, instance.DrawModel);
			int ms2Length = ms2.Length();
			ProtocolParser.WriteUInt32_(stream, ms2Length);
			stream.Write(ms2.GetBuffer(), 0, ms2Length);
		}
		if (instance.DrawName_ != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(26));
			CitoMemoryStream ms3 = new CitoMemoryStream();
			Packet_ServerEntityDrawNameSerializer.Serialize(ms3, instance.DrawName_);
			int ms3Length = ms3.Length();
			ProtocolParser.WriteUInt32_(stream, ms3Length);
			stream.Write(ms3.GetBuffer(), 0, ms3Length);
		}
		if (instance.DrawText != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(34));
			CitoMemoryStream ms4 = new CitoMemoryStream();
			Packet_ServerEntityDrawTextSerializer.Serialize(ms4, instance.DrawText);
			int ms4Length = ms4.Length();
			ProtocolParser.WriteUInt32_(stream, ms4Length);
			stream.Write(ms4.GetBuffer(), 0, ms4Length);
		}
		if (instance.DrawBlock != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(42));
			CitoMemoryStream ms5 = new CitoMemoryStream();
			Packet_ServerEntityDrawBlockSerializer.Serialize(ms5, instance.DrawBlock);
			int ms5Length = ms5.Length();
			ProtocolParser.WriteUInt32_(stream, ms5Length);
			stream.Write(ms5.GetBuffer(), 0, ms5Length);
		}
		if (instance.Push != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(50));
			CitoMemoryStream ms6 = new CitoMemoryStream();
			Packet_ServerEntityPushSerializer.Serialize(ms6, instance.Push);
			int ms6Length = ms6.Length();
			ProtocolParser.WriteUInt32_(stream, ms6Length);
			stream.Write(ms6.GetBuffer(), 0, ms6Length);
		}
		stream.WriteByte(ProtoPlatform.IntToByte(56));
		ProtocolParser.WriteBool(stream, instance.Usable);
		if (instance.PlayerStats != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(66));
			CitoMemoryStream ms8 = new CitoMemoryStream();
			Packet_ServerPlayerStatsSerializer.Serialize(ms8, instance.PlayerStats);
			int ms8Length = ms8.Length();
			ProtocolParser.WriteUInt32_(stream, ms8Length);
			stream.Write(ms8.GetBuffer(), 0, ms8Length);
		}
		if (instance.DrawArea != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(74));
			CitoMemoryStream ms9 = new CitoMemoryStream();
			Packet_ServerEntityDrawAreaSerializer.Serialize(ms9, instance.DrawArea);
			int ms9Length = ms9.Length();
			ProtocolParser.WriteUInt32_(stream, ms9Length);
			stream.Write(ms9.GetBuffer(), 0, ms9Length);
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerEntity instance)
	{
		byte[] data = Packet_ServerEntitySerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerEntity instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerEntitySerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerEntitySpawn
{
	internal Packet_ServerEntity Entity_;

	public Packet_ServerEntity GetEntity_()
	{
		return this.Entity_;
	}

	public int GetId()
	{
		return this.Id;
	}
	internal int Id;

	public void SetEntity_(Packet_ServerEntity value)
	{
		this.Entity_ = value;
	}

	public void SetId(int value)
	{
		this.Id = value;
	}
}

public class Packet_ServerEntitySpawnSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntitySpawn Deserialize(CitoStream stream, Packet_ServerEntitySpawn instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.Id = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				if (instance.Entity_ == null)
					instance.Entity_ = Packet_ServerEntitySerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntitySerializer.DeserializeLengthDelimited(stream, instance.Entity_);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerEntitySpawn DeserializeBuffer(byte[] buffer, int length, Packet_ServerEntitySpawn instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerEntitySpawnSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntitySpawn DeserializeLength(CitoStream stream, int length, Packet_ServerEntitySpawn instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Id = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				if (instance.Entity_ == null)
					instance.Entity_ = Packet_ServerEntitySerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntitySerializer.DeserializeLengthDelimited(stream, instance.Entity_);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerEntitySpawn DeserializeLengthDelimited(CitoStream stream, Packet_ServerEntitySpawn instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Id = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				if (instance.Entity_ == null)
					instance.Entity_ = Packet_ServerEntitySerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntitySerializer.DeserializeLengthDelimited(stream, instance.Entity_);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerEntitySpawn DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerEntitySpawn instance = new Packet_ServerEntitySpawn();
		Packet_ServerEntitySpawnSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerEntitySpawn instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.Id);
		if (instance.Entity_ != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(18));
			CitoMemoryStream ms2 = new CitoMemoryStream();
			Packet_ServerEntitySerializer.Serialize(ms2, instance.Entity_);
			int ms2Length = ms2.Length();
			ProtocolParser.WriteUInt32_(stream, ms2Length);
			stream.Write(ms2.GetBuffer(), 0, ms2Length);
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerEntitySpawn instance)
	{
		byte[] data = Packet_ServerEntitySpawnSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerEntitySpawn instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerEntitySpawnSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerExplosion
{

	public int GetIsRelativeToPlayerPosition()
	{
		return this.IsRelativeToPlayerPosition;
	}

	public int GetRangeFloat()
	{
		return this.RangeFloat;
	}

	public int GetTimeFloat()
	{
		return this.TimeFloat;
	}

	public int GetXFloat()
	{
		return this.XFloat;
	}

	public int GetYFloat()
	{
		return this.YFloat;
	}

	public int GetZFloat()
	{
		return this.ZFloat;
	}
	internal int IsRelativeToPlayerPosition;
	internal int RangeFloat;

	public void SetIsRelativeToPlayerPosition(int value)
	{
		this.IsRelativeToPlayerPosition = value;
	}

	public void SetRangeFloat(int value)
	{
		this.RangeFloat = value;
	}

	public void SetTimeFloat(int value)
	{
		this.TimeFloat = value;
	}

	public void SetXFloat(int value)
	{
		this.XFloat = value;
	}

	public void SetYFloat(int value)
	{
		this.YFloat = value;
	}

	public void SetZFloat(int value)
	{
		this.ZFloat = value;
	}
	internal int TimeFloat;
	internal int XFloat;
	internal int YFloat;
	internal int ZFloat;
}

public class Packet_ServerExplosionSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerExplosion Deserialize(CitoStream stream, Packet_ServerExplosion instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.XFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.YFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.ZFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.IsRelativeToPlayerPosition = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.RangeFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.TimeFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerExplosion DeserializeBuffer(byte[] buffer, int length, Packet_ServerExplosion instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerExplosionSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerExplosion DeserializeLength(CitoStream stream, int length, Packet_ServerExplosion instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.XFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.YFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.ZFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.IsRelativeToPlayerPosition = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.RangeFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.TimeFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerExplosion DeserializeLengthDelimited(CitoStream stream, Packet_ServerExplosion instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.XFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.YFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.ZFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.IsRelativeToPlayerPosition = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.RangeFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.TimeFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerExplosion DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerExplosion instance = new Packet_ServerExplosion();
		Packet_ServerExplosionSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerExplosion instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.XFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.YFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteUInt64(stream, instance.ZFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(32));
		ProtocolParser.WriteUInt64(stream, instance.IsRelativeToPlayerPosition);
		stream.WriteByte(ProtoPlatform.IntToByte(40));
		ProtocolParser.WriteUInt64(stream, instance.RangeFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(48));
		ProtocolParser.WriteUInt64(stream, instance.TimeFloat);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerExplosion instance)
	{
		byte[] data = Packet_ServerExplosionSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerExplosion instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerExplosionSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerFillArea
{
	internal int BlockCount;
	internal int BlockType;

	public int GetBlockCount()
	{
		return this.BlockCount;
	}

	public int GetBlockType()
	{
		return this.BlockType;
	}

	public int GetX1()
	{
		return this.X1;
	}

	public int GetX2()
	{
		return this.X2;
	}

	public int GetY1()
	{
		return this.Y1;
	}

	public int GetY2()
	{
		return this.Y2;
	}

	public int GetZ1()
	{
		return this.Z1;
	}

	public int GetZ2()
	{
		return this.Z2;
	}

	public void SetBlockCount(int value)
	{
		this.BlockCount = value;
	}

	public void SetBlockType(int value)
	{
		this.BlockType = value;
	}

	public void SetX1(int value)
	{
		this.X1 = value;
	}

	public void SetX2(int value)
	{
		this.X2 = value;
	}

	public void SetY1(int value)
	{
		this.Y1 = value;
	}

	public void SetY2(int value)
	{
		this.Y2 = value;
	}

	public void SetZ1(int value)
	{
		this.Z1 = value;
	}

	public void SetZ2(int value)
	{
		this.Z2 = value;
	}
	internal int X1;
	internal int X2;
	internal int Y1;
	internal int Y2;
	internal int Z1;
	internal int Z2;
}

public class Packet_ServerFillAreaLimit
{

	public int GetLimit()
	{
		return this.Limit;
	}
	internal int Limit;

	public void SetLimit(int value)
	{
		this.Limit = value;
	}
}

public class Packet_ServerFillAreaLimitSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerFillAreaLimit Deserialize(CitoStream stream, Packet_ServerFillAreaLimit instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.Limit = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerFillAreaLimit DeserializeBuffer(byte[] buffer, int length, Packet_ServerFillAreaLimit instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerFillAreaLimitSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerFillAreaLimit DeserializeLength(CitoStream stream, int length, Packet_ServerFillAreaLimit instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Limit = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerFillAreaLimit DeserializeLengthDelimited(CitoStream stream, Packet_ServerFillAreaLimit instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Limit = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerFillAreaLimit DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerFillAreaLimit instance = new Packet_ServerFillAreaLimit();
		Packet_ServerFillAreaLimitSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerFillAreaLimit instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.Limit);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerFillAreaLimit instance)
	{
		byte[] data = Packet_ServerFillAreaLimitSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerFillAreaLimit instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerFillAreaLimitSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerFillAreaSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerFillArea Deserialize(CitoStream stream, Packet_ServerFillArea instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.X1 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.X2 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Y1 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Y2 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.Z1 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.Z2 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.BlockType = ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.BlockCount = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerFillArea DeserializeBuffer(byte[] buffer, int length, Packet_ServerFillArea instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerFillAreaSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerFillArea DeserializeLength(CitoStream stream, int length, Packet_ServerFillArea instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.X1 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.X2 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Y1 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Y2 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.Z1 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.Z2 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.BlockType = ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.BlockCount = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerFillArea DeserializeLengthDelimited(CitoStream stream, Packet_ServerFillArea instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.X1 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.X2 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Y1 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Y2 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.Z1 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.Z2 = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.BlockType = ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.BlockCount = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerFillArea DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerFillArea instance = new Packet_ServerFillArea();
		Packet_ServerFillAreaSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerFillArea instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.X1);
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.X2);
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteUInt64(stream, instance.Y1);
		stream.WriteByte(ProtoPlatform.IntToByte(32));
		ProtocolParser.WriteUInt64(stream, instance.Y2);
		stream.WriteByte(ProtoPlatform.IntToByte(40));
		ProtocolParser.WriteUInt64(stream, instance.Z1);
		stream.WriteByte(ProtoPlatform.IntToByte(48));
		ProtocolParser.WriteUInt64(stream, instance.Z2);
		stream.WriteByte(ProtoPlatform.IntToByte(56));
		ProtocolParser.WriteUInt64(stream, instance.BlockType);
		stream.WriteByte(ProtoPlatform.IntToByte(64));
		ProtocolParser.WriteUInt64(stream, instance.BlockCount);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerFillArea instance)
	{
		byte[] data = Packet_ServerFillAreaSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerFillArea instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerFillAreaSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerFollow
{
	internal string Client;

	public string GetClient()
	{
		return this.Client;
	}

	public int GetTpp()
	{
		return this.Tpp;
	}

	public void SetClient(string value)
	{
		this.Client = value;
	}

	public void SetTpp(int value)
	{
		this.Tpp = value;
	}
	internal int Tpp;
}

public class Packet_ServerFollowSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerFollow Deserialize(CitoStream stream, Packet_ServerFollow instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.Client = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.Tpp = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerFollow DeserializeBuffer(byte[] buffer, int length, Packet_ServerFollow instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerFollowSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerFollow DeserializeLength(CitoStream stream, int length, Packet_ServerFollow instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.Client = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.Tpp = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerFollow DeserializeLengthDelimited(CitoStream stream, Packet_ServerFollow instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.Client = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.Tpp = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerFollow DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerFollow instance = new Packet_ServerFollow();
		Packet_ServerFollowSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerFollow instance)
	{
		if (instance.Client != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(10));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.Client));
		}
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.Tpp);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerFollow instance)
	{
		byte[] data = Packet_ServerFollowSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerFollow instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerFollowSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerFreemove
{

	public int GetIsEnabled()
	{
		return this.IsEnabled;
	}
	internal int IsEnabled;

	public void SetIsEnabled(int value)
	{
		this.IsEnabled = value;
	}
}

public class Packet_ServerFreemoveSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerFreemove Deserialize(CitoStream stream, Packet_ServerFreemove instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.IsEnabled = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerFreemove DeserializeBuffer(byte[] buffer, int length, Packet_ServerFreemove instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerFreemoveSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerFreemove DeserializeLength(CitoStream stream, int length, Packet_ServerFreemove instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.IsEnabled = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerFreemove DeserializeLengthDelimited(CitoStream stream, Packet_ServerFreemove instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.IsEnabled = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerFreemove DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerFreemove instance = new Packet_ServerFreemove();
		Packet_ServerFreemoveSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerFreemove instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.IsEnabled);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerFreemove instance)
	{
		byte[] data = Packet_ServerFreemoveSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerFreemove instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerFreemoveSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

/// <summary>&lt;summary&gt;
/// &lt;para&gt;needed for drawing shadows.&lt;/para&gt;
/// &lt;para&gt;sent before any chunks or blocks in the column.&lt;/para&gt;
/// &lt;/summary&gt;</summary>
public class Packet_ServerHeightmapChunk
{
	internal byte[] CompressedHeightmap;

	public byte[] GetCompressedHeightmap()
	{
		return this.CompressedHeightmap;
	}

	public int GetSizeX()
	{
		return this.SizeX;
	}

	public int GetSizeY()
	{
		return this.SizeY;
	}

	public int GetX()
	{
		return this.X;
	}

	public int GetY()
	{
		return this.Y;
	}

	public void SetCompressedHeightmap(byte[] value)
	{
		this.CompressedHeightmap = value;
	}

	public void SetSizeX(int value)
	{
		this.SizeX = value;
	}

	public void SetSizeY(int value)
	{
		this.SizeY = value;
	}

	public void SetX(int value)
	{
		this.X = value;
	}

	public void SetY(int value)
	{
		this.Y = value;
	}
	internal int SizeX;
	internal int SizeY;
	internal int X;
	internal int Y;
}

public class Packet_ServerHeightmapChunkSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerHeightmapChunk Deserialize(CitoStream stream, Packet_ServerHeightmapChunk instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.SizeX = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.SizeY = ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.CompressedHeightmap = ProtocolParser.ReadBytes(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerHeightmapChunk DeserializeBuffer(byte[] buffer, int length, Packet_ServerHeightmapChunk instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerHeightmapChunkSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerHeightmapChunk DeserializeLength(CitoStream stream, int length, Packet_ServerHeightmapChunk instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.SizeX = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.SizeY = ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.CompressedHeightmap = ProtocolParser.ReadBytes(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerHeightmapChunk DeserializeLengthDelimited(CitoStream stream, Packet_ServerHeightmapChunk instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.SizeX = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.SizeY = ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.CompressedHeightmap = ProtocolParser.ReadBytes(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerHeightmapChunk DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerHeightmapChunk instance = new Packet_ServerHeightmapChunk();
		Packet_ServerHeightmapChunkSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerHeightmapChunk instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.X);
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.Y);
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteUInt64(stream, instance.SizeX);
		stream.WriteByte(ProtoPlatform.IntToByte(32));
		ProtocolParser.WriteUInt64(stream, instance.SizeY);
		if (instance.CompressedHeightmap != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(42));
			ProtocolParser.WriteBytes(stream, instance.CompressedHeightmap);
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerHeightmapChunk instance)
	{
		byte[] data = Packet_ServerHeightmapChunkSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerHeightmapChunk instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerHeightmapChunkSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerIdEnum
{
	public const int ActiveMonsters = 25;
	public const int Ammo = 55;
	public const int BlobFinalize = 20;
	public const int BlobInitialize = 18;
	public const int BlobPart = 19;
	public const int BlockType = 56;
	public const int BlockTypes = 27;
	public const int Bullet = 54;
	public const int ChunkPart = 57;
	public const int Chunk_ = 15;
	public const int CraftingRecipes = 30;
	public const int Dialog = 52;
	public const int DisconnectPlayer = 14;
	public const int EntityDespawn = 68;
	public const int EntityPosition = 67;
	public const int EntitySpawn = 66;
	public const int Explosion = 58;
	public const int ExtendedPacketCommand = 100;
	public const int ExtendedPacketTick = 101;
	public const int FillArea = 61;
	public const int FillAreaLimit = 62;
	public const int FiniteInventory = 16;
	public const int Follow = 53;
	public const int Freemove = 51;
	public const int HeightmapChunk = 21;
	public const int LevelDataChunk = 3;
	public const int LevelFinalize = 4;
	public const int LevelInitialize = 2;
	public const int LightLevels = 29;
	public const int Message = 13;
	public const int Monster = 24;
	public const int Ping = 1;
	public const int PlayerPing = 111;
	public const int PlayerSpawnPosition = 26;
	public const int PlayerStats = 23;
	public const int Projectile = 59;
	public const int QueryAnswer = 64;
	public const int RemoveMonsters = 50;
	public const int Season = 17;
	public const int ServerIdentification = 0;
	public const int ServerRedirect = 65;
	public const int SetBlock = 6;
	public const int Sound = 22;
	public const int SunLevels = 28;
	public const int Translation = 60;
}

public class Packet_ServerIdentification
{
	internal int AssignedClientId;
	internal int DisableShadows;

	public int GetAssignedClientId()
	{
		return this.AssignedClientId;
	}

	public int GetDisableShadows()
	{
		return this.DisableShadows;
	}

	public int GetMapSizeX()
	{
		return this.MapSizeX;
	}

	public int GetMapSizeY()
	{
		return this.MapSizeY;
	}

	public int GetMapSizeZ()
	{
		return this.MapSizeZ;
	}

	public string GetMdProtocolVersion()
	{
		return this.MdProtocolVersion;
	}

	public int GetPlayerAreaSize()
	{
		return this.PlayerAreaSize;
	}

	public int GetRenderHint_()
	{
		return this.RenderHint_;
	}

	public Packet_StringList GetRequiredBlobMd5()
	{
		return this.RequiredBlobMd5;
	}

	public Packet_StringList GetRequiredBlobName()
	{
		return this.RequiredBlobName;
	}

	public string GetServerMotd()
	{
		return this.ServerMotd;
	}

	public string GetServerName()
	{
		return this.ServerName;
	}
	internal int MapSizeX;
	internal int MapSizeY;
	internal int MapSizeZ;
	internal string MdProtocolVersion;
	internal int PlayerAreaSize;
	internal int RenderHint_;
	internal Packet_StringList RequiredBlobMd5;
	internal Packet_StringList RequiredBlobName;
	internal string ServerMotd;
	internal string ServerName;

	public void SetAssignedClientId(int value)
	{
		this.AssignedClientId = value;
	}

	public void SetDisableShadows(int value)
	{
		this.DisableShadows = value;
	}

	public void SetMapSizeX(int value)
	{
		this.MapSizeX = value;
	}

	public void SetMapSizeY(int value)
	{
		this.MapSizeY = value;
	}

	public void SetMapSizeZ(int value)
	{
		this.MapSizeZ = value;
	}

	public void SetMdProtocolVersion(string value)
	{
		this.MdProtocolVersion = value;
	}

	public void SetPlayerAreaSize(int value)
	{
		this.PlayerAreaSize = value;
	}

	public void SetRenderHint_(int value)
	{
		this.RenderHint_ = value;
	}

	public void SetRequiredBlobMd5(Packet_StringList value)
	{
		this.RequiredBlobMd5 = value;
	}

	public void SetRequiredBlobName(Packet_StringList value)
	{
		this.RequiredBlobName = value;
	}

	public void SetServerMotd(string value)
	{
		this.ServerMotd = value;
	}

	public void SetServerName(string value)
	{
		this.ServerName = value;
	}
}

public class Packet_ServerIdentificationSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerIdentification Deserialize(CitoStream stream, Packet_ServerIdentification instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.MdProtocolVersion = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.AssignedClientId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.ServerName = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.ServerMotd = ProtocolParser.ReadString(stream);
				continue;
			case 56:
				instance.MapSizeX = ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.MapSizeY = ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.MapSizeZ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 88:
				instance.DisableShadows = ProtocolParser.ReadUInt64(stream);
				continue;
			case 96:
				instance.PlayerAreaSize = ProtocolParser.ReadUInt64(stream);
				continue;
			case 104:
				instance.RenderHint_ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 114:
				if (instance.RequiredBlobMd5 == null)
					instance.RequiredBlobMd5 = Packet_StringListSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_StringListSerializer.DeserializeLengthDelimited(stream, instance.RequiredBlobMd5);
				continue;
			case 122:
				if (instance.RequiredBlobName == null)
					instance.RequiredBlobName = Packet_StringListSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_StringListSerializer.DeserializeLengthDelimited(stream, instance.RequiredBlobName);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerIdentification DeserializeBuffer(byte[] buffer, int length, Packet_ServerIdentification instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerIdentificationSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerIdentification DeserializeLength(CitoStream stream, int length, Packet_ServerIdentification instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.MdProtocolVersion = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.AssignedClientId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.ServerName = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.ServerMotd = ProtocolParser.ReadString(stream);
				continue;
			case 56:
				instance.MapSizeX = ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.MapSizeY = ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.MapSizeZ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 88:
				instance.DisableShadows = ProtocolParser.ReadUInt64(stream);
				continue;
			case 96:
				instance.PlayerAreaSize = ProtocolParser.ReadUInt64(stream);
				continue;
			case 104:
				instance.RenderHint_ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 114:
				if (instance.RequiredBlobMd5 == null)
					instance.RequiredBlobMd5 = Packet_StringListSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_StringListSerializer.DeserializeLengthDelimited(stream, instance.RequiredBlobMd5);
				continue;
			case 122:
				if (instance.RequiredBlobName == null)
					instance.RequiredBlobName = Packet_StringListSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_StringListSerializer.DeserializeLengthDelimited(stream, instance.RequiredBlobName);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerIdentification DeserializeLengthDelimited(CitoStream stream, Packet_ServerIdentification instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.MdProtocolVersion = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.AssignedClientId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.ServerName = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.ServerMotd = ProtocolParser.ReadString(stream);
				continue;
			case 56:
				instance.MapSizeX = ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.MapSizeY = ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.MapSizeZ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 88:
				instance.DisableShadows = ProtocolParser.ReadUInt64(stream);
				continue;
			case 96:
				instance.PlayerAreaSize = ProtocolParser.ReadUInt64(stream);
				continue;
			case 104:
				instance.RenderHint_ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 114:
				if (instance.RequiredBlobMd5 == null)
					instance.RequiredBlobMd5 = Packet_StringListSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_StringListSerializer.DeserializeLengthDelimited(stream, instance.RequiredBlobMd5);
				continue;
			case 122:
				if (instance.RequiredBlobName == null)
					instance.RequiredBlobName = Packet_StringListSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_StringListSerializer.DeserializeLengthDelimited(stream, instance.RequiredBlobName);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerIdentification DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerIdentification instance = new Packet_ServerIdentification();
		Packet_ServerIdentificationSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerIdentification instance)
	{
		if (instance.MdProtocolVersion != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(10));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.MdProtocolVersion));
		}
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.AssignedClientId);
		if (instance.ServerName != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(26));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.ServerName));
		}
		if (instance.ServerMotd != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(34));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.ServerMotd));
		}
		stream.WriteByte(ProtoPlatform.IntToByte(56));
		ProtocolParser.WriteUInt64(stream, instance.MapSizeX);
		stream.WriteByte(ProtoPlatform.IntToByte(64));
		ProtocolParser.WriteUInt64(stream, instance.MapSizeY);
		stream.WriteByte(ProtoPlatform.IntToByte(72));
		ProtocolParser.WriteUInt64(stream, instance.MapSizeZ);
		stream.WriteByte(ProtoPlatform.IntToByte(88));
		ProtocolParser.WriteUInt64(stream, instance.DisableShadows);
		stream.WriteByte(ProtoPlatform.IntToByte(96));
		ProtocolParser.WriteUInt64(stream, instance.PlayerAreaSize);
		stream.WriteByte(ProtoPlatform.IntToByte(104));
		ProtocolParser.WriteUInt64(stream, instance.RenderHint_);
		if (instance.RequiredBlobMd5 != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(114));
			CitoMemoryStream ms14 = new CitoMemoryStream();
			Packet_StringListSerializer.Serialize(ms14, instance.RequiredBlobMd5);
			int ms14Length = ms14.Length();
			ProtocolParser.WriteUInt32_(stream, ms14Length);
			stream.Write(ms14.GetBuffer(), 0, ms14Length);
		}
		if (instance.RequiredBlobName != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(122));
			CitoMemoryStream ms15 = new CitoMemoryStream();
			Packet_StringListSerializer.Serialize(ms15, instance.RequiredBlobName);
			int ms15Length = ms15.Length();
			ProtocolParser.WriteUInt32_(stream, ms15Length);
			stream.Write(ms15.GetBuffer(), 0, ms15Length);
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerIdentification instance)
	{
		byte[] data = Packet_ServerIdentificationSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerIdentification instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerIdentificationSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerInventory
{

	public Packet_Inventory GetInventory()
	{
		return this.Inventory;
	}
	internal Packet_Inventory Inventory;

	public void SetInventory(Packet_Inventory value)
	{
		this.Inventory = value;
	}
}

public class Packet_ServerInventorySerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerInventory Deserialize(CitoStream stream, Packet_ServerInventory instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 34:
				if (instance.Inventory == null)
					instance.Inventory = Packet_InventorySerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_InventorySerializer.DeserializeLengthDelimited(stream, instance.Inventory);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerInventory DeserializeBuffer(byte[] buffer, int length, Packet_ServerInventory instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerInventorySerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerInventory DeserializeLength(CitoStream stream, int length, Packet_ServerInventory instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 34:
				if (instance.Inventory == null)
					instance.Inventory = Packet_InventorySerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_InventorySerializer.DeserializeLengthDelimited(stream, instance.Inventory);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerInventory DeserializeLengthDelimited(CitoStream stream, Packet_ServerInventory instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 34:
				if (instance.Inventory == null)
					instance.Inventory = Packet_InventorySerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_InventorySerializer.DeserializeLengthDelimited(stream, instance.Inventory);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerInventory DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerInventory instance = new Packet_ServerInventory();
		Packet_ServerInventorySerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerInventory instance)
	{
		if (instance.Inventory != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(34));
			CitoMemoryStream ms4 = new CitoMemoryStream();
			Packet_InventorySerializer.Serialize(ms4, instance.Inventory);
			int ms4Length = ms4.Length();
			ProtocolParser.WriteUInt32_(stream, ms4Length);
			stream.Write(ms4.GetBuffer(), 0, ms4Length);
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerInventory instance)
	{
		byte[] data = Packet_ServerInventorySerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerInventory instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerInventorySerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerLevelFinalize
{
}

public class Packet_ServerLevelFinalizeSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerLevelFinalize Deserialize(CitoStream stream, Packet_ServerLevelFinalize instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerLevelFinalize DeserializeBuffer(byte[] buffer, int length, Packet_ServerLevelFinalize instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerLevelFinalizeSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerLevelFinalize DeserializeLength(CitoStream stream, int length, Packet_ServerLevelFinalize instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerLevelFinalize DeserializeLengthDelimited(CitoStream stream, Packet_ServerLevelFinalize instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerLevelFinalize DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerLevelFinalize instance = new Packet_ServerLevelFinalize();
		Packet_ServerLevelFinalizeSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerLevelFinalize instance)
	{
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerLevelFinalize instance)
	{
		byte[] data = Packet_ServerLevelFinalizeSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerLevelFinalize instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerLevelFinalizeSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerLevelInitialize
{
}

public class Packet_ServerLevelInitializeSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerLevelInitialize Deserialize(CitoStream stream, Packet_ServerLevelInitialize instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerLevelInitialize DeserializeBuffer(byte[] buffer, int length, Packet_ServerLevelInitialize instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerLevelInitializeSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerLevelInitialize DeserializeLength(CitoStream stream, int length, Packet_ServerLevelInitialize instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerLevelInitialize DeserializeLengthDelimited(CitoStream stream, Packet_ServerLevelInitialize instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerLevelInitialize DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerLevelInitialize instance = new Packet_ServerLevelInitialize();
		Packet_ServerLevelInitializeSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerLevelInitialize instance)
	{
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerLevelInitialize instance)
	{
		byte[] data = Packet_ServerLevelInitializeSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerLevelInitialize instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerLevelInitializeSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerLevelProgress
{

	public int GetPercentComplete()
	{
		return this.PercentComplete;
	}

	public int GetPercentCompleteSubitem()
	{
		return this.PercentCompleteSubitem;
	}

	public string GetStatus()
	{
		return this.Status;
	}
	/// <summary>&lt;summary&gt;
	/// &lt;para&gt;[ProtoMember(1, IsRequired = false)]&lt;/para&gt;
	/// &lt;para&gt;optional byte[] Chunk;&lt;/para&gt;
	/// &lt;/summary&gt;</summary>
	internal int PercentComplete;
	internal int PercentCompleteSubitem;

	public void SetPercentComplete(int value)
	{
		this.PercentComplete = value;
	}

	public void SetPercentCompleteSubitem(int value)
	{
		this.PercentCompleteSubitem = value;
	}

	public void SetStatus(string value)
	{
		this.Status = value;
	}
	internal string Status;
}

public class Packet_ServerLevelProgressSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerLevelProgress Deserialize(CitoStream stream, Packet_ServerLevelProgress instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 16:
				instance.PercentComplete = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.Status = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.PercentCompleteSubitem = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerLevelProgress DeserializeBuffer(byte[] buffer, int length, Packet_ServerLevelProgress instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerLevelProgressSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerLevelProgress DeserializeLength(CitoStream stream, int length, Packet_ServerLevelProgress instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 16:
				instance.PercentComplete = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.Status = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.PercentCompleteSubitem = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerLevelProgress DeserializeLengthDelimited(CitoStream stream, Packet_ServerLevelProgress instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 16:
				instance.PercentComplete = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.Status = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.PercentCompleteSubitem = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerLevelProgress DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerLevelProgress instance = new Packet_ServerLevelProgress();
		Packet_ServerLevelProgressSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerLevelProgress instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.PercentComplete);
		if (instance.Status != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(26));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.Status));
		}
		stream.WriteByte(ProtoPlatform.IntToByte(32));
		ProtocolParser.WriteUInt64(stream, instance.PercentCompleteSubitem);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerLevelProgress instance)
	{
		byte[] data = Packet_ServerLevelProgressSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerLevelProgress instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerLevelProgressSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerLightLevels
{

	public int[] GetLightlevels()
	{
		return this.Lightlevels;
	}

	public int GetLightlevelsCount()
	{
		return this.LightlevelsCount;
	}

	public int GetLightlevelsLength()
	{
		return this.LightlevelsLength;
	}
	internal int[] Lightlevels;

	public void LightlevelsAdd(int value)
	{
		if (this.LightlevelsCount >= this.LightlevelsLength) {
			int[] Lightlevels2 = new int[this.LightlevelsLength * 2];
			this.LightlevelsLength = this.LightlevelsLength * 2;
			for (int i = 0; i < this.LightlevelsCount; i++) {
				Lightlevels2[i] = this.Lightlevels[i];
			}
			this.Lightlevels = Lightlevels2;
		}
		this.Lightlevels[this.LightlevelsCount] = value;
		this.LightlevelsCount++;
	}
	internal int LightlevelsCount;
	internal int LightlevelsLength;

	public void SetLightlevels(int[] value, int count, int length)
	{
		this.Lightlevels = value;
		this.LightlevelsCount = count;
		this.LightlevelsLength = length;
	}
}

public class Packet_ServerLightLevelsSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerLightLevels Deserialize(CitoStream stream, Packet_ServerLightLevels instance)
	{
		if (instance.Lightlevels == null) {
			instance.Lightlevels = new int[1];
			instance.LightlevelsCount = 0;
			instance.LightlevelsLength = 1;
		}
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.LightlevelsAdd(ProtocolParser.ReadUInt64(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerLightLevels DeserializeBuffer(byte[] buffer, int length, Packet_ServerLightLevels instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerLightLevelsSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerLightLevels DeserializeLength(CitoStream stream, int length, Packet_ServerLightLevels instance)
	{
		if (instance.Lightlevels == null) {
			instance.Lightlevels = new int[1];
			instance.LightlevelsCount = 0;
			instance.LightlevelsLength = 1;
		}
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.LightlevelsAdd(ProtocolParser.ReadUInt64(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerLightLevels DeserializeLengthDelimited(CitoStream stream, Packet_ServerLightLevels instance)
	{
		if (instance.Lightlevels == null) {
			instance.Lightlevels = new int[1];
			instance.LightlevelsCount = 0;
			instance.LightlevelsLength = 1;
		}
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.LightlevelsAdd(ProtocolParser.ReadUInt64(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerLightLevels DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerLightLevels instance = new Packet_ServerLightLevels();
		Packet_ServerLightLevelsSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerLightLevels instance)
	{
		if (instance.Lightlevels != null) {
			for (int k = 0; k < instance.LightlevelsCount; k++) {
				int i1 = instance.Lightlevels[k];
				stream.WriteByte(ProtoPlatform.IntToByte(8));
				ProtocolParser.WriteUInt64(stream, i1);
			}
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerLightLevels instance)
	{
		byte[] data = Packet_ServerLightLevelsSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerLightLevels instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerLightLevelsSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerMessage
{

	public string GetMessage()
	{
		return this.Message;
	}
	/// <summary>&lt;summary&gt; optional int32 playerId = 1;&lt;/summary&gt;</summary>
	internal string Message;

	public void SetMessage(string value)
	{
		this.Message = value;
	}
}

public class Packet_ServerMessageSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerMessage Deserialize(CitoStream stream, Packet_ServerMessage instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 18:
				instance.Message = ProtocolParser.ReadString(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerMessage DeserializeBuffer(byte[] buffer, int length, Packet_ServerMessage instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerMessageSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerMessage DeserializeLength(CitoStream stream, int length, Packet_ServerMessage instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 18:
				instance.Message = ProtocolParser.ReadString(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerMessage DeserializeLengthDelimited(CitoStream stream, Packet_ServerMessage instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 18:
				instance.Message = ProtocolParser.ReadString(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerMessage DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerMessage instance = new Packet_ServerMessage();
		Packet_ServerMessageSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerMessage instance)
	{
		if (instance.Message != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(18));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.Message));
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerMessage instance)
	{
		byte[] data = Packet_ServerMessageSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerMessage instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerMessageSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerMonster
{

	public int GetHealth()
	{
		return this.Health;
	}

	public int GetId()
	{
		return this.Id;
	}

	public int GetMonsterType()
	{
		return this.MonsterType;
	}

	public Packet_PositionAndOrientation GetPositionAndOrientation()
	{
		return this.PositionAndOrientation;
	}
	internal int Health;
	internal int Id;
	internal int MonsterType;
	internal Packet_PositionAndOrientation PositionAndOrientation;

	public void SetHealth(int value)
	{
		this.Health = value;
	}

	public void SetId(int value)
	{
		this.Id = value;
	}

	public void SetMonsterType(int value)
	{
		this.MonsterType = value;
	}

	public void SetPositionAndOrientation(Packet_PositionAndOrientation value)
	{
		this.PositionAndOrientation = value;
	}
}

public class Packet_ServerMonsterSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerMonster Deserialize(CitoStream stream, Packet_ServerMonster instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.Id = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.MonsterType = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				if (instance.PositionAndOrientation == null)
					instance.PositionAndOrientation = Packet_PositionAndOrientationSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_PositionAndOrientationSerializer.DeserializeLengthDelimited(stream, instance.PositionAndOrientation);
				continue;
			case 32:
				instance.Health = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerMonster DeserializeBuffer(byte[] buffer, int length, Packet_ServerMonster instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerMonsterSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerMonster DeserializeLength(CitoStream stream, int length, Packet_ServerMonster instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Id = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.MonsterType = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				if (instance.PositionAndOrientation == null)
					instance.PositionAndOrientation = Packet_PositionAndOrientationSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_PositionAndOrientationSerializer.DeserializeLengthDelimited(stream, instance.PositionAndOrientation);
				continue;
			case 32:
				instance.Health = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerMonster DeserializeLengthDelimited(CitoStream stream, Packet_ServerMonster instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.Id = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.MonsterType = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				if (instance.PositionAndOrientation == null)
					instance.PositionAndOrientation = Packet_PositionAndOrientationSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_PositionAndOrientationSerializer.DeserializeLengthDelimited(stream, instance.PositionAndOrientation);
				continue;
			case 32:
				instance.Health = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerMonster DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerMonster instance = new Packet_ServerMonster();
		Packet_ServerMonsterSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerMonster instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.Id);
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.MonsterType);
		if (instance.PositionAndOrientation != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(26));
			CitoMemoryStream ms3 = new CitoMemoryStream();
			Packet_PositionAndOrientationSerializer.Serialize(ms3, instance.PositionAndOrientation);
			int ms3Length = ms3.Length();
			ProtocolParser.WriteUInt32_(stream, ms3Length);
			stream.Write(ms3.GetBuffer(), 0, ms3Length);
		}
		stream.WriteByte(ProtoPlatform.IntToByte(32));
		ProtocolParser.WriteUInt64(stream, instance.Health);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerMonster instance)
	{
		byte[] data = Packet_ServerMonsterSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerMonster instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerMonsterSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerMonsters
{

	public Packet_ServerMonster[] GetMonsters()
	{
		return this.Monsters;
	}

	public int GetMonstersCount()
	{
		return this.MonstersCount;
	}

	public int GetMonstersLength()
	{
		return this.MonstersLength;
	}
	internal Packet_ServerMonster[] Monsters;

	public void MonstersAdd(Packet_ServerMonster value)
	{
		if (this.MonstersCount >= this.MonstersLength) {
			Packet_ServerMonster[] Monsters2 = new Packet_ServerMonster[this.MonstersLength * 2];
			this.MonstersLength = this.MonstersLength * 2;
			for (int i = 0; i < this.MonstersCount; i++) {
				Monsters2[i] = this.Monsters[i];
			}
			this.Monsters = Monsters2;
		}
		this.Monsters[this.MonstersCount] = value;
		this.MonstersCount++;
	}
	internal int MonstersCount;
	internal int MonstersLength;

	public void SetMonsters(Packet_ServerMonster[] value, int count, int length)
	{
		this.Monsters = value;
		this.MonstersCount = count;
		this.MonstersLength = length;
	}
}

public class Packet_ServerMonstersSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerMonsters Deserialize(CitoStream stream, Packet_ServerMonsters instance)
	{
		if (instance.Monsters == null) {
			instance.Monsters = new Packet_ServerMonster[1];
			instance.MonstersCount = 0;
			instance.MonstersLength = 1;
		}
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.MonstersAdd(Packet_ServerMonsterSerializer.DeserializeLengthDelimitedNew(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerMonsters DeserializeBuffer(byte[] buffer, int length, Packet_ServerMonsters instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerMonstersSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerMonsters DeserializeLength(CitoStream stream, int length, Packet_ServerMonsters instance)
	{
		if (instance.Monsters == null) {
			instance.Monsters = new Packet_ServerMonster[1];
			instance.MonstersCount = 0;
			instance.MonstersLength = 1;
		}
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.MonstersAdd(Packet_ServerMonsterSerializer.DeserializeLengthDelimitedNew(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerMonsters DeserializeLengthDelimited(CitoStream stream, Packet_ServerMonsters instance)
	{
		if (instance.Monsters == null) {
			instance.Monsters = new Packet_ServerMonster[1];
			instance.MonstersCount = 0;
			instance.MonstersLength = 1;
		}
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.MonstersAdd(Packet_ServerMonsterSerializer.DeserializeLengthDelimitedNew(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerMonsters DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerMonsters instance = new Packet_ServerMonsters();
		Packet_ServerMonstersSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerMonsters instance)
	{
		if (instance.Monsters != null) {
			for (int k = 0; k < instance.MonstersCount; k++) {
				Packet_ServerMonster i1 = instance.Monsters[k];
				stream.WriteByte(ProtoPlatform.IntToByte(10));
				CitoMemoryStream ms1 = new CitoMemoryStream();
				Packet_ServerMonsterSerializer.Serialize(ms1, i1);
				int ms1Length = ms1.Length();
				ProtocolParser.WriteUInt32_(stream, ms1Length);
				stream.Write(ms1.GetBuffer(), 0, ms1Length);
			}
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerMonsters instance)
	{
		byte[] data = Packet_ServerMonstersSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerMonsters instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerMonstersSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerPing
{
}

public class Packet_ServerPingSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerPing Deserialize(CitoStream stream, Packet_ServerPing instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerPing DeserializeBuffer(byte[] buffer, int length, Packet_ServerPing instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerPingSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerPing DeserializeLength(CitoStream stream, int length, Packet_ServerPing instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerPing DeserializeLengthDelimited(CitoStream stream, Packet_ServerPing instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerPing DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerPing instance = new Packet_ServerPing();
		Packet_ServerPingSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerPing instance)
	{
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerPing instance)
	{
		byte[] data = Packet_ServerPingSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerPing instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerPingSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerPlayerPing
{
	internal int ClientId;

	public int GetClientId()
	{
		return this.ClientId;
	}

	public int GetPing()
	{
		return this.Ping;
	}
	internal int Ping;

	public void SetClientId(int value)
	{
		this.ClientId = value;
	}

	public void SetPing(int value)
	{
		this.Ping = value;
	}
}

public class Packet_ServerPlayerPingSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerPlayerPing Deserialize(CitoStream stream, Packet_ServerPlayerPing instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.ClientId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Ping = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerPlayerPing DeserializeBuffer(byte[] buffer, int length, Packet_ServerPlayerPing instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerPlayerPingSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerPlayerPing DeserializeLength(CitoStream stream, int length, Packet_ServerPlayerPing instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.ClientId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Ping = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerPlayerPing DeserializeLengthDelimited(CitoStream stream, Packet_ServerPlayerPing instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.ClientId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Ping = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerPlayerPing DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerPlayerPing instance = new Packet_ServerPlayerPing();
		Packet_ServerPlayerPingSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerPlayerPing instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.ClientId);
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.Ping);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerPlayerPing instance)
	{
		byte[] data = Packet_ServerPlayerPingSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerPlayerPing instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerPlayerPingSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerPlayerSpawnPosition
{

	public int GetX()
	{
		return this.X;
	}

	public int GetY()
	{
		return this.Y;
	}

	public int GetZ()
	{
		return this.Z;
	}

	public void SetX(int value)
	{
		this.X = value;
	}

	public void SetY(int value)
	{
		this.Y = value;
	}

	public void SetZ(int value)
	{
		this.Z = value;
	}
	internal int X;
	internal int Y;
	internal int Z;
}

public class Packet_ServerPlayerSpawnPositionSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerPlayerSpawnPosition Deserialize(CitoStream stream, Packet_ServerPlayerSpawnPosition instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerPlayerSpawnPosition DeserializeBuffer(byte[] buffer, int length, Packet_ServerPlayerSpawnPosition instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerPlayerSpawnPositionSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerPlayerSpawnPosition DeserializeLength(CitoStream stream, int length, Packet_ServerPlayerSpawnPosition instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerPlayerSpawnPosition DeserializeLengthDelimited(CitoStream stream, Packet_ServerPlayerSpawnPosition instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerPlayerSpawnPosition DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerPlayerSpawnPosition instance = new Packet_ServerPlayerSpawnPosition();
		Packet_ServerPlayerSpawnPositionSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerPlayerSpawnPosition instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.X);
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.Y);
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteUInt64(stream, instance.Z);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerPlayerSpawnPosition instance)
	{
		byte[] data = Packet_ServerPlayerSpawnPositionSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerPlayerSpawnPosition instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerPlayerSpawnPositionSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerPlayerStats
{
	internal int CurrentHealth;
	internal int CurrentOxygen;

	public int GetCurrentHealth()
	{
		return this.CurrentHealth;
	}

	public int GetCurrentOxygen()
	{
		return this.CurrentOxygen;
	}

	public int GetMaxHealth()
	{
		return this.MaxHealth;
	}

	public int GetMaxOxygen()
	{
		return this.MaxOxygen;
	}
	internal int MaxHealth;
	internal int MaxOxygen;

	public void SetCurrentHealth(int value)
	{
		this.CurrentHealth = value;
	}

	public void SetCurrentOxygen(int value)
	{
		this.CurrentOxygen = value;
	}

	public void SetMaxHealth(int value)
	{
		this.MaxHealth = value;
	}

	public void SetMaxOxygen(int value)
	{
		this.MaxOxygen = value;
	}
}

public class Packet_ServerPlayerStatsSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerPlayerStats Deserialize(CitoStream stream, Packet_ServerPlayerStats instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.CurrentHealth = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.MaxHealth = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.CurrentOxygen = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.MaxOxygen = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerPlayerStats DeserializeBuffer(byte[] buffer, int length, Packet_ServerPlayerStats instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerPlayerStatsSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerPlayerStats DeserializeLength(CitoStream stream, int length, Packet_ServerPlayerStats instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.CurrentHealth = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.MaxHealth = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.CurrentOxygen = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.MaxOxygen = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerPlayerStats DeserializeLengthDelimited(CitoStream stream, Packet_ServerPlayerStats instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.CurrentHealth = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.MaxHealth = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.CurrentOxygen = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.MaxOxygen = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerPlayerStats DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerPlayerStats instance = new Packet_ServerPlayerStats();
		Packet_ServerPlayerStatsSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerPlayerStats instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.CurrentHealth);
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.MaxHealth);
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteUInt64(stream, instance.CurrentOxygen);
		stream.WriteByte(ProtoPlatform.IntToByte(32));
		ProtocolParser.WriteUInt64(stream, instance.MaxOxygen);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerPlayerStats instance)
	{
		byte[] data = Packet_ServerPlayerStatsSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerPlayerStats instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerPlayerStatsSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerProjectile
{
	internal int BlockId;
	internal int ExplodesAfterFloat;
	internal int FromXFloat;
	internal int FromYFloat;
	internal int FromZFloat;

	public int GetBlockId()
	{
		return this.BlockId;
	}

	public int GetExplodesAfterFloat()
	{
		return this.ExplodesAfterFloat;
	}

	public int GetFromXFloat()
	{
		return this.FromXFloat;
	}

	public int GetFromYFloat()
	{
		return this.FromYFloat;
	}

	public int GetFromZFloat()
	{
		return this.FromZFloat;
	}

	public int GetSourcePlayerID()
	{
		return this.SourcePlayerID;
	}

	public int GetVelocityXFloat()
	{
		return this.VelocityXFloat;
	}

	public int GetVelocityYFloat()
	{
		return this.VelocityYFloat;
	}

	public int GetVelocityZFloat()
	{
		return this.VelocityZFloat;
	}

	public void SetBlockId(int value)
	{
		this.BlockId = value;
	}

	public void SetExplodesAfterFloat(int value)
	{
		this.ExplodesAfterFloat = value;
	}

	public void SetFromXFloat(int value)
	{
		this.FromXFloat = value;
	}

	public void SetFromYFloat(int value)
	{
		this.FromYFloat = value;
	}

	public void SetFromZFloat(int value)
	{
		this.FromZFloat = value;
	}

	public void SetSourcePlayerID(int value)
	{
		this.SourcePlayerID = value;
	}

	public void SetVelocityXFloat(int value)
	{
		this.VelocityXFloat = value;
	}

	public void SetVelocityYFloat(int value)
	{
		this.VelocityYFloat = value;
	}

	public void SetVelocityZFloat(int value)
	{
		this.VelocityZFloat = value;
	}
	internal int SourcePlayerID;
	internal int VelocityXFloat;
	internal int VelocityYFloat;
	internal int VelocityZFloat;
}

public class Packet_ServerProjectileSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerProjectile Deserialize(CitoStream stream, Packet_ServerProjectile instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.FromXFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.FromYFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.FromZFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.VelocityXFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.VelocityYFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.VelocityZFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.BlockId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.ExplodesAfterFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.SourcePlayerID = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerProjectile DeserializeBuffer(byte[] buffer, int length, Packet_ServerProjectile instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerProjectileSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerProjectile DeserializeLength(CitoStream stream, int length, Packet_ServerProjectile instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.FromXFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.FromYFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.FromZFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.VelocityXFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.VelocityYFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.VelocityZFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.BlockId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.ExplodesAfterFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.SourcePlayerID = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerProjectile DeserializeLengthDelimited(CitoStream stream, Packet_ServerProjectile instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.FromXFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.FromYFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.FromZFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.VelocityXFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.VelocityYFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.VelocityZFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.BlockId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 64:
				instance.ExplodesAfterFloat = ProtocolParser.ReadUInt64(stream);
				continue;
			case 72:
				instance.SourcePlayerID = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerProjectile DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerProjectile instance = new Packet_ServerProjectile();
		Packet_ServerProjectileSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerProjectile instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.FromXFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.FromYFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteUInt64(stream, instance.FromZFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(32));
		ProtocolParser.WriteUInt64(stream, instance.VelocityXFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(40));
		ProtocolParser.WriteUInt64(stream, instance.VelocityYFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(48));
		ProtocolParser.WriteUInt64(stream, instance.VelocityZFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(56));
		ProtocolParser.WriteUInt64(stream, instance.BlockId);
		stream.WriteByte(ProtoPlatform.IntToByte(64));
		ProtocolParser.WriteUInt64(stream, instance.ExplodesAfterFloat);
		stream.WriteByte(ProtoPlatform.IntToByte(72));
		ProtocolParser.WriteUInt64(stream, instance.SourcePlayerID);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerProjectile instance)
	{
		byte[] data = Packet_ServerProjectileSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerProjectile instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerProjectileSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerQueryAnswer
{
	internal string GameMode;

	public string GetGameMode()
	{
		return this.GameMode;
	}

	public string GetMOTD()
	{
		return this.MOTD;
	}

	public int GetMapSizeX()
	{
		return this.MapSizeX;
	}

	public int GetMapSizeY()
	{
		return this.MapSizeY;
	}

	public int GetMapSizeZ()
	{
		return this.MapSizeZ;
	}

	public int GetMaxPlayers()
	{
		return this.MaxPlayers;
	}

	public string GetName()
	{
		return this.Name;
	}

	public bool GetPassword()
	{
		return this.Password;
	}

	public int GetPlayerCount()
	{
		return this.PlayerCount;
	}

	public string GetPlayerList()
	{
		return this.PlayerList;
	}

	public int GetPort()
	{
		return this.Port;
	}

	public string GetPublicHash()
	{
		return this.PublicHash;
	}

	public byte[] GetServerThumbnail()
	{
		return this.ServerThumbnail;
	}

	public string GetServerVersion()
	{
		return this.ServerVersion;
	}
	internal string MOTD;
	internal int MapSizeX;
	internal int MapSizeY;
	internal int MapSizeZ;
	internal int MaxPlayers;
	internal string Name;
	internal bool Password;
	internal int PlayerCount;
	internal string PlayerList;
	internal int Port;
	internal string PublicHash;
	internal byte[] ServerThumbnail;
	internal string ServerVersion;

	public void SetGameMode(string value)
	{
		this.GameMode = value;
	}

	public void SetMOTD(string value)
	{
		this.MOTD = value;
	}

	public void SetMapSizeX(int value)
	{
		this.MapSizeX = value;
	}

	public void SetMapSizeY(int value)
	{
		this.MapSizeY = value;
	}

	public void SetMapSizeZ(int value)
	{
		this.MapSizeZ = value;
	}

	public void SetMaxPlayers(int value)
	{
		this.MaxPlayers = value;
	}

	public void SetName(string value)
	{
		this.Name = value;
	}

	public void SetPassword(bool value)
	{
		this.Password = value;
	}

	public void SetPlayerCount(int value)
	{
		this.PlayerCount = value;
	}

	public void SetPlayerList(string value)
	{
		this.PlayerList = value;
	}

	public void SetPort(int value)
	{
		this.Port = value;
	}

	public void SetPublicHash(string value)
	{
		this.PublicHash = value;
	}

	public void SetServerThumbnail(byte[] value)
	{
		this.ServerThumbnail = value;
	}

	public void SetServerVersion(string value)
	{
		this.ServerVersion = value;
	}
}

public class Packet_ServerQueryAnswerSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerQueryAnswer Deserialize(CitoStream stream, Packet_ServerQueryAnswer instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.Name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.MOTD = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.PlayerCount = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.MaxPlayers = ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.PlayerList = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.Port = ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				instance.GameMode = ProtocolParser.ReadString(stream);
				continue;
			case 64:
				instance.Password = ProtocolParser.ReadBool(stream);
				continue;
			case 74:
				instance.PublicHash = ProtocolParser.ReadString(stream);
				continue;
			case 82:
				instance.ServerVersion = ProtocolParser.ReadString(stream);
				continue;
			case 88:
				instance.MapSizeX = ProtocolParser.ReadUInt64(stream);
				continue;
			case 96:
				instance.MapSizeY = ProtocolParser.ReadUInt64(stream);
				continue;
			case 104:
				instance.MapSizeZ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 114:
				instance.ServerThumbnail = ProtocolParser.ReadBytes(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerQueryAnswer DeserializeBuffer(byte[] buffer, int length, Packet_ServerQueryAnswer instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerQueryAnswerSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerQueryAnswer DeserializeLength(CitoStream stream, int length, Packet_ServerQueryAnswer instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.Name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.MOTD = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.PlayerCount = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.MaxPlayers = ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.PlayerList = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.Port = ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				instance.GameMode = ProtocolParser.ReadString(stream);
				continue;
			case 64:
				instance.Password = ProtocolParser.ReadBool(stream);
				continue;
			case 74:
				instance.PublicHash = ProtocolParser.ReadString(stream);
				continue;
			case 82:
				instance.ServerVersion = ProtocolParser.ReadString(stream);
				continue;
			case 88:
				instance.MapSizeX = ProtocolParser.ReadUInt64(stream);
				continue;
			case 96:
				instance.MapSizeY = ProtocolParser.ReadUInt64(stream);
				continue;
			case 104:
				instance.MapSizeZ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 114:
				instance.ServerThumbnail = ProtocolParser.ReadBytes(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerQueryAnswer DeserializeLengthDelimited(CitoStream stream, Packet_ServerQueryAnswer instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.Name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.MOTD = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.PlayerCount = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.MaxPlayers = ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.PlayerList = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.Port = ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				instance.GameMode = ProtocolParser.ReadString(stream);
				continue;
			case 64:
				instance.Password = ProtocolParser.ReadBool(stream);
				continue;
			case 74:
				instance.PublicHash = ProtocolParser.ReadString(stream);
				continue;
			case 82:
				instance.ServerVersion = ProtocolParser.ReadString(stream);
				continue;
			case 88:
				instance.MapSizeX = ProtocolParser.ReadUInt64(stream);
				continue;
			case 96:
				instance.MapSizeY = ProtocolParser.ReadUInt64(stream);
				continue;
			case 104:
				instance.MapSizeZ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 114:
				instance.ServerThumbnail = ProtocolParser.ReadBytes(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerQueryAnswer DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerQueryAnswer instance = new Packet_ServerQueryAnswer();
		Packet_ServerQueryAnswerSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerQueryAnswer instance)
	{
		if (instance.Name != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(10));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.Name));
		}
		if (instance.MOTD != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(18));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.MOTD));
		}
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteUInt64(stream, instance.PlayerCount);
		stream.WriteByte(ProtoPlatform.IntToByte(32));
		ProtocolParser.WriteUInt64(stream, instance.MaxPlayers);
		if (instance.PlayerList != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(42));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.PlayerList));
		}
		stream.WriteByte(ProtoPlatform.IntToByte(48));
		ProtocolParser.WriteUInt64(stream, instance.Port);
		if (instance.GameMode != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(58));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.GameMode));
		}
		stream.WriteByte(ProtoPlatform.IntToByte(64));
		ProtocolParser.WriteBool(stream, instance.Password);
		if (instance.PublicHash != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(74));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.PublicHash));
		}
		if (instance.ServerVersion != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(82));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.ServerVersion));
		}
		stream.WriteByte(ProtoPlatform.IntToByte(88));
		ProtocolParser.WriteUInt64(stream, instance.MapSizeX);
		stream.WriteByte(ProtoPlatform.IntToByte(96));
		ProtocolParser.WriteUInt64(stream, instance.MapSizeY);
		stream.WriteByte(ProtoPlatform.IntToByte(104));
		ProtocolParser.WriteUInt64(stream, instance.MapSizeZ);
		if (instance.ServerThumbnail != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(114));
			ProtocolParser.WriteBytes(stream, instance.ServerThumbnail);
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerQueryAnswer instance)
	{
		byte[] data = Packet_ServerQueryAnswerSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerQueryAnswer instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerQueryAnswerSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerRedirect
{

	public string GetIP()
	{
		return this.IP;
	}

	public int GetPort()
	{
		return this.Port;
	}
	internal string IP;
	internal int Port;

	public void SetIP(string value)
	{
		this.IP = value;
	}

	public void SetPort(int value)
	{
		this.Port = value;
	}
}

public class Packet_ServerRedirectSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerRedirect Deserialize(CitoStream stream, Packet_ServerRedirect instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.IP = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.Port = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerRedirect DeserializeBuffer(byte[] buffer, int length, Packet_ServerRedirect instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerRedirectSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerRedirect DeserializeLength(CitoStream stream, int length, Packet_ServerRedirect instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.IP = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.Port = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerRedirect DeserializeLengthDelimited(CitoStream stream, Packet_ServerRedirect instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.IP = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.Port = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerRedirect DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerRedirect instance = new Packet_ServerRedirect();
		Packet_ServerRedirectSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerRedirect instance)
	{
		if (instance.IP != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(10));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.IP));
		}
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.Port);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerRedirect instance)
	{
		byte[] data = Packet_ServerRedirectSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerRedirect instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerRedirectSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerSeason
{
	/// <summary>&lt;summary&gt;1-24*4&lt;/summary&gt;</summary>
	internal int DayNightCycleSpeedup;

	public int GetDayNightCycleSpeedup()
	{
		return this.DayNightCycleSpeedup;
	}

	public int GetHour()
	{
		return this.Hour;
	}

	public int GetMoon()
	{
		return this.Moon;
	}
	/// <summary>&lt;summary&gt;optional int32 Season;&lt;/summary&gt;</summary>
	internal int Hour;
	/// <summary>&lt;summary&gt;used for predicting sun speed.&lt;/summary&gt;</summary>
	internal int Moon;

	public void SetDayNightCycleSpeedup(int value)
	{
		this.DayNightCycleSpeedup = value;
	}

	public void SetHour(int value)
	{
		this.Hour = value;
	}

	public void SetMoon(int value)
	{
		this.Moon = value;
	}
}

public class Packet_ServerSeasonSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerSeason Deserialize(CitoStream stream, Packet_ServerSeason instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 16:
				instance.Hour = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.DayNightCycleSpeedup = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Moon = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerSeason DeserializeBuffer(byte[] buffer, int length, Packet_ServerSeason instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerSeasonSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerSeason DeserializeLength(CitoStream stream, int length, Packet_ServerSeason instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 16:
				instance.Hour = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.DayNightCycleSpeedup = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Moon = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerSeason DeserializeLengthDelimited(CitoStream stream, Packet_ServerSeason instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 16:
				instance.Hour = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.DayNightCycleSpeedup = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Moon = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerSeason DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerSeason instance = new Packet_ServerSeason();
		Packet_ServerSeasonSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerSeason instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.Hour);
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteUInt64(stream, instance.DayNightCycleSpeedup);
		stream.WriteByte(ProtoPlatform.IntToByte(32));
		ProtocolParser.WriteUInt64(stream, instance.Moon);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerSeason instance)
	{
		byte[] data = Packet_ServerSeasonSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerSeason instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerSeasonSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_Server Deserialize(CitoStream stream, Packet_Server instance)
	{
		instance.Id = 0;
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				if (instance.Identification == null)
					instance.Identification = Packet_ServerIdentificationSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerIdentificationSerializer.DeserializeLengthDelimited(stream, instance.Identification);
				continue;
			case 18:
				if (instance.LevelInitialize == null)
					instance.LevelInitialize = Packet_ServerLevelInitializeSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerLevelInitializeSerializer.DeserializeLengthDelimited(stream, instance.LevelInitialize);
				continue;
			case 26:
				if (instance.LevelDataChunk == null)
					instance.LevelDataChunk = Packet_ServerLevelProgressSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerLevelProgressSerializer.DeserializeLengthDelimited(stream, instance.LevelDataChunk);
				continue;
			case 34:
				if (instance.LevelFinalize == null)
					instance.LevelFinalize = Packet_ServerLevelFinalizeSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerLevelFinalizeSerializer.DeserializeLengthDelimited(stream, instance.LevelFinalize);
				continue;
			case 42:
				if (instance.SetBlock == null)
					instance.SetBlock = Packet_ServerSetBlockSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerSetBlockSerializer.DeserializeLengthDelimited(stream, instance.SetBlock);
				continue;
			case 74:
				if (instance.Message == null)
					instance.Message = Packet_ServerMessageSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerMessageSerializer.DeserializeLengthDelimited(stream, instance.Message);
				continue;
			case 82:
				if (instance.DisconnectPlayer == null)
					instance.DisconnectPlayer = Packet_ServerDisconnectPlayerSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerDisconnectPlayerSerializer.DeserializeLengthDelimited(stream, instance.DisconnectPlayer);
				continue;
			case 90:
				if (instance.Chunk_ == null)
					instance.Chunk_ = Packet_ServerChunkSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerChunkSerializer.DeserializeLengthDelimited(stream, instance.Chunk_);
				continue;
			case 98:
				if (instance.Inventory == null)
					instance.Inventory = Packet_ServerInventorySerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerInventorySerializer.DeserializeLengthDelimited(stream, instance.Inventory);
				continue;
			case 106:
				if (instance.Season == null)
					instance.Season = Packet_ServerSeasonSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerSeasonSerializer.DeserializeLengthDelimited(stream, instance.Season);
				continue;
			case 114:
				if (instance.BlobInitialize == null)
					instance.BlobInitialize = Packet_ServerBlobInitializeSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerBlobInitializeSerializer.DeserializeLengthDelimited(stream, instance.BlobInitialize);
				continue;
			case 122:
				if (instance.BlobPart == null)
					instance.BlobPart = Packet_ServerBlobPartSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerBlobPartSerializer.DeserializeLengthDelimited(stream, instance.BlobPart);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			case 90:
				if (key.GetWireType() != 0)
					break;
				instance.Id = ProtocolParser.ReadUInt64(stream);
				continue;
			case 51:
				if (key.GetWireType() != 2)
					break;
				if (instance.FillArea == null)
					instance.FillArea = Packet_ServerFillAreaSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerFillAreaSerializer.DeserializeLengthDelimited(stream, instance.FillArea);
				continue;
			case 52:
				if (key.GetWireType() != 2)
					break;
				if (instance.FillAreaLimit == null)
					instance.FillAreaLimit = Packet_ServerFillAreaLimitSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerFillAreaLimitSerializer.DeserializeLengthDelimited(stream, instance.FillAreaLimit);
				continue;
			case 53:
				if (key.GetWireType() != 2)
					break;
				if (instance.Freemove == null)
					instance.Freemove = Packet_ServerFreemoveSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerFreemoveSerializer.DeserializeLengthDelimited(stream, instance.Freemove);
				continue;
			case 16:
				if (key.GetWireType() != 2)
					break;
				if (instance.BlobFinalize == null)
					instance.BlobFinalize = Packet_ServerBlobFinalizeSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerBlobFinalizeSerializer.DeserializeLengthDelimited(stream, instance.BlobFinalize);
				continue;
			case 17:
				if (key.GetWireType() != 2)
					break;
				if (instance.HeightmapChunk == null)
					instance.HeightmapChunk = Packet_ServerHeightmapChunkSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerHeightmapChunkSerializer.DeserializeLengthDelimited(stream, instance.HeightmapChunk);
				continue;
			case 18:
				if (key.GetWireType() != 2)
					break;
				if (instance.Ping == null)
					instance.Ping = Packet_ServerPingSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerPingSerializer.DeserializeLengthDelimited(stream, instance.Ping);
				continue;
			case 181:
				if (key.GetWireType() != 2)
					break;
				if (instance.PlayerPing == null)
					instance.PlayerPing = Packet_ServerPlayerPingSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerPlayerPingSerializer.DeserializeLengthDelimited(stream, instance.PlayerPing);
				continue;
			case 19:
				if (key.GetWireType() != 2)
					break;
				if (instance.Sound == null)
					instance.Sound = Packet_ServerSoundSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerSoundSerializer.DeserializeLengthDelimited(stream, instance.Sound);
				continue;
			case 20:
				if (key.GetWireType() != 2)
					break;
				if (instance.PlayerStats == null)
					instance.PlayerStats = Packet_ServerPlayerStatsSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerPlayerStatsSerializer.DeserializeLengthDelimited(stream, instance.PlayerStats);
				continue;
			case 21:
				if (key.GetWireType() != 2)
					break;
				if (instance.Monster == null)
					instance.Monster = Packet_ServerMonstersSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerMonstersSerializer.DeserializeLengthDelimited(stream, instance.Monster);
				continue;
			case 22:
				if (key.GetWireType() != 2)
					break;
				if (instance.PlayerSpawnPosition == null)
					instance.PlayerSpawnPosition = Packet_ServerPlayerSpawnPositionSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerPlayerSpawnPositionSerializer.DeserializeLengthDelimited(stream, instance.PlayerSpawnPosition);
				continue;
			case 23:
				if (key.GetWireType() != 2)
					break;
				if (instance.BlockTypes == null)
					instance.BlockTypes = Packet_ServerBlockTypesSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerBlockTypesSerializer.DeserializeLengthDelimited(stream, instance.BlockTypes);
				continue;
			case 24:
				if (key.GetWireType() != 2)
					break;
				if (instance.SunLevels == null)
					instance.SunLevels = Packet_ServerSunLevelsSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerSunLevelsSerializer.DeserializeLengthDelimited(stream, instance.SunLevels);
				continue;
			case 25:
				if (key.GetWireType() != 2)
					break;
				if (instance.LightLevels == null)
					instance.LightLevels = Packet_ServerLightLevelsSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerLightLevelsSerializer.DeserializeLengthDelimited(stream, instance.LightLevels);
				continue;
			case 26:
				if (key.GetWireType() != 2)
					break;
				if (instance.CraftingRecipes == null)
					instance.CraftingRecipes = Packet_ServerCraftingRecipesSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerCraftingRecipesSerializer.DeserializeLengthDelimited(stream, instance.CraftingRecipes);
				continue;
			case 27:
				if (key.GetWireType() != 2)
					break;
				if (instance.Dialog == null)
					instance.Dialog = Packet_ServerDialogSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerDialogSerializer.DeserializeLengthDelimited(stream, instance.Dialog);
				continue;
			case 28:
				if (key.GetWireType() != 2)
					break;
				if (instance.Follow == null)
					instance.Follow = Packet_ServerFollowSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerFollowSerializer.DeserializeLengthDelimited(stream, instance.Follow);
				continue;
			case 29:
				if (key.GetWireType() != 2)
					break;
				if (instance.Bullet == null)
					instance.Bullet = Packet_ServerBulletSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerBulletSerializer.DeserializeLengthDelimited(stream, instance.Bullet);
				continue;
			case 30:
				if (key.GetWireType() != 2)
					break;
				if (instance.Ammo == null)
					instance.Ammo = Packet_ServerAmmoSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerAmmoSerializer.DeserializeLengthDelimited(stream, instance.Ammo);
				continue;
			case 31:
				if (key.GetWireType() != 2)
					break;
				if (instance.BlockType == null)
					instance.BlockType = Packet_ServerBlockTypeSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerBlockTypeSerializer.DeserializeLengthDelimited(stream, instance.BlockType);
				continue;
			case 32:
				if (key.GetWireType() != 2)
					break;
				if (instance.ChunkPart == null)
					instance.ChunkPart = Packet_ServerChunkPartSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerChunkPartSerializer.DeserializeLengthDelimited(stream, instance.ChunkPart);
				continue;
			case 33:
				if (key.GetWireType() != 2)
					break;
				if (instance.Explosion == null)
					instance.Explosion = Packet_ServerExplosionSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerExplosionSerializer.DeserializeLengthDelimited(stream, instance.Explosion);
				continue;
			case 34:
				if (key.GetWireType() != 2)
					break;
				if (instance.Projectile == null)
					instance.Projectile = Packet_ServerProjectileSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerProjectileSerializer.DeserializeLengthDelimited(stream, instance.Projectile);
				continue;
			case 35:
				if (key.GetWireType() != 2)
					break;
				if (instance.Translation == null)
					instance.Translation = Packet_ServerTranslatedStringSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerTranslatedStringSerializer.DeserializeLengthDelimited(stream, instance.Translation);
				continue;
			case 36:
				if (key.GetWireType() != 2)
					break;
				if (instance.QueryAnswer == null)
					instance.QueryAnswer = Packet_ServerQueryAnswerSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerQueryAnswerSerializer.DeserializeLengthDelimited(stream, instance.QueryAnswer);
				continue;
			case 37:
				if (key.GetWireType() != 2)
					break;
				if (instance.Redirect == null)
					instance.Redirect = Packet_ServerRedirectSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerRedirectSerializer.DeserializeLengthDelimited(stream, instance.Redirect);
				continue;
			case 39:
				if (key.GetWireType() != 2)
					break;
				if (instance.EntitySpawn == null)
					instance.EntitySpawn = Packet_ServerEntitySpawnSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntitySpawnSerializer.DeserializeLengthDelimited(stream, instance.EntitySpawn);
				continue;
			case 40:
				if (key.GetWireType() != 2)
					break;
				if (instance.EntityPosition == null)
					instance.EntityPosition = Packet_ServerEntityPositionAndOrientationSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntityPositionAndOrientationSerializer.DeserializeLengthDelimited(stream, instance.EntityPosition);
				continue;
			case 41:
				if (key.GetWireType() != 2)
					break;
				if (instance.EntityDespawn == null)
					instance.EntityDespawn = Packet_ServerEntityDespawnSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntityDespawnSerializer.DeserializeLengthDelimited(stream, instance.EntityDespawn);
				continue;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_Server DeserializeBuffer(byte[] buffer, int length, Packet_Server instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_Server DeserializeLength(CitoStream stream, int length, Packet_Server instance)
	{
		instance.Id = 0;
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				if (instance.Identification == null)
					instance.Identification = Packet_ServerIdentificationSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerIdentificationSerializer.DeserializeLengthDelimited(stream, instance.Identification);
				continue;
			case 18:
				if (instance.LevelInitialize == null)
					instance.LevelInitialize = Packet_ServerLevelInitializeSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerLevelInitializeSerializer.DeserializeLengthDelimited(stream, instance.LevelInitialize);
				continue;
			case 26:
				if (instance.LevelDataChunk == null)
					instance.LevelDataChunk = Packet_ServerLevelProgressSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerLevelProgressSerializer.DeserializeLengthDelimited(stream, instance.LevelDataChunk);
				continue;
			case 34:
				if (instance.LevelFinalize == null)
					instance.LevelFinalize = Packet_ServerLevelFinalizeSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerLevelFinalizeSerializer.DeserializeLengthDelimited(stream, instance.LevelFinalize);
				continue;
			case 42:
				if (instance.SetBlock == null)
					instance.SetBlock = Packet_ServerSetBlockSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerSetBlockSerializer.DeserializeLengthDelimited(stream, instance.SetBlock);
				continue;
			case 74:
				if (instance.Message == null)
					instance.Message = Packet_ServerMessageSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerMessageSerializer.DeserializeLengthDelimited(stream, instance.Message);
				continue;
			case 82:
				if (instance.DisconnectPlayer == null)
					instance.DisconnectPlayer = Packet_ServerDisconnectPlayerSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerDisconnectPlayerSerializer.DeserializeLengthDelimited(stream, instance.DisconnectPlayer);
				continue;
			case 90:
				if (instance.Chunk_ == null)
					instance.Chunk_ = Packet_ServerChunkSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerChunkSerializer.DeserializeLengthDelimited(stream, instance.Chunk_);
				continue;
			case 98:
				if (instance.Inventory == null)
					instance.Inventory = Packet_ServerInventorySerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerInventorySerializer.DeserializeLengthDelimited(stream, instance.Inventory);
				continue;
			case 106:
				if (instance.Season == null)
					instance.Season = Packet_ServerSeasonSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerSeasonSerializer.DeserializeLengthDelimited(stream, instance.Season);
				continue;
			case 114:
				if (instance.BlobInitialize == null)
					instance.BlobInitialize = Packet_ServerBlobInitializeSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerBlobInitializeSerializer.DeserializeLengthDelimited(stream, instance.BlobInitialize);
				continue;
			case 122:
				if (instance.BlobPart == null)
					instance.BlobPart = Packet_ServerBlobPartSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerBlobPartSerializer.DeserializeLengthDelimited(stream, instance.BlobPart);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			case 90:
				if (key.GetWireType() != 0)
					break;
				instance.Id = ProtocolParser.ReadUInt64(stream);
				continue;
			case 51:
				if (key.GetWireType() != 2)
					break;
				if (instance.FillArea == null)
					instance.FillArea = Packet_ServerFillAreaSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerFillAreaSerializer.DeserializeLengthDelimited(stream, instance.FillArea);
				continue;
			case 52:
				if (key.GetWireType() != 2)
					break;
				if (instance.FillAreaLimit == null)
					instance.FillAreaLimit = Packet_ServerFillAreaLimitSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerFillAreaLimitSerializer.DeserializeLengthDelimited(stream, instance.FillAreaLimit);
				continue;
			case 53:
				if (key.GetWireType() != 2)
					break;
				if (instance.Freemove == null)
					instance.Freemove = Packet_ServerFreemoveSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerFreemoveSerializer.DeserializeLengthDelimited(stream, instance.Freemove);
				continue;
			case 16:
				if (key.GetWireType() != 2)
					break;
				if (instance.BlobFinalize == null)
					instance.BlobFinalize = Packet_ServerBlobFinalizeSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerBlobFinalizeSerializer.DeserializeLengthDelimited(stream, instance.BlobFinalize);
				continue;
			case 17:
				if (key.GetWireType() != 2)
					break;
				if (instance.HeightmapChunk == null)
					instance.HeightmapChunk = Packet_ServerHeightmapChunkSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerHeightmapChunkSerializer.DeserializeLengthDelimited(stream, instance.HeightmapChunk);
				continue;
			case 18:
				if (key.GetWireType() != 2)
					break;
				if (instance.Ping == null)
					instance.Ping = Packet_ServerPingSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerPingSerializer.DeserializeLengthDelimited(stream, instance.Ping);
				continue;
			case 181:
				if (key.GetWireType() != 2)
					break;
				if (instance.PlayerPing == null)
					instance.PlayerPing = Packet_ServerPlayerPingSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerPlayerPingSerializer.DeserializeLengthDelimited(stream, instance.PlayerPing);
				continue;
			case 19:
				if (key.GetWireType() != 2)
					break;
				if (instance.Sound == null)
					instance.Sound = Packet_ServerSoundSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerSoundSerializer.DeserializeLengthDelimited(stream, instance.Sound);
				continue;
			case 20:
				if (key.GetWireType() != 2)
					break;
				if (instance.PlayerStats == null)
					instance.PlayerStats = Packet_ServerPlayerStatsSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerPlayerStatsSerializer.DeserializeLengthDelimited(stream, instance.PlayerStats);
				continue;
			case 21:
				if (key.GetWireType() != 2)
					break;
				if (instance.Monster == null)
					instance.Monster = Packet_ServerMonstersSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerMonstersSerializer.DeserializeLengthDelimited(stream, instance.Monster);
				continue;
			case 22:
				if (key.GetWireType() != 2)
					break;
				if (instance.PlayerSpawnPosition == null)
					instance.PlayerSpawnPosition = Packet_ServerPlayerSpawnPositionSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerPlayerSpawnPositionSerializer.DeserializeLengthDelimited(stream, instance.PlayerSpawnPosition);
				continue;
			case 23:
				if (key.GetWireType() != 2)
					break;
				if (instance.BlockTypes == null)
					instance.BlockTypes = Packet_ServerBlockTypesSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerBlockTypesSerializer.DeserializeLengthDelimited(stream, instance.BlockTypes);
				continue;
			case 24:
				if (key.GetWireType() != 2)
					break;
				if (instance.SunLevels == null)
					instance.SunLevels = Packet_ServerSunLevelsSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerSunLevelsSerializer.DeserializeLengthDelimited(stream, instance.SunLevels);
				continue;
			case 25:
				if (key.GetWireType() != 2)
					break;
				if (instance.LightLevels == null)
					instance.LightLevels = Packet_ServerLightLevelsSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerLightLevelsSerializer.DeserializeLengthDelimited(stream, instance.LightLevels);
				continue;
			case 26:
				if (key.GetWireType() != 2)
					break;
				if (instance.CraftingRecipes == null)
					instance.CraftingRecipes = Packet_ServerCraftingRecipesSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerCraftingRecipesSerializer.DeserializeLengthDelimited(stream, instance.CraftingRecipes);
				continue;
			case 27:
				if (key.GetWireType() != 2)
					break;
				if (instance.Dialog == null)
					instance.Dialog = Packet_ServerDialogSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerDialogSerializer.DeserializeLengthDelimited(stream, instance.Dialog);
				continue;
			case 28:
				if (key.GetWireType() != 2)
					break;
				if (instance.Follow == null)
					instance.Follow = Packet_ServerFollowSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerFollowSerializer.DeserializeLengthDelimited(stream, instance.Follow);
				continue;
			case 29:
				if (key.GetWireType() != 2)
					break;
				if (instance.Bullet == null)
					instance.Bullet = Packet_ServerBulletSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerBulletSerializer.DeserializeLengthDelimited(stream, instance.Bullet);
				continue;
			case 30:
				if (key.GetWireType() != 2)
					break;
				if (instance.Ammo == null)
					instance.Ammo = Packet_ServerAmmoSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerAmmoSerializer.DeserializeLengthDelimited(stream, instance.Ammo);
				continue;
			case 31:
				if (key.GetWireType() != 2)
					break;
				if (instance.BlockType == null)
					instance.BlockType = Packet_ServerBlockTypeSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerBlockTypeSerializer.DeserializeLengthDelimited(stream, instance.BlockType);
				continue;
			case 32:
				if (key.GetWireType() != 2)
					break;
				if (instance.ChunkPart == null)
					instance.ChunkPart = Packet_ServerChunkPartSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerChunkPartSerializer.DeserializeLengthDelimited(stream, instance.ChunkPart);
				continue;
			case 33:
				if (key.GetWireType() != 2)
					break;
				if (instance.Explosion == null)
					instance.Explosion = Packet_ServerExplosionSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerExplosionSerializer.DeserializeLengthDelimited(stream, instance.Explosion);
				continue;
			case 34:
				if (key.GetWireType() != 2)
					break;
				if (instance.Projectile == null)
					instance.Projectile = Packet_ServerProjectileSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerProjectileSerializer.DeserializeLengthDelimited(stream, instance.Projectile);
				continue;
			case 35:
				if (key.GetWireType() != 2)
					break;
				if (instance.Translation == null)
					instance.Translation = Packet_ServerTranslatedStringSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerTranslatedStringSerializer.DeserializeLengthDelimited(stream, instance.Translation);
				continue;
			case 36:
				if (key.GetWireType() != 2)
					break;
				if (instance.QueryAnswer == null)
					instance.QueryAnswer = Packet_ServerQueryAnswerSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerQueryAnswerSerializer.DeserializeLengthDelimited(stream, instance.QueryAnswer);
				continue;
			case 37:
				if (key.GetWireType() != 2)
					break;
				if (instance.Redirect == null)
					instance.Redirect = Packet_ServerRedirectSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerRedirectSerializer.DeserializeLengthDelimited(stream, instance.Redirect);
				continue;
			case 39:
				if (key.GetWireType() != 2)
					break;
				if (instance.EntitySpawn == null)
					instance.EntitySpawn = Packet_ServerEntitySpawnSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntitySpawnSerializer.DeserializeLengthDelimited(stream, instance.EntitySpawn);
				continue;
			case 40:
				if (key.GetWireType() != 2)
					break;
				if (instance.EntityPosition == null)
					instance.EntityPosition = Packet_ServerEntityPositionAndOrientationSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntityPositionAndOrientationSerializer.DeserializeLengthDelimited(stream, instance.EntityPosition);
				continue;
			case 41:
				if (key.GetWireType() != 2)
					break;
				if (instance.EntityDespawn == null)
					instance.EntityDespawn = Packet_ServerEntityDespawnSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntityDespawnSerializer.DeserializeLengthDelimited(stream, instance.EntityDespawn);
				continue;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_Server DeserializeLengthDelimited(CitoStream stream, Packet_Server instance)
	{
		instance.Id = 0;
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				if (instance.Identification == null)
					instance.Identification = Packet_ServerIdentificationSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerIdentificationSerializer.DeserializeLengthDelimited(stream, instance.Identification);
				continue;
			case 18:
				if (instance.LevelInitialize == null)
					instance.LevelInitialize = Packet_ServerLevelInitializeSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerLevelInitializeSerializer.DeserializeLengthDelimited(stream, instance.LevelInitialize);
				continue;
			case 26:
				if (instance.LevelDataChunk == null)
					instance.LevelDataChunk = Packet_ServerLevelProgressSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerLevelProgressSerializer.DeserializeLengthDelimited(stream, instance.LevelDataChunk);
				continue;
			case 34:
				if (instance.LevelFinalize == null)
					instance.LevelFinalize = Packet_ServerLevelFinalizeSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerLevelFinalizeSerializer.DeserializeLengthDelimited(stream, instance.LevelFinalize);
				continue;
			case 42:
				if (instance.SetBlock == null)
					instance.SetBlock = Packet_ServerSetBlockSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerSetBlockSerializer.DeserializeLengthDelimited(stream, instance.SetBlock);
				continue;
			case 74:
				if (instance.Message == null)
					instance.Message = Packet_ServerMessageSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerMessageSerializer.DeserializeLengthDelimited(stream, instance.Message);
				continue;
			case 82:
				if (instance.DisconnectPlayer == null)
					instance.DisconnectPlayer = Packet_ServerDisconnectPlayerSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerDisconnectPlayerSerializer.DeserializeLengthDelimited(stream, instance.DisconnectPlayer);
				continue;
			case 90:
				if (instance.Chunk_ == null)
					instance.Chunk_ = Packet_ServerChunkSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerChunkSerializer.DeserializeLengthDelimited(stream, instance.Chunk_);
				continue;
			case 98:
				if (instance.Inventory == null)
					instance.Inventory = Packet_ServerInventorySerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerInventorySerializer.DeserializeLengthDelimited(stream, instance.Inventory);
				continue;
			case 106:
				if (instance.Season == null)
					instance.Season = Packet_ServerSeasonSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerSeasonSerializer.DeserializeLengthDelimited(stream, instance.Season);
				continue;
			case 114:
				if (instance.BlobInitialize == null)
					instance.BlobInitialize = Packet_ServerBlobInitializeSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerBlobInitializeSerializer.DeserializeLengthDelimited(stream, instance.BlobInitialize);
				continue;
			case 122:
				if (instance.BlobPart == null)
					instance.BlobPart = Packet_ServerBlobPartSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerBlobPartSerializer.DeserializeLengthDelimited(stream, instance.BlobPart);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			case 90:
				if (key.GetWireType() != 0)
					break;
				instance.Id = ProtocolParser.ReadUInt64(stream);
				continue;
			case 51:
				if (key.GetWireType() != 2)
					break;
				if (instance.FillArea == null)
					instance.FillArea = Packet_ServerFillAreaSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerFillAreaSerializer.DeserializeLengthDelimited(stream, instance.FillArea);
				continue;
			case 52:
				if (key.GetWireType() != 2)
					break;
				if (instance.FillAreaLimit == null)
					instance.FillAreaLimit = Packet_ServerFillAreaLimitSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerFillAreaLimitSerializer.DeserializeLengthDelimited(stream, instance.FillAreaLimit);
				continue;
			case 53:
				if (key.GetWireType() != 2)
					break;
				if (instance.Freemove == null)
					instance.Freemove = Packet_ServerFreemoveSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerFreemoveSerializer.DeserializeLengthDelimited(stream, instance.Freemove);
				continue;
			case 16:
				if (key.GetWireType() != 2)
					break;
				if (instance.BlobFinalize == null)
					instance.BlobFinalize = Packet_ServerBlobFinalizeSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerBlobFinalizeSerializer.DeserializeLengthDelimited(stream, instance.BlobFinalize);
				continue;
			case 17:
				if (key.GetWireType() != 2)
					break;
				if (instance.HeightmapChunk == null)
					instance.HeightmapChunk = Packet_ServerHeightmapChunkSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerHeightmapChunkSerializer.DeserializeLengthDelimited(stream, instance.HeightmapChunk);
				continue;
			case 18:
				if (key.GetWireType() != 2)
					break;
				if (instance.Ping == null)
					instance.Ping = Packet_ServerPingSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerPingSerializer.DeserializeLengthDelimited(stream, instance.Ping);
				continue;
			case 181:
				if (key.GetWireType() != 2)
					break;
				if (instance.PlayerPing == null)
					instance.PlayerPing = Packet_ServerPlayerPingSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerPlayerPingSerializer.DeserializeLengthDelimited(stream, instance.PlayerPing);
				continue;
			case 19:
				if (key.GetWireType() != 2)
					break;
				if (instance.Sound == null)
					instance.Sound = Packet_ServerSoundSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerSoundSerializer.DeserializeLengthDelimited(stream, instance.Sound);
				continue;
			case 20:
				if (key.GetWireType() != 2)
					break;
				if (instance.PlayerStats == null)
					instance.PlayerStats = Packet_ServerPlayerStatsSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerPlayerStatsSerializer.DeserializeLengthDelimited(stream, instance.PlayerStats);
				continue;
			case 21:
				if (key.GetWireType() != 2)
					break;
				if (instance.Monster == null)
					instance.Monster = Packet_ServerMonstersSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerMonstersSerializer.DeserializeLengthDelimited(stream, instance.Monster);
				continue;
			case 22:
				if (key.GetWireType() != 2)
					break;
				if (instance.PlayerSpawnPosition == null)
					instance.PlayerSpawnPosition = Packet_ServerPlayerSpawnPositionSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerPlayerSpawnPositionSerializer.DeserializeLengthDelimited(stream, instance.PlayerSpawnPosition);
				continue;
			case 23:
				if (key.GetWireType() != 2)
					break;
				if (instance.BlockTypes == null)
					instance.BlockTypes = Packet_ServerBlockTypesSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerBlockTypesSerializer.DeserializeLengthDelimited(stream, instance.BlockTypes);
				continue;
			case 24:
				if (key.GetWireType() != 2)
					break;
				if (instance.SunLevels == null)
					instance.SunLevels = Packet_ServerSunLevelsSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerSunLevelsSerializer.DeserializeLengthDelimited(stream, instance.SunLevels);
				continue;
			case 25:
				if (key.GetWireType() != 2)
					break;
				if (instance.LightLevels == null)
					instance.LightLevels = Packet_ServerLightLevelsSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerLightLevelsSerializer.DeserializeLengthDelimited(stream, instance.LightLevels);
				continue;
			case 26:
				if (key.GetWireType() != 2)
					break;
				if (instance.CraftingRecipes == null)
					instance.CraftingRecipes = Packet_ServerCraftingRecipesSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerCraftingRecipesSerializer.DeserializeLengthDelimited(stream, instance.CraftingRecipes);
				continue;
			case 27:
				if (key.GetWireType() != 2)
					break;
				if (instance.Dialog == null)
					instance.Dialog = Packet_ServerDialogSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerDialogSerializer.DeserializeLengthDelimited(stream, instance.Dialog);
				continue;
			case 28:
				if (key.GetWireType() != 2)
					break;
				if (instance.Follow == null)
					instance.Follow = Packet_ServerFollowSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerFollowSerializer.DeserializeLengthDelimited(stream, instance.Follow);
				continue;
			case 29:
				if (key.GetWireType() != 2)
					break;
				if (instance.Bullet == null)
					instance.Bullet = Packet_ServerBulletSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerBulletSerializer.DeserializeLengthDelimited(stream, instance.Bullet);
				continue;
			case 30:
				if (key.GetWireType() != 2)
					break;
				if (instance.Ammo == null)
					instance.Ammo = Packet_ServerAmmoSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerAmmoSerializer.DeserializeLengthDelimited(stream, instance.Ammo);
				continue;
			case 31:
				if (key.GetWireType() != 2)
					break;
				if (instance.BlockType == null)
					instance.BlockType = Packet_ServerBlockTypeSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerBlockTypeSerializer.DeserializeLengthDelimited(stream, instance.BlockType);
				continue;
			case 32:
				if (key.GetWireType() != 2)
					break;
				if (instance.ChunkPart == null)
					instance.ChunkPart = Packet_ServerChunkPartSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerChunkPartSerializer.DeserializeLengthDelimited(stream, instance.ChunkPart);
				continue;
			case 33:
				if (key.GetWireType() != 2)
					break;
				if (instance.Explosion == null)
					instance.Explosion = Packet_ServerExplosionSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerExplosionSerializer.DeserializeLengthDelimited(stream, instance.Explosion);
				continue;
			case 34:
				if (key.GetWireType() != 2)
					break;
				if (instance.Projectile == null)
					instance.Projectile = Packet_ServerProjectileSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerProjectileSerializer.DeserializeLengthDelimited(stream, instance.Projectile);
				continue;
			case 35:
				if (key.GetWireType() != 2)
					break;
				if (instance.Translation == null)
					instance.Translation = Packet_ServerTranslatedStringSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerTranslatedStringSerializer.DeserializeLengthDelimited(stream, instance.Translation);
				continue;
			case 36:
				if (key.GetWireType() != 2)
					break;
				if (instance.QueryAnswer == null)
					instance.QueryAnswer = Packet_ServerQueryAnswerSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerQueryAnswerSerializer.DeserializeLengthDelimited(stream, instance.QueryAnswer);
				continue;
			case 37:
				if (key.GetWireType() != 2)
					break;
				if (instance.Redirect == null)
					instance.Redirect = Packet_ServerRedirectSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerRedirectSerializer.DeserializeLengthDelimited(stream, instance.Redirect);
				continue;
			case 39:
				if (key.GetWireType() != 2)
					break;
				if (instance.EntitySpawn == null)
					instance.EntitySpawn = Packet_ServerEntitySpawnSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntitySpawnSerializer.DeserializeLengthDelimited(stream, instance.EntitySpawn);
				continue;
			case 40:
				if (key.GetWireType() != 2)
					break;
				if (instance.EntityPosition == null)
					instance.EntityPosition = Packet_ServerEntityPositionAndOrientationSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntityPositionAndOrientationSerializer.DeserializeLengthDelimited(stream, instance.EntityPosition);
				continue;
			case 41:
				if (key.GetWireType() != 2)
					break;
				if (instance.EntityDespawn == null)
					instance.EntityDespawn = Packet_ServerEntityDespawnSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_ServerEntityDespawnSerializer.DeserializeLengthDelimited(stream, instance.EntityDespawn);
				continue;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_Server DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_Server instance = new Packet_Server();
		Packet_ServerSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_Server instance)
	{
		if (instance.Id != 0) {
			stream.WriteByte(ProtoPlatform.IntToByte(208));
			stream.WriteByte(ProtoPlatform.IntToByte(5));
			ProtocolParser.WriteUInt64(stream, instance.Id);
		}
		if (instance.Identification != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(10));
			CitoMemoryStream ms1 = new CitoMemoryStream();
			Packet_ServerIdentificationSerializer.Serialize(ms1, instance.Identification);
			int ms1Length = ms1.Length();
			ProtocolParser.WriteUInt32_(stream, ms1Length);
			stream.Write(ms1.GetBuffer(), 0, ms1Length);
		}
		if (instance.LevelInitialize != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(18));
			CitoMemoryStream ms2 = new CitoMemoryStream();
			Packet_ServerLevelInitializeSerializer.Serialize(ms2, instance.LevelInitialize);
			int ms2Length = ms2.Length();
			ProtocolParser.WriteUInt32_(stream, ms2Length);
			stream.Write(ms2.GetBuffer(), 0, ms2Length);
		}
		if (instance.LevelDataChunk != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(26));
			CitoMemoryStream ms3 = new CitoMemoryStream();
			Packet_ServerLevelProgressSerializer.Serialize(ms3, instance.LevelDataChunk);
			int ms3Length = ms3.Length();
			ProtocolParser.WriteUInt32_(stream, ms3Length);
			stream.Write(ms3.GetBuffer(), 0, ms3Length);
		}
		if (instance.LevelFinalize != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(34));
			CitoMemoryStream ms4 = new CitoMemoryStream();
			Packet_ServerLevelFinalizeSerializer.Serialize(ms4, instance.LevelFinalize);
			int ms4Length = ms4.Length();
			ProtocolParser.WriteUInt32_(stream, ms4Length);
			stream.Write(ms4.GetBuffer(), 0, ms4Length);
		}
		if (instance.SetBlock != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(42));
			CitoMemoryStream ms5 = new CitoMemoryStream();
			Packet_ServerSetBlockSerializer.Serialize(ms5, instance.SetBlock);
			int ms5Length = ms5.Length();
			ProtocolParser.WriteUInt32_(stream, ms5Length);
			stream.Write(ms5.GetBuffer(), 0, ms5Length);
		}
		if (instance.FillArea != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(154));
			stream.WriteByte(ProtoPlatform.IntToByte(3));
			CitoMemoryStream ms51 = new CitoMemoryStream();
			Packet_ServerFillAreaSerializer.Serialize(ms51, instance.FillArea);
			int ms51Length = ms51.Length();
			ProtocolParser.WriteUInt32_(stream, ms51Length);
			stream.Write(ms51.GetBuffer(), 0, ms51Length);
		}
		if (instance.FillAreaLimit != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(162));
			stream.WriteByte(ProtoPlatform.IntToByte(3));
			CitoMemoryStream ms52 = new CitoMemoryStream();
			Packet_ServerFillAreaLimitSerializer.Serialize(ms52, instance.FillAreaLimit);
			int ms52Length = ms52.Length();
			ProtocolParser.WriteUInt32_(stream, ms52Length);
			stream.Write(ms52.GetBuffer(), 0, ms52Length);
		}
		if (instance.Freemove != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(170));
			stream.WriteByte(ProtoPlatform.IntToByte(3));
			CitoMemoryStream ms53 = new CitoMemoryStream();
			Packet_ServerFreemoveSerializer.Serialize(ms53, instance.Freemove);
			int ms53Length = ms53.Length();
			ProtocolParser.WriteUInt32_(stream, ms53Length);
			stream.Write(ms53.GetBuffer(), 0, ms53Length);
		}
		if (instance.Message != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(74));
			CitoMemoryStream ms9 = new CitoMemoryStream();
			Packet_ServerMessageSerializer.Serialize(ms9, instance.Message);
			int ms9Length = ms9.Length();
			ProtocolParser.WriteUInt32_(stream, ms9Length);
			stream.Write(ms9.GetBuffer(), 0, ms9Length);
		}
		if (instance.DisconnectPlayer != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(82));
			CitoMemoryStream ms10 = new CitoMemoryStream();
			Packet_ServerDisconnectPlayerSerializer.Serialize(ms10, instance.DisconnectPlayer);
			int ms10Length = ms10.Length();
			ProtocolParser.WriteUInt32_(stream, ms10Length);
			stream.Write(ms10.GetBuffer(), 0, ms10Length);
		}
		if (instance.Chunk_ != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(90));
			CitoMemoryStream ms11 = new CitoMemoryStream();
			Packet_ServerChunkSerializer.Serialize(ms11, instance.Chunk_);
			int ms11Length = ms11.Length();
			ProtocolParser.WriteUInt32_(stream, ms11Length);
			stream.Write(ms11.GetBuffer(), 0, ms11Length);
		}
		if (instance.Inventory != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(98));
			CitoMemoryStream ms12 = new CitoMemoryStream();
			Packet_ServerInventorySerializer.Serialize(ms12, instance.Inventory);
			int ms12Length = ms12.Length();
			ProtocolParser.WriteUInt32_(stream, ms12Length);
			stream.Write(ms12.GetBuffer(), 0, ms12Length);
		}
		if (instance.Season != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(106));
			CitoMemoryStream ms13 = new CitoMemoryStream();
			Packet_ServerSeasonSerializer.Serialize(ms13, instance.Season);
			int ms13Length = ms13.Length();
			ProtocolParser.WriteUInt32_(stream, ms13Length);
			stream.Write(ms13.GetBuffer(), 0, ms13Length);
		}
		if (instance.BlobInitialize != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(114));
			CitoMemoryStream ms14 = new CitoMemoryStream();
			Packet_ServerBlobInitializeSerializer.Serialize(ms14, instance.BlobInitialize);
			int ms14Length = ms14.Length();
			ProtocolParser.WriteUInt32_(stream, ms14Length);
			stream.Write(ms14.GetBuffer(), 0, ms14Length);
		}
		if (instance.BlobPart != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(122));
			CitoMemoryStream ms15 = new CitoMemoryStream();
			Packet_ServerBlobPartSerializer.Serialize(ms15, instance.BlobPart);
			int ms15Length = ms15.Length();
			ProtocolParser.WriteUInt32_(stream, ms15Length);
			stream.Write(ms15.GetBuffer(), 0, ms15Length);
		}
		if (instance.BlobFinalize != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(130));
			stream.WriteByte(ProtoPlatform.IntToByte(1));
			CitoMemoryStream ms16 = new CitoMemoryStream();
			Packet_ServerBlobFinalizeSerializer.Serialize(ms16, instance.BlobFinalize);
			int ms16Length = ms16.Length();
			ProtocolParser.WriteUInt32_(stream, ms16Length);
			stream.Write(ms16.GetBuffer(), 0, ms16Length);
		}
		if (instance.HeightmapChunk != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(138));
			stream.WriteByte(ProtoPlatform.IntToByte(1));
			CitoMemoryStream ms17 = new CitoMemoryStream();
			Packet_ServerHeightmapChunkSerializer.Serialize(ms17, instance.HeightmapChunk);
			int ms17Length = ms17.Length();
			ProtocolParser.WriteUInt32_(stream, ms17Length);
			stream.Write(ms17.GetBuffer(), 0, ms17Length);
		}
		if (instance.Ping != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(146));
			stream.WriteByte(ProtoPlatform.IntToByte(1));
			CitoMemoryStream ms18 = new CitoMemoryStream();
			Packet_ServerPingSerializer.Serialize(ms18, instance.Ping);
			int ms18Length = ms18.Length();
			ProtocolParser.WriteUInt32_(stream, ms18Length);
			stream.Write(ms18.GetBuffer(), 0, ms18Length);
		}
		if (instance.PlayerPing != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(170));
			stream.WriteByte(ProtoPlatform.IntToByte(11));
			CitoMemoryStream ms181 = new CitoMemoryStream();
			Packet_ServerPlayerPingSerializer.Serialize(ms181, instance.PlayerPing);
			int ms181Length = ms181.Length();
			ProtocolParser.WriteUInt32_(stream, ms181Length);
			stream.Write(ms181.GetBuffer(), 0, ms181Length);
		}
		if (instance.Sound != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(154));
			stream.WriteByte(ProtoPlatform.IntToByte(1));
			CitoMemoryStream ms19 = new CitoMemoryStream();
			Packet_ServerSoundSerializer.Serialize(ms19, instance.Sound);
			int ms19Length = ms19.Length();
			ProtocolParser.WriteUInt32_(stream, ms19Length);
			stream.Write(ms19.GetBuffer(), 0, ms19Length);
		}
		if (instance.PlayerStats != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(162));
			stream.WriteByte(ProtoPlatform.IntToByte(1));
			CitoMemoryStream ms20 = new CitoMemoryStream();
			Packet_ServerPlayerStatsSerializer.Serialize(ms20, instance.PlayerStats);
			int ms20Length = ms20.Length();
			ProtocolParser.WriteUInt32_(stream, ms20Length);
			stream.Write(ms20.GetBuffer(), 0, ms20Length);
		}
		if (instance.Monster != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(170));
			stream.WriteByte(ProtoPlatform.IntToByte(1));
			CitoMemoryStream ms21 = new CitoMemoryStream();
			Packet_ServerMonstersSerializer.Serialize(ms21, instance.Monster);
			int ms21Length = ms21.Length();
			ProtocolParser.WriteUInt32_(stream, ms21Length);
			stream.Write(ms21.GetBuffer(), 0, ms21Length);
		}
		if (instance.PlayerSpawnPosition != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(178));
			stream.WriteByte(ProtoPlatform.IntToByte(1));
			CitoMemoryStream ms22 = new CitoMemoryStream();
			Packet_ServerPlayerSpawnPositionSerializer.Serialize(ms22, instance.PlayerSpawnPosition);
			int ms22Length = ms22.Length();
			ProtocolParser.WriteUInt32_(stream, ms22Length);
			stream.Write(ms22.GetBuffer(), 0, ms22Length);
		}
		if (instance.BlockTypes != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(186));
			stream.WriteByte(ProtoPlatform.IntToByte(1));
			CitoMemoryStream ms23 = new CitoMemoryStream();
			Packet_ServerBlockTypesSerializer.Serialize(ms23, instance.BlockTypes);
			int ms23Length = ms23.Length();
			ProtocolParser.WriteUInt32_(stream, ms23Length);
			stream.Write(ms23.GetBuffer(), 0, ms23Length);
		}
		if (instance.SunLevels != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(194));
			stream.WriteByte(ProtoPlatform.IntToByte(1));
			CitoMemoryStream ms24 = new CitoMemoryStream();
			Packet_ServerSunLevelsSerializer.Serialize(ms24, instance.SunLevels);
			int ms24Length = ms24.Length();
			ProtocolParser.WriteUInt32_(stream, ms24Length);
			stream.Write(ms24.GetBuffer(), 0, ms24Length);
		}
		if (instance.LightLevels != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(202));
			stream.WriteByte(ProtoPlatform.IntToByte(1));
			CitoMemoryStream ms25 = new CitoMemoryStream();
			Packet_ServerLightLevelsSerializer.Serialize(ms25, instance.LightLevels);
			int ms25Length = ms25.Length();
			ProtocolParser.WriteUInt32_(stream, ms25Length);
			stream.Write(ms25.GetBuffer(), 0, ms25Length);
		}
		if (instance.CraftingRecipes != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(210));
			stream.WriteByte(ProtoPlatform.IntToByte(1));
			CitoMemoryStream ms26 = new CitoMemoryStream();
			Packet_ServerCraftingRecipesSerializer.Serialize(ms26, instance.CraftingRecipes);
			int ms26Length = ms26.Length();
			ProtocolParser.WriteUInt32_(stream, ms26Length);
			stream.Write(ms26.GetBuffer(), 0, ms26Length);
		}
		if (instance.Dialog != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(218));
			stream.WriteByte(ProtoPlatform.IntToByte(1));
			CitoMemoryStream ms27 = new CitoMemoryStream();
			Packet_ServerDialogSerializer.Serialize(ms27, instance.Dialog);
			int ms27Length = ms27.Length();
			ProtocolParser.WriteUInt32_(stream, ms27Length);
			stream.Write(ms27.GetBuffer(), 0, ms27Length);
		}
		if (instance.Follow != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(226));
			stream.WriteByte(ProtoPlatform.IntToByte(1));
			CitoMemoryStream ms28 = new CitoMemoryStream();
			Packet_ServerFollowSerializer.Serialize(ms28, instance.Follow);
			int ms28Length = ms28.Length();
			ProtocolParser.WriteUInt32_(stream, ms28Length);
			stream.Write(ms28.GetBuffer(), 0, ms28Length);
		}
		if (instance.Bullet != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(234));
			stream.WriteByte(ProtoPlatform.IntToByte(1));
			CitoMemoryStream ms29 = new CitoMemoryStream();
			Packet_ServerBulletSerializer.Serialize(ms29, instance.Bullet);
			int ms29Length = ms29.Length();
			ProtocolParser.WriteUInt32_(stream, ms29Length);
			stream.Write(ms29.GetBuffer(), 0, ms29Length);
		}
		if (instance.Ammo != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(242));
			stream.WriteByte(ProtoPlatform.IntToByte(1));
			CitoMemoryStream ms30 = new CitoMemoryStream();
			Packet_ServerAmmoSerializer.Serialize(ms30, instance.Ammo);
			int ms30Length = ms30.Length();
			ProtocolParser.WriteUInt32_(stream, ms30Length);
			stream.Write(ms30.GetBuffer(), 0, ms30Length);
		}
		if (instance.BlockType != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(250));
			stream.WriteByte(ProtoPlatform.IntToByte(1));
			CitoMemoryStream ms31 = new CitoMemoryStream();
			Packet_ServerBlockTypeSerializer.Serialize(ms31, instance.BlockType);
			int ms31Length = ms31.Length();
			ProtocolParser.WriteUInt32_(stream, ms31Length);
			stream.Write(ms31.GetBuffer(), 0, ms31Length);
		}
		if (instance.ChunkPart != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(130));
			stream.WriteByte(ProtoPlatform.IntToByte(2));
			CitoMemoryStream ms32 = new CitoMemoryStream();
			Packet_ServerChunkPartSerializer.Serialize(ms32, instance.ChunkPart);
			int ms32Length = ms32.Length();
			ProtocolParser.WriteUInt32_(stream, ms32Length);
			stream.Write(ms32.GetBuffer(), 0, ms32Length);
		}
		if (instance.Explosion != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(138));
			stream.WriteByte(ProtoPlatform.IntToByte(2));
			CitoMemoryStream ms33 = new CitoMemoryStream();
			Packet_ServerExplosionSerializer.Serialize(ms33, instance.Explosion);
			int ms33Length = ms33.Length();
			ProtocolParser.WriteUInt32_(stream, ms33Length);
			stream.Write(ms33.GetBuffer(), 0, ms33Length);
		}
		if (instance.Projectile != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(146));
			stream.WriteByte(ProtoPlatform.IntToByte(2));
			CitoMemoryStream ms34 = new CitoMemoryStream();
			Packet_ServerProjectileSerializer.Serialize(ms34, instance.Projectile);
			int ms34Length = ms34.Length();
			ProtocolParser.WriteUInt32_(stream, ms34Length);
			stream.Write(ms34.GetBuffer(), 0, ms34Length);
		}
		if (instance.Translation != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(154));
			stream.WriteByte(ProtoPlatform.IntToByte(2));
			CitoMemoryStream ms35 = new CitoMemoryStream();
			Packet_ServerTranslatedStringSerializer.Serialize(ms35, instance.Translation);
			int ms35Length = ms35.Length();
			ProtocolParser.WriteUInt32_(stream, ms35Length);
			stream.Write(ms35.GetBuffer(), 0, ms35Length);
		}
		if (instance.QueryAnswer != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(162));
			stream.WriteByte(ProtoPlatform.IntToByte(2));
			CitoMemoryStream ms36 = new CitoMemoryStream();
			Packet_ServerQueryAnswerSerializer.Serialize(ms36, instance.QueryAnswer);
			int ms36Length = ms36.Length();
			ProtocolParser.WriteUInt32_(stream, ms36Length);
			stream.Write(ms36.GetBuffer(), 0, ms36Length);
		}
		if (instance.Redirect != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(170));
			stream.WriteByte(ProtoPlatform.IntToByte(2));
			CitoMemoryStream ms37 = new CitoMemoryStream();
			Packet_ServerRedirectSerializer.Serialize(ms37, instance.Redirect);
			int ms37Length = ms37.Length();
			ProtocolParser.WriteUInt32_(stream, ms37Length);
			stream.Write(ms37.GetBuffer(), 0, ms37Length);
		}
		if (instance.EntitySpawn != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(186));
			stream.WriteByte(ProtoPlatform.IntToByte(2));
			CitoMemoryStream ms39 = new CitoMemoryStream();
			Packet_ServerEntitySpawnSerializer.Serialize(ms39, instance.EntitySpawn);
			int ms39Length = ms39.Length();
			ProtocolParser.WriteUInt32_(stream, ms39Length);
			stream.Write(ms39.GetBuffer(), 0, ms39Length);
		}
		if (instance.EntityPosition != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(194));
			stream.WriteByte(ProtoPlatform.IntToByte(2));
			CitoMemoryStream ms40 = new CitoMemoryStream();
			Packet_ServerEntityPositionAndOrientationSerializer.Serialize(ms40, instance.EntityPosition);
			int ms40Length = ms40.Length();
			ProtocolParser.WriteUInt32_(stream, ms40Length);
			stream.Write(ms40.GetBuffer(), 0, ms40Length);
		}
		if (instance.EntityDespawn != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(202));
			stream.WriteByte(ProtoPlatform.IntToByte(2));
			CitoMemoryStream ms41 = new CitoMemoryStream();
			Packet_ServerEntityDespawnSerializer.Serialize(ms41, instance.EntityDespawn);
			int ms41Length = ms41.Length();
			ProtocolParser.WriteUInt32_(stream, ms41Length);
			stream.Write(ms41.GetBuffer(), 0, ms41Length);
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_Server instance)
	{
		byte[] data = Packet_ServerSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_Server instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerSetBlock
{
	internal int BlockType;

	public int GetBlockType()
	{
		return this.BlockType;
	}

	public int GetX()
	{
		return this.X;
	}

	public int GetY()
	{
		return this.Y;
	}

	public int GetZ()
	{
		return this.Z;
	}

	public void SetBlockType(int value)
	{
		this.BlockType = value;
	}

	public void SetX(int value)
	{
		this.X = value;
	}

	public void SetY(int value)
	{
		this.Y = value;
	}

	public void SetZ(int value)
	{
		this.Z = value;
	}
	internal int X;
	internal int Y;
	internal int Z;
}

public class Packet_ServerSetBlockSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerSetBlock Deserialize(CitoStream stream, Packet_ServerSetBlock instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.BlockType = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerSetBlock DeserializeBuffer(byte[] buffer, int length, Packet_ServerSetBlock instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerSetBlockSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerSetBlock DeserializeLength(CitoStream stream, int length, Packet_ServerSetBlock instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.BlockType = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerSetBlock DeserializeLengthDelimited(CitoStream stream, Packet_ServerSetBlock instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.BlockType = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerSetBlock DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerSetBlock instance = new Packet_ServerSetBlock();
		Packet_ServerSetBlockSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerSetBlock instance)
	{
		stream.WriteByte(ProtoPlatform.IntToByte(8));
		ProtocolParser.WriteUInt64(stream, instance.X);
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.Y);
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteUInt64(stream, instance.Z);
		stream.WriteByte(ProtoPlatform.IntToByte(32));
		ProtocolParser.WriteUInt64(stream, instance.BlockType);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerSetBlock instance)
	{
		byte[] data = Packet_ServerSetBlockSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerSetBlock instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerSetBlockSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerSound
{

	public string GetName()
	{
		return this.Name;
	}

	public int GetX()
	{
		return this.X;
	}

	public int GetY()
	{
		return this.Y;
	}

	public int GetZ()
	{
		return this.Z;
	}
	internal string Name;

	public void SetName(string value)
	{
		this.Name = value;
	}

	public void SetX(int value)
	{
		this.X = value;
	}

	public void SetY(int value)
	{
		this.Y = value;
	}

	public void SetZ(int value)
	{
		this.Z = value;
	}
	internal int X;
	internal int Y;
	internal int Z;
}

public class Packet_ServerSoundSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerSound Deserialize(CitoStream stream, Packet_ServerSound instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.Name = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerSound DeserializeBuffer(byte[] buffer, int length, Packet_ServerSound instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerSoundSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerSound DeserializeLength(CitoStream stream, int length, Packet_ServerSound instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.Name = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerSound DeserializeLengthDelimited(CitoStream stream, Packet_ServerSound instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.Name = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Z = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerSound DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerSound instance = new Packet_ServerSound();
		Packet_ServerSoundSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerSound instance)
	{
		if (instance.Name != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(10));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.Name));
		}
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.X);
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteUInt64(stream, instance.Y);
		stream.WriteByte(ProtoPlatform.IntToByte(32));
		ProtocolParser.WriteUInt64(stream, instance.Z);
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerSound instance)
	{
		byte[] data = Packet_ServerSoundSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerSound instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerSoundSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerSunLevels
{

	public int[] GetSunlevels()
	{
		return this.Sunlevels;
	}

	public int GetSunlevelsCount()
	{
		return this.SunlevelsCount;
	}

	public int GetSunlevelsLength()
	{
		return this.SunlevelsLength;
	}

	public void SetSunlevels(int[] value, int count, int length)
	{
		this.Sunlevels = value;
		this.SunlevelsCount = count;
		this.SunlevelsLength = length;
	}
	internal int[] Sunlevels;

	public void SunlevelsAdd(int value)
	{
		if (this.SunlevelsCount >= this.SunlevelsLength) {
			int[] Sunlevels2 = new int[this.SunlevelsLength * 2];
			this.SunlevelsLength = this.SunlevelsLength * 2;
			for (int i = 0; i < this.SunlevelsCount; i++) {
				Sunlevels2[i] = this.Sunlevels[i];
			}
			this.Sunlevels = Sunlevels2;
		}
		this.Sunlevels[this.SunlevelsCount] = value;
		this.SunlevelsCount++;
	}
	internal int SunlevelsCount;
	internal int SunlevelsLength;
}

public class Packet_ServerSunLevelsSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerSunLevels Deserialize(CitoStream stream, Packet_ServerSunLevels instance)
	{
		if (instance.Sunlevels == null) {
			instance.Sunlevels = new int[1];
			instance.SunlevelsCount = 0;
			instance.SunlevelsLength = 1;
		}
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 8:
				instance.SunlevelsAdd(ProtocolParser.ReadUInt64(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerSunLevels DeserializeBuffer(byte[] buffer, int length, Packet_ServerSunLevels instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerSunLevelsSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerSunLevels DeserializeLength(CitoStream stream, int length, Packet_ServerSunLevels instance)
	{
		if (instance.Sunlevels == null) {
			instance.Sunlevels = new int[1];
			instance.SunlevelsCount = 0;
			instance.SunlevelsLength = 1;
		}
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.SunlevelsAdd(ProtocolParser.ReadUInt64(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerSunLevels DeserializeLengthDelimited(CitoStream stream, Packet_ServerSunLevels instance)
	{
		if (instance.Sunlevels == null) {
			instance.Sunlevels = new int[1];
			instance.SunlevelsCount = 0;
			instance.SunlevelsLength = 1;
		}
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 8:
				instance.SunlevelsAdd(ProtocolParser.ReadUInt64(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerSunLevels DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerSunLevels instance = new Packet_ServerSunLevels();
		Packet_ServerSunLevelsSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerSunLevels instance)
	{
		if (instance.Sunlevels != null) {
			for (int k = 0; k < instance.SunlevelsCount; k++) {
				int i1 = instance.Sunlevels[k];
				stream.WriteByte(ProtoPlatform.IntToByte(8));
				ProtocolParser.WriteUInt64(stream, i1);
			}
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerSunLevels instance)
	{
		byte[] data = Packet_ServerSunLevelsSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerSunLevels instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerSunLevelsSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_ServerTranslatedString
{

	public string GetId()
	{
		return this.Id;
	}

	public string GetLang()
	{
		return this.Lang;
	}

	public string GetTranslation()
	{
		return this.Translation;
	}
	internal string Id;
	internal string Lang;

	public void SetId(string value)
	{
		this.Id = value;
	}

	public void SetLang(string value)
	{
		this.Lang = value;
	}

	public void SetTranslation(string value)
	{
		this.Translation = value;
	}
	internal string Translation;
}

public class Packet_ServerTranslatedStringSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerTranslatedString Deserialize(CitoStream stream, Packet_ServerTranslatedString instance)
	{
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.Lang = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.Id = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.Translation = ProtocolParser.ReadString(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_ServerTranslatedString DeserializeBuffer(byte[] buffer, int length, Packet_ServerTranslatedString instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_ServerTranslatedStringSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerTranslatedString DeserializeLength(CitoStream stream, int length, Packet_ServerTranslatedString instance)
	{
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.Lang = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.Id = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.Translation = ProtocolParser.ReadString(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_ServerTranslatedString DeserializeLengthDelimited(CitoStream stream, Packet_ServerTranslatedString instance)
	{
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.Lang = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.Id = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.Translation = ProtocolParser.ReadString(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_ServerTranslatedString DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_ServerTranslatedString instance = new Packet_ServerTranslatedString();
		Packet_ServerTranslatedStringSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_ServerTranslatedString instance)
	{
		if (instance.Lang != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(10));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.Lang));
		}
		if (instance.Id != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(18));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.Id));
		}
		if (instance.Translation != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(26));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.Translation));
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_ServerTranslatedString instance)
	{
		byte[] data = Packet_ServerTranslatedStringSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_ServerTranslatedString instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerTranslatedStringSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_SoundSet
{
	internal string[] Break1;

	public void Break1Add(string value)
	{
		if (this.Break1Count >= this.Break1Length) {
			string[] Break12 = new string[this.Break1Length * 2];
			this.Break1Length = this.Break1Length * 2;
			for (int i = 0; i < this.Break1Count; i++) {
				Break12[i] = this.Break1[i];
			}
			this.Break1 = Break12;
		}
		this.Break1[this.Break1Count] = value;
		this.Break1Count++;
	}
	internal int Break1Count;
	internal int Break1Length;
	internal string[] Build;

	public void BuildAdd(string value)
	{
		if (this.BuildCount >= this.BuildLength) {
			string[] Build2 = new string[this.BuildLength * 2];
			this.BuildLength = this.BuildLength * 2;
			for (int i = 0; i < this.BuildCount; i++) {
				Build2[i] = this.Build[i];
			}
			this.Build = Build2;
		}
		this.Build[this.BuildCount] = value;
		this.BuildCount++;
	}
	internal int BuildCount;
	internal int BuildLength;
	internal string[] Clone;

	public void CloneAdd(string value)
	{
		if (this.CloneCount >= this.CloneLength) {
			string[] Clone2 = new string[this.CloneLength * 2];
			this.CloneLength = this.CloneLength * 2;
			for (int i = 0; i < this.CloneCount; i++) {
				Clone2[i] = this.Clone[i];
			}
			this.Clone = Clone2;
		}
		this.Clone[this.CloneCount] = value;
		this.CloneCount++;
	}
	internal int CloneCount;
	internal int CloneLength;

	public string[] GetBreak1()
	{
		return this.Break1;
	}

	public int GetBreak1Count()
	{
		return this.Break1Count;
	}

	public int GetBreak1Length()
	{
		return this.Break1Length;
	}

	public string[] GetBuild()
	{
		return this.Build;
	}

	public int GetBuildCount()
	{
		return this.BuildCount;
	}

	public int GetBuildLength()
	{
		return this.BuildLength;
	}

	public string[] GetClone()
	{
		return this.Clone;
	}

	public int GetCloneCount()
	{
		return this.CloneCount;
	}

	public int GetCloneLength()
	{
		return this.CloneLength;
	}

	public string[] GetReload()
	{
		return this.Reload;
	}

	public int GetReloadCount()
	{
		return this.ReloadCount;
	}

	public int GetReloadLength()
	{
		return this.ReloadLength;
	}

	public string[] GetShoot()
	{
		return this.Shoot;
	}

	public int GetShootCount()
	{
		return this.ShootCount;
	}

	public string[] GetShootEnd()
	{
		return this.ShootEnd;
	}

	public int GetShootEndCount()
	{
		return this.ShootEndCount;
	}

	public int GetShootEndLength()
	{
		return this.ShootEndLength;
	}

	public int GetShootLength()
	{
		return this.ShootLength;
	}

	public string[] GetWalk()
	{
		return this.Walk;
	}

	public int GetWalkCount()
	{
		return this.WalkCount;
	}

	public int GetWalkLength()
	{
		return this.WalkLength;
	}
	internal string[] Reload;

	public void ReloadAdd(string value)
	{
		if (this.ReloadCount >= this.ReloadLength) {
			string[] Reload2 = new string[this.ReloadLength * 2];
			this.ReloadLength = this.ReloadLength * 2;
			for (int i = 0; i < this.ReloadCount; i++) {
				Reload2[i] = this.Reload[i];
			}
			this.Reload = Reload2;
		}
		this.Reload[this.ReloadCount] = value;
		this.ReloadCount++;
	}
	internal int ReloadCount;
	internal int ReloadLength;

	public void SetBreak1(string[] value, int count, int length)
	{
		this.Break1 = value;
		this.Break1Count = count;
		this.Break1Length = length;
	}

	public void SetBuild(string[] value, int count, int length)
	{
		this.Build = value;
		this.BuildCount = count;
		this.BuildLength = length;
	}

	public void SetClone(string[] value, int count, int length)
	{
		this.Clone = value;
		this.CloneCount = count;
		this.CloneLength = length;
	}

	public void SetReload(string[] value, int count, int length)
	{
		this.Reload = value;
		this.ReloadCount = count;
		this.ReloadLength = length;
	}

	public void SetShoot(string[] value, int count, int length)
	{
		this.Shoot = value;
		this.ShootCount = count;
		this.ShootLength = length;
	}

	public void SetShootEnd(string[] value, int count, int length)
	{
		this.ShootEnd = value;
		this.ShootEndCount = count;
		this.ShootEndLength = length;
	}

	public void SetWalk(string[] value, int count, int length)
	{
		this.Walk = value;
		this.WalkCount = count;
		this.WalkLength = length;
	}
	internal string[] Shoot;

	public void ShootAdd(string value)
	{
		if (this.ShootCount >= this.ShootLength) {
			string[] Shoot2 = new string[this.ShootLength * 2];
			this.ShootLength = this.ShootLength * 2;
			for (int i = 0; i < this.ShootCount; i++) {
				Shoot2[i] = this.Shoot[i];
			}
			this.Shoot = Shoot2;
		}
		this.Shoot[this.ShootCount] = value;
		this.ShootCount++;
	}
	internal int ShootCount;
	internal string[] ShootEnd;

	public void ShootEndAdd(string value)
	{
		if (this.ShootEndCount >= this.ShootEndLength) {
			string[] ShootEnd2 = new string[this.ShootEndLength * 2];
			this.ShootEndLength = this.ShootEndLength * 2;
			for (int i = 0; i < this.ShootEndCount; i++) {
				ShootEnd2[i] = this.ShootEnd[i];
			}
			this.ShootEnd = ShootEnd2;
		}
		this.ShootEnd[this.ShootEndCount] = value;
		this.ShootEndCount++;
	}
	internal int ShootEndCount;
	internal int ShootEndLength;
	internal int ShootLength;
	internal string[] Walk;

	public void WalkAdd(string value)
	{
		if (this.WalkCount >= this.WalkLength) {
			string[] Walk2 = new string[this.WalkLength * 2];
			this.WalkLength = this.WalkLength * 2;
			for (int i = 0; i < this.WalkCount; i++) {
				Walk2[i] = this.Walk[i];
			}
			this.Walk = Walk2;
		}
		this.Walk[this.WalkCount] = value;
		this.WalkCount++;
	}
	internal int WalkCount;
	internal int WalkLength;
}

public class Packet_SoundSetSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_SoundSet Deserialize(CitoStream stream, Packet_SoundSet instance)
	{
		if (instance.Walk == null) {
			instance.Walk = new string[1];
			instance.WalkCount = 0;
			instance.WalkLength = 1;
		}
		if (instance.Break1 == null) {
			instance.Break1 = new string[1];
			instance.Break1Count = 0;
			instance.Break1Length = 1;
		}
		if (instance.Build == null) {
			instance.Build = new string[1];
			instance.BuildCount = 0;
			instance.BuildLength = 1;
		}
		if (instance.Clone == null) {
			instance.Clone = new string[1];
			instance.CloneCount = 0;
			instance.CloneLength = 1;
		}
		if (instance.Shoot == null) {
			instance.Shoot = new string[1];
			instance.ShootCount = 0;
			instance.ShootLength = 1;
		}
		if (instance.ShootEnd == null) {
			instance.ShootEnd = new string[1];
			instance.ShootEndCount = 0;
			instance.ShootEndLength = 1;
		}
		if (instance.Reload == null) {
			instance.Reload = new string[1];
			instance.ReloadCount = 0;
			instance.ReloadLength = 1;
		}
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.WalkAdd(ProtocolParser.ReadString(stream));
				continue;
			case 18:
				instance.Break1Add(ProtocolParser.ReadString(stream));
				continue;
			case 26:
				instance.BuildAdd(ProtocolParser.ReadString(stream));
				continue;
			case 34:
				instance.CloneAdd(ProtocolParser.ReadString(stream));
				continue;
			case 42:
				instance.ShootAdd(ProtocolParser.ReadString(stream));
				continue;
			case 50:
				instance.ShootEndAdd(ProtocolParser.ReadString(stream));
				continue;
			case 58:
				instance.ReloadAdd(ProtocolParser.ReadString(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_SoundSet DeserializeBuffer(byte[] buffer, int length, Packet_SoundSet instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_SoundSetSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_SoundSet DeserializeLength(CitoStream stream, int length, Packet_SoundSet instance)
	{
		if (instance.Walk == null) {
			instance.Walk = new string[1];
			instance.WalkCount = 0;
			instance.WalkLength = 1;
		}
		if (instance.Break1 == null) {
			instance.Break1 = new string[1];
			instance.Break1Count = 0;
			instance.Break1Length = 1;
		}
		if (instance.Build == null) {
			instance.Build = new string[1];
			instance.BuildCount = 0;
			instance.BuildLength = 1;
		}
		if (instance.Clone == null) {
			instance.Clone = new string[1];
			instance.CloneCount = 0;
			instance.CloneLength = 1;
		}
		if (instance.Shoot == null) {
			instance.Shoot = new string[1];
			instance.ShootCount = 0;
			instance.ShootLength = 1;
		}
		if (instance.ShootEnd == null) {
			instance.ShootEnd = new string[1];
			instance.ShootEndCount = 0;
			instance.ShootEndLength = 1;
		}
		if (instance.Reload == null) {
			instance.Reload = new string[1];
			instance.ReloadCount = 0;
			instance.ReloadLength = 1;
		}
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.WalkAdd(ProtocolParser.ReadString(stream));
				continue;
			case 18:
				instance.Break1Add(ProtocolParser.ReadString(stream));
				continue;
			case 26:
				instance.BuildAdd(ProtocolParser.ReadString(stream));
				continue;
			case 34:
				instance.CloneAdd(ProtocolParser.ReadString(stream));
				continue;
			case 42:
				instance.ShootAdd(ProtocolParser.ReadString(stream));
				continue;
			case 50:
				instance.ShootEndAdd(ProtocolParser.ReadString(stream));
				continue;
			case 58:
				instance.ReloadAdd(ProtocolParser.ReadString(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_SoundSet DeserializeLengthDelimited(CitoStream stream, Packet_SoundSet instance)
	{
		if (instance.Walk == null) {
			instance.Walk = new string[1];
			instance.WalkCount = 0;
			instance.WalkLength = 1;
		}
		if (instance.Break1 == null) {
			instance.Break1 = new string[1];
			instance.Break1Count = 0;
			instance.Break1Length = 1;
		}
		if (instance.Build == null) {
			instance.Build = new string[1];
			instance.BuildCount = 0;
			instance.BuildLength = 1;
		}
		if (instance.Clone == null) {
			instance.Clone = new string[1];
			instance.CloneCount = 0;
			instance.CloneLength = 1;
		}
		if (instance.Shoot == null) {
			instance.Shoot = new string[1];
			instance.ShootCount = 0;
			instance.ShootLength = 1;
		}
		if (instance.ShootEnd == null) {
			instance.ShootEnd = new string[1];
			instance.ShootEndCount = 0;
			instance.ShootEndLength = 1;
		}
		if (instance.Reload == null) {
			instance.Reload = new string[1];
			instance.ReloadCount = 0;
			instance.ReloadLength = 1;
		}
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.WalkAdd(ProtocolParser.ReadString(stream));
				continue;
			case 18:
				instance.Break1Add(ProtocolParser.ReadString(stream));
				continue;
			case 26:
				instance.BuildAdd(ProtocolParser.ReadString(stream));
				continue;
			case 34:
				instance.CloneAdd(ProtocolParser.ReadString(stream));
				continue;
			case 42:
				instance.ShootAdd(ProtocolParser.ReadString(stream));
				continue;
			case 50:
				instance.ShootEndAdd(ProtocolParser.ReadString(stream));
				continue;
			case 58:
				instance.ReloadAdd(ProtocolParser.ReadString(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_SoundSet DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_SoundSet instance = new Packet_SoundSet();
		Packet_SoundSetSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_SoundSet instance)
	{
		if (instance.Walk != null) {
			for (int k = 0; k < instance.WalkCount; k++) {
				string i1 = instance.Walk[k];
				stream.WriteByte(ProtoPlatform.IntToByte(10));
				ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(i1));
			}
		}
		if (instance.Break1 != null) {
			for (int k = 0; k < instance.Break1Count; k++) {
				string i2 = instance.Break1[k];
				stream.WriteByte(ProtoPlatform.IntToByte(18));
				ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(i2));
			}
		}
		if (instance.Build != null) {
			for (int k = 0; k < instance.BuildCount; k++) {
				string i3 = instance.Build[k];
				stream.WriteByte(ProtoPlatform.IntToByte(26));
				ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(i3));
			}
		}
		if (instance.Clone != null) {
			for (int k = 0; k < instance.CloneCount; k++) {
				string i4 = instance.Clone[k];
				stream.WriteByte(ProtoPlatform.IntToByte(34));
				ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(i4));
			}
		}
		if (instance.Shoot != null) {
			for (int k = 0; k < instance.ShootCount; k++) {
				string i5 = instance.Shoot[k];
				stream.WriteByte(ProtoPlatform.IntToByte(42));
				ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(i5));
			}
		}
		if (instance.ShootEnd != null) {
			for (int k = 0; k < instance.ShootEndCount; k++) {
				string i6 = instance.ShootEnd[k];
				stream.WriteByte(ProtoPlatform.IntToByte(50));
				ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(i6));
			}
		}
		if (instance.Reload != null) {
			for (int k = 0; k < instance.ReloadCount; k++) {
				string i7 = instance.Reload[k];
				stream.WriteByte(ProtoPlatform.IntToByte(58));
				ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(i7));
			}
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_SoundSet instance)
	{
		byte[] data = Packet_SoundSetSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_SoundSet instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_SoundSetSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_SpecialKeyEnum
{
	public const int Respawn = 0;
	public const int SelectTeam = 3;
	public const int SetSpawn = 1;
	public const int TabPlayerList = 2;
}

public class Packet_StringList
{

	public string[] GetItems()
	{
		return this.Items;
	}

	public int GetItemsCount()
	{
		return this.ItemsCount;
	}

	public int GetItemsLength()
	{
		return this.ItemsLength;
	}
	internal string[] Items;

	public void ItemsAdd(string value)
	{
		if (this.ItemsCount >= this.ItemsLength) {
			string[] Items2 = new string[this.ItemsLength * 2];
			this.ItemsLength = this.ItemsLength * 2;
			for (int i = 0; i < this.ItemsCount; i++) {
				Items2[i] = this.Items[i];
			}
			this.Items = Items2;
		}
		this.Items[this.ItemsCount] = value;
		this.ItemsCount++;
	}
	internal int ItemsCount;
	internal int ItemsLength;

	public void SetItems(string[] value, int count, int length)
	{
		this.Items = value;
		this.ItemsCount = count;
		this.ItemsLength = length;
	}
}

public class Packet_StringListSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_StringList Deserialize(CitoStream stream, Packet_StringList instance)
	{
		if (instance.Items == null) {
			instance.Items = new string[1];
			instance.ItemsCount = 0;
			instance.ItemsLength = 1;
		}
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.ItemsAdd(ProtocolParser.ReadString(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_StringList DeserializeBuffer(byte[] buffer, int length, Packet_StringList instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_StringListSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_StringList DeserializeLength(CitoStream stream, int length, Packet_StringList instance)
	{
		if (instance.Items == null) {
			instance.Items = new string[1];
			instance.ItemsCount = 0;
			instance.ItemsLength = 1;
		}
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.ItemsAdd(ProtocolParser.ReadString(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_StringList DeserializeLengthDelimited(CitoStream stream, Packet_StringList instance)
	{
		if (instance.Items == null) {
			instance.Items = new string[1];
			instance.ItemsCount = 0;
			instance.ItemsLength = 1;
		}
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.ItemsAdd(ProtocolParser.ReadString(stream));
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_StringList DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_StringList instance = new Packet_StringList();
		Packet_StringListSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_StringList instance)
	{
		if (instance.Items != null) {
			for (int k = 0; k < instance.ItemsCount; k++) {
				string i1 = instance.Items[k];
				stream.WriteByte(ProtoPlatform.IntToByte(10));
				ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(i1));
			}
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_StringList instance)
	{
		byte[] data = Packet_StringListSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_StringList instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_StringListSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_WalkableTypeEnum
{
	public const int Empty = 0;
	public const int Fluid = 1;
	public const int Solid = 2;
}

public class Packet_Widget
{
	internal int Click;
	internal int ClickKey;
	internal int Color;
	/// <summary>&lt;summary&gt;white&lt;/summary&gt;</summary>
	internal Packet_DialogFont Font;

	public int GetClick()
	{
		return this.Click;
	}

	public int GetClickKey()
	{
		return this.ClickKey;
	}

	public int GetColor()
	{
		return this.Color;
	}

	public Packet_DialogFont GetFont()
	{
		return this.Font;
	}

	public int GetHeight_()
	{
		return this.Height_;
	}

	public string GetId()
	{
		return this.Id;
	}

	public string GetImage()
	{
		return this.Image;
	}

	public string GetText()
	{
		return this.Text;
	}

	public int GetType()
	{
		return this.Type;
	}

	public int GetWidth()
	{
		return this.Width;
	}

	public int GetX()
	{
		return this.X;
	}

	public int GetY()
	{
		return this.Y;
	}
	internal int Height_;
	internal string Id;
	internal string Image;

	public void SetClick(int value)
	{
		this.Click = value;
	}

	public void SetClickKey(int value)
	{
		this.ClickKey = value;
	}

	public void SetColor(int value)
	{
		this.Color = value;
	}

	public void SetFont(Packet_DialogFont value)
	{
		this.Font = value;
	}

	public void SetHeight_(int value)
	{
		this.Height_ = value;
	}

	public void SetId(string value)
	{
		this.Id = value;
	}

	public void SetImage(string value)
	{
		this.Image = value;
	}

	public void SetText(string value)
	{
		this.Text = value;
	}

	public void SetType(int value)
	{
		this.Type = value;
	}

	public void SetWidth(int value)
	{
		this.Width = value;
	}

	public void SetX(int value)
	{
		this.X = value;
	}

	public void SetY(int value)
	{
		this.Y = value;
	}
	internal string Text;
	internal int Type;
	internal int Width;
	internal int X;
	internal int Y;
}

public class Packet_WidgetSerializer
{

	/// <summary>&lt;summary&gt;Takes the remaining content of the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_Widget Deserialize(CitoStream stream, Packet_Widget instance)
	{
		instance.Type = 0;
		while (true) {
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				break;
			switch (keyByte) {
			case 10:
				instance.Id = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.Click = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.Width = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.Height_ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				instance.Text = ProtocolParser.ReadString(stream);
				continue;
			case 64:
				instance.ClickKey = ProtocolParser.ReadUInt64(stream);
				continue;
			case 74:
				instance.Image = ProtocolParser.ReadString(stream);
				continue;
			case 80:
				instance.Color = ProtocolParser.ReadUInt64(stream);
				continue;
			case 90:
				if (instance.Font == null)
					instance.Font = Packet_DialogFontSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_DialogFontSerializer.DeserializeLengthDelimited(stream, instance.Font);
				continue;
			case 96:
				instance.Type = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: put the buffer into a MemoryStream before deserializing&lt;/summary&gt;</summary>
	public static Packet_Widget DeserializeBuffer(byte[] buffer, int length, Packet_Widget instance)
	{
		CitoMemoryStream ms = CitoMemoryStream.Create(buffer, length);
		Packet_WidgetSerializer.Deserialize(ms, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_Widget DeserializeLength(CitoStream stream, int length, Packet_Widget instance)
	{
		instance.Type = 0;
		int limit = stream.Position() + length;
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.Id = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.Click = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.Width = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.Height_ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				instance.Text = ProtocolParser.ReadString(stream);
				continue;
			case 64:
				instance.ClickKey = ProtocolParser.ReadUInt64(stream);
				continue;
			case 74:
				instance.Image = ProtocolParser.ReadString(stream);
				continue;
			case 80:
				instance.Color = ProtocolParser.ReadUInt64(stream);
				continue;
			case 90:
				if (instance.Font == null)
					instance.Font = Packet_DialogFontSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_DialogFontSerializer.DeserializeLengthDelimited(stream, instance.Font);
				continue;
			case 96:
				instance.Type = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.&lt;/summary&gt;</summary>
	public static Packet_Widget DeserializeLengthDelimited(CitoStream stream, Packet_Widget instance)
	{
		instance.Type = 0;
		int limit = ProtocolParser.ReadUInt32(stream);
		limit += stream.Position();
		while (true) {
			if (stream.Position() >= limit) {
				if (stream.Position() == limit)
					break;
				else
					return null;
			}
			int keyByte = stream.ReadByte();
			if (keyByte == -1)
				return null;
			switch (keyByte) {
			case 10:
				instance.Id = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.Click = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.X = ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.Y = ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.Width = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.Height_ = ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				instance.Text = ProtocolParser.ReadString(stream);
				continue;
			case 64:
				instance.ClickKey = ProtocolParser.ReadUInt64(stream);
				continue;
			case 74:
				instance.Image = ProtocolParser.ReadString(stream);
				continue;
			case 80:
				instance.Color = ProtocolParser.ReadUInt64(stream);
				continue;
			case 90:
				if (instance.Font == null)
					instance.Font = Packet_DialogFontSerializer.DeserializeLengthDelimitedNew(stream);
				else
					Packet_DialogFontSerializer.DeserializeLengthDelimited(stream, instance.Font);
				continue;
			case 96:
				instance.Type = ProtocolParser.ReadUInt64(stream);
				continue;
			default:
				break;
			}
			Key key = ProtocolParser.ReadKey_((byte) keyByte, stream);
			switch (key.GetField()) {
			case 0:
				return null;
			default:
				ProtocolParser.SkipKey(stream, key);
				break;
			}
		}
		return instance;
	}

	/// <summary>&lt;summary&gt;Helper: create a new instance to deserializing into&lt;/summary&gt;</summary>
	public static Packet_Widget DeserializeLengthDelimitedNew(CitoStream stream)
	{
		Packet_Widget instance = new Packet_Widget();
		Packet_WidgetSerializer.DeserializeLengthDelimited(stream, instance);
		return instance;
	}

	/// <summary>&lt;summary&gt;Serialize the instance into the stream&lt;/summary&gt;</summary>
	public static void Serialize(CitoStream stream, Packet_Widget instance)
	{
		if (instance.Id != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(10));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.Id));
		}
		stream.WriteByte(ProtoPlatform.IntToByte(16));
		ProtocolParser.WriteUInt64(stream, instance.Click);
		stream.WriteByte(ProtoPlatform.IntToByte(24));
		ProtocolParser.WriteUInt64(stream, instance.X);
		stream.WriteByte(ProtoPlatform.IntToByte(32));
		ProtocolParser.WriteUInt64(stream, instance.Y);
		stream.WriteByte(ProtoPlatform.IntToByte(40));
		ProtocolParser.WriteUInt64(stream, instance.Width);
		stream.WriteByte(ProtoPlatform.IntToByte(48));
		ProtocolParser.WriteUInt64(stream, instance.Height_);
		if (instance.Text != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(58));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.Text));
		}
		stream.WriteByte(ProtoPlatform.IntToByte(64));
		ProtocolParser.WriteUInt64(stream, instance.ClickKey);
		if (instance.Image != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(74));
			ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(instance.Image));
		}
		stream.WriteByte(ProtoPlatform.IntToByte(80));
		ProtocolParser.WriteUInt64(stream, instance.Color);
		if (instance.Font != null) {
			stream.WriteByte(ProtoPlatform.IntToByte(90));
			CitoMemoryStream ms11 = new CitoMemoryStream();
			Packet_DialogFontSerializer.Serialize(ms11, instance.Font);
			int ms11Length = ms11.Length();
			ProtocolParser.WriteUInt32_(stream, ms11Length);
			stream.Write(ms11.GetBuffer(), 0, ms11Length);
		}
		if (instance.Type != 0) {
			stream.WriteByte(ProtoPlatform.IntToByte(96));
			ProtocolParser.WriteUInt64(stream, instance.Type);
		}
	}

	/// <summary>&lt;summary&gt;Helper: Serialize with a varint length prefix&lt;/summary&gt;</summary>
	public static void SerializeLengthDelimited(CitoStream stream, Packet_Widget instance)
	{
		byte[] data = Packet_WidgetSerializer.SerializeToBytes(instance);
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(data));
		stream.Write(data, 0, ProtoPlatform.ArrayLength(data));
	}

	/// <summary>&lt;summary&gt;Helper: Serialize into a MemoryStream and return its byte array&lt;/summary&gt;</summary>
	public static byte[] SerializeToBytes(Packet_Widget instance)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_WidgetSerializer.Serialize(ms, instance);
		return ms.ToArray();
	}
}

public class Packet_WidgetTypeEnum
{
	public const int Image = 0;
	public const int Text = 1;
	public const int TextBox = 2;
}

public class Ping_
{
	public Ping_()
	{
		this.RoundtripTimeMilliseconds = 0;
		this.ready = true;
		this.timeSendMilliseconds = 0;
		this.timeout = 10;
	}

	public int GetTimeoutValue()
	{
		return this.timeout;
	}

	public bool Receive(GamePlatform platform)
	{
		if (this.ready) {
			return false;
		}
		this.RoundtripTimeMilliseconds = platform.TimeMillisecondsFromStart() - this.timeSendMilliseconds;
		this.ready = true;
		return true;
	}
	int RoundtripTimeMilliseconds;

	internal int RoundtripTimeTotalMilliseconds()
	{
		return this.RoundtripTimeMilliseconds;
	}

	public bool Send(GamePlatform platform)
	{
		if (!this.ready) {
			return false;
		}
		this.ready = false;
		this.timeSendMilliseconds = platform.TimeMillisecondsFromStart();
		return true;
	}

	public void SetTimeoutValue(int value)
	{
		this.timeout = value;
	}

	public bool Timeout(GamePlatform platform)
	{
		if ((platform.TimeMillisecondsFromStart() - this.timeSendMilliseconds) / 1000 > this.timeout) {
			this.ready = true;
			return true;
		}
		return false;
	}
	bool ready;
	int timeSendMilliseconds;
	int timeout;
}

public class Platform
{

	public static float Acos(float a)
	{
		
            return (float)System.Math.Acos(a);
        return 0;
	}

	public static float Cos(float a)
	{
		
            return (float)System.Math.Cos(a);
        return 0;
	}

	public static float Sin(float a)
	{
		
            return (float)System.Math.Sin(a);
        return 0;
	}

	public static float Sqrt(float a)
	{
		
            return (float)System.Math.Sqrt(a);
        return 0;
	}

	public static float Tan(float a)
	{
		
            return (float)System.Math.Tan(a);
        return 0;
	}

	public static void WriteInt(int a)
	{
		
            System.Console.Write(a);
        }

	public static void WriteString(string a)
	{
		
            System.Console.Write(a);
        }
}

public class Player
{
	public Player()
	{
		this.AnimationHint_ = new AnimationHint();
		this.Model_ = "player.txt";
		this.EyeHeight = this.DefaultEyeHeight();
		this.ModelHeight = this.DefaultModelHeight();
		this.CurrentTexture = -1;
	}
	internal AnimationHint AnimationHint_;
	internal int CurrentTexture;

	public float DefaultEyeHeight()
	{
		float one = 1;
		return one * 15 / 10;
	}

	public float DefaultModelHeight()
	{
		float one = 1;
		return one * 17 / 10;
	}
	internal float EyeHeight;
	internal byte Heading;
	internal int Health;
	internal int LastUpdateMilliseconds;
	internal float ModelHeight;
	internal string Model_;
	internal int MonsterType;
	internal string Name;
	internal byte NetworkHeading;
	internal byte NetworkPitch;
	internal float NetworkX;
	internal float NetworkY;
	internal float NetworkZ;
	internal byte Pitch;
	internal bool PositionLoaded;
	internal float PositionX;
	internal float PositionY;
	internal float PositionZ;
	internal HttpResponseCi SkinDownloadResponse;
	internal string Texture;
	internal PlayerType Type;
	internal bool moves;
	internal PlayerDrawInfo playerDrawInfo;
}

public class PlayerDrawInfo
{
	public PlayerDrawInfo()
	{
		this.anim = new AnimationState();
		this.AnimationHint_ = new AnimationHint();
	}
	internal AnimationHint AnimationHint_;
	internal AnimationState anim;
	internal NetworkInterpolation interpolation;
	internal float lastcurposX;
	internal float lastcurposY;
	internal float lastcurposZ;
	internal float lastnetworkposX;
	internal float lastnetworkposY;
	internal float lastnetworkposZ;
	internal float lastnetworkrotx;
	internal float lastnetworkroty;
	internal float lastnetworkrotz;
	internal bool moves;
	internal float velocityX;
	internal float velocityY;
	internal float velocityZ;
}

public class PlayerInterpolate : IInterpolation
{

	public static float DegToRad(float deg)
	{
		return deg / 360 * 2 * Game.GetPi();
	}

	public override InterpolatedObject Interpolate(InterpolatedObject a, InterpolatedObject b, float progress)
	{
		PlayerInterpolationState aa = this.platform.CastToPlayerInterpolationState(a);
		PlayerInterpolationState bb = this.platform.CastToPlayerInterpolationState(b);
		PlayerInterpolationState cc = new PlayerInterpolationState();
		cc.positionX = aa.positionX + (bb.positionX - aa.positionX) * progress;
		cc.positionY = aa.positionY + (bb.positionY - aa.positionY) * progress;
		cc.positionZ = aa.positionZ + (bb.positionZ - aa.positionZ) * progress;
		cc.rotx = PlayerInterpolate.DegToRad(AngleInterpolation.InterpolateAngle360(this.platform, PlayerInterpolate.RadToDeg(aa.rotx), PlayerInterpolate.RadToDeg(bb.rotx), progress));
		cc.roty = PlayerInterpolate.DegToRad(AngleInterpolation.InterpolateAngle360(this.platform, PlayerInterpolate.RadToDeg(aa.roty), PlayerInterpolate.RadToDeg(bb.roty), progress));
		cc.rotz = PlayerInterpolate.DegToRad(AngleInterpolation.InterpolateAngle360(this.platform, PlayerInterpolate.RadToDeg(aa.rotz), PlayerInterpolate.RadToDeg(bb.rotz), progress));
		return cc;
	}

	public static float RadToDeg(float rad)
	{
		return rad / (2 * Game.GetPi()) * 360;
	}
	internal GamePlatform platform;
}

public class PlayerInterpolationState : InterpolatedObject
{
	internal byte heading;
	internal byte pitch;
	internal float positionX;
	internal float positionY;
	internal float positionZ;
	internal float rotx;
	internal float roty;
	internal float rotz;
}

public enum PlayerType
{
	Player,
	Monster
}

public class PointFloatRef
{

	public static PointFloatRef Create(float x_, float y_)
	{
		PointFloatRef p = new PointFloatRef();
		p.X = x_;
		p.Y = y_;
		return p;
	}
	internal float X;
	internal float Y;
}

public class PointRef
{

	public static PointRef Create(int x_, int y_)
	{
		PointRef p = new PointRef();
		p.X = x_;
		p.Y = y_;
		return p;
	}
	internal int X;
	internal int Y;
}

public abstract class PredicateBox3D
{

	public abstract bool Hit(Box3D o);
}

public class PredicateBox3DHit : PredicateBox3D
{

	public static PredicateBox3DHit Create(BlockOctreeSearcher s_)
	{
		PredicateBox3DHit p = new PredicateBox3DHit();
		p.s = s_;
		return p;
	}

	public override bool Hit(Box3D o)
	{
		return this.s.BoxHit(o);
	}
	BlockOctreeSearcher s;
}

public class Preferences
{
	public Preferences()
	{
		this.items = new DictionaryStringString();
	}

	public bool GetBool(string key, bool default_)
	{
		string value = this.GetString(key, null);
		if (value == null) {
			return default_;
		}
		if (value == "0") {
			return false;
		}
		if (value == "1") {
			return true;
		}
		return default_;
	}

	public int GetInt(string key, int default_)
	{
		if (this.GetString(key, null) == null) {
			return default_;
		}
		FloatRef ret = new FloatRef();
		if (this.platform.FloatTryParse(this.GetString(key, null), ret)) {
			return this.platform.FloatToInt(ret.value);
		}
		return default_;
	}

	public string GetKey(int i)
	{
		if (this.items.items[i] != null) {
			return this.items.items[i].key;
		}
		else {
			return null;
		}
	}

	public int GetKeysCount()
	{
		return this.items.count;
	}

	public string GetString(string key, string default_)
	{
		if (!this.items.ContainsKey(key)) {
			return default_;
		}
		return this.items.Get(key);
	}

	internal void Remove(string key)
	{
		this.items.Remove(key);
	}

	public void SetBool(string key, bool value)
	{
		this.SetString(key, value ? "1" : "0");
	}

	public void SetInt(string key, int value)
	{
		this.SetString(key, this.platform.IntToString(value));
	}

	public void SetString(string key, string value)
	{
		this.items.Set(key, value);
	}
	internal DictionaryStringString items;
	internal GamePlatform platform;
}

public class ProcessPacketTask : Action_
{

	bool Contains(string[] arr, int arrLength, string value)
	{
		return this.IndexOf(arr, arrLength, value) != -1;
	}

	int IndexOf(string[] arr, int arrLength, string value)
	{
		for (int i = 0; i < arrLength; i++) {
			if (Game.StringEquals(arr[i], value)) {
				return i;
			}
		}
		return -1;
	}

	internal void ProcessPacket(Packet_Server packet)
	{
		if (this.game.packetHandlers[packet.Id] != null) {
			this.game.packetHandlers[packet.Id].Handle(this.game, packet);
		}
		switch (packet.Id) {
		case 0:
			{
				string invalidversionstr = this.game.language.InvalidVersionConnectAnyway();
				this.game.serverGameVersion = packet.Identification.MdProtocolVersion;
				if (this.game.serverGameVersion != this.game.platform.GetGameVersion()) {
					this.game.ChatLog("[GAME] Different game versions");
					string q = this.game.platform.StringFormat2(invalidversionstr, this.game.platform.GetGameVersion(), this.game.serverGameVersion);
					this.game.invalidVersionDrawMessage = q;
					this.game.invalidVersionPacketIdentification = packet;
				}
				else {
					this.game.ProcessServerIdentification(packet);
				}
				this.game.ReceivedMapLength = 0;
			}
			break;
		case 1:
			{
				this.game.SendPingReply();
				this.game.ServerInfo.ServerPing.Send(this.game.platform);
			}
			break;
		case 111:
			{
				this.game.ServerInfo.ServerPing.Receive(this.game.platform);
			}
			break;
		case 2:
			{
				this.game.ChatLog("[GAME] Initialized map loading");
				this.game.ReceivedMapLength = 0;
				this.game.InvokeMapLoadingProgress(0, 0, this.game.language.Connecting());
			}
			break;
		case 3:
			{
				this.game.InvokeMapLoadingProgress(packet.LevelDataChunk.PercentComplete, this.game.ReceivedMapLength, packet.LevelDataChunk.Status);
			}
			break;
		case 4:
			{
				this.game.ChatLog("[GAME] Finished map loading");
			}
			break;
		case 6:
			{
				int x = packet.SetBlock.X;
				int y = packet.SetBlock.Y;
				int z = packet.SetBlock.Z;
				int type = packet.SetBlock.BlockType;
				{
					this.game.SetTileAndUpdate(x, y, z, type);
				}
			}
			break;
		case 61:
			{
				int ax = packet.FillArea.X1;
				int ay = packet.FillArea.Y1;
				int az = packet.FillArea.Z1;
				int bx = packet.FillArea.X2;
				int by = packet.FillArea.Y2;
				int bz = packet.FillArea.Z2;
				int startx = MathCi.MinInt(ax, bx);
				int endx = MathCi.MaxInt(ax, bx);
				int starty = MathCi.MinInt(ay, by);
				int endy = MathCi.MaxInt(ay, by);
				int startz = MathCi.MinInt(az, bz);
				int endz = MathCi.MaxInt(az, bz);
				int blockCount = packet.FillArea.BlockCount;
				{
					for (int x = startx; x <= endx; x++) {
						for (int y = starty; y <= endy; y++) {
							for (int z = startz; z <= endz; z++) {
								if (blockCount == 0) {
									return;
								}
								{
									this.game.SetTileAndUpdate(x, y, z, packet.FillArea.BlockType);
								}
								blockCount--;
							}
						}
					}
				}
			}
			break;
		case 62:
			{
				this.game.fillAreaLimit = packet.FillAreaLimit.Limit;
				if (this.game.fillAreaLimit > 100000) {
					this.game.fillAreaLimit = 100000;
				}
			}
			break;
		case 51:
			{
				this.game.AllowFreemove = packet.Freemove.IsEnabled != 0;
				if (!this.game.AllowFreemove) {
					this.game.controls.SetFreemove(0);
					this.game.movespeed = this.game.basemovespeed;
					this.game.Log(this.game.language.MoveNormal());
				}
			}
			break;
		case 26:
			{
				int x = packet.PlayerSpawnPosition.X;
				int y = packet.PlayerSpawnPosition.Y;
				int z = packet.PlayerSpawnPosition.Z;
				this.game.playerPositionSpawnX = x;
				this.game.playerPositionSpawnY = z;
				this.game.playerPositionSpawnZ = y;
				this.game.Log(this.game.platform.StringFormat(this.game.language.SpawnPositionSetTo(), this.game.platform.StringFormat3("{0},{1},{2}", this.game.platform.IntToString(x), this.game.platform.IntToString(y), this.game.platform.IntToString(z))));
			}
			break;
		case 13:
			{
				this.game.AddChatline(packet.Message.Message);
				this.game.ChatLog(packet.Message.Message);
			}
			break;
		case 14:
			{
				this.game.ChatLog(this.game.platform.StringFormat("[GAME] Disconnected by the server ({0})", packet.DisconnectPlayer.DisconnectReason));
				if (this.game.platform.IsMousePointerLocked()) {
					this.game.platform.ExitMousePointerLock();
				}
				this.game.platform.MessageBoxShowError(packet.DisconnectPlayer.DisconnectReason, "Disconnected from server");
				this.game.ExitToMainMenu_();
				break;
			}
		case 23:
			{
				Packet_ServerPlayerStats p = packet.PlayerStats;
				this.game.PlayerStats = p;
			}
			break;
		case 16:
			{
				if (packet.Inventory.Inventory != null) {
					this.game.UseInventory(packet.Inventory.Inventory);
				}
			}
			break;
		case 17:
			{
				packet.Season.Hour -= 1;
				if (packet.Season.Hour < 0) {
					packet.Season.Hour = 48;
				}
				int sunlight = this.game.NightLevels[packet.Season.Hour];
				this.game.SkySphereNight = sunlight < 8;
				this.game.d_SunMoonRenderer.day_length_in_seconds = 86400 / packet.Season.DayNightCycleSpeedup;
				int hour = packet.Season.Hour / 4;
				if (this.game.d_SunMoonRenderer.GetHour() != hour) {
					this.game.d_SunMoonRenderer.SetHour(hour);
				}
				if (this.game.sunlight_ != sunlight) {
					this.game.sunlight_ = sunlight;
					this.game.RedrawAllBlocks();
				}
			}
			break;
		case 18:
			{
				this.game.blobdownload = new CitoMemoryStream();
				this.game.blobdownloadname = packet.BlobInitialize.Name;
				this.game.blobdownloadmd5 = packet.BlobInitialize.Md5;
			}
			break;
		case 19:
			{
				int length = this.game.platform.ByteArrayLength(packet.BlobPart.Data);
				this.game.blobdownload.Write(packet.BlobPart.Data, 0, length);
				this.game.ReceivedMapLength += length;
			}
			break;
		case 20:
			{
				byte[] downloaded = this.game.blobdownload.ToArray();
				if (this.game.blobdownloadname != null) {
					this.game.SetFile(this.game.blobdownloadname, this.game.blobdownloadmd5, downloaded, this.game.blobdownload.Length());
				}
				this.game.blobdownload = null;
			}
			break;
		case 22:
			{
				this.game.PlaySoundAt(packet.Sound.Name, packet.Sound.X, packet.Sound.Y, packet.Sound.Z);
			}
			break;
		case 50:
			{
				for (int i = 128; i < 256; i++) {
					this.game.entities[i] = null;
				}
			}
			break;
		case 60:
			this.game.language.Override(packet.Translation.Lang, packet.Translation.Id, packet.Translation.Translation);
			break;
		case 56:
			this.game.NewBlockTypes[packet.BlockType.Id] = packet.BlockType.Blocktype;
			break;
		case 28:
			this.game.NightLevels = packet.SunLevels.Sunlevels;
			break;
		case 29:
			for (int i = 0; i < packet.LightLevels.LightlevelsCount; i++) {
				this.game.mLightLevels[i] = this.game.DeserializeFloat(packet.LightLevels.Lightlevels[i]);
			}
			break;
		case 53:
			IntRef oldFollowId = this.game.FollowId();
			this.game.Follow = packet.Follow.Client;
			if (packet.Follow.Tpp != 0) {
				this.game.SetCamera(CameraType.Overhead);
				this.game.player.position.rotx = Game.GetPi();
				this.game.GuiStateBackToGame();
			}
			else {
				this.game.SetCamera(CameraType.Fpp);
			}
			break;
		case 54:
			this.game.EntityAddLocal(this.game.CreateBulletEntity(this.game.DeserializeFloat(packet.Bullet.FromXFloat), this.game.DeserializeFloat(packet.Bullet.FromYFloat), this.game.DeserializeFloat(packet.Bullet.FromZFloat), this.game.DeserializeFloat(packet.Bullet.ToXFloat), this.game.DeserializeFloat(packet.Bullet.ToYFloat), this.game.DeserializeFloat(packet.Bullet.ToZFloat), this.game.DeserializeFloat(packet.Bullet.SpeedFloat)));
			break;
		case 55:
			if (!this.game.ammostarted) {
				this.game.ammostarted = true;
				for (int i = 0; i < packet.Ammo.TotalAmmoCount; i++) {
					Packet_IntInt k = packet.Ammo.TotalAmmo[i];
					this.game.LoadedAmmo[k.Key_] = MathCi.MinInt(k.Value_, this.game.blocktypes[k.Key_].AmmoMagazine);
				}
			}
			this.game.TotalAmmo = new int[1024];
			for (int i = 0; i < packet.Ammo.TotalAmmoCount; i++) {
				this.game.TotalAmmo[packet.Ammo.TotalAmmo[i].Key_] = packet.Ammo.TotalAmmo[i].Value_;
			}
			break;
		case 58:
			{
				Entity entity = new Entity();
				entity.expires = new Expires();
				entity.expires.timeLeft = this.game.DeserializeFloat(packet.Explosion.TimeFloat);
				entity.push = packet.Explosion;
				this.game.EntityAddLocal(entity);
			}
			break;
		case 59:
			{
				Entity entity = new Entity();
				Sprite sprite = new Sprite();
				sprite.image = "ChemicalGreen.png";
				sprite.size = 14;
				sprite.animationcount = 0;
				sprite.positionX = this.game.DeserializeFloat(packet.Projectile.FromXFloat);
				sprite.positionY = this.game.DeserializeFloat(packet.Projectile.FromYFloat);
				sprite.positionZ = this.game.DeserializeFloat(packet.Projectile.FromZFloat);
				entity.sprite = sprite;
				Grenade_ grenade = new Grenade_();
				grenade.velocityX = this.game.DeserializeFloat(packet.Projectile.VelocityXFloat);
				grenade.velocityY = this.game.DeserializeFloat(packet.Projectile.VelocityYFloat);
				grenade.velocityZ = this.game.DeserializeFloat(packet.Projectile.VelocityZFloat);
				grenade.block = packet.Projectile.BlockId;
				grenade.sourcePlayer = packet.Projectile.SourcePlayerID;
				entity.grenade = grenade;
				entity.expires = Expires.Create(this.game.DeserializeFloat(packet.Projectile.ExplodesAfterFloat));
				this.game.EntityAddLocal(entity);
			}
			break;
		case 27:
			this.game.blocktypes = this.game.NewBlockTypes;
			this.game.NewBlockTypes = new Packet_BlockType[1024];
			int textureInAtlasIdsCount = 1024;
			string[] textureInAtlasIds = new string[textureInAtlasIdsCount];
			int lastTextureId = 0;
			for (int i = 0; i < 1024; i++) {
				if (this.game.blocktypes[i] != null) {
					string[] to_load = new string[7];
					int to_loadLength = 7;
					{
						to_load[0] = this.game.blocktypes[i].TextureIdLeft;
						to_load[1] = this.game.blocktypes[i].TextureIdRight;
						to_load[2] = this.game.blocktypes[i].TextureIdFront;
						to_load[3] = this.game.blocktypes[i].TextureIdBack;
						to_load[4] = this.game.blocktypes[i].TextureIdTop;
						to_load[5] = this.game.blocktypes[i].TextureIdBottom;
						to_load[6] = this.game.blocktypes[i].TextureIdForInventory;
					}
					for (int k = 0; k < to_loadLength; k++) {
						if (!this.Contains(textureInAtlasIds, textureInAtlasIdsCount, to_load[k])) {
							textureInAtlasIds[lastTextureId++] = to_load[k];
						}
					}
				}
			}
			this.game.d_Data.UseBlockTypes(this.game.platform, this.game.blocktypes, 1024);
			for (int i = 0; i < 1024; i++) {
				Packet_BlockType b = this.game.blocktypes[i];
				if (b == null) {
					continue;
				}
				if (textureInAtlasIds != null) {
					this.game.TextureId[i][0] = this.IndexOf(textureInAtlasIds, textureInAtlasIdsCount, b.TextureIdTop);
					this.game.TextureId[i][1] = this.IndexOf(textureInAtlasIds, textureInAtlasIdsCount, b.TextureIdBottom);
					this.game.TextureId[i][2] = this.IndexOf(textureInAtlasIds, textureInAtlasIdsCount, b.TextureIdFront);
					this.game.TextureId[i][3] = this.IndexOf(textureInAtlasIds, textureInAtlasIdsCount, b.TextureIdBack);
					this.game.TextureId[i][4] = this.IndexOf(textureInAtlasIds, textureInAtlasIdsCount, b.TextureIdLeft);
					this.game.TextureId[i][5] = this.IndexOf(textureInAtlasIds, textureInAtlasIdsCount, b.TextureIdRight);
					this.game.TextureIdForInventory[i] = this.IndexOf(textureInAtlasIds, textureInAtlasIdsCount, b.TextureIdForInventory);
				}
			}
			this.game.UseTerrainTextures(textureInAtlasIds, textureInAtlasIdsCount);
			this.game.handRedraw = true;
			this.game.RedrawAllBlocks();
			break;
		case 65:
			this.game.ChatLog("[GAME] Received server redirect");
			this.game.SendLeave(0);
			this.game.ExitAndSwitchServer(packet.Redirect);
			break;
		}
	}

	public override void Run()
	{
		this.ProcessPacket(this.packet_);
	}
	internal Game game;
	internal Packet_Server packet_;
}

public class ProtoPlatform
{

	public static int ArrayLength(byte[] a)
	{
		int len;
		
            len = a.Length;
        return len;
	}

	public static string BytesToString(byte[] bytes, int length)
	{
		string s;
		
            s = Encoding.UTF8.GetString(bytes);
        return s;
	}

	public static byte IntToByte(int a)
	{
		return (byte) a;
	}

	public static byte[] StringToBytes(string s)
	{
		byte[] b;
		
            b = Encoding.UTF8.GetBytes(s);
            
        return b;
	}

	public static int logical_right_shift(int x, int n)
	{
		int mask = ~(-1 << n) << 32 - n;
		return ~mask & (x >> n | mask);
	}
}

public class ProtocolParser
{

	public static bool ReadBool(CitoStream stream)
	{
		int b = stream.ReadByte();
		if (b < 0)
			return false;
		if (b == 1)
			return true;
		if (b == 0)
			return false;
		return false;
	}

	/// <summary>&lt;summary&gt;
	/// Reads a length delimited byte array
	/// &lt;/summary&gt;</summary>
	public static byte[] ReadBytes(CitoStream stream)
	{
		int length = ProtocolParser.ReadUInt32(stream);
		byte[] buffer = new byte[length];
		int read = 0;
		while (read < length) {
			int r = stream.Read(buffer, read, length - read);
			if (r == 0)
				return null;
			read += r;
		}
		return buffer;
	}

	/// <summary>&lt;summary&gt;
	/// Since the int32 format is inefficient for negative numbers we have avoided to implement it.</summary>
	/// <remarks>The same functionality can be achieved using: (int)ReadUInt64(stream);
	/// &lt;/summary&gt;</remarks>
	public static int ReadInt32(CitoStream stream)
	{
		return ProtocolParser.ReadUInt64(stream);
	}

	/// <summary>&lt;summary&gt;
	/// Since the int64 format is inefficient for negative numbers we have avoided to implement it.</summary>
	/// <remarks>The same functionality can be achieved using: (long)ReadUInt64(stream);
	/// &lt;/summary&gt;</remarks>
	public static int ReadInt64(CitoStream stream)
	{
		return ProtocolParser.ReadUInt64(stream);
	}

	public static Key ReadKey(CitoStream stream)
	{
		int n = ProtocolParser.ReadUInt32(stream);
		return Key.Create(n >> 3, n & 7);
	}

	public static Key ReadKey_(byte firstByte, CitoStream stream)
	{
		if (firstByte < 128)
			return Key.Create(firstByte >> 3, firstByte & 7);
		int fieldID = ProtocolParser.ReadUInt32(stream) << 4 | firstByte >> 3 & 15;
		return Key.Create(fieldID, firstByte & 7);
	}

	/// <summary>&lt;summary&gt;
	/// Reads past a varint for an unknown field.</summary>
	/// <remarks>&lt;/summary&gt;</remarks>
	public static void ReadSkipVarInt(CitoStream stream)
	{
		while (true) {
			int b = stream.ReadByte();
			if (b < 0)
				return;
			if ((b & 128) == 0)
				return;
		}
	}

	public static string ReadString(CitoStream stream)
	{
		byte[] bytes = ProtocolParser.ReadBytes(stream);
		return ProtoPlatform.BytesToString(bytes, 0);
	}

	/// <summary>&lt;summary&gt;
	/// Unsigned VarInt format
	/// Do not use to read int32, use ReadUint64 for that.</summary>
	/// <remarks>&lt;/summary&gt;</remarks>
	public static int ReadUInt32(CitoStream stream)
	{
		int b;
		int val = 0;
		for (int n = 0; n < 5; n++) {
			b = stream.ReadByte();
			if (b < 0)
				return 0;
			if (n == 4 && (b & 240) != 0)
				return 0;
			if ((b & 128) == 0)
				return val | b << 7 * n;
			val |= (b & 127) << 7 * n;
		}
		return 0;
	}

	/// <summary>&lt;summary&gt;
	/// Unsigned VarInt format
	/// &lt;/summary&gt;</summary>
	public static int ReadUInt64(CitoStream stream)
	{
		int b;
		int val = 0;
		for (int n = 0; n < 10; n++) {
			b = stream.ReadByte();
			if (b < 0)
				return 0;
			if (n == 9 && (b & 254) != 0)
				return 0;
			if ((b & 128) == 0)
				return val | b << 7 * n;
			val |= (b & 127) << 7 * n;
		}
		return 0;
	}

	/// <summary>&lt;summary&gt;
	/// Read the value for an unknown key as bytes.</summary>
	/// <remarks>Used to preserve unknown keys during deserialization.
	/// Requires the message option preserveunknown=true.
	/// &lt;/summary&gt;</remarks>
	public static byte[] ReadValueBytes(CitoStream stream, Key key)
	{
		byte[] b;
		int offset = 0;
		switch (key.GetWireType()) {
		case 5:
			b = new byte[4];
			while (offset < 4)
				offset += stream.Read(b, offset, 4 - offset);
			return b;
		case 1:
			b = new byte[8];
			while (offset < 8)
				offset += stream.Read(b, offset, 8 - offset);
			return b;
		case 2:
			int length = ProtocolParser.ReadUInt32(stream);
			CitoMemoryStream ms = new CitoMemoryStream();
			{
				ProtocolParser.WriteUInt32(ms, length);
				b = new byte[length + ms.Length()];
				byte[] arr = ms.ToArray();
				for (int i = 0; i < ProtoPlatform.ArrayLength(arr); i++) {
					b[i] = arr[i];
				}
				offset = ms.Length();
			}
			while (offset < ProtoPlatform.ArrayLength(b))
				offset += stream.Read(b, offset, ProtoPlatform.ArrayLength(b) - offset);
			return b;
		case 0:
			return ProtocolParser.ReadVarIntBytes(stream);
		default:
			return null;
		}
	}

	public static byte[] ReadVarIntBytes(CitoStream stream)
	{
		byte[] buffer = new byte[10];
		int offset = 0;
		while (true) {
			int b = stream.ReadByte();
			if (b < 0)
				return null;
			buffer[offset] = (byte) b;
			offset += 1;
			if ((b & 128) == 0)
				break;
			if (offset >= ProtoPlatform.ArrayLength(buffer))
				return null;
		}
		byte[] ret = new byte[offset];
		for (int i = 0; i < offset; i++) {
			ret[i] = buffer[i];
		}
		return ret;
	}

	/// <summary>&lt;summary&gt;
	/// Zig-zag signed VarInt format
	/// &lt;/summary&gt;</summary>
	public static int ReadZInt32(CitoStream stream)
	{
		int val = ProtocolParser.ReadUInt32(stream);
		return val >> 1 ^ val << 31 >> 31;
	}

	/// <summary>&lt;summary&gt;
	/// Zig-zag signed VarInt format
	/// &lt;/summary&gt;</summary>
	public static int ReadZInt64(CitoStream stream)
	{
		int val = ProtocolParser.ReadUInt64(stream);
		return val >> 1 ^ val << 63 >> 63;
	}

	/// <summary>&lt;summary&gt;
	/// Skip the next varint length prefixed bytes.</summary>
	/// <remarks>Alternative to ReadBytes when the data is not of interest.
	/// &lt;/summary&gt;</remarks>
	public static void SkipBytes(CitoStream stream)
	{
		int length = ProtocolParser.ReadUInt32(stream);
		if (stream.CanSeek())
			stream.Seek(length, CitoSeekOrigin.Current);
		else
			ProtocolParser.ReadBytes(stream);
	}

	/// <summary>&lt;summary&gt;
	/// Seek past the value for the previously read key.</summary>
	/// <remarks>&lt;/summary&gt;</remarks>
	public static void SkipKey(CitoStream stream, Key key)
	{
		switch (key.GetWireType()) {
		case 5:
			stream.Seek(4, CitoSeekOrigin.Current);
			return;
		case 1:
			stream.Seek(8, CitoSeekOrigin.Current);
			return;
		case 2:
			stream.Seek(ProtocolParser.ReadUInt32(stream), CitoSeekOrigin.Current);
			return;
		case 0:
			ProtocolParser.ReadSkipVarInt(stream);
			return;
		default:
			return;
		}
	}

	public static void WriteBool(CitoStream stream, bool val)
	{
		byte ret = 0;
		if (val) {
			ret = 1;
		}
		stream.WriteByte(ret);
	}

	/// <summary>&lt;summary&gt;
	/// Writes length delimited byte array
	/// &lt;/summary&gt;</summary>
	public static void WriteBytes(CitoStream stream, byte[] val)
	{
		ProtocolParser.WriteUInt32_(stream, ProtoPlatform.ArrayLength(val));
		stream.Write(val, 0, ProtoPlatform.ArrayLength(val));
	}

	/// <summary>&lt;summary&gt;
	/// Since the int32 format is inefficient for negative numbers we have avoided to imlplement.</summary>
	/// <remarks>The same functionality can be achieved using: WriteUInt64(stream, (uint)val);
	/// Note that 64 must always be used for int32 to generate the ten byte wire format.
	/// &lt;/summary&gt;</remarks>
	public static void WriteInt32(CitoStream stream, int val)
	{
		ProtocolParser.WriteUInt64(stream, val);
	}

	/// <summary>&lt;summary&gt;
	/// Since the int64 format is inefficient for negative numbers we have avoided to implement.</summary>
	/// <remarks>The same functionality can be achieved using: WriteUInt64 (stream, (ulong)val);
	/// &lt;/summary&gt;</remarks>
	public static void WriteInt64(CitoStream stream, int val)
	{
		ProtocolParser.WriteUInt64(stream, val);
	}

	public static void WriteKey(CitoStream stream, Key key)
	{
		int n = key.GetField() << 3 | key.GetWireType();
		ProtocolParser.WriteUInt32_(stream, n);
	}

	public static void WriteString(CitoStream stream, string val)
	{
		ProtocolParser.WriteBytes(stream, ProtoPlatform.StringToBytes(val));
	}

	static void WriteUInt32(CitoMemoryStream ms, int length)
	{
	}

	/// <summary>&lt;summary&gt;
	/// Unsigned VarInt format
	/// &lt;/summary&gt;</summary>
	public static void WriteUInt32_(CitoStream stream, int val)
	{
		byte[] buffer = new byte[5];
		int count = 0;
		while (true) {
			buffer[count] = (byte) (val & 127);
			val = val >> 7;
			if (val == 0)
				break;
			buffer[count] |= 128;
			count += 1;
		}
		stream.Write(buffer, 0, count + 1);
	}

	/// <summary>&lt;summary&gt;
	/// Unsigned VarInt format
	/// &lt;/summary&gt;</summary>
	public static void WriteUInt64(CitoStream stream, int val)
	{
		byte[] buffer = new byte[10];
		int count = 0;
		while (true) {
			buffer[count] = (byte) (val & 127);
			val = ProtoPlatform.logical_right_shift(val, 7);
			if (val == 0)
				break;
			buffer[count] |= 128;
			count += 1;
		}
		stream.Write(buffer, 0, count + 1);
	}

	/// <summary>&lt;summary&gt;
	/// Zig-zag signed VarInt format
	/// &lt;/summary&gt;</summary>
	public static void WriteZInt32(CitoStream stream, int val)
	{
		ProtocolParser.WriteUInt32_(stream, val << 1 ^ val >> 31);
	}

	/// <summary>&lt;summary&gt;
	/// Zig-zag signed VarInt format
	/// &lt;/summary&gt;</summary>
	public static void WriteZInt64(CitoStream stream, int val)
	{
		ProtocolParser.WriteUInt64(stream, val << 1 ^ val >> 63);
	}
}

public class QuadModelData
{

	public static ModelData GetQuadModelData()
	{
		ModelData m = new ModelData();
		float[] xyz = new float[12];
		for (int i = 0; i < 12; i++) {
			xyz[i] = CiConstArray_1[i];
		}
		m.setXyz(xyz);
		float[] uv = new float[8];
		for (int i = 0; i < 8; i++) {
			uv[i] = CiConstArray_2[i];
		}
		m.setUv(uv);
		m.SetVerticesCount(4);
		m.setIndices(CiConstArray_3);
		m.SetIndicesCount(6);
		return m;
	}

	public static ModelData GetQuadModelData2(float sx, float sy, float sw, float sh, float dx, float dy, float dw, float dh, byte r, byte g, byte b, byte a)
	{
		ModelData m = new ModelData();
		float[] xyz = new float[12];
		xyz[0] = dx;
		xyz[1] = dy;
		xyz[2] = 0;
		xyz[3] = dx + dw;
		xyz[4] = dy;
		xyz[5] = 0;
		xyz[6] = dx + dw;
		xyz[7] = dy + dh;
		xyz[8] = 0;
		xyz[9] = dx;
		xyz[10] = dy + dh;
		xyz[11] = 0;
		m.setXyz(xyz);
		float[] uv = new float[8];
		uv[0] = sx;
		uv[1] = sy;
		uv[2] = sx + sw;
		uv[3] = sy;
		uv[4] = sx + sw;
		uv[5] = sy + sh;
		uv[6] = sx;
		uv[7] = sy + sh;
		m.setUv(uv);
		byte[] rgba = new byte[16];
		for (int i = 0; i < 4; i++) {
			rgba[i * 4 + 0] = r;
			rgba[i * 4 + 1] = g;
			rgba[i * 4 + 2] = b;
			rgba[i * 4 + 3] = a;
		}
		m.setRgba(rgba);
		m.SetVerticesCount(4);
		m.setIndices(CiConstArray_3);
		m.SetIndicesCount(6);
		return m;
	}
	static readonly int[] CiConstArray_1 = { -1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0 };
	static readonly int[] CiConstArray_2 = { 0, 0, 1, 0, 1, 1, 0, 1 };
	static readonly int[] CiConstArray_3 = { 0, 1, 2, 0, 2, 3 };
}

public class Quat
{

	/// <summary>**</summary>
	public static float[] Add(float[] output, float[] a, float[] b)
	{
		return Vec4.Add(output, a, b);
	}

	/// <summary>**</summary>
	public static float[] CalculateW(float[] output, float[] a)
	{
		float x = a[0];
		float y = a[1];
		float z = a[2];
		output[0] = x;
		output[1] = y;
		output[2] = z;
		float one = 1;
		output[3] = -Platform.Sqrt(GlMatrixMath.Abs(one - x * x - y * y - z * z));
		return output;
	}

	/// <summary>**</summary>
	public static float[] CloneIt(float[] a)
	{
		return Vec4.CloneIt(a);
	}

	/// <summary>**</summary>
	public float[] Conjugate(float[] output, float[] a)
	{
		output[0] = -a[0];
		output[1] = -a[1];
		output[2] = -a[2];
		output[3] = a[3];
		return output;
	}

	/// <summary>**</summary>
	public static float[] Copy(float[] output, float[] a)
	{
		return Vec4.Copy(output, a);
	}

	/// <summary>**</summary>
	public static float[] Create()
	{
		float[] output = new float[4];
		output[0] = 0;
		output[1] = 0;
		output[2] = 0;
		output[3] = 1;
		return output;
	}

	/// <summary>**</summary>
	public static float Dot(float[] a, float[] b)
	{
		return Vec4.Dot(a, b);
	}

	/// <summary>**</summary>
	public static float[] FromMat3(float[] output, float[] m)
	{
		float fTrace = m[0] + m[4] + m[8];
		float fRoot;
		float zero = 0;
		float one = 1;
		float half = one / 2;
		if (fTrace > zero) {
			fRoot = Platform.Sqrt(fTrace + one);
			output[3] = half * fRoot;
			fRoot = half / fRoot;
			output[0] = (m[7] - m[5]) * fRoot;
			output[1] = (m[2] - m[6]) * fRoot;
			output[2] = (m[3] - m[1]) * fRoot;
		}
		else {
			int i = 0;
			if (m[4] > m[0])
				i = 1;
			if (m[8] > m[i * 3 + i])
				i = 2;
			int j = (i + 1) % 3;
			int k = (i + 2) % 3;
			fRoot = Platform.Sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + one);
			output[i] = half * fRoot;
			fRoot = half / fRoot;
			output[3] = (m[k * 3 + j] - m[j * 3 + k]) * fRoot;
			output[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
			output[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
		}
		return output;
	}

	/// <summary>**</summary>
	public static float[] FromValues(float x, float y, float z, float w)
	{
		return Vec4.FromValues(x, y, z, w);
	}

	/// <summary>**</summary>
	public static float[] Identity_(float[] output)
	{
		output[0] = 0;
		output[1] = 0;
		output[2] = 0;
		output[3] = 1;
		return output;
	}

	/// <summary>**</summary>
	public float[] Invert(float[] output, float[] a)
	{
		float a0 = a[0];
		float a1 = a[1];
		float a2 = a[2];
		float a3 = a[3];
		float dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
		float one = 1;
		float invDot = dot != 0 ? one / dot : 0;
		output[0] = -a0 * invDot;
		output[1] = -a1 * invDot;
		output[2] = -a2 * invDot;
		output[3] = a3 * invDot;
		return output;
	}

	/// <summary>**</summary>
	public static float Len(float[] a)
	{
		return Quat.Length_(a);
	}

	/// <summary>**</summary>
	public static float Length_(float[] a)
	{
		return Vec4.Length_(a);
	}

	/// <summary>**</summary>
	public static float[] Lerp(float[] output, float[] a, float[] b, float t)
	{
		return Vec4.Lerp(output, a, b, t);
	}

	/// <summary>**</summary>
	public static float[] Mul(float[] output, float[] a, float[] b)
	{
		return Quat.Multiply(output, a, b);
	}

	/// <summary>**</summary>
	public static float[] Multiply(float[] output, float[] a, float[] b)
	{
		float ax = a[0];
		float ay = a[1];
		float az = a[2];
		float aw = a[3];
		float bx = b[0];
		float by = b[1];
		float bz = b[2];
		float bw = b[3];
		output[0] = ax * bw + aw * bx + ay * bz - az * by;
		output[1] = ay * bw + aw * by + az * bx - ax * bz;
		output[2] = az * bw + aw * bz + ax * by - ay * bx;
		output[3] = aw * bw - ax * bx - ay * by - az * bz;
		return output;
	}

	/// <summary>**</summary>
	public static float[] Normalize(float[] output, float[] a)
	{
		return Vec4.Normalize(output, a);
	}

	/// <summary>**</summary>
	public static float[] RotateX(float[] output, float[] a, float rad)
	{
		rad /= 2;
		float ax = a[0];
		float ay = a[1];
		float az = a[2];
		float aw = a[3];
		float bx = Platform.Sin(rad);
		float bw = Platform.Cos(rad);
		output[0] = ax * bw + aw * bx;
		output[1] = ay * bw + az * bx;
		output[2] = az * bw - ay * bx;
		output[3] = aw * bw - ax * bx;
		return output;
	}

	/// <summary>**</summary>
	public static float[] RotateY(float[] output, float[] a, float rad)
	{
		rad /= 2;
		float ax = a[0];
		float ay = a[1];
		float az = a[2];
		float aw = a[3];
		float by = Platform.Sin(rad);
		float bw = Platform.Cos(rad);
		output[0] = ax * bw - az * by;
		output[1] = ay * bw + aw * by;
		output[2] = az * bw + ax * by;
		output[3] = aw * bw - ay * by;
		return output;
	}

	/// <summary>**</summary>
	public static float[] RotateZ(float[] output, float[] a, float rad)
	{
		rad /= 2;
		float ax = a[0];
		float ay = a[1];
		float az = a[2];
		float aw = a[3];
		float bz = Platform.Sin(rad);
		float bw = Platform.Cos(rad);
		output[0] = ax * bw + ay * bz;
		output[1] = ay * bw - ax * bz;
		output[2] = az * bw + aw * bz;
		output[3] = aw * bw - az * bz;
		return output;
	}

	/// <summary>**</summary>
	public static float[] RotationTo(float[] output, float[] a, float[] b)
	{
		float[] tmpvec3 = Vec3.Create();
		float[] xUnitVec3 = Vec3.FromValues(1, 0, 0);
		float[] yUnitVec3 = Vec3.FromValues(0, 1, 0);
		float dot = Vec3.Dot(a, b);
		float nines = 999999;
		nines /= 1000000;
		float epsilon = 1;
		epsilon /= 1000000;
		if (dot < -nines) {
			Vec3.Cross(tmpvec3, xUnitVec3, a);
			if (Vec3.Length_(tmpvec3) < epsilon)
				Vec3.Cross(tmpvec3, yUnitVec3, a);
			Vec3.Normalize(tmpvec3, tmpvec3);
			Quat.SetAxisAngle(output, tmpvec3, GlMatrixMath.PI());
			return output;
		}
		else if (dot > nines) {
			output[0] = 0;
			output[1] = 0;
			output[2] = 0;
			output[3] = 1;
			return output;
		}
		else {
			Vec3.Cross(tmpvec3, a, b);
			output[0] = tmpvec3[0];
			output[1] = tmpvec3[1];
			output[2] = tmpvec3[2];
			output[3] = 1 + dot;
			return Quat.Normalize(output, output);
		}
	}

	/// <summary>**</summary>
	public static float[] Scale(float[] output, float[] a, float b)
	{
		return Vec4.Scale(output, a, b);
	}

	/// <summary>**</summary>
	public static float[] Set(float[] output, float x, float y, float z, float w)
	{
		return Vec4.Set(output, x, y, z, w);
	}

	/// <summary>**</summary>
	public static float[] SetAxes(float[] output, float[] view, float[] right, float[] up)
	{
		float[] matr = Mat3.Create();
		matr[0] = right[0];
		matr[3] = right[1];
		matr[6] = right[2];
		matr[1] = up[0];
		matr[4] = up[1];
		matr[7] = up[2];
		matr[2] = view[0];
		matr[5] = view[1];
		matr[8] = view[2];
		return Quat.Normalize(output, Quat.FromMat3(output, matr));
	}

	/// <summary>**</summary>
	public static float[] SetAxisAngle(float[] output, float[] axis, float rad)
	{
		rad = rad / 2;
		float s = Platform.Sin(rad);
		output[0] = s * axis[0];
		output[1] = s * axis[1];
		output[2] = s * axis[2];
		output[3] = Platform.Cos(rad);
		return output;
	}

	/// <summary>**</summary>
	public static float[] Slerp(float[] output, float[] a, float[] b, float t)
	{
		float ax = a[0];
		float ay = a[1];
		float az = a[2];
		float aw = a[3];
		float bx = b[0];
		float by = b[1];
		float bz = b[2];
		float bw = b[3];
		float omega;
		float cosom;
		float sinom;
		float scale0;
		float scale1;
		cosom = ax * bx + ay * by + az * bz + aw * bw;
		if (cosom < 0) {
			cosom = -cosom;
			bx = -bx;
			by = -by;
			bz = -bz;
			bw = -bw;
		}
		float one = 1;
		float epsilon = one / 1000000;
		if (one - cosom > epsilon) {
			omega = Platform.Acos(cosom);
			sinom = Platform.Sin(omega);
			scale0 = Platform.Sin((one - t) * omega) / sinom;
			scale1 = Platform.Sin(t * omega) / sinom;
		}
		else {
			scale0 = one - t;
			scale1 = t;
		}
		output[0] = scale0 * ax + scale1 * bx;
		output[1] = scale0 * ay + scale1 * by;
		output[2] = scale0 * az + scale1 * bz;
		output[3] = scale0 * aw + scale1 * bw;
		return output;
	}

	/// <summary>**</summary>
	public static float SqrLen(float[] a)
	{
		return Quat.SquaredLength(a);
	}

	/// <summary>**</summary>
	public static float SquaredLength(float[] a)
	{
		return Vec4.SquaredLength(a);
	}

	/// <summary>**</summary>
	void f()
	{
	}
}

public class QueryClient
{
	public QueryClient()
	{
		this.result = new QueryResult();
		this.querySuccess = false;
		this.queryPerformed = false;
	}

	public QueryResult GetResult()
	{
		return this.result;
	}

	public string GetServerMessage()
	{
		return this.serverMessage;
	}

	public void PerformQuery(string ip, int port)
	{
		this.serverMessage = "";
		NetClient client;
		if (this.p.EnetAvailable()) {
			EnetNetClient c = new EnetNetClient();
			c.SetPlatform(this.p);
			client = c;
		}
		else {
			TcpNetClient c = new TcpNetClient();
			c.SetPlatform(this.p);
			client = c;
		}
		client.Start();
		client.Connect(ip, port);
		this.SendRequest(client);
		this.ReadPacket(client);
		this.queryPerformed = true;
	}

	void ReadPacket(NetClient client)
	{
		bool success = false;
		int started = this.p.TimeMillisecondsFromStart();
		int timeout = 2000;
		while (this.p.TimeMillisecondsFromStart() < started + timeout) {
			if (success) {
				this.querySuccess = true;
				return;
			}
			NetIncomingMessage msg;
			msg = client.ReadMessage();
			if (msg == null) {
				continue;
			}
			Packet_Server packet = new Packet_Server();
			Packet_ServerSerializer.DeserializeBuffer(msg.message, msg.messageLength, packet);
			switch (packet.Id) {
			case 64:
				this.result.Name = packet.QueryAnswer.Name;
				this.result.MOTD = packet.QueryAnswer.MOTD;
				this.result.PlayerCount = packet.QueryAnswer.PlayerCount;
				this.result.MaxPlayers = packet.QueryAnswer.MaxPlayers;
				this.result.PlayerList = packet.QueryAnswer.PlayerList;
				this.result.Port = packet.QueryAnswer.Port;
				this.result.GameMode = packet.QueryAnswer.GameMode;
				this.result.Password = packet.QueryAnswer.Password;
				this.result.PublicHash = packet.QueryAnswer.PublicHash;
				this.result.ServerVersion = packet.QueryAnswer.ServerVersion;
				this.result.MapSizeX = packet.QueryAnswer.MapSizeX;
				this.result.MapSizeY = packet.QueryAnswer.MapSizeY;
				this.result.MapSizeZ = packet.QueryAnswer.MapSizeZ;
				this.result.ServerThumbnail = packet.QueryAnswer.ServerThumbnail;
				success = true;
				continue;
			case 14:
				this.serverMessage = packet.DisconnectPlayer.DisconnectReason;
				return;
			default:
				continue;
			}
		}
		this.serverMessage = "Timeout while querying server!";
	}

	void SendRequest(NetClient client)
	{
		Packet_Client pp = ClientPackets.ServerQuery();
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ClientSerializer.Serialize(ms, pp);
		byte[] data = ms.ToArray();
		INetOutgoingMessage msg = new INetOutgoingMessage();
		msg.Write(data, ms.Length());
		client.SendMessage(msg, MyNetDeliveryMethod.ReliableOrdered);
	}

	public void SetPlatform(GamePlatform p_)
	{
		this.p = p_;
	}
	internal GamePlatform p;
	internal bool queryPerformed;
	internal bool querySuccess;
	internal QueryResult result;
	internal string serverMessage;
}

public class QueryResult
{
	internal string GameMode;
	internal string MOTD;
	internal int MapSizeX;
	internal int MapSizeY;
	internal int MapSizeZ;
	internal int MaxPlayers;
	internal string Name;
	internal bool Password;
	internal int PlayerCount;
	internal string PlayerList;
	internal int Port;
	internal string PublicHash;
	internal byte[] ServerThumbnail;
	internal string ServerVersion;
}

public class QueueAction
{
	public QueueAction()
	{
		this.Start(128);
	}

	public int Count()
	{
		return this.count;
	}

	public static QueueAction Create(int max_)
	{
		QueueAction queue = new QueueAction();
		queue.Start(max_);
		return queue;
	}

	public Action_ Dequeue()
	{
		Action_ ret = this.items[this.start];
		this.items[this.start] = null;
		this.start++;
		this.start = this.start % this.max;
		this.count--;
		return ret;
	}

	public void Enqueue(Action_ value)
	{
		if (this.count == this.max) {
			this.Resize(this.max * 2);
		}
		int pos = this.start + this.count;
		pos = pos % this.max;
		this.count++;
		this.items[pos] = value;
	}

	void Resize(int newSize)
	{
		Action_[] items2 = new Action_[newSize];
		for (int i = 0; i < this.max; i++) {
			items2[i] = this.items[(this.start + i) % this.max];
		}
		this.items = items2;
		this.start = 0;
		this.max = newSize;
	}

	void Start(int max_)
	{
		this.max = max_;
		this.items = new Action_[max_];
		this.count = 0;
	}
	internal int count;
	internal Action_[] items;
	internal int max;
	internal int start;
}

public class QueueByte
{
	public QueueByte()
	{
		this.max = 5242880;
		this.items = new byte[this.max];
	}

	public byte Dequeue()
	{
		byte ret = this.items[this.start];
		this.start++;
		this.start = this.start % this.max;
		this.count--;
		return ret;
	}

	public void DequeueRange(byte[] data, int length)
	{
		for (int i = 0; i < length; i++) {
			data[i] = this.Dequeue();
		}
	}

	public void Enqueue(byte value)
	{
		int pos = this.start + this.count;
		pos = pos % this.max;
		this.count++;
		this.items[pos] = value;
	}

	public int GetCount()
	{
		return this.count;
	}

	internal void PeekRange(byte[] data, int length)
	{
		for (int i = 0; i < length; i++) {
			data[i] = this.items[(this.start + i) % this.max];
		}
	}
	internal int count;
	byte[] items;
	internal int max;
	internal int start;
}

public class QueueByteArray
{
	public QueueByteArray()
	{
		this.items = new ByteArray[1];
		this.itemsSize = 1;
		this.count = 0;
	}

	internal int Count()
	{
		return this.count;
	}

	internal ByteArray Dequeue()
	{
		ByteArray ret = this.items[0];
		for (int i = 0; i < this.count - 1; i++) {
			this.items[i] = this.items[i + 1];
		}
		this.count--;
		return ret;
	}

	internal void Enqueue(ByteArray p)
	{
		if (this.count == this.itemsSize) {
			ByteArray[] items2 = new ByteArray[this.itemsSize * 2];
			for (int i = 0; i < this.itemsSize; i++) {
				items2[i] = this.items[i];
			}
			this.itemsSize = this.itemsSize * 2;
			this.items = items2;
		}
		this.items[this.count++] = p;
	}
	int count;
	ByteArray[] items;
	int itemsSize;
}

public class QueueINetOutgoingMessage
{
	public QueueINetOutgoingMessage()
	{
		this.items = new INetOutgoingMessage[1];
		this.itemsSize = 1;
		this.count = 0;
	}

	internal int Count()
	{
		return this.count;
	}

	internal INetOutgoingMessage Dequeue()
	{
		INetOutgoingMessage ret = this.items[0];
		for (int i = 0; i < this.count - 1; i++) {
			this.items[i] = this.items[i + 1];
		}
		this.count--;
		return ret;
	}

	internal void Enqueue(INetOutgoingMessage p)
	{
		if (this.count == this.itemsSize) {
			INetOutgoingMessage[] items2 = new INetOutgoingMessage[this.itemsSize * 2];
			for (int i = 0; i < this.itemsSize; i++) {
				items2[i] = this.items[i];
			}
			this.itemsSize = this.itemsSize * 2;
			this.items = items2;
		}
		this.items[this.count++] = p;
	}
	int count;
	INetOutgoingMessage[] items;
	int itemsSize;
}

public class QueueNetIncomingMessage
{
	public QueueNetIncomingMessage()
	{
		this.items = new NetIncomingMessage[1];
		this.itemsSize = 1;
		this.count = 0;
	}

	internal int Count()
	{
		return this.count;
	}

	internal NetIncomingMessage Dequeue()
	{
		NetIncomingMessage ret = this.items[0];
		for (int i = 0; i < this.count - 1; i++) {
			this.items[i] = this.items[i + 1];
		}
		this.count--;
		return ret;
	}

	internal void Enqueue(NetIncomingMessage p)
	{
		if (this.count == this.itemsSize) {
			NetIncomingMessage[] items2 = new NetIncomingMessage[this.itemsSize * 2];
			for (int i = 0; i < this.itemsSize; i++) {
				items2[i] = this.items[i];
			}
			this.itemsSize = this.itemsSize * 2;
			this.items = items2;
		}
		this.items[this.count++] = p;
	}
	int count;
	NetIncomingMessage[] items;
	int itemsSize;
}

public enum RailDirection
{
	Horizontal,
	Vertical,
	UpLeft,
	UpRight,
	DownLeft,
	DownRight
}

public class RailDirectionFlags
{
	public const int Corners = 60;
	public const int DownLeft = 16;
	public const int DownRight = 32;
	public const int Full = 63;
	public const int Horizontal = 1;
	public const int None = 0;
	public const int TwoHorizontalVertical = 3;
	public const int UpLeft = 4;
	public const int UpRight = 8;
	public const int Vertical = 2;
}

public class RailDirectionFlagsEnum
{
	public const int DownLeft = 16;
	public const int DownRight = 32;
	public const int Horizontal = 1;
	public const int None = 0;
	public const int UpLeft = 4;
	public const int UpRight = 8;
	public const int Vertical = 2;
}

public class RailMapUtil
{

	public RailSlope GetRailSlope(int x, int y, int z)
	{
		int tiletype = this.game.map.GetBlock(x, y, z);
		int railDirectionFlags = this.game.blocktypes[tiletype].Rail;
		int blocknear;
		if (x < this.game.map.MapSizeX - 1) {
			blocknear = this.game.map.GetBlock(x + 1, y, z);
			if (railDirectionFlags == 1 && blocknear != 0 && this.game.blocktypes[blocknear].Rail == 0) {
				return RailSlope.TwoRightRaised;
			}
		}
		if (x > 0) {
			blocknear = this.game.map.GetBlock(x - 1, y, z);
			if (railDirectionFlags == 1 && blocknear != 0 && this.game.blocktypes[blocknear].Rail == 0) {
				return RailSlope.TwoLeftRaised;
			}
		}
		if (y > 0) {
			blocknear = this.game.map.GetBlock(x, y - 1, z);
			if (railDirectionFlags == 2 && blocknear != 0 && this.game.blocktypes[blocknear].Rail == 0) {
				return RailSlope.TwoUpRaised;
			}
		}
		if (y < this.game.map.MapSizeY - 1) {
			blocknear = this.game.map.GetBlock(x, y + 1, z);
			if (railDirectionFlags == 2 && blocknear != 0 && this.game.blocktypes[blocknear].Rail == 0) {
				return RailSlope.TwoDownRaised;
			}
		}
		return RailSlope.Flat;
	}
	internal Game game;
}

public enum RailSlope
{
	Flat,
	TwoLeftRaised,
	TwoRightRaised,
	TwoUpRaised,
	TwoDownRaised
}

public class RailSlopeEnum
{
	public const int Flat = 0;
	public const int TwoDownRaised = 4;
	public const int TwoLeftRaised = 1;
	public const int TwoRightRaised = 2;
	public const int TwoUpRaised = 3;
}

public abstract class RandomCi
{

	public abstract int MaxNext(int range);

	public abstract int Next();

	public abstract float NextFloat();
}

public class RectFRef
{

	internal float Bottom()
	{
		return this.y + this.h;
	}

	public static RectFRef Create(float x_, float y_, float w_, float h_)
	{
		RectFRef r = new RectFRef();
		r.x = x_;
		r.y = y_;
		r.w = w_;
		r.h = h_;
		return r;
	}

	internal float Left()
	{
		return this.x;
	}

	internal float Right()
	{
		return this.x + this.w;
	}

	internal float Top()
	{
		return this.y;
	}
	internal float h;
	internal float w;
	internal float x;
	internal float y;
}

public class RectangleFloat
{

	public float Bottom()
	{
		return this.Y + this.Height;
	}

	public static RectangleFloat Create(float x_, float y_, float width_, float height_)
	{
		RectangleFloat r = new RectangleFloat();
		r.X = x_;
		r.Y = y_;
		r.Width = width_;
		r.Height = height_;
		return r;
	}
	internal float Height;
	internal float Width;
	internal float X;
	internal float Y;
}

public class RenderHintEnum
{
	public const int Fast = 0;
	public const int Nice = 1;
}

public class RenderedChunk
{
	public RenderedChunk()
	{
		this.dirty = true;
	}
	internal bool dirty;
	internal int[] ids;
	internal int idsCount;
	internal byte[] light;
}

public class Screen
{
	public Screen()
	{
		this.WidgetCount = 64;
		this.widgets = new MenuWidget[this.WidgetCount];
	}

	void AllLoseFocus()
	{
		for (int i = 0; i < this.WidgetCount; i++) {
			MenuWidget w = this.widgets[i];
			if (w != null) {
				w.LoseFocus();
			}
		}
	}

	public void DrawWidgets()
	{
		for (int i = 0; i < this.WidgetCount; i++) {
			MenuWidget w = this.widgets[i];
			if (w != null) {
				if (!w.visible) {
					continue;
				}
				string text = w.text;
				if (w.selected) {
					text = StringTools.StringAppend(this.menu.p, "&2", text);
				}
				if (w.type == WidgetType.Button) {
					if (w.buttonStyle == ButtonStyle.Text) {
						if (w.image != null) {
							this.menu.Draw2dQuad(this.menu.GetTexture(w.image), w.x, w.y, w.sizex, w.sizey);
						}
						this.menu.DrawText(text, w.fontSize, w.x, w.y + w.sizey / 2, TextAlign.Left, TextBaseline.Middle);
					}
					else if (w.buttonStyle == ButtonStyle.Button) {
						this.menu.DrawButton(text, w.fontSize, w.x, w.y, w.sizex, w.sizey, w.hover || w.hasKeyboardFocus);
						if (w.description != null) {
							this.menu.DrawText(w.description, w.fontSize, w.x, w.y + w.sizey / 2, TextAlign.Right, TextBaseline.Middle);
						}
					}
					else {
						string[] strings = this.menu.p.StringSplit(w.text, "\n", new IntRef());
						if (w.selected) {
							strings[0] = StringTools.StringAppend(this.menu.p, "&2", strings[0]);
							strings[1] = StringTools.StringAppend(this.menu.p, "&2", strings[1]);
							strings[2] = StringTools.StringAppend(this.menu.p, "&2", strings[2]);
							strings[3] = StringTools.StringAppend(this.menu.p, "&2", strings[3]);
						}
						this.menu.DrawServerButton(strings[0], strings[1], strings[2], strings[3], w.x, w.y, w.sizex, w.sizey, w.image);
						if (w.description != null) {
							this.menu.Draw2dQuad(this.menu.GetTexture("serverlist_entry_noresponse.png"), w.x - 38 * this.menu.GetScale(), w.y, w.sizey / 2, w.sizey / 2);
						}
						if (strings[4] != this.menu.p.GetGameVersion()) {
							this.menu.Draw2dQuad(this.menu.GetTexture("serverlist_entry_differentversion.png"), w.x - 38 * this.menu.GetScale(), w.y + w.sizey / 2, w.sizey / 2, w.sizey / 2);
						}
					}
				}
				if (w.type == WidgetType.Textbox) {
					if (w.password) {
						text = this.menu.CharRepeat(42, this.menu.StringLength(w.text));
					}
					if (w.editing) {
						text = StringTools.StringAppend(this.menu.p, text, "_");
					}
					if (w.buttonStyle == ButtonStyle.Text) {
						if (w.image != null) {
							this.menu.Draw2dQuad(this.menu.GetTexture(w.image), w.x, w.y, w.sizex, w.sizey);
						}
						this.menu.DrawText(text, w.fontSize, w.x, w.y, TextAlign.Left, TextBaseline.Top);
					}
					else {
						this.menu.DrawButton(text, w.fontSize, w.x, w.y, w.sizex, w.sizey, w.hover || w.editing || w.hasKeyboardFocus);
					}
					if (w.description != null) {
						this.menu.DrawText(w.description, w.fontSize, w.x, w.y + w.sizey / 2, TextAlign.Right, TextBaseline.Middle);
					}
				}
			}
		}
	}

	void KeyDown(KeyEventArgs e)
	{
		for (int i = 0; i < this.WidgetCount; i++) {
			MenuWidget w = this.widgets[i];
			if (w == null) {
				continue;
			}
			if (w.hasKeyboardFocus) {
				if (e.GetKeyCode() == 52 || e.GetKeyCode() == 49) {
					if (w.type == WidgetType.Button && e.GetKeyCode() == 49) {
						this.OnButton(w);
						return;
					}
					if (w.nextWidget != -1) {
						w.LoseFocus();
						this.widgets[w.nextWidget].GetFocus();
						return;
					}
				}
			}
			if (w.type == WidgetType.Textbox) {
				if (w.editing) {
					int key = e.GetKeyCode();
					if (e.GetCtrlPressed() && key == 104) {
						if (this.menu.p.ClipboardContainsText()) {
							w.text = StringTools.StringAppend(this.menu.p, w.text, this.menu.p.ClipboardGetText());
						}
						return;
					}
					if (key == 53) {
						if (this.menu.StringLength(w.text) > 0) {
							w.text = StringTools.StringSubstring(this.menu.p, w.text, 0, this.menu.StringLength(w.text) - 1);
						}
						return;
					}
				}
			}
		}
	}

	void KeyPress(KeyPressEventArgs e)
	{
		for (int i = 0; i < this.WidgetCount; i++) {
			MenuWidget w = this.widgets[i];
			if (w != null) {
				if (w.type == WidgetType.Textbox) {
					if (w.editing) {
						if (this.menu.p.IsValidTypingChar(e.GetKeyChar())) {
							w.text = StringTools.StringAppend(this.menu.p, w.text, this.menu.CharToString(e.GetKeyChar()));
						}
					}
				}
			}
		}
	}

	public virtual void LoadTranslations()
	{
	}

	void MouseDown(int x, int y)
	{
		bool editingChange = false;
		for (int i = 0; i < this.WidgetCount; i++) {
			MenuWidget w = this.widgets[i];
			if (w != null) {
				if (w.type == WidgetType.Button) {
					w.pressed = this.pointInRect(x, y, w.x, w.y, w.sizex, w.sizey);
				}
				if (w.type == WidgetType.Textbox) {
					w.pressed = this.pointInRect(x, y, w.x, w.y, w.sizex, w.sizey);
					bool wasEditing = w.editing;
					w.editing = w.pressed;
					if (w.editing && !wasEditing) {
						this.menu.p.ShowKeyboard(true);
						editingChange = true;
					}
					if (!w.editing && wasEditing && !editingChange) {
						this.menu.p.ShowKeyboard(false);
					}
				}
				if (w.pressed) {
					this.AllLoseFocus();
					w.GetFocus();
				}
			}
		}
	}

	void MouseMove(MouseEventArgs e)
	{
		if (e.GetEmulated() && !e.GetForceUsage()) {
			return;
		}
		for (int i = 0; i < this.WidgetCount; i++) {
			MenuWidget w = this.widgets[i];
			if (w != null) {
				w.hover = this.pointInRect(e.GetX(), e.GetY(), w.x, w.y, w.sizex, w.sizey);
			}
		}
	}

	void MouseUp(int x, int y)
	{
		for (int i = 0; i < this.WidgetCount; i++) {
			MenuWidget w = this.widgets[i];
			if (w != null) {
				w.pressed = false;
			}
		}
		for (int i = 0; i < this.WidgetCount; i++) {
			MenuWidget w = this.widgets[i];
			if (w != null) {
				if (w.type == WidgetType.Button) {
					if (this.pointInRect(x, y, w.x, w.y, w.sizex, w.sizey)) {
						this.OnButton(w);
					}
				}
			}
		}
	}

	public virtual void OnBackPressed()
	{
	}

	public virtual void OnButton(MenuWidget w)
	{
	}

	public virtual void OnKeyDown(KeyEventArgs e)
	{
		this.KeyDown(e);
	}

	public virtual void OnKeyPress(KeyPressEventArgs e)
	{
		this.KeyPress(e);
	}

	public virtual void OnKeyUp(KeyEventArgs e)
	{
	}

	public virtual void OnMouseDown(MouseEventArgs e)
	{
		this.MouseDown(e.GetX(), e.GetY());
	}

	public virtual void OnMouseMove(MouseEventArgs e)
	{
		this.MouseMove(e);
	}

	public virtual void OnMouseUp(MouseEventArgs e)
	{
		this.MouseUp(e.GetX(), e.GetY());
	}

	public virtual void OnMouseWheel(MouseWheelEventArgs e)
	{
	}

	public virtual void OnTouchEnd(TouchEventArgs e)
	{
		this.MouseUp(e.GetX(), e.GetY());
	}

	public virtual void OnTouchMove(TouchEventArgs e)
	{
	}

	public virtual void OnTouchStart(TouchEventArgs e)
	{
		this.MouseDown(e.GetX(), e.GetY());
	}

	public virtual void Render(float dt)
	{
	}
	internal int WidgetCount;
	internal MainMenu menu;

	bool pointInRect(float x, float y, float rx, float ry, float rw, float rh)
	{
		return x >= rx && y >= ry && x < rx + rw && y < ry + rh;
	}
	internal MenuWidget[] widgets;
}

public class ScreenConnectToIp : Screen
{
	public ScreenConnectToIp()
	{
		this.buttonConnect = new MenuWidget();
		this.buttonConnect.text = "Connect";
		this.buttonConnect.type = WidgetType.Button;
		this.buttonConnect.nextWidget = 3;
		this.textboxIp = new MenuWidget();
		this.textboxIp.type = WidgetType.Textbox;
		this.textboxIp.text = "";
		this.textboxIp.description = "Ip";
		this.textboxIp.nextWidget = 2;
		this.textboxPort = new MenuWidget();
		this.textboxPort.type = WidgetType.Textbox;
		this.textboxPort.text = "";
		this.textboxPort.description = "Port";
		this.textboxPort.nextWidget = 0;
		this.back = new MenuWidget();
		this.back.text = "Back";
		this.back.type = WidgetType.Button;
		this.back.nextWidget = 1;
		this.title = "Connect to IP";
		this.widgets[0] = this.buttonConnect;
		this.widgets[1] = this.textboxIp;
		this.widgets[2] = this.textboxPort;
		this.widgets[3] = this.back;
		this.textboxIp.GetFocus();
	}

	public override void LoadTranslations()
	{
		this.buttonConnect.text = this.menu.lang.Get("MainMenu_ConnectToIpConnect");
		this.textboxIp.description = this.menu.lang.Get("MainMenu_ConnectToIpIp");
		this.textboxPort.description = this.menu.lang.Get("MainMenu_ConnectToIpPort");
		this.title = this.menu.lang.Get("MainMenu_MultiplayerConnectIP");
	}

	public override void OnBackPressed()
	{
		this.menu.StartMultiplayer();
	}

	public override void OnButton(MenuWidget w)
	{
		if (w == this.buttonConnect) {
			FloatRef ret = new FloatRef();
			if (!Game.StringEquals(this.textboxIp.text, "") && this.menu.p.FloatTryParse(this.textboxPort.text, ret)) {
				this.menu.StartLogin(null, this.textboxIp.text, this.menu.p.IntParse(this.textboxPort.text));
			}
		}
		if (w == this.back) {
			this.OnBackPressed();
		}
	}

	public override void Render(float dt)
	{
		if (!this.loaded) {
			this.preferences_ip = this.menu.p.GetPreferences().GetString("ConnectToIpIp", "127.0.0.1");
			this.preferences_port = this.menu.p.GetPreferences().GetString("ConnectToIpPort", "25565");
			this.textboxIp.text = this.preferences_ip;
			this.textboxPort.text = this.preferences_port;
			this.loaded = true;
		}
		if (this.textboxIp.text != this.preferences_ip || this.textboxPort.text != this.preferences_port) {
			this.preferences_ip = this.textboxIp.text;
			this.preferences_port = this.textboxPort.text;
			Preferences preferences = this.menu.p.GetPreferences();
			preferences.SetString("ConnectToIpIp", this.preferences_ip);
			preferences.SetString("ConnectToIpPort", this.preferences_port);
			this.menu.p.SetPreferences(preferences);
		}
		GamePlatform p = this.menu.p;
		float scale = this.menu.GetScale();
		this.menu.DrawBackground();
		float leftx = p.GetCanvasWidth() / 2 - 400 * scale;
		float y = p.GetCanvasHeight() / 2 - 250 * scale;
		string loginResultText = null;
		if (this.errorText != null) {
			this.menu.DrawText(loginResultText, 14 * scale, leftx, y - 50 * scale, TextAlign.Left, TextBaseline.Top);
		}
		this.menu.DrawText(this.title, 14 * scale, leftx, y + 50 * scale, TextAlign.Left, TextBaseline.Top);
		this.textboxIp.x = leftx;
		this.textboxIp.y = y + 100 * scale;
		this.textboxIp.sizex = 256 * scale;
		this.textboxIp.sizey = 64 * scale;
		this.textboxIp.fontSize = 14 * scale;
		this.textboxPort.x = leftx;
		this.textboxPort.y = y + 200 * scale;
		this.textboxPort.sizex = 256 * scale;
		this.textboxPort.sizey = 64 * scale;
		this.textboxPort.fontSize = 14 * scale;
		this.buttonConnect.x = leftx;
		this.buttonConnect.y = y + 400 * scale;
		this.buttonConnect.sizex = 256 * scale;
		this.buttonConnect.sizey = 64 * scale;
		this.buttonConnect.fontSize = 14 * scale;
		this.back.x = 40 * scale;
		this.back.y = p.GetCanvasHeight() - 104 * scale;
		this.back.sizex = 256 * scale;
		this.back.sizey = 64 * scale;
		this.back.fontSize = 14 * scale;
		this.DrawWidgets();
	}
	MenuWidget back;
	MenuWidget buttonConnect;
	string errorText;
	bool loaded;
	string preferences_ip;
	string preferences_port;
	MenuWidget textboxIp;
	MenuWidget textboxPort;
	string title;
}

public class ScreenGame : Screen
{
	public ScreenGame()
	{
		this.game = new Game();
	}

	void Connect(GamePlatform platform)
	{
		if (this.singleplayer) {
			if (platform.SinglePlayerServerAvailable()) {
				platform.SinglePlayerServerStart(this.singleplayerSavePath);
			}
			else {
				this.serverSimple = new ServerSimple();
				DummyNetwork network = platform.SinglePlayerServerGetNetwork();
				network.Start(platform.MonitorCreate(), platform.MonitorCreate());
				DummyNetServer server = new DummyNetServer();
				server.network = network;
				server.platform = platform;
				server.Start();
				this.serverSimple.Start(server, this.singleplayerSavePath, platform);
				this.serverSimpleMod = new ModServerSimple();
				this.serverSimpleMod.server = this.serverSimple;
				this.game.AddMod(this.serverSimpleMod);
				platform.SinglePlayerServerGetNetwork().ServerReceiveBuffer.Enqueue(new ByteArray());
			}
			this.connectData = new ConnectData();
			this.connectData.Username = "Local";
			this.game.connectdata = this.connectData;
			DummyNetClient netclient = new DummyNetClient();
			netclient.SetPlatform(platform);
			netclient.SetNetwork(platform.SinglePlayerServerGetNetwork());
			this.game.main = netclient;
		}
		else {
			this.game.connectdata = this.connectData;
			if (platform.EnetAvailable()) {
				EnetNetClient client = new EnetNetClient();
				client.SetPlatform(platform);
				this.game.main = client;
			}
			else if (platform.TcpAvailable()) {
				TcpNetClient client = new TcpNetClient();
				client.SetPlatform(platform);
				this.game.main = client;
			}
			else if (platform.WebSocketAvailable()) {
				WebSocketClient client = new WebSocketClient();
				client.SetPlatform(platform);
				this.game.main = client;
			}
			else {
				platform.ThrowException("Network not implemented");
			}
		}
	}

	public override void OnBackPressed()
	{
		this.game.OnBackPressed();
	}

	public override void OnKeyDown(KeyEventArgs e)
	{
		this.game.KeyDown(e.GetKeyCode());
	}

	public override void OnKeyPress(KeyPressEventArgs e)
	{
		this.game.KeyPress(e.GetKeyChar());
	}

	public override void OnKeyUp(KeyEventArgs e)
	{
		this.game.KeyUp(e.GetKeyCode());
	}

	public override void OnMouseDown(MouseEventArgs e)
	{
		if (!this.game.platform.Focused()) {
			return;
		}
		this.game.MouseDown(e);
	}

	public override void OnMouseMove(MouseEventArgs e)
	{
		if (!this.game.platform.Focused()) {
			return;
		}
		this.game.MouseMove(e);
	}

	public override void OnMouseUp(MouseEventArgs e)
	{
		if (!this.game.platform.Focused()) {
			return;
		}
		this.game.MouseUp(e);
	}

	public override void OnMouseWheel(MouseWheelEventArgs e)
	{
		this.game.MouseWheelChanged(e);
	}

	public override void OnTouchEnd(TouchEventArgs e)
	{
		this.game.OnTouchEnd(e);
	}

	public override void OnTouchMove(TouchEventArgs e)
	{
		this.game.OnTouchMove(e);
	}

	public override void OnTouchStart(TouchEventArgs e)
	{
		this.game.OnTouchStart(e);
	}

	public override void Render(float dt)
	{
		if (this.game.reconnect) {
			this.game.Dispose();
			this.menu.StartGame(this.singleplayer, this.singleplayerSavePath, this.connectData);
			return;
		}
		if (this.game.exitToMainMenu) {
			this.game.Dispose();
			if (this.game.GetRedirect() != null) {
				QueryClient qclient = new QueryClient();
				qclient.SetPlatform(this.platform);
				qclient.PerformQuery(this.game.GetRedirect().GetIP(), this.game.GetRedirect().GetPort());
				if (qclient.queryPerformed && !qclient.querySuccess) {
					this.platform.MessageBoxShowError(qclient.GetServerMessage(), "Redirection error");
					this.menu.StartMainMenu();
					return;
				}
				QueryResult qresult = qclient.GetResult();
				LoginClientCi lic = new LoginClientCi();
				LoginData lidata = new LoginData();
				string token = this.platform.StringSplit(qresult.PublicHash, "=", new IntRef())[1];
				lic.Login(this.platform, this.connectData.Username, "", token, this.platform.GetPreferences().GetString("Password", ""), new LoginResultRef(), lidata);
				while (lic.loginResult.value == LoginResult.Connecting) {
					lic.Update(this.platform);
				}
				if (!lidata.ServerCorrect) {
					this.platform.MessageBoxShowError("Invalid server address!", "Redirection error!");
					this.menu.StartMainMenu();
				}
				else if (!lidata.PasswordCorrect) {
					this.menu.StartLogin(token, null, 0);
				}
				else if (lidata.ServerAddress != null && lidata.ServerAddress != "") {
					this.menu.ConnectToGame(lidata, this.connectData.Username);
				}
			}
			else {
				this.menu.StartMainMenu();
			}
			return;
		}
		this.game.OnRenderFrame(dt);
	}

	public void Start(GamePlatform platform_, bool singleplayer_, string singleplayerSavePath_, ConnectData connectData_)
	{
		this.platform = platform_;
		this.singleplayer = singleplayer_;
		this.singleplayerSavePath = singleplayerSavePath_;
		this.connectData = connectData_;
		this.game.platform = this.platform;
		this.game.issingleplayer = this.singleplayer;
		this.game.assets = this.menu.assets;
		this.game.assetsLoadProgress = this.menu.assetsLoadProgress;
		this.game.Start();
		this.Connect(this.platform);
	}
	ConnectData connectData;
	Game game;
	GamePlatform platform;
	ServerSimple serverSimple;
	ModServerSimple serverSimpleMod;
	bool singleplayer;
	string singleplayerSavePath;
}

public class ScreenLogin : Screen
{
	public ScreenLogin()
	{
		this.login = new MenuWidget();
		this.login.text = "Login";
		this.login.type = WidgetType.Button;
		this.login.nextWidget = 9;
		this.loginUsername = new MenuWidget();
		this.loginUsername.type = WidgetType.Textbox;
		this.loginUsername.text = "";
		this.loginUsername.description = "Username";
		this.loginUsername.nextWidget = 2;
		this.loginPassword = new MenuWidget();
		this.loginPassword.type = WidgetType.Textbox;
		this.loginPassword.text = "";
		this.loginPassword.description = "Password";
		this.loginPassword.password = true;
		this.loginPassword.nextWidget = 3;
		this.loginRememberMe = new MenuWidget();
		this.loginRememberMe.text = "Yes";
		this.loginRememberMe.type = WidgetType.Button;
		this.loginRememberMe.description = "Remember me";
		this.loginRememberMe.nextWidget = 0;
		this.createAccount = new MenuWidget();
		this.createAccount.text = "Create account";
		this.createAccount.type = WidgetType.Button;
		this.createAccountUsername = new MenuWidget();
		this.createAccountUsername.text = "";
		this.createAccountUsername.type = WidgetType.Textbox;
		this.createAccountUsername.description = "Username";
		this.createAccountPassword = new MenuWidget();
		this.createAccountPassword.text = "";
		this.createAccountPassword.type = WidgetType.Textbox;
		this.createAccountPassword.description = "Password";
		this.createAccountPassword.password = true;
		this.createAccountRememberMe = new MenuWidget();
		this.createAccountRememberMe.text = "Yes";
		this.createAccountRememberMe.type = WidgetType.Button;
		this.createAccountRememberMe.description = "Remember me";
		this.back = new MenuWidget();
		this.back.text = "Back";
		this.back.type = WidgetType.Button;
		this.back.nextWidget = 1;
		this.title = "Login";
		this.widgets[0] = this.login;
		this.widgets[1] = this.loginUsername;
		this.widgets[2] = this.loginPassword;
		this.widgets[3] = this.loginRememberMe;
		this.widgets[4] = this.createAccount;
		this.widgets[5] = this.createAccountUsername;
		this.widgets[6] = this.createAccountPassword;
		this.widgets[7] = this.createAccountRememberMe;
		this.widgets[9] = this.back;
		this.loginUsername.GetFocus();
		this.loginResult = new LoginResultRef();
	}

	public override void LoadTranslations()
	{
		this.login.text = this.menu.lang.Get("MainMenu_Login");
		this.loginUsername.description = this.menu.lang.Get("MainMenu_LoginUsername");
		this.loginPassword.description = this.menu.lang.Get("MainMenu_LoginPassword");
		this.loginRememberMe.text = this.menu.lang.Get("MainMenu_ChoiceYes");
		this.loginRememberMe.description = this.menu.lang.Get("MainMenu_LoginRemember");
		this.back.text = this.menu.lang.Get("MainMenu_ButtonBack");
		this.title = this.menu.lang.Get("MainMenu_Login");
	}

	public override void OnBackPressed()
	{
		this.menu.StartMultiplayer();
	}

	public override void OnButton(MenuWidget w)
	{
		if (w == this.login) {
			this.loginResultData = new LoginData();
			if (this.serverHash != null) {
				this.menu.Login(this.loginUsername.text, this.loginPassword.text, this.serverHash, "", this.loginResult, this.loginResultData);
			}
			else {
				if (this.loginRememberMe.text == this.menu.lang.Get("MainMenu_ChoiceYes")) {
					Preferences preferences = this.menu.p.GetPreferences();
					preferences.SetString("Username", this.loginUsername.text);
					this.menu.p.SetPreferences(preferences);
				}
				ConnectData connectdata = new ConnectData();
				connectdata.Ip = this.serverIp;
				connectdata.Port = this.serverPort;
				connectdata.Username = this.loginUsername.text;
				this.menu.StartGame(false, null, connectdata);
			}
		}
		if (w == this.createAccount) {
			this.menu.CreateAccount(this.createAccountUsername.text, this.createAccountPassword.text, this.loginResult);
		}
		if (w == this.loginRememberMe || w == this.createAccountRememberMe) {
			if (w.text == this.menu.lang.Get("MainMenu_ChoiceYes")) {
				w.text = this.menu.lang.Get("MainMenu_ChoiceNo");
			}
			else {
				w.text = this.menu.lang.Get("MainMenu_ChoiceYes");
			}
		}
		if (w == this.back) {
			this.OnBackPressed();
		}
	}

	public override void Render(float dt)
	{
		if (!this.triedSavedLogin) {
			Preferences preferences = this.menu.p.GetPreferences();
			this.loginUsername.text = preferences.GetString("Username", "");
			this.loginPassword.text = "";
			string token = preferences.GetString("Password", "");
			this.loginResultData = new LoginData();
			if (this.serverHash != null && token != "") {
				this.menu.Login(this.loginUsername.text, this.loginPassword.text, this.serverHash, token, this.loginResult, this.loginResultData);
			}
			this.triedSavedLogin = true;
		}
		if (this.loginResultData != null && this.loginResultData.ServerCorrect && this.loginResultData.PasswordCorrect) {
			if (this.loginRememberMe.text == this.menu.lang.Get("MainMenu_ChoiceYes")) {
				Preferences preferences = this.menu.p.GetPreferences();
				preferences.SetString("Username", this.loginUsername.text);
				if (this.loginResultData.Token != null && this.loginResultData.Token != "") {
					preferences.SetString("Password", this.loginResultData.Token);
				}
				this.menu.p.SetPreferences(preferences);
			}
			this.menu.ConnectToGame(this.loginResultData, this.loginUsername.text);
		}
		GamePlatform p = this.menu.p;
		float scale = this.menu.GetScale();
		this.menu.DrawBackground();
		float leftx = p.GetCanvasWidth() / 2 - 400 * scale;
		float y = p.GetCanvasHeight() / 2 - 250 * scale;
		string loginResultText = null;
		if (this.loginResult.value == LoginResult.Failed) {
			loginResultText = this.menu.lang.Get("MainMenu_LoginInvalid");
		}
		if (this.loginResult.value == LoginResult.Connecting) {
			loginResultText = this.menu.lang.Get("MainMenu_LoginConnecting");
		}
		if (loginResultText != null) {
			this.menu.DrawText(loginResultText, 14 * scale, leftx, y - 50 * scale, TextAlign.Left, TextBaseline.Top);
		}
		this.menu.DrawText(this.title, 14 * scale, leftx, y + 50 * scale, TextAlign.Left, TextBaseline.Top);
		this.loginUsername.x = leftx;
		this.loginUsername.y = y + 100 * scale;
		this.loginUsername.sizex = 256 * scale;
		this.loginUsername.sizey = 64 * scale;
		this.loginUsername.fontSize = 14 * scale;
		this.loginPassword.x = leftx;
		this.loginPassword.y = y + 200 * scale;
		this.loginPassword.sizex = 256 * scale;
		this.loginPassword.sizey = 64 * scale;
		this.loginPassword.fontSize = 14 * scale;
		this.loginRememberMe.x = leftx;
		this.loginRememberMe.y = y + 300 * scale;
		this.loginRememberMe.sizex = 256 * scale;
		this.loginRememberMe.sizey = 64 * scale;
		this.loginRememberMe.fontSize = 14 * scale;
		this.login.x = leftx;
		this.login.y = y + 400 * scale;
		this.login.sizex = 256 * scale;
		this.login.sizey = 64 * scale;
		this.login.fontSize = 14 * scale;
		float rightx = p.GetCanvasWidth() / 2 + 150 * scale;
		this.createAccountUsername.x = rightx;
		this.createAccountUsername.y = y + 100 * scale;
		this.createAccountUsername.sizex = 256 * scale;
		this.createAccountUsername.sizey = 64 * scale;
		this.createAccountUsername.fontSize = 14 * scale;
		this.createAccountPassword.x = rightx;
		this.createAccountPassword.y = y + 200 * scale;
		this.createAccountPassword.sizex = 256 * scale;
		this.createAccountPassword.sizey = 64 * scale;
		this.createAccountPassword.fontSize = 14 * scale;
		this.createAccountRememberMe.x = rightx;
		this.createAccountRememberMe.y = y + 300 * scale;
		this.createAccountRememberMe.sizex = 256 * scale;
		this.createAccountRememberMe.sizey = 64 * scale;
		this.createAccountRememberMe.fontSize = 14 * scale;
		this.createAccount.x = rightx;
		this.createAccount.y = y + 400 * scale;
		this.createAccount.sizex = 256 * scale;
		this.createAccount.sizey = 64 * scale;
		this.createAccount.fontSize = 14 * scale;
		this.createAccountUsername.visible = false;
		this.createAccountPassword.visible = false;
		this.createAccountRememberMe.visible = false;
		this.createAccount.visible = false;
		this.back.x = 40 * scale;
		this.back.y = p.GetCanvasHeight() - 104 * scale;
		this.back.sizex = 256 * scale;
		this.back.sizey = 64 * scale;
		this.back.fontSize = 14 * scale;
		this.DrawWidgets();
	}
	MenuWidget back;
	MenuWidget createAccount;
	MenuWidget createAccountPassword;
	MenuWidget createAccountRememberMe;
	MenuWidget createAccountUsername;
	MenuWidget login;
	MenuWidget loginPassword;
	MenuWidget loginRememberMe;
	LoginResultRef loginResult;
	LoginData loginResultData;
	MenuWidget loginUsername;
	internal string serverHash;
	internal string serverIp;
	internal int serverPort;
	string title;
	bool triedSavedLogin;
}

public class ScreenMain : Screen
{
	public ScreenMain()
	{
		this.singleplayer = new MenuWidget();
		this.multiplayer = new MenuWidget();
		this.exit = new MenuWidget();
		this.widgets[0] = this.singleplayer;
		this.widgets[1] = this.multiplayer;
		this.widgets[2] = this.exit;
		this.queryStringChecked = false;
		this.cursorLoaded = false;
	}

	public override void OnBackPressed()
	{
		this.menu.Exit();
	}

	public override void OnButton(MenuWidget w)
	{
		if (w == this.singleplayer) {
			this.menu.StartSingleplayer();
		}
		if (w == this.multiplayer) {
			this.menu.StartMultiplayer();
		}
		if (w == this.exit) {
			this.menu.Exit();
		}
	}

	public override void OnKeyDown(KeyEventArgs e)
	{
		if (e.GetKeyCode() == 14) {
			this.menu.p.SinglePlayerServerDisable();
			this.menu.StartGame(true, this.menu.p.PathCombine(this.menu.p.PathSavegames(), "Default.mdss"), null);
		}
		if (e.GetKeyCode() == 15) {
			this.menu.StartGame(true, this.menu.p.PathCombine(this.menu.p.PathSavegames(), "Default.mddbs"), null);
		}
	}

	public override void Render(float dt)
	{
		this.windowX = this.menu.p.GetCanvasWidth();
		this.windowY = this.menu.p.GetCanvasHeight();
		float scale = this.menu.GetScale();
		if (this.menu.assetsLoadProgress.value != 1) {
			string s = this.menu.p.StringFormat(this.menu.lang.Get("MainMenu_AssetsLoadProgress"), this.menu.p.FloatToString(this.menu.p.FloatToInt(this.menu.assetsLoadProgress.value * 100)));
			this.menu.DrawText(s, 20 * scale, this.windowX / 2, this.windowY / 2, TextAlign.Center, TextBaseline.Middle);
			return;
		}
		if (!this.cursorLoaded) {
			this.menu.p.SetWindowCursor(0, 0, 32, 32, this.menu.GetFile("mousecursor.png"), this.menu.GetFileLength("mousecursor.png"));
			this.cursorLoaded = true;
		}
		this.UseQueryStringIpAndPort(this.menu);
		this.menu.DrawBackground();
		this.menu.Draw2dQuad(this.menu.GetTexture("logo.png"), this.windowX / 2 - 1024 * scale / 2, 0, 1024 * scale, 512 * scale);
		int buttonheight = 64;
		int buttonwidth = 256;
		int spacebetween = 5;
		int offsetfromborder = 50;
		this.singleplayer.text = this.menu.lang.Get("MainMenu_Singleplayer");
		this.singleplayer.x = this.windowX / 2 - buttonwidth / 2 * scale;
		this.singleplayer.y = this.windowY - 3 * (buttonheight * scale + spacebetween) - offsetfromborder * scale;
		this.singleplayer.sizex = buttonwidth * scale;
		this.singleplayer.sizey = buttonheight * scale;
		this.multiplayer.text = this.menu.lang.Get("MainMenu_Multiplayer");
		this.multiplayer.x = this.windowX / 2 - buttonwidth / 2 * scale;
		this.multiplayer.y = this.windowY - 2 * (buttonheight * scale + spacebetween) - offsetfromborder * scale;
		this.multiplayer.sizex = buttonwidth * scale;
		this.multiplayer.sizey = buttonheight * scale;
		this.exit.visible = this.menu.p.ExitAvailable();
		this.exit.text = this.menu.lang.Get("MainMenu_Quit");
		this.exit.x = this.windowX / 2 - buttonwidth / 2 * scale;
		this.exit.y = this.windowY - 1 * (buttonheight * scale + spacebetween) - offsetfromborder * scale;
		this.exit.sizex = buttonwidth * scale;
		this.exit.sizey = buttonheight * scale;
		this.DrawWidgets();
	}

	void UseQueryStringIpAndPort(MainMenu menu)
	{
		if (this.queryStringChecked) {
			return;
		}
		this.queryStringChecked = true;
		string ip = menu.p.QueryStringValue("ip");
		string port = menu.p.QueryStringValue("port");
		int portInt = 25565;
		if (port != null && menu.p.FloatTryParse(port, new FloatRef())) {
			portInt = menu.p.IntParse(port);
		}
		if (ip != null) {
			menu.StartLogin(null, ip, portInt);
		}
	}
	bool cursorLoaded;
	MenuWidget exit;
	MenuWidget multiplayer;
	bool queryStringChecked;
	MenuWidget singleplayer;
	internal float windowX;
	internal float windowY;
}

public class ScreenModifyWorld : Screen
{
	public ScreenModifyWorld()
	{
		this.back = new MenuWidget();
		this.back.text = "Back";
		this.back.type = WidgetType.Button;
		this.widgets[0] = this.back;
	}

	public override void OnBackPressed()
	{
		this.menu.StartSingleplayer();
	}

	public override void OnButton(MenuWidget w)
	{
		if (w == this.back) {
			this.OnBackPressed();
		}
	}

	public override void Render(float dt)
	{
		GamePlatform p = this.menu.p;
		float scale = this.menu.GetScale();
		this.menu.DrawBackground();
		this.menu.DrawText("Modify World", 14 * scale, this.menu.p.GetCanvasWidth() / 2, 0, TextAlign.Center, TextBaseline.Top);
		this.back.x = 40 * scale;
		this.back.y = p.GetCanvasHeight() - 104 * scale;
		this.back.sizex = 256 * scale;
		this.back.sizey = 64 * scale;
		this.back.fontSize = 14 * scale;
		this.DrawWidgets();
	}
	MenuWidget back;
}

public class ScreenMultiplayer : Screen
{
	public ScreenMultiplayer()
	{
		this.WidgetCount = 1088;
		this.widgets = new MenuWidget[this.WidgetCount];
		this.back = new MenuWidget();
		this.back.text = "Back";
		this.back.type = WidgetType.Button;
		this.back.nextWidget = 1;
		this.connect = new MenuWidget();
		this.connect.text = "Connect";
		this.connect.type = WidgetType.Button;
		this.connect.nextWidget = 3;
		this.connectToIp = new MenuWidget();
		this.connectToIp.text = "Connect to IP";
		this.connectToIp.type = WidgetType.Button;
		this.connectToIp.nextWidget = 2;
		this.refresh = new MenuWidget();
		this.refresh.text = "Refresh";
		this.refresh.type = WidgetType.Button;
		this.refresh.nextWidget = 0;
		this.page = 0;
		this.pageUp = new MenuWidget();
		this.pageUp.text = "";
		this.pageUp.type = WidgetType.Button;
		this.pageUp.buttonStyle = ButtonStyle.Text;
		this.pageUp.visible = false;
		this.pageDown = new MenuWidget();
		this.pageDown.text = "";
		this.pageDown.type = WidgetType.Button;
		this.pageDown.buttonStyle = ButtonStyle.Text;
		this.pageDown.visible = false;
		this.loggedInName = new MenuWidget();
		this.loggedInName.text = "";
		this.loggedInName.type = WidgetType.Button;
		this.loggedInName.buttonStyle = ButtonStyle.Text;
		this.logout = new MenuWidget();
		this.logout.text = "";
		this.logout.type = WidgetType.Button;
		this.logout.buttonStyle = ButtonStyle.Button;
		this.title = "Multiplayer";
		this.widgets[0] = this.back;
		this.widgets[1] = this.connect;
		this.widgets[2] = this.refresh;
		this.widgets[3] = this.connectToIp;
		this.widgets[4] = this.pageUp;
		this.widgets[5] = this.pageDown;
		this.widgets[6] = this.loggedInName;
		this.widgets[7] = this.logout;
		this.serverListAddress = new HttpResponseCi();
		this.serverListCsv = new HttpResponseCi();
		this.serversOnList = new ServerOnList[1024];
		this.thumbResponses = new ThumbnailResponseCi[1024];
		this.serverButtons = new MenuWidget[1024];
		for (int i = 0; i < 1024; i++) {
			MenuWidget b = new MenuWidget();
			b = new MenuWidget();
			b.text = "Invalid";
			b.type = WidgetType.Button;
			b.visible = false;
			b.image = "serverlist_entry_noimage.png";
			this.serverButtons[i] = b;
			this.widgets[8 + i] = b;
		}
		this.loading = true;
	}

	public override void LoadTranslations()
	{
		this.back.text = this.menu.lang.Get("MainMenu_ButtonBack");
		this.connect.text = this.menu.lang.Get("MainMenu_MultiplayerConnect");
		this.connectToIp.text = this.menu.lang.Get("MainMenu_MultiplayerConnectIP");
		this.refresh.text = this.menu.lang.Get("MainMenu_MultiplayerRefresh");
		this.title = this.menu.lang.Get("MainMenu_Multiplayer");
	}

	public override void OnBackPressed()
	{
		this.menu.StartMainMenu();
	}

	public override void OnButton(MenuWidget w)
	{
		for (int i = 0; i < 1024; i++) {
			this.serverButtons[i].selected = false;
			if (this.serverButtons[i] == w) {
				this.serverButtons[i].selected = true;
				if (this.serversOnList[i + this.serversPerPage * this.page] != null) {
					this.selectedServerHash = this.serversOnList[i + this.serversPerPage * this.page].hash;
				}
			}
		}
		if (w == this.pageUp) {
			this.PageUp_();
		}
		if (w == this.pageDown) {
			this.PageDown_();
		}
		if (w == this.back) {
			this.OnBackPressed();
		}
		if (w == this.connect) {
			if (this.selectedServerHash != null) {
				this.menu.StartLogin(this.selectedServerHash, null, 0);
			}
		}
		if (w == this.connectToIp) {
			this.menu.StartConnectToIp();
		}
		if (w == this.refresh) {
			this.loaded = false;
			this.loading = true;
		}
		if (w == this.logout) {
			Preferences pref = this.menu.p.GetPreferences();
			pref.Remove("Username");
			pref.Remove("Password");
			this.menu.p.SetPreferences(pref);
			this.loggedInName.text = "";
		}
	}

	public override void OnMouseWheel(MouseWheelEventArgs e)
	{
		if (e.GetDelta() < 0) {
			this.PageUp_();
		}
		else if (e.GetDelta() > 0) {
			this.PageDown_();
		}
	}

	public void PageDown_()
	{
		if (this.page > 0) {
			this.page--;
		}
	}

	public void PageUp_()
	{
		if (this.pageUp.visible && this.page < 1024 / this.serversPerPage - 1) {
			this.page++;
		}
	}

	public override void Render(float dt)
	{
		if (!this.loaded) {
			this.menu.p.WebClientDownloadDataAsync("http://manicdigger.sourceforge.net/serverlistcsv.php", this.serverListAddress);
			this.loaded = true;
		}
		if (this.serverListAddress.done) {
			this.serverListAddress.done = false;
			this.menu.p.WebClientDownloadDataAsync(this.serverListAddress.GetString(this.menu.p), this.serverListCsv);
		}
		if (this.serverListCsv.done) {
			this.loading = false;
			this.serverListCsv.done = false;
			for (int i = 0; i < 1024; i++) {
				this.serversOnList[i] = null;
				this.thumbResponses[i] = null;
			}
			IntRef serversCount = new IntRef();
			string[] servers = this.menu.p.StringSplit(this.serverListCsv.GetString(this.menu.p), "\n", serversCount);
			for (int i = 0; i < serversCount.value; i++) {
				IntRef ssCount = new IntRef();
				string[] ss = this.menu.p.StringSplit(servers[i], "\t", ssCount);
				if (ssCount.value < 10) {
					continue;
				}
				ServerOnList s = new ServerOnList();
				s.hash = ss[0];
				s.name = this.menu.p.DecodeHTMLEntities(ss[1]);
				s.motd = this.menu.p.DecodeHTMLEntities(ss[2]);
				s.port = this.menu.p.IntParse(ss[3]);
				s.ip = ss[4];
				s.version = ss[5];
				s.users = this.menu.p.IntParse(ss[6]);
				s.max = this.menu.p.IntParse(ss[7]);
				s.gamemode = ss[8];
				s.players = ss[9];
				this.serversOnList[i] = s;
			}
		}
		GamePlatform p = this.menu.p;
		float scale = this.menu.GetScale();
		this.back.x = 40 * scale;
		this.back.y = p.GetCanvasHeight() - 104 * scale;
		this.back.sizex = 256 * scale;
		this.back.sizey = 64 * scale;
		this.back.fontSize = 14 * scale;
		this.connect.x = p.GetCanvasWidth() / 2 - 300 * scale;
		this.connect.y = p.GetCanvasHeight() - 104 * scale;
		this.connect.sizex = 256 * scale;
		this.connect.sizey = 64 * scale;
		this.connect.fontSize = 14 * scale;
		this.connectToIp.x = p.GetCanvasWidth() / 2 - 0 * scale;
		this.connectToIp.y = p.GetCanvasHeight() - 104 * scale;
		this.connectToIp.sizex = 256 * scale;
		this.connectToIp.sizey = 64 * scale;
		this.connectToIp.fontSize = 14 * scale;
		this.refresh.x = p.GetCanvasWidth() / 2 + 350 * scale;
		this.refresh.y = p.GetCanvasHeight() - 104 * scale;
		this.refresh.sizex = 256 * scale;
		this.refresh.sizey = 64 * scale;
		this.refresh.fontSize = 14 * scale;
		this.pageUp.x = p.GetCanvasWidth() - 94 * scale;
		this.pageUp.y = 100 * scale + (this.serversPerPage - 1) * 70 * scale;
		this.pageUp.sizex = 64 * scale;
		this.pageUp.sizey = 64 * scale;
		this.pageUp.image = "serverlist_nav_down.png";
		this.pageDown.x = p.GetCanvasWidth() - 94 * scale;
		this.pageDown.y = 100 * scale;
		this.pageDown.sizex = 64 * scale;
		this.pageDown.sizey = 64 * scale;
		this.pageDown.image = "serverlist_nav_up.png";
		this.loggedInName.x = p.GetCanvasWidth() - 228 * scale;
		this.loggedInName.y = 32 * scale;
		this.loggedInName.sizex = 128 * scale;
		this.loggedInName.sizey = 32 * scale;
		this.loggedInName.fontSize = 12 * scale;
		if (this.loggedInName.text == "") {
			if (p.GetPreferences().GetString("Password", "") != "") {
				this.loggedInName.text = p.GetPreferences().GetString("Username", "Invalid");
			}
		}
		this.logout.visible = this.loggedInName.text != "";
		this.logout.x = p.GetCanvasWidth() - 228 * scale;
		this.logout.y = 62 * scale;
		this.logout.sizex = 128 * scale;
		this.logout.sizey = 32 * scale;
		this.logout.fontSize = 12 * scale;
		this.logout.text = "Logout";
		this.menu.DrawBackground();
		this.menu.DrawText(this.title, 20 * scale, p.GetCanvasWidth() / 2, 10, TextAlign.Center, TextBaseline.Top);
		this.menu.DrawText(p.IntToString(this.page + 1), 14 * scale, p.GetCanvasWidth() - 68 * scale, p.GetCanvasHeight() / 2, TextAlign.Center, TextBaseline.Middle);
		if (this.loading) {
			this.menu.DrawText(this.menu.lang.Get("MainMenu_MultiplayerLoading"), 14 * scale, 100 * scale, 50 * scale, TextAlign.Left, TextBaseline.Top);
		}
		this.UpdateThumbnails();
		for (int i = 0; i < 1024; i++) {
			this.serverButtons[i].visible = false;
		}
		this.serversPerPage = this.menu.p.FloatToInt((this.menu.p.GetCanvasHeight() - 200 * scale) / 70 * scale);
		if (this.serversPerPage <= 0) {
			this.serversPerPage = 1;
		}
		for (int i = 0; i < this.serversPerPage; i++) {
			int index = i + this.serversPerPage * this.page;
			if (index > 1024) {
				this.page = 0;
				index = i + this.serversPerPage * this.page;
			}
			ServerOnList s = this.serversOnList[index];
			if (s == null) {
				continue;
			}
			string t = this.menu.p.StringFormat2("{1}", this.menu.p.IntToString(index), s.name);
			t = this.menu.p.StringFormat2("{0}\n{1}", t, s.motd);
			t = this.menu.p.StringFormat2("{0}\n{1}", t, s.gamemode);
			t = this.menu.p.StringFormat2("{0}\n{1}", t, this.menu.p.IntToString(s.users));
			t = this.menu.p.StringFormat2("{0}/{1}", t, this.menu.p.IntToString(s.max));
			t = this.menu.p.StringFormat2("{0}\n{1}", t, s.version);
			this.serverButtons[i].text = t;
			this.serverButtons[i].x = 100 * scale;
			this.serverButtons[i].y = 100 * scale + i * 70 * scale;
			this.serverButtons[i].sizex = p.GetCanvasWidth() - 200 * scale;
			this.serverButtons[i].sizey = 64 * scale;
			this.serverButtons[i].visible = true;
			this.serverButtons[i].buttonStyle = ButtonStyle.ServerEntry;
			if (s.thumbnailError) {
				this.serverButtons[i].description = "Server did not respond to query!";
			}
			else {
				this.serverButtons[i].description = null;
			}
			if (s.thumbnailFetched && !s.thumbnailError) {
				this.serverButtons[i].image = this.menu.p.StringFormat("serverlist_entry_{0}.png", s.hash);
			}
			else {
				this.serverButtons[i].image = "serverlist_entry_noimage.png";
			}
		}
		this.UpdateScrollButtons();
		this.DrawWidgets();
	}

	public void UpdateScrollButtons()
	{
		bool maxpage = false;
		if ((this.page + 1) * this.serversPerPage >= 1024) {
			maxpage = true;
		}
		else {
			if (this.serversOnList[(this.page + 1) * this.serversPerPage] == null) {
				maxpage = true;
			}
		}
		if (this.page == 0) {
			this.pageDown.visible = false;
		}
		else {
			this.pageDown.visible = true;
		}
		if (maxpage) {
			this.pageUp.visible = false;
		}
		else {
			this.pageUp.visible = true;
		}
	}

	public void UpdateThumbnails()
	{
		for (int i = 0; i < 1024; i++) {
			ServerOnList server = this.serversOnList[i];
			if (server == null) {
				continue;
			}
			if (server.thumbnailFetched) {
				continue;
			}
			if (!server.thumbnailDownloading) {
				this.thumbResponses[i] = new ThumbnailResponseCi();
				this.menu.p.ThumbnailDownloadAsync(server.ip, server.port, this.thumbResponses[i]);
				server.thumbnailDownloading = true;
			}
			else {
				if (this.thumbResponses[i] != null) {
					if (this.thumbResponses[i].done) {
						BitmapCi bmp = this.menu.p.BitmapCreateFromPng(this.thumbResponses[i].data, this.thumbResponses[i].dataLength);
						if (bmp != null) {
							int texture = this.menu.p.LoadTextureFromBitmap(bmp);
							this.menu.textures.Set(this.menu.p.StringFormat("serverlist_entry_{0}.png", server.hash), texture);
							this.menu.p.BitmapDelete(bmp);
						}
						server.thumbnailDownloading = false;
						server.thumbnailFetched = true;
					}
					if (this.thumbResponses[i].error) {
						server.thumbnailDownloading = false;
						server.thumbnailError = true;
						server.thumbnailFetched = true;
					}
				}
				else {
					server.thumbnailDownloading = false;
					server.thumbnailError = true;
					server.thumbnailFetched = true;
				}
			}
		}
	}
	MenuWidget back;
	MenuWidget connect;
	MenuWidget connectToIp;
	bool loaded;
	bool loading;
	MenuWidget loggedInName;
	MenuWidget logout;
	int page;
	MenuWidget pageDown;
	MenuWidget pageUp;
	MenuWidget refresh;
	string selectedServerHash;
	MenuWidget[] serverButtons;
	HttpResponseCi serverListAddress;
	HttpResponseCi serverListCsv;
	ServerOnList[] serversOnList;
	int serversPerPage;
	ThumbnailResponseCi[] thumbResponses;
	string title;
}

public class ScreenSingleplayer : Screen
{
	public ScreenSingleplayer()
	{
		this.play = new MenuWidget();
		this.play.text = "Play";
		this.newWorld = new MenuWidget();
		this.newWorld.text = "New World";
		this.modify = new MenuWidget();
		this.modify.text = "Modify";
		this.back = new MenuWidget();
		this.back.text = "Back";
		this.back.type = WidgetType.Button;
		this.open = new MenuWidget();
		this.open.text = "Create or open...";
		this.open.type = WidgetType.Button;
		this.title = "Singleplayer";
		this.widgets[0] = this.play;
		this.widgets[1] = this.newWorld;
		this.widgets[2] = this.modify;
		this.widgets[3] = this.back;
		this.widgets[4] = this.open;
		this.worldButtons = new MenuWidget[10];
		for (int i = 0; i < 10; i++) {
			this.worldButtons[i] = new MenuWidget();
			this.worldButtons[i].visible = false;
			this.widgets[5 + i] = this.worldButtons[i];
		}
	}

	public override void LoadTranslations()
	{
		this.back.text = this.menu.lang.Get("MainMenu_ButtonBack");
		this.open.text = this.menu.lang.Get("MainMenu_SingleplayerButtonCreate");
		this.title = this.menu.lang.Get("MainMenu_Singleplayer");
	}

	public override void OnBackPressed()
	{
		this.menu.StartMainMenu();
	}

	public override void OnButton(MenuWidget w)
	{
		for (int i = 0; i < 10; i++) {
			this.worldButtons[i].selected = false;
		}
		for (int i = 0; i < 10; i++) {
			if (this.worldButtons[i] == w) {
				this.worldButtons[i].selected = true;
			}
		}
		if (w == this.newWorld) {
			this.menu.StartNewWorld();
		}
		if (w == this.play) {
		}
		if (w == this.modify) {
			this.menu.StartModifyWorld();
		}
		if (w == this.back) {
			this.OnBackPressed();
		}
		if (w == this.open) {
			string extension;
			if (this.menu.p.SinglePlayerServerAvailable()) {
				extension = "mddbs";
			}
			else {
				extension = "mdss";
			}
			string result = this.menu.p.FileOpenDialog(extension, "Manic Digger Savegame", this.menu.p.PathSavegames());
			if (result != null) {
				this.menu.ConnectToSingleplayer(result);
			}
		}
	}

	public override void Render(float dt)
	{
		GamePlatform p = this.menu.p;
		float scale = this.menu.GetScale();
		this.menu.DrawBackground();
		this.menu.DrawText(this.title, 20 * scale, p.GetCanvasWidth() / 2, 10, TextAlign.Center, TextBaseline.Top);
		float leftx = p.GetCanvasWidth() / 2 - 128 * scale;
		float y = p.GetCanvasHeight() / 2 + 0 * scale;
		this.play.x = leftx;
		this.play.y = y + 100 * scale;
		this.play.sizex = 256 * scale;
		this.play.sizey = 64 * scale;
		this.play.fontSize = 14 * scale;
		this.newWorld.x = leftx;
		this.newWorld.y = y + 170 * scale;
		this.newWorld.sizex = 256 * scale;
		this.newWorld.sizey = 64 * scale;
		this.newWorld.fontSize = 14 * scale;
		this.modify.x = leftx;
		this.modify.y = y + 240 * scale;
		this.modify.sizex = 256 * scale;
		this.modify.sizey = 64 * scale;
		this.modify.fontSize = 14 * scale;
		this.back.x = 40 * scale;
		this.back.y = p.GetCanvasHeight() - 104 * scale;
		this.back.sizex = 256 * scale;
		this.back.sizey = 64 * scale;
		this.back.fontSize = 14 * scale;
		this.open.x = leftx;
		this.open.y = y + 0 * scale;
		this.open.sizex = 256 * scale;
		this.open.sizey = 64 * scale;
		this.open.fontSize = 14 * scale;
		if (this.savegames == null) {
			IntRef savegamesCount_ = new IntRef();
			this.savegames = this.menu.GetSavegames(savegamesCount_);
			this.savegamesCount = savegamesCount_.value;
		}
		for (int i = 0; i < 10; i++) {
			this.worldButtons[i].visible = false;
		}
		for (int i = 0; i < this.savegamesCount; i++) {
			this.worldButtons[i].visible = true;
			this.worldButtons[i].text = this.menu.p.FileName(this.savegames[i]);
			this.worldButtons[i].x = leftx;
			this.worldButtons[i].y = 100 + 100 * scale * i;
			this.worldButtons[i].sizex = 256 * scale;
			this.worldButtons[i].sizey = 64 * scale;
			this.worldButtons[i].fontSize = 14 * scale;
		}
		this.open.visible = this.menu.p.SinglePlayerServerAvailable();
		this.play.visible = false;
		this.newWorld.visible = false;
		this.modify.visible = false;
		for (int i = 0; i < this.savegamesCount; i++) {
			this.worldButtons[i].visible = false;
		}
		this.DrawWidgets();
		if (!this.menu.p.SinglePlayerServerAvailable()) {
			this.menu.DrawText("Singleplayer is only available on desktop (Windows, Linux, Mac) version of game.", 16 * scale, this.menu.p.GetCanvasWidth() / 2, this.menu.p.GetCanvasHeight() / 2, TextAlign.Center, TextBaseline.Middle);
		}
	}
	MenuWidget back;
	MenuWidget modify;
	MenuWidget newWorld;
	MenuWidget open;
	MenuWidget play;
	string[] savegames;
	int savegamesCount;
	string title;
	MenuWidget[] worldButtons;
}

public class Script
{

	public virtual void OnCreate(ScriptManager manager)
	{
	}

	public virtual void OnUse()
	{
	}
}

public class ScriptCharacterPhysics : EntityScript
{
	public ScriptCharacterPhysics()
	{
		this.movedz = 0;
		this.curspeed = new Vector3Ref();
		this.jumpacceleration = 0;
		this.isplayeronground = false;
		this.acceleration = new Acceleration();
		this.jumpstartacceleration = 0;
		this.jumpstartaccelerationhalf = 0;
		this.movespeednow = 0;
		this.tmpPlayerPosition = new float[3];
		this.tmpBlockingBlockType = new IntRef();
		this.constGravity = 0.3f;
		this.constWaterGravityMultiplier = 3;
		this.constEnableAcceleration = true;
		this.constJump = 2.1f;
	}

	public static float BoxPointDistance(float minX, float minY, float minZ, float maxX, float maxY, float maxZ, float pX, float pY, float pZ)
	{
		float dx = ScriptCharacterPhysics.Max3(minX - pX, 0, pX - maxX);
		float dy = ScriptCharacterPhysics.Max3(minY - pY, 0, pY - maxY);
		float dz = ScriptCharacterPhysics.Max3(minZ - pZ, 0, pZ - maxZ);
		return ScriptCharacterPhysics.Max3(dx, dy, dz);
	}

	int FloatToInt(float value)
	{
		return this.game.platform.FloatToInt(value);
	}

	bool IsEmptyPoint(float x, float y, float z, IntRef blockingBlocktype)
	{
		for (int xx = 0; xx < 3; xx++) {
			for (int yy = 0; yy < 3; yy++) {
				for (int zz = 0; zz < 3; zz++) {
					if (!this.IsTileEmptyForPhysics(this.FloatToInt(x + xx - 1), this.FloatToInt(z + zz - 1), this.FloatToInt(y + yy - 1))) {
						float minX = this.FloatToInt(x + xx - 1);
						float minY = this.FloatToInt(y + yy - 1);
						float minZ = this.FloatToInt(z + zz - 1);
						float maxX = minX + 1;
						float maxY = minY + this.game.getblockheight(this.FloatToInt(x + xx - 1), this.FloatToInt(z + zz - 1), this.FloatToInt(y + yy - 1));
						float maxZ = minZ + 1;
						if (ScriptCharacterPhysics.BoxPointDistance(minX, minY, minZ, maxX, maxY, maxZ, x, y, z) < this.game.constWallDistance) {
							if (blockingBlocktype != null) {
								blockingBlocktype.value = this.game.map.GetBlock(this.FloatToInt(x + xx - 1), this.FloatToInt(z + zz - 1), this.FloatToInt(y + yy - 1));
							}
							return false;
						}
					}
				}
			}
		}
		return true;
	}

	bool IsEmptySpaceForPlayer(bool high, float x, float y, float z, IntRef blockingBlockType)
	{
		return this.IsEmptyPoint(x, y, z, blockingBlockType) && this.IsEmptyPoint(x, y + 1, z, blockingBlockType) && (!high || this.IsEmptyPoint(x, y + 2, z, blockingBlockType));
	}

	public bool IsTileEmptyForPhysics(int x, int y, int z)
	{
		if (z >= this.game.map.MapSizeZ) {
			return true;
		}
		bool enableFreemove = false;
		if (x < 0 || y < 0 || z < 0) {
			return enableFreemove;
		}
		if (x >= this.game.map.MapSizeX || y >= this.game.map.MapSizeY) {
			return enableFreemove;
		}
		int block = this.game.map.GetBlockValid(x, y, z);
		if (block == 0) {
			return true;
		}
		Packet_BlockType blocktype = this.game.blocktypes[block];
		return blocktype.WalkableType == 1 || this.game.IsEmptyForPhysics(blocktype) || this.game.IsRail(blocktype);
	}

	public static float MakeCloserToZero(float a, float b)
	{
		if (a > 0) {
			float c = a - b;
			if (c < 0) {
				c = 0;
			}
			return c;
		}
		else {
			float c = a + b;
			if (c > 0) {
				c = 0;
			}
			return c;
		}
	}

	static float Max3(float a, float b, float c)
	{
		return MathCi.MaxFloat(MathCi.MaxFloat(a, b), c);
	}

	public override void OnNewFrameFixed(Game game_, int entity, float dt)
	{
		this.game = game_;
		if (this.game.guistate == GuiState.MapLoading) {
			return;
		}
		this.movespeednow = this.game.MoveSpeedNow();
		this.game.controls.movedx = MathCi.ClampFloat(this.game.controls.movedx, -1, 1);
		this.game.controls.movedy = MathCi.ClampFloat(this.game.controls.movedy, -1, 1);
		Controls move = this.game.controls;
		this.jumpstartacceleration = 13.333f * this.constGravity;
		this.jumpstartaccelerationhalf = 9 * this.constGravity;
		this.acceleration.SetDefault();
		this.game.soundnow = new BoolRef();
		if (this.game.FollowId() != null && this.game.FollowId().value == this.game.LocalPlayerId) {
			move.movedx = 0;
			move.movedy = 0;
			move.moveup = false;
			move.wantsjump = false;
		}
		this.Update(this.game.player.position, move, dt, this.game.soundnow, Vector3Ref.Create(this.game.pushX, this.game.pushY, this.game.pushZ), this.game.entities[this.game.LocalPlayerId].drawModel.ModelHeight);
	}

	bool StandingOnHalfBlock(float x, float y, float z)
	{
		int under = this.game.map.GetBlock(this.game.platform.FloatToInt(x), this.game.platform.FloatToInt(z), this.game.platform.FloatToInt(y));
		return this.game.blocktypes[under].DrawType == 11;
	}

	public void Update(EntityPosition_ stateplayerposition, Controls move, float dt, BoolRef soundnow, Vector3Ref push, float modelheight)
	{
		if (this.game.stopPlayerMove) {
			this.movedz = 0;
			this.game.stopPlayerMove = false;
		}
		if (!this.isplayeronground) {
			this.acceleration.acceleration1 = 0.99f;
			this.acceleration.acceleration2 = 0.2f;
			this.acceleration.acceleration3 = 70;
		}
		{
			int blockunderplayer = this.game.BlockUnderPlayer();
			if (blockunderplayer != -1 && blockunderplayer == this.game.d_Data.BlockIdTrampoline() && !this.isplayeronground && !this.game.controls.shiftkeydown) {
				this.game.controls.wantsjump = true;
				this.jumpstartacceleration = 20.666f * this.constGravity;
			}
		}
		{
			int blockunderplayer = this.game.BlockUnderPlayer();
			if (blockunderplayer != -1 && this.game.d_Data.IsSlipperyWalk()[blockunderplayer] || this.game.SwimmingBody()) {
				this.acceleration.acceleration1 = 0.99f;
				this.acceleration.acceleration2 = 0.2f;
				this.acceleration.acceleration3 = 70;
			}
		}
		soundnow.value = false;
		Vector3Ref diff1ref = new Vector3Ref();
		VectorTool.ToVectorInFixedSystem(move.movedx * this.movespeednow * dt, 0, move.movedy * this.movespeednow * dt, stateplayerposition.rotx, stateplayerposition.roty, diff1ref);
		Vector3Ref diff1 = new Vector3Ref();
		diff1.X = diff1ref.X;
		diff1.Y = diff1ref.Y;
		diff1.Z = diff1ref.Z;
		if (MiscCi.Vec3Length(push.X, push.Y, push.Z) > 0.01f) {
			push.Normalize();
			push.X *= 5;
			push.Y *= 5;
			push.Z *= 5;
		}
		diff1.X += push.X * dt;
		diff1.Y += push.Y * dt;
		diff1.Z += push.Z * dt;
		bool loaded = false;
		int cx = this.game.platform.FloatToInt(this.game.player.position.x / 16);
		int cy = this.game.platform.FloatToInt(this.game.player.position.z / 16);
		int cz = this.game.platform.FloatToInt(this.game.player.position.y / 16);
		if (this.game.map.IsValidChunkPos(cx, cy, cz)) {
			if (this.game.map.chunks[MapUtilCi.Index3d(cx, cy, cz, this.game.map.MapSizeX / 16, this.game.map.MapSizeY / 16)] != null) {
				loaded = true;
			}
		}
		else {
			loaded = true;
		}
		if (!move.freemove && loaded) {
			if (!this.game.SwimmingBody()) {
				this.movedz += -this.constGravity;
			}
			else {
				this.movedz += -this.constGravity * this.constWaterGravityMultiplier;
			}
		}
		this.game.movedz = this.movedz;
		if (this.constEnableAcceleration) {
			this.curspeed.X *= this.acceleration.acceleration1;
			this.curspeed.Y *= this.acceleration.acceleration1;
			this.curspeed.Z *= this.acceleration.acceleration1;
			this.curspeed.X = ScriptCharacterPhysics.MakeCloserToZero(this.curspeed.X, this.acceleration.acceleration2 * dt);
			this.curspeed.Y = ScriptCharacterPhysics.MakeCloserToZero(this.curspeed.Y, this.acceleration.acceleration2 * dt);
			this.curspeed.Z = ScriptCharacterPhysics.MakeCloserToZero(this.curspeed.Z, this.acceleration.acceleration2 * dt);
			diff1.Y += move.moveup ? 2 * this.movespeednow * dt : 0;
			diff1.Y -= move.movedown ? 2 * this.movespeednow * dt : 0;
			this.curspeed.X += diff1.X * this.acceleration.acceleration3 * dt;
			this.curspeed.Y += diff1.Y * this.acceleration.acceleration3 * dt;
			this.curspeed.Z += diff1.Z * this.acceleration.acceleration3 * dt;
			if (this.curspeed.Length() > this.movespeednow) {
				this.curspeed.Normalize();
				this.curspeed.X *= this.movespeednow;
				this.curspeed.Y *= this.movespeednow;
				this.curspeed.Z *= this.movespeednow;
			}
		}
		else {
			if (MiscCi.Vec3Length(diff1.X, diff1.Y, diff1.Z) > 0) {
				diff1.Normalize();
			}
			this.curspeed.X = diff1.X * this.movespeednow;
			this.curspeed.Y = diff1.Y * this.movespeednow;
			this.curspeed.Z = diff1.Z * this.movespeednow;
		}
		Vector3Ref newposition = Vector3Ref.Create(0, 0, 0);
		if (!move.freemove) {
			newposition.X = stateplayerposition.x + this.curspeed.X;
			newposition.Y = stateplayerposition.y + this.curspeed.Y;
			newposition.Z = stateplayerposition.z + this.curspeed.Z;
			if (!this.game.SwimmingBody()) {
				newposition.Y = stateplayerposition.y;
			}
			float diffx = newposition.X - stateplayerposition.x;
			float diffy = newposition.Y - stateplayerposition.y;
			float diffz = newposition.Z - stateplayerposition.z;
			float difflength = MiscCi.Vec3Length(diffx, diffy, diffz);
			if (difflength > 0) {
				diffx /= difflength;
				diffy /= difflength;
				diffz /= difflength;
				diffx *= this.curspeed.Length();
				diffy *= this.curspeed.Length();
				diffz *= this.curspeed.Length();
			}
			newposition.X = stateplayerposition.x + diffx * dt;
			newposition.Y = stateplayerposition.y + diffy * dt;
			newposition.Z = stateplayerposition.z + diffz * dt;
		}
		else {
			newposition.X = stateplayerposition.x + this.curspeed.X * dt;
			newposition.Y = stateplayerposition.y + this.curspeed.Y * dt;
			newposition.Z = stateplayerposition.z + this.curspeed.Z * dt;
		}
		newposition.Y += this.movedz * dt;
		Vector3Ref previousposition = Vector3Ref.Create(stateplayerposition.x, stateplayerposition.y, stateplayerposition.z);
		if (!move.noclip) {
			float[] v = this.WallSlide(Vec3.FromValues(stateplayerposition.x, stateplayerposition.y, stateplayerposition.z), Vec3.FromValues(newposition.X, newposition.Y, newposition.Z), modelheight);
			stateplayerposition.x = v[0];
			stateplayerposition.y = v[1];
			stateplayerposition.z = v[2];
		}
		else {
			stateplayerposition.x = newposition.X;
			stateplayerposition.y = newposition.Y;
			stateplayerposition.z = newposition.Z;
		}
		if (!move.freemove) {
			if (this.isplayeronground || this.game.SwimmingBody()) {
				this.jumpacceleration = 0;
				this.movedz = 0;
			}
			if ((move.wantsjump || move.wantsjumphalf) && (this.jumpacceleration == 0 && this.isplayeronground || this.game.SwimmingBody()) && loaded && !this.game.SwimmingEyes()) {
				this.jumpacceleration = move.wantsjumphalf ? this.jumpstartaccelerationhalf : this.jumpstartacceleration;
				soundnow.value = true;
			}
			if (this.jumpacceleration > 0) {
				this.isplayeronground = false;
				this.jumpacceleration = this.jumpacceleration / 2;
			}
			{
				this.movedz += this.jumpacceleration * this.constJump;
			}
		}
		else {
			this.isplayeronground = true;
		}
		this.game.isplayeronground = this.isplayeronground;
	}

	public float[] WallSlide(float[] oldposition, float[] newposition, float modelheight)
	{
		bool high = false;
		if (modelheight >= 2) {
			high = true;
		}
		oldposition[1] += this.game.constWallDistance;
		newposition[1] += this.game.constWallDistance;
		this.game.reachedwall = false;
		this.game.reachedwall_1blockhigh = false;
		this.game.reachedHalfBlock = false;
		this.tmpPlayerPosition[0] = oldposition[0];
		this.tmpPlayerPosition[1] = oldposition[1];
		this.tmpPlayerPosition[2] = oldposition[2];
		this.tmpBlockingBlockType.value = 0;
		if (this.IsEmptySpaceForPlayer(high, newposition[0], this.tmpPlayerPosition[1], this.tmpPlayerPosition[2], this.tmpBlockingBlockType)) {
			this.tmpPlayerPosition[0] = newposition[0];
		}
		else {
			this.game.reachedwall = true;
			if (this.IsEmptyPoint(newposition[0], this.tmpPlayerPosition[1] + 0.5f, this.tmpPlayerPosition[2], null)) {
				this.game.reachedwall_1blockhigh = true;
				if (this.game.blocktypes[this.tmpBlockingBlockType.value].DrawType == 11) {
					this.game.reachedHalfBlock = true;
				}
				if (this.StandingOnHalfBlock(newposition[0], this.tmpPlayerPosition[1], this.tmpPlayerPosition[2])) {
					this.game.reachedHalfBlock = true;
				}
			}
		}
		if (this.IsEmptySpaceForPlayer(high, this.tmpPlayerPosition[0], newposition[1], this.tmpPlayerPosition[2], this.tmpBlockingBlockType)) {
			this.tmpPlayerPosition[1] = newposition[1];
		}
		if (this.IsEmptySpaceForPlayer(high, this.tmpPlayerPosition[0], this.tmpPlayerPosition[1], newposition[2], this.tmpBlockingBlockType)) {
			this.tmpPlayerPosition[2] = newposition[2];
		}
		else {
			this.game.reachedwall = true;
			if (this.IsEmptyPoint(this.tmpPlayerPosition[0], this.tmpPlayerPosition[1] + 0.5f, newposition[2], null)) {
				this.game.reachedwall_1blockhigh = true;
				if (this.game.blocktypes[this.tmpBlockingBlockType.value].DrawType == 11) {
					this.game.reachedHalfBlock = true;
				}
				if (this.StandingOnHalfBlock(this.tmpPlayerPosition[0], this.tmpPlayerPosition[1], newposition[2])) {
					this.game.reachedHalfBlock = true;
				}
			}
		}
		this.isplayeronground = this.tmpPlayerPosition[1] == oldposition[1] && newposition[1] < oldposition[1];
		this.tmpPlayerPosition[1] -= this.game.constWallDistance;
		return this.tmpPlayerPosition;
	}
	internal Acceleration acceleration;
	internal bool constEnableAcceleration;
	internal float constGravity;
	internal float constJump;
	internal float constWaterGravityMultiplier;
	internal Vector3Ref curspeed;
	internal Game game;
	internal bool isplayeronground;
	internal float jumpacceleration;
	internal float jumpstartacceleration;
	internal float jumpstartaccelerationhalf;
	internal float movedz;
	internal float movespeednow;
	IntRef tmpBlockingBlockType;
	float[] tmpPlayerPosition;
}

public abstract class ScriptManager
{

	public abstract void SendMessage(int player, string p);
}

public class SendPacketAction : Action_
{

	public static SendPacketAction Create(ServerSimple server_, int client_, Packet_Server packet_)
	{
		SendPacketAction a = new SendPacketAction();
		a.server = server_;
		a.client = client_;
		a.packet = packet_;
		return a;
	}

	public override void Run()
	{
		this.server.SendPacket(this.client, this.packet);
	}
	internal int client;
	internal Packet_Server packet;
	internal ServerSimple server;
}

public class ServerCi
{
	public ServerCi()
	{
		this.one = 1;
		this.mainSocketsCount = 3;
	}
	internal NetServer[] mainSockets;
	internal int mainSocketsCount;
	float one;
}

public class ServerInformation
{
	public ServerInformation()
	{
		this.ServerName = "";
		this.ServerMotd = "";
		this.connectdata = new ConnectData();
		this.ServerPing = new Ping_();
	}
	internal string ServerMotd;
	internal string ServerName;
	internal Ping_ ServerPing;
	internal ConnectData connectdata;
}

public class ServerOnList
{
	internal string gamemode;
	internal string hash;
	internal string ip;
	internal int max;
	internal string motd;
	internal string name;
	internal string players;
	internal int port;
	internal bool thumbnailDownloading;
	internal bool thumbnailError;
	internal bool thumbnailFetched;
	internal int users;
	internal string version;
}

public class ServerPackets
{

	internal static Packet_Server AnswerQuery(Packet_ServerQueryAnswer answer)
	{
		Packet_Server p = new Packet_Server();
		p.Id = 64;
		p.QueryAnswer = answer;
		return p;
	}

	public static Packet_Server BlockType(int id, Packet_BlockType blockType)
	{
		Packet_Server p = new Packet_Server();
		p.Id = 56;
		p.BlockType = new Packet_ServerBlockType();
		p.BlockType.Id = id;
		p.BlockType.Blocktype = blockType;
		return p;
	}

	public static Packet_Server BlockTypes()
	{
		Packet_Server p = new Packet_Server();
		p.Id = 27;
		p.BlockTypes = new Packet_ServerBlockTypes();
		return p;
	}

	public static Packet_Server ChunkPart(byte[] compressedChunkPart)
	{
		Packet_Server p = new Packet_Server();
		p.Id = 57;
		p.ChunkPart = new Packet_ServerChunkPart();
		p.ChunkPart.CompressedChunkPart = compressedChunkPart;
		return p;
	}

	public static Packet_Server Chunk_(int x, int y, int z, int chunksize)
	{
		Packet_Server p = new Packet_Server();
		p.Id = 15;
		p.Chunk_ = new Packet_ServerChunk();
		p.Chunk_.X = x;
		p.Chunk_.Y = y;
		p.Chunk_.Z = z;
		p.Chunk_.SizeX = chunksize;
		p.Chunk_.SizeY = chunksize;
		p.Chunk_.SizeZ = chunksize;
		return p;
	}

	internal static Packet_Server DisconnectPlayer(string disconnectReason)
	{
		Packet_Server p = new Packet_Server();
		p.Id = 14;
		p.DisconnectPlayer = new Packet_ServerDisconnectPlayer();
		p.DisconnectPlayer.DisconnectReason = disconnectReason;
		return p;
	}

	internal static Packet_Server EntityDespawn(int id)
	{
		Packet_Server p = new Packet_Server();
		p.Id = 68;
		p.EntityDespawn = new Packet_ServerEntityDespawn();
		p.EntityDespawn.Id = id;
		return p;
	}

	internal static Packet_Server EntityPositionAndOrientation(int id, Packet_PositionAndOrientation positionAndOrientation)
	{
		Packet_Server p = new Packet_Server();
		p.Id = 67;
		p.EntityPosition = new Packet_ServerEntityPositionAndOrientation();
		p.EntityPosition.Id = id;
		p.EntityPosition.PositionAndOrientation = positionAndOrientation;
		return p;
	}

	internal static Packet_Server EntitySpawn(int id, Packet_ServerEntity entity)
	{
		Packet_Server p = new Packet_Server();
		p.Id = 66;
		p.EntitySpawn = new Packet_ServerEntitySpawn();
		p.EntitySpawn.Id = id;
		p.EntitySpawn.Entity_ = entity;
		return p;
	}

	public static Packet_Server Identification(int assignedClientId, int mapSizeX, int mapSizeY, int mapSizeZ, string version)
	{
		Packet_Server p = new Packet_Server();
		p.Id = 0;
		p.Identification = new Packet_ServerIdentification();
		p.Identification.AssignedClientId = assignedClientId;
		p.Identification.MapSizeX = mapSizeX;
		p.Identification.MapSizeY = mapSizeY;
		p.Identification.MapSizeZ = mapSizeZ;
		p.Identification.ServerName = "Simple";
		p.Identification.MdProtocolVersion = version;
		return p;
	}

	internal static Packet_Server Inventory(Packet_Inventory inventory)
	{
		Packet_Server p = new Packet_Server();
		p.Id = 16;
		p.Inventory = new Packet_ServerInventory();
		p.Inventory.Inventory = inventory;
		return p;
	}

	public static Packet_Server LevelFinalize()
	{
		Packet_Server p = new Packet_Server();
		p.Id = 4;
		p.LevelFinalize = new Packet_ServerLevelFinalize();
		return p;
	}

	public static Packet_Server LevelInitialize()
	{
		Packet_Server p = new Packet_Server();
		p.Id = 2;
		p.LevelInitialize = new Packet_ServerLevelInitialize();
		return p;
	}

	public static Packet_Server Message(string text)
	{
		Packet_Server p = new Packet_Server();
		p.Id = 13;
		p.Message = new Packet_ServerMessage();
		p.Message.Message = text;
		return p;
	}

	internal static Packet_Server Ping()
	{
		Packet_Server p = new Packet_Server();
		p.Id = 1;
		p.Ping = new Packet_ServerPing();
		return p;
	}

	internal static Packet_Server PlayerStats(int health, int maxHealth, int oxygen, int maxOxygen)
	{
		Packet_Server p = new Packet_Server();
		p.Id = 23;
		p.PlayerStats = new Packet_ServerPlayerStats();
		p.PlayerStats.CurrentHealth = health;
		p.PlayerStats.MaxHealth = maxHealth;
		p.PlayerStats.CurrentOxygen = oxygen;
		p.PlayerStats.MaxOxygen = maxOxygen;
		return p;
	}

	public static byte[] Serialize(Packet_Server packet, IntRef retLength)
	{
		CitoMemoryStream ms = new CitoMemoryStream();
		Packet_ServerSerializer.Serialize(ms, packet);
		byte[] data = ms.ToArray();
		retLength.value = ms.Length();
		return data;
	}

	internal static Packet_Server SetBlock(int x, int y, int z, int block)
	{
		Packet_Server p = new Packet_Server();
		p.Id = 6;
		p.SetBlock = new Packet_ServerSetBlock();
		p.SetBlock.X = x;
		p.SetBlock.Y = y;
		p.SetBlock.Z = z;
		p.SetBlock.BlockType = block;
		return p;
	}
}

public class ServerSimple
{
	public ServerSimple()
	{
		this.one = 1;
		this.clients = new ClientSimple[256];
		this.clientsCount = 0;
		this.blockTypes = new Packet_BlockType[1024];
		this.blockTypesCount = 0;
		this.mods = new ModSimple[128];
		ModManagerSimple1 m = new ModManagerSimple1();
		m.Start(this);
		this.mods[this.modsCount++] = new ModSimpleDefault();
		this.mods[this.modsCount++] = new ModSimpleWorldGenerator();
		for (int i = 0; i < this.modsCount; i++) {
			this.mods[i].Start(m);
		}
		this.MapSizeX = 8192;
		this.MapSizeY = 8192;
		this.MapSizeZ = 128;
		this.chunks = new ChunkSimple[this.MapSizeX / 32 * this.MapSizeY / 32][];
		this.chunkdrawdistance = 4;
		this.actions = new QueueAction();
		this.mainThreadActions = new QueueAction();
		this.spawnGlX = this.MapSizeX / 2;
		this.spawnGlY = this.MapSizeZ;
		for (int i = 0; i < this.modsCount; i++) {
			int spawnHeight = this.mods[i].GetHeight();
			if (spawnHeight != -1) {
				this.spawnGlY = spawnHeight;
			}
		}
		this.spawnGlZ = this.MapSizeY / 2;
	}
	public const int ChunkSize = 32;
	internal int MapSizeX;
	internal int MapSizeY;
	internal int MapSizeZ;

	void Move(QueueAction from, QueueAction to)
	{
		this.platform.MonitorEnter(this.mainThreadActionsLock);
		int count = from.count;
		for (int i = 0; i < count; i++) {
			Action_ task = from.Dequeue();
			to.Enqueue(task);
		}
		this.platform.MonitorExit(this.mainThreadActionsLock);
	}

	void NotifyInventory()
	{
		for (int i = 0; i < this.clientsCount; i++) {
			if (this.clients[i] == null) {
				continue;
			}
			if (!this.clients[i].connected) {
				continue;
			}
			if (!this.clients[i].inventoryDirty) {
				continue;
			}
			this.SendPacket(i, ServerPackets.Inventory(this.clients[i].inventory));
			this.clients[i].inventoryDirty = false;
		}
	}

	void NotifyMap()
	{
		for (int i = 0; i < this.clientsCount; i++) {
			if (this.clients[i] == null) {
				continue;
			}
			if (!this.clients[i].connected) {
				continue;
			}
			if (this.clients[i].notifyMapAction == null) {
				NotifyMapAction notify = new NotifyMapAction();
				notify.server = this;
				notify.clientId = i;
				this.clients[i].notifyMapAction = notify;
				this.platform.QueueUserWorkItem(notify);
			}
		}
	}

	void NotifyPing()
	{
		for (int i = 0; i < this.clientsCount; i++) {
			if (this.clients[i] == null) {
				continue;
			}
			int now = this.platform.TimeMillisecondsFromStart();
			if (now - this.clients[i].pingLastMilliseconds > 1000) {
				this.SendPacket(i, ServerPackets.Ping());
				this.clients[i].pingLastMilliseconds = now;
			}
		}
	}

	void ProcessActions()
	{
		this.Move(this.mainThreadActions, this.actions);
		while (this.actions.Count() > 0) {
			Action_ a = this.actions.Dequeue();
			a.Run();
		}
	}

	void ProcessPacket(int client, Packet_Client packet)
	{
		switch (packet.GetId()) {
		case 0:
			{
				if (packet.Identification == null) {
					return;
				}
				this.SendPacket(client, ServerPackets.Identification(0, this.MapSizeX, this.MapSizeY, this.MapSizeZ, this.platform.GetGameVersion()));
				this.clients[client].Name = packet.Identification.Username;
			}
			break;
		case 50:
			{
				this.SendPacket(client, ServerPackets.LevelInitialize());
				for (int i = 0; i < this.blockTypesCount; i++) {
					Packet_BlockType blocktype = this.blockTypes[i];
					if (blocktype == null) {
						blocktype = new Packet_BlockType();
					}
					this.SendPacket(client, ServerPackets.BlockType(i, blocktype));
				}
				this.SendPacket(client, ServerPackets.BlockTypes());
				this.SendPacket(client, ServerPackets.LevelFinalize());
				for (int i = 0; i < this.clientsCount; i++) {
					if (this.clients[i] == null) {
						continue;
					}
					this.clients[i].glX = this.spawnGlX;
					this.clients[i].glY = this.spawnGlY;
					this.clients[i].glZ = this.spawnGlZ;
					Packet_PositionAndOrientation pos = new Packet_PositionAndOrientation();
					pos.X = this.platform.FloatToInt(32 * this.clients[i].glX);
					pos.Y = this.platform.FloatToInt(32 * this.clients[i].glY);
					pos.Z = this.platform.FloatToInt(32 * this.clients[i].glZ);
					pos.Pitch = 127;
					Packet_ServerEntity e = new Packet_ServerEntity();
					e.DrawModel = new Packet_ServerEntityAnimatedModel();
					e.DrawModel.Model_ = "player.txt";
					e.DrawModel.ModelHeight = this.platform.FloatToInt(this.one * 17 / 10 * 32);
					e.DrawModel.EyeHeight = this.platform.FloatToInt(this.one * 15 / 10 * 32);
					e.Position = pos;
					this.SendPacket(client, ServerPackets.EntitySpawn(0, e));
					this.SendPacket(client, ServerPackets.PlayerStats(100, 100, 100, 100));
				}
				for (int i = 0; i < this.modsCount; i++) {
					this.mods[i].OnPlayerJoin(client);
				}
				this.clients[client].connected = true;
			}
			break;
		case 13:
			{
				this.SendPacketToAll(ServerPackets.Message(this.platform.StringFormat2("{0}: &f{1}", this.clients[client].Name, packet.Message.Message)));
			}
			break;
		case 5:
			{
				int x = packet.SetBlock.X;
				int y = packet.SetBlock.Y;
				int z = packet.SetBlock.Z;
				int block = packet.SetBlock.BlockType;
				int mode = packet.SetBlock.Mode;
				if (mode == 1) {
				}
				if (mode == 0) {
					this.SendPacketToAll(ServerPackets.SetBlock(x, y, z, 0));
				}
				if (mode == 2) {
				}
				if (mode == 3) {
				}
			}
			break;
		case 8:
			{
				this.clients[client].glX = this.one * packet.PositionAndOrientation.X / 32;
				this.clients[client].glY = this.one * packet.PositionAndOrientation.Y / 32;
				this.clients[client].glZ = this.one * packet.PositionAndOrientation.Z / 32;
			}
			break;
		case 51:
			{
				switch (packet.InventoryAction.Action) {
				case 0:
					break;
				}
			}
			break;
		}
	}

	void ProcessPackets()
	{
		for (;;) {
			NetIncomingMessage msg = this.server.ReadMessage();
			if (msg == null) {
				return;
			}
			switch (msg.Type) {
			case NetworkMessageType.Connect:
				ClientSimple c = new ClientSimple();
				c.MainSocket = this.server;
				c.Connection = msg.SenderConnection;
				c.chunksseen = new bool[this.MapSizeX / 32 * this.MapSizeY / 32][];
				this.clients[0] = c;
				this.clientsCount = 1;
				break;
			case NetworkMessageType.Data:
				byte[] data = msg.message;
				Packet_Client packet = new Packet_Client();
				Packet_ClientSerializer.DeserializeBuffer(data, msg.messageLength, packet);
				this.ProcessPacket(0, packet);
				break;
			case NetworkMessageType.Disconnect:
				break;
			}
		}
	}

	public void QueueMainThreadAction(Action_ action)
	{
		this.platform.MonitorEnter(this.mainThreadActionsLock);
		this.mainThreadActions.Enqueue(action);
		this.platform.MonitorExit(this.mainThreadActionsLock);
	}

	public void SendPacket(int client, Packet_Server packet)
	{
		IntRef length = new IntRef();
		byte[] data = ServerPackets.Serialize(packet, length);
		INetOutgoingMessage msg = new INetOutgoingMessage();
		msg.Write(data, length.value);
		this.clients[client].Connection.SendMessage(msg, MyNetDeliveryMethod.ReliableOrdered, 0);
	}

	void SendPacketToAll(Packet_Server packet)
	{
		for (int i = 0; i < this.clientsCount; i++) {
			this.SendPacket(i, packet);
		}
	}

	public void Start(NetServer server_, string saveFilename_, GamePlatform platform_)
	{
		this.server = server_;
		this.saveFilename = saveFilename_;
		this.platform = platform_;
		this.mainThreadActionsLock = this.platform.MonitorCreate();
	}

	public void Update()
	{
		this.ProcessPackets();
		this.NotifyMap();
		this.NotifyInventory();
		this.NotifyPing();
		this.ProcessActions();
	}
	QueueAction actions;
	internal Packet_BlockType[] blockTypes;
	internal int blockTypesCount;
	internal int chunkdrawdistance;
	internal ChunkSimple[][] chunks;
	internal ClientSimple[] clients;
	internal int clientsCount;
	QueueAction mainThreadActions;
	MonitorObject mainThreadActionsLock;
	internal ModSimple[] mods;
	internal int modsCount;
	float one;
	internal GamePlatform platform;
	string saveFilename;
	NetServer server;
	int spawnGlX;
	int spawnGlY;
	int spawnGlZ;
}

public class Sound_
{
	public Sound_()
	{
		this.name = null;
		this.x = 0;
		this.y = 0;
		this.z = 0;
		this.loop = false;
		this.stop = false;
		this.audio = null;
	}
	internal AudioCi audio;
	internal bool loop;
	internal string name;
	internal bool stop;
	internal float x;
	internal float y;
	internal float z;
}

public class SpecialBlockId
{
	public const int Empty = 0;
}

public class Speculative
{
	internal int blocktype;
	internal int timeMilliseconds;
	internal int x;
	internal int y;
	internal int z;
}

public class SphereModelData
{

	public static int[] CalculateElements(float radius, float height, int segments, int rings)
	{
		int i = 0;
		int[] data = new int[segments * rings * 6];
		for (int y = 0; y < rings - 1; y++) {
			for (int x = 0; x < segments - 1; x++) {
				data[i++] = (y + 0) * segments + x;
				data[i++] = (y + 1) * segments + x;
				data[i++] = (y + 1) * segments + x + 1;
				data[i++] = (y + 1) * segments + x + 1;
				data[i++] = (y + 0) * segments + x + 1;
				data[i++] = (y + 0) * segments + x;
			}
		}
		return data;
	}

	static float GetPi()
	{
		float a = 3141592;
		return a / 1000000;
	}

	public static ModelData GetSphereModelData(float radius, float height, int segments, int rings)
	{
		int i = 0;
		float[] xyz = new float[rings * segments * 3];
		float[] uv = new float[rings * segments * 2];
		byte[] rgba = new byte[rings * segments * 4];
		for (int y = 0; y < rings; y++) {
			float yFloat = y;
			float phiFloat = yFloat / (rings - 1) * SphereModelData.GetPi();
			for (int x = 0; x < segments; x++) {
				float xFloat = x;
				float thetaFloat = xFloat / (segments - 1) * 2 * SphereModelData.GetPi();
				float vxFloat = radius * Platform.Sin(phiFloat) * Platform.Cos(thetaFloat);
				float vyFloat = height * Platform.Cos(phiFloat);
				float vzFloat = radius * Platform.Sin(phiFloat) * Platform.Sin(thetaFloat);
				float uFloat = xFloat / (segments - 1);
				float vFloat = yFloat / (rings - 1);
				xyz[i * 3 + 0] = vxFloat;
				xyz[i * 3 + 1] = vyFloat;
				xyz[i * 3 + 2] = vzFloat;
				uv[i * 2 + 0] = uFloat;
				uv[i * 2 + 1] = vFloat;
				rgba[i * 4 + 0] = 255;
				rgba[i * 4 + 1] = 255;
				rgba[i * 4 + 2] = 255;
				rgba[i * 4 + 3] = 255;
				i++;
			}
		}
		ModelData data = new ModelData();
		data.SetVerticesCount(segments * rings);
		data.SetIndicesCount(segments * rings * 6);
		data.setXyz(xyz);
		data.setUv(uv);
		data.setRgba(rgba);
		data.setIndices(SphereModelData.CalculateElements(radius, height, segments, rings));
		return data;
	}
}

public class Sprite
{
	public Sprite()
	{
		this.size = 40;
	}
	internal int animationcount;
	internal string image;
	internal float positionX;
	internal float positionY;
	internal float positionZ;
	internal int size;
}

public class StackMatrix4
{
	public StackMatrix4()
	{
		this.values = new float[1024][];
		for (int i = 0; i < 1024; i++) {
			this.values[i] = Mat4.Create();
		}
	}

	internal int Count()
	{
		return this.count_;
	}

	internal float[] Peek()
	{
		return this.values[this.count_ - 1];
	}

	internal float[] Pop()
	{
		float[] ret = this.values[this.count_ - 1];
		this.count_--;
		return ret;
	}

	internal void Push(float[] p)
	{
		Mat4.Copy(this.values[this.count_], p);
		this.count_++;
	}
	int count_;
	float[][] values;
}

internal class StringByteArray
{
	internal byte[] data;
	internal string name;
}

public class StringTools
{

	public static string StringAppend(GamePlatform p, string a, string b)
	{
		IntRef aLength = new IntRef();
		int[] aChars = p.StringToCharArray(a, aLength);
		IntRef bLength = new IntRef();
		int[] bChars = p.StringToCharArray(b, bLength);
		int[] cChars = new int[aLength.value + bLength.value];
		for (int i = 0; i < aLength.value; i++) {
			cChars[i] = aChars[i];
		}
		for (int i = 0; i < bLength.value; i++) {
			cChars[i + aLength.value] = bChars[i];
		}
		return p.CharArrayToString(cChars, aLength.value + bLength.value);
	}

	public static int StringLength(GamePlatform p, string a)
	{
		IntRef aLength = new IntRef();
		int[] aChars = p.StringToCharArray(a, aLength);
		return aLength.value;
	}

	public static bool StringStartsWith(GamePlatform p, string s, string b)
	{
		return StringTools.StringSubstring(p, s, 0, StringTools.StringLength(p, b)) == b;
	}

	public static string StringSubstring(GamePlatform p, string a, int start, int count)
	{
		IntRef aLength = new IntRef();
		int[] aChars = p.StringToCharArray(a, aLength);
		int[] bChars = new int[count];
		for (int i = 0; i < count; i++) {
			bChars[i] = aChars[start + i];
		}
		return p.CharArrayToString(bChars, count);
	}

	public static string StringSubstringToEnd(GamePlatform p, string a, int start)
	{
		return StringTools.StringSubstring(p, a, start, StringTools.StringLength(p, a) - start);
	}
}

public class SunMoonRenderer : ClientMod
{
	public SunMoonRenderer()
	{
		this.one = 1;
		this.hour = 6;
		this.t = 0;
		this.suntexture = -1;
		this.moontexture = -1;
		this.ImageSize = 96;
		this.day_length_in_seconds = 30;
	}

	public int GetHour()
	{
		return this.hour;
	}
	internal int ImageSize;

	public override void OnNewFrameDraw3d(Game game, float dt)
	{
		GamePlatform platform = game.platform;
		game.GLMatrixModeModelView();
		if (this.suntexture == -1) {
			this.suntexture = game.GetTexture("sun.png");
			this.moontexture = game.GetTexture("moon.png");
		}
		this.UpdateSunMoonPosition(game, dt);
		float posX;
		float posY;
		float posZ;
		if (!game.isNight) {
			posX = game.sunPositionX;
			posY = game.sunPositionY;
			posZ = game.sunPositionZ;
		}
		else {
			posX = game.moonPositionX;
			posY = game.moonPositionY;
			posZ = game.moonPositionZ;
		}
		posX += game.player.position.x;
		posY += game.player.position.y;
		posZ += game.player.position.z;
		game.GLPushMatrix();
		game.GLTranslate(posX, posY, posZ);
		ModDrawSprites.Billboard(game);
		game.GLScale(this.one * 2 / 100, this.one * 2 / 100, this.one * 2 / 100);
		game.Draw2dTexture(game.isNight ? this.moontexture : this.suntexture, 0, 0, this.ImageSize, this.ImageSize, null, 0, Game.ColorFromArgb(255, 255, 255, 255), false);
		game.GLPopMatrix();
	}

	public void SetHour(int value)
	{
		this.hour = value;
		this.t = (this.hour - 6) / (this.one * 24) * 2 * Game.GetPi();
	}

	void UpdateSunMoonPosition(Game game, float dt)
	{
		this.t += dt * 2 * Game.GetPi() / this.day_length_in_seconds;
		game.isNight = (this.t + 2 * Game.GetPi()) % (2 * Game.GetPi()) > Game.GetPi();
		game.sunPositionX = game.platform.MathCos(this.t) * 20;
		game.sunPositionY = game.platform.MathSin(this.t) * 20;
		game.sunPositionZ = game.platform.MathSin(this.t) * 20;
		game.moonPositionX = game.platform.MathCos(-this.t) * 20;
		game.moonPositionY = game.platform.MathSin(-this.t) * 20;
		game.moonPositionZ = game.platform.MathSin(this.t) * 20;
	}
	internal float day_length_in_seconds;
	int hour;
	int moontexture;
	float one;
	int suntexture;
	float t;
}

public abstract class TableBinding
{

	public abstract void Get(string table, int index, DictionaryStringString items);

	public abstract void Set(string table, int index, string column, string value);
}

public class TableSerializer
{

	public void Deserialize(GamePlatform p, string data, TableBinding b)
	{
		IntRef linesCount = new IntRef();
		string[] lines = p.ReadAllLines(data, linesCount);
		string[] header = null;
		IntRef headerLength = new IntRef();
		string current = "";
		int currentI = 0;
		for (int i = 0; i < linesCount.value; i++) {
			string s = p.StringTrim(lines[i]);
			if (s == "") {
				continue;
			}
			if (p.StringStartsWithIgnoreCase(s, "//") || p.StringStartsWithIgnoreCase(s, "#")) {
				continue;
			}
			if (p.StringStartsWithIgnoreCase(s, "section=")) {
				current = p.StringReplace(s, "section=", "");
				string sHeader = p.StringTrim(lines[i + 1]);
				header = p.StringSplit(sHeader, "\t", headerLength);
				i++;
				currentI = 0;
				continue;
			}
			{
				if (header == null) {
					continue;
				}
				IntRef ssLength = new IntRef();
				string[] ss = p.StringSplit(s, "\t", ssLength);
				for (int k = 0; k < ssLength.value; k++) {
					b.Set(current, currentI, header[k], ss[k]);
				}
				currentI++;
			}
		}
	}
}

public class TaskScheduler
{
	public TaskScheduler()
	{
		this.actions = null;
	}

	public void Update(Game game, float dt)
	{
		if (this.actions == null) {
			this.actions = new BackgroundAction[game.clientmodsCount];
			for (int i = 0; i < game.clientmodsCount; i++) {
				this.actions[i] = new BackgroundAction();
			}
		}
		if (game.platform.MultithreadingAvailable()) {
			for (int i = 0; i < game.clientmodsCount; i++) {
				game.clientmods[i].OnReadOnlyMainThread(game, dt);
			}
			bool allDone = true;
			for (int i = 0; i < game.clientmodsCount; i++) {
				if (this.actions[i] != null && this.actions[i].active && !this.actions[i].finished) {
					allDone = false;
				}
			}
			if (allDone) {
				for (int i = 0; i < game.clientmodsCount; i++) {
					game.clientmods[i].OnReadWriteMainThread(game, dt);
				}
				for (int i = 0; i < game.commitActions.count; i++) {
					game.commitActions.items[i].Run();
				}
				game.commitActions.Clear();
				for (int i = 0; i < game.clientmodsCount; i++) {
					BackgroundAction a = this.actions[i];
					a.game = game;
					a.dt = dt;
					a.i = i;
					a.active = true;
					a.finished = false;
					game.platform.QueueUserWorkItem(a);
				}
			}
		}
		else {
			for (int i = 0; i < game.clientmodsCount; i++) {
				game.clientmods[i].OnReadOnlyMainThread(game, dt);
			}
			for (int i = 0; i < game.clientmodsCount; i++) {
				game.clientmods[i].OnReadOnlyBackgroundThread(game, dt);
			}
			for (int i = 0; i < game.clientmodsCount; i++) {
				game.clientmods[i].OnReadWriteMainThread(game, dt);
			}
			for (int i = 0; i < game.commitActions.count; i++) {
				game.commitActions.items[i].Run();
			}
			game.commitActions.Clear();
		}
	}
	BackgroundAction[] actions;
}

public class TcpNetClient : NetClient
{
	public TcpNetClient()
	{
		this.incoming = new QueueByte();
		this.data = new byte[1024];
		this.connected = new BoolRef();
	}

	public override NetConnection Connect(string ip, int port)
	{
		this.platform.TcpConnect(ip, port, this.connected);
		return null;
	}

	void DoSendPacket(INetOutgoingMessage msg)
	{
		byte[] packet = new byte[msg.messageLength + 4];
		this.WriteInt(packet, 0, msg.messageLength);
		for (int i = 0; i < msg.messageLength; i++) {
			packet[i + 4] = msg.message[i];
		}
		this.platform.TcpSend(packet, msg.messageLength + 4);
	}

	NetIncomingMessage GetMessage()
	{
		if (this.incoming.count >= 4) {
			byte[] length = new byte[4];
			this.incoming.PeekRange(length, 4);
			int messageLength = this.ReadInt(length, 0);
			if (this.incoming.count >= 4 + messageLength) {
				this.incoming.DequeueRange(new byte[4], 4);
				NetIncomingMessage msg = new NetIncomingMessage();
				msg.message = new byte[messageLength];
				msg.messageLength = messageLength;
				this.incoming.DequeueRange(msg.message, msg.messageLength);
				return msg;
			}
		}
		return null;
	}
	public const int MaxPacketLength = 4096;

	int ReadInt(byte[] readBuf, int readPos)
	{
		int n = readBuf[readPos] << 24;
		n |= readBuf[readPos + 1] << 16;
		n |= readBuf[readPos + 2] << 8;
		n |= readBuf[readPos + 3];
		return n;
	}

	public override NetIncomingMessage ReadMessage()
	{
		if (this.connected.value) {
			while (this.tosend.Count() > 0) {
				INetOutgoingMessage msg = this.tosend.Dequeue();
				this.DoSendPacket(msg);
			}
		}
		NetIncomingMessage message = this.GetMessage();
		if (message != null) {
			return message;
		}
		for (int k = 0; k < 1; k++) {
			int received = this.platform.TcpReceive(this.data, 1024);
			if (received <= 0) {
				break;
			}
			for (int i = 0; i < received; i++) {
				this.incoming.Enqueue(this.data[i]);
			}
		}
		message = this.GetMessage();
		if (message != null) {
			return message;
		}
		return null;
	}

	public override void SendMessage(INetOutgoingMessage message, MyNetDeliveryMethod method)
	{
		INetOutgoingMessage msg = message;
		if (!this.connected.value) {
			this.tosend.Enqueue(msg);
			return;
		}
		this.DoSendPacket(msg);
	}

	public void SetPlatform(GamePlatform platform_)
	{
		this.platform = platform_;
	}

	public override void Start()
	{
		this.tosend = new QueueINetOutgoingMessage();
	}

	void WriteInt(byte[] writeBuf, int writePos, int n)
	{
		int a = n >> 24 & 255;
		int b = n >> 16 & 255;
		int c = n >> 8 & 255;
		int d = n & 255;
		writeBuf[writePos] = Game.IntToByte(a);
		writeBuf[writePos + 1] = Game.IntToByte(b);
		writeBuf[writePos + 2] = Game.IntToByte(c);
		writeBuf[writePos + 3] = Game.IntToByte(d);
	}
	BoolRef connected;
	byte[] data;
	QueueByte incoming;
	internal GamePlatform platform;
	QueueINetOutgoingMessage tosend;
}

public class TerrainChunkTesselatorCi
{
	public TerrainChunkTesselatorCi()
	{
		this.EnableSmoothLight = true;
		this.ENABLE_TEXTURE_TILING = true;
		this._colorWhite = Game.ColorFromArgb(255, 255, 255, 255);
		this.BlockShadow = 0.6f;
		this.option_DarkenBlockSides = true;
		this.option_DoNotDrawEdges = true;
		this.occ = 0.7f;
		this.halfocc = 0.4f;
		this.tmpnPos = new int[7];
		this.tmpshadowration = new int[9];
		this.tmpoccupied = new bool[9];
		this.tmpfShadowRation = new float[4];
		this.tmpv = new VecCito3i();
		this.ref_blockCornerHeight = new float[4];
		this.c_OcclusionNeighbors = new VecCito3i[6][];
		for (int i = 0; i < 6; i++) {
			this.c_OcclusionNeighbors[i] = new VecCito3i[9];
		}
		this.c_OcclusionNeighbors[0][8] = VecCito3i.CitoCtr(0, 0, 1);
		this.c_OcclusionNeighbors[0][0] = VecCito3i.CitoCtr(0, -1, 1);
		this.c_OcclusionNeighbors[0][1] = VecCito3i.CitoCtr(0, 1, 1);
		this.c_OcclusionNeighbors[0][2] = VecCito3i.CitoCtr(-1, 0, 1);
		this.c_OcclusionNeighbors[0][3] = VecCito3i.CitoCtr(1, 0, 1);
		this.c_OcclusionNeighbors[0][4] = VecCito3i.CitoCtr(-1, -1, 1);
		this.c_OcclusionNeighbors[0][5] = VecCito3i.CitoCtr(1, -1, 1);
		this.c_OcclusionNeighbors[0][6] = VecCito3i.CitoCtr(-1, 1, 1);
		this.c_OcclusionNeighbors[0][7] = VecCito3i.CitoCtr(1, 1, 1);
		this.c_OcclusionNeighbors[2][8] = VecCito3i.CitoCtr(-1, 0, 0);
		this.c_OcclusionNeighbors[2][0] = VecCito3i.CitoCtr(-1, 0, 1);
		this.c_OcclusionNeighbors[2][1] = VecCito3i.CitoCtr(-1, 0, -1);
		this.c_OcclusionNeighbors[2][2] = VecCito3i.CitoCtr(-1, -1, 0);
		this.c_OcclusionNeighbors[2][3] = VecCito3i.CitoCtr(-1, 1, 0);
		this.c_OcclusionNeighbors[2][4] = VecCito3i.CitoCtr(-1, -1, 1);
		this.c_OcclusionNeighbors[2][5] = VecCito3i.CitoCtr(-1, 1, 1);
		this.c_OcclusionNeighbors[2][6] = VecCito3i.CitoCtr(-1, -1, -1);
		this.c_OcclusionNeighbors[2][7] = VecCito3i.CitoCtr(-1, 1, -1);
		this.c_OcclusionNeighbors[1][8] = VecCito3i.CitoCtr(0, 0, -1);
		this.c_OcclusionNeighbors[1][0] = VecCito3i.CitoCtr(0, 1, -1);
		this.c_OcclusionNeighbors[1][1] = VecCito3i.CitoCtr(0, -1, -1);
		this.c_OcclusionNeighbors[1][2] = VecCito3i.CitoCtr(-1, 0, -1);
		this.c_OcclusionNeighbors[1][3] = VecCito3i.CitoCtr(1, 0, -1);
		this.c_OcclusionNeighbors[1][4] = VecCito3i.CitoCtr(-1, 1, -1);
		this.c_OcclusionNeighbors[1][5] = VecCito3i.CitoCtr(1, 1, -1);
		this.c_OcclusionNeighbors[1][6] = VecCito3i.CitoCtr(-1, -1, -1);
		this.c_OcclusionNeighbors[1][7] = VecCito3i.CitoCtr(1, -1, -1);
		this.c_OcclusionNeighbors[3][8] = VecCito3i.CitoCtr(1, 0, 0);
		this.c_OcclusionNeighbors[3][0] = VecCito3i.CitoCtr(1, 0, 1);
		this.c_OcclusionNeighbors[3][1] = VecCito3i.CitoCtr(1, 0, -1);
		this.c_OcclusionNeighbors[3][2] = VecCito3i.CitoCtr(1, 1, 0);
		this.c_OcclusionNeighbors[3][3] = VecCito3i.CitoCtr(1, -1, 0);
		this.c_OcclusionNeighbors[3][4] = VecCito3i.CitoCtr(1, 1, 1);
		this.c_OcclusionNeighbors[3][5] = VecCito3i.CitoCtr(1, -1, 1);
		this.c_OcclusionNeighbors[3][6] = VecCito3i.CitoCtr(1, 1, -1);
		this.c_OcclusionNeighbors[3][7] = VecCito3i.CitoCtr(1, -1, -1);
		this.c_OcclusionNeighbors[4][8] = VecCito3i.CitoCtr(0, -1, 0);
		this.c_OcclusionNeighbors[4][0] = VecCito3i.CitoCtr(0, -1, 1);
		this.c_OcclusionNeighbors[4][1] = VecCito3i.CitoCtr(0, -1, -1);
		this.c_OcclusionNeighbors[4][2] = VecCito3i.CitoCtr(1, -1, 0);
		this.c_OcclusionNeighbors[4][3] = VecCito3i.CitoCtr(-1, -1, 0);
		this.c_OcclusionNeighbors[4][4] = VecCito3i.CitoCtr(1, -1, 1);
		this.c_OcclusionNeighbors[4][5] = VecCito3i.CitoCtr(-1, -1, 1);
		this.c_OcclusionNeighbors[4][6] = VecCito3i.CitoCtr(1, -1, -1);
		this.c_OcclusionNeighbors[4][7] = VecCito3i.CitoCtr(-1, -1, -1);
		this.c_OcclusionNeighbors[5][8] = VecCito3i.CitoCtr(0, 1, 0);
		this.c_OcclusionNeighbors[5][0] = VecCito3i.CitoCtr(0, 1, 1);
		this.c_OcclusionNeighbors[5][1] = VecCito3i.CitoCtr(0, 1, -1);
		this.c_OcclusionNeighbors[5][2] = VecCito3i.CitoCtr(-1, 1, 0);
		this.c_OcclusionNeighbors[5][3] = VecCito3i.CitoCtr(1, 1, 0);
		this.c_OcclusionNeighbors[5][4] = VecCito3i.CitoCtr(-1, 1, 1);
		this.c_OcclusionNeighbors[5][5] = VecCito3i.CitoCtr(1, 1, 1);
		this.c_OcclusionNeighbors[5][6] = VecCito3i.CitoCtr(-1, 1, -1);
		this.c_OcclusionNeighbors[5][7] = VecCito3i.CitoCtr(1, 1, -1);
	}

	public void AddTorch(int x, int y, int z, int type, int tt)
	{
		TerrainChunkTesselatorCi d_TerainRenderer = this;
		int curcolor = this._colorWhite;
		float torchsizexy = 0.16f;
		float topx = 0.5f - torchsizexy / 2;
		float topy = 0.5f - torchsizexy / 2;
		float bottomx = 0.5f - torchsizexy / 2;
		float bottomy = 0.5f - torchsizexy / 2;
		topx += x;
		topy += y;
		bottomx += x;
		bottomy += y;
		if (type == 3) {
			bottomx = x - torchsizexy;
		}
		if (type == 4) {
			bottomx = x + 1;
		}
		if (type == 1) {
			bottomy = y - torchsizexy;
		}
		if (type == 2) {
			bottomy = y + 1;
		}
		Vector3Ref top00 = Vector3Ref.Create(topx, z + 0.9f, topy);
		Vector3Ref top01 = Vector3Ref.Create(topx, z + 0.9f, topy + torchsizexy);
		Vector3Ref top10 = Vector3Ref.Create(topx + torchsizexy, z + 0.9f, topy);
		Vector3Ref top11 = Vector3Ref.Create(topx + torchsizexy, z + 0.9f, topy + torchsizexy);
		if (type == 1) {
			top01.Y += -0.1f;
			top11.Y += -0.1f;
		}
		if (type == 2) {
			top10.Y += -0.1f;
			top00.Y += -0.1f;
		}
		if (type == 3) {
			top10.Y += -0.1f;
			top11.Y += -0.1f;
		}
		if (type == 4) {
			top01.Y += -0.1f;
			top00.Y += -0.1f;
		}
		Vector3Ref bottom00 = Vector3Ref.Create(bottomx, z + 0, bottomy);
		Vector3Ref bottom01 = Vector3Ref.Create(bottomx, z + 0, bottomy + torchsizexy);
		Vector3Ref bottom10 = Vector3Ref.Create(bottomx + torchsizexy, z + 0, bottomy);
		Vector3Ref bottom11 = Vector3Ref.Create(bottomx + torchsizexy, z + 0, bottomy + torchsizexy);
		{
			int sidetexture = this.TorchTopTexture;
			float texrecTop = this.terrainTexturesPerAtlasInverse * sidetexture % this.terrainTexturesPerAtlas;
			float texrecBottom = texrecTop + this._texrecHeight;
			ModelData toreturn = this.GetModelData(tt, sidetexture);
			int lastelement = toreturn.verticesCount;
			ModelDataTool.AddVertex(toreturn, top00.X, top00.Y, top00.Z, this._texrecLeft, texrecTop, curcolor);
			ModelDataTool.AddVertex(toreturn, top01.X, top01.Y, top01.Z, this._texrecLeft, texrecBottom, curcolor);
			ModelDataTool.AddVertex(toreturn, top10.X, top10.Y, top10.Z, this._texrecRight, texrecTop, curcolor);
			ModelDataTool.AddVertex(toreturn, top11.X, top11.Y, top11.Z, this._texrecRight, texrecBottom, curcolor);
			ModelDataTool.AddIndex(toreturn, lastelement + 0);
			ModelDataTool.AddIndex(toreturn, lastelement + 1);
			ModelDataTool.AddIndex(toreturn, lastelement + 2);
			ModelDataTool.AddIndex(toreturn, lastelement + 1);
			ModelDataTool.AddIndex(toreturn, lastelement + 3);
			ModelDataTool.AddIndex(toreturn, lastelement + 2);
		}
		{
			int sidetexture = this.TorchSideTexture;
			float texrecTop = this.terrainTexturesPerAtlasInverse * sidetexture % this.terrainTexturesPerAtlas;
			float texrecBottom = texrecTop + this._texrecHeight;
			ModelData toreturn = this.GetModelData(tt, sidetexture);
			int lastelement = toreturn.verticesCount;
			ModelDataTool.AddVertex(toreturn, bottom00.X, bottom00.Y, bottom00.Z, this._texrecLeft, texrecTop, curcolor);
			ModelDataTool.AddVertex(toreturn, bottom01.X, bottom01.Y, bottom01.Z, this._texrecLeft, texrecBottom, curcolor);
			ModelDataTool.AddVertex(toreturn, bottom10.X, bottom10.Y, bottom10.Z, this._texrecRight, texrecTop, curcolor);
			ModelDataTool.AddVertex(toreturn, bottom11.X, bottom11.Y, bottom11.Z, this._texrecRight, texrecBottom, curcolor);
			ModelDataTool.AddIndex(toreturn, lastelement + 1);
			ModelDataTool.AddIndex(toreturn, lastelement + 0);
			ModelDataTool.AddIndex(toreturn, lastelement + 2);
			ModelDataTool.AddIndex(toreturn, lastelement + 3);
			ModelDataTool.AddIndex(toreturn, lastelement + 1);
			ModelDataTool.AddIndex(toreturn, lastelement + 2);
		}
		{
			int sidetexture = this.TorchSideTexture;
			float texrecTop = this.terrainTexturesPerAtlasInverse * sidetexture % this.terrainTexturesPerAtlas;
			float texrecBottom = texrecTop + this._texrecHeight;
			ModelData toreturn = this.GetModelData(tt, sidetexture);
			int lastelement = toreturn.verticesCount;
			ModelDataTool.AddVertex(toreturn, bottom00.X, bottom00.Y, bottom00.Z, this._texrecLeft, texrecBottom, curcolor);
			ModelDataTool.AddVertex(toreturn, bottom01.X, bottom01.Y, bottom01.Z, this._texrecRight, texrecBottom, curcolor);
			ModelDataTool.AddVertex(toreturn, top00.X, top00.Y, top00.Z, this._texrecLeft, texrecTop, curcolor);
			ModelDataTool.AddVertex(toreturn, top01.X, top01.Y, top01.Z, this._texrecRight, texrecTop, curcolor);
			ModelDataTool.AddIndex(toreturn, lastelement + 0);
			ModelDataTool.AddIndex(toreturn, lastelement + 1);
			ModelDataTool.AddIndex(toreturn, lastelement + 2);
			ModelDataTool.AddIndex(toreturn, lastelement + 1);
			ModelDataTool.AddIndex(toreturn, lastelement + 3);
			ModelDataTool.AddIndex(toreturn, lastelement + 2);
		}
		{
			int sidetexture = this.TorchSideTexture;
			float texrecTop = this.terrainTexturesPerAtlasInverse * sidetexture % this.terrainTexturesPerAtlas;
			float texrecBottom = texrecTop + this._texrecHeight;
			ModelData toreturn = this.GetModelData(tt, sidetexture);
			int lastelement = toreturn.verticesCount;
			ModelDataTool.AddVertex(toreturn, bottom10.X, bottom10.Y, bottom10.Z, this._texrecRight, texrecBottom, curcolor);
			ModelDataTool.AddVertex(toreturn, bottom11.X, bottom11.Y, bottom11.Z, this._texrecLeft, texrecBottom, curcolor);
			ModelDataTool.AddVertex(toreturn, top10.X, top10.Y, top10.Z, this._texrecRight, texrecTop, curcolor);
			ModelDataTool.AddVertex(toreturn, top11.X, top11.Y, top11.Z, this._texrecLeft, texrecTop, curcolor);
			ModelDataTool.AddIndex(toreturn, lastelement + 1);
			ModelDataTool.AddIndex(toreturn, lastelement + 0);
			ModelDataTool.AddIndex(toreturn, lastelement + 2);
			ModelDataTool.AddIndex(toreturn, lastelement + 3);
			ModelDataTool.AddIndex(toreturn, lastelement + 1);
			ModelDataTool.AddIndex(toreturn, lastelement + 2);
		}
		{
			int sidetexture = this.TorchSideTexture;
			float texrecTop = this.terrainTexturesPerAtlasInverse * sidetexture % this.terrainTexturesPerAtlas;
			float texrecBottom = texrecTop + this._texrecHeight;
			ModelData toreturn = this.GetModelData(tt, sidetexture);
			int lastelement = toreturn.verticesCount;
			ModelDataTool.AddVertex(toreturn, bottom00.X, bottom00.Y, bottom00.Z, this._texrecRight, texrecBottom, curcolor);
			ModelDataTool.AddVertex(toreturn, top00.X, top00.Y, top00.Z, this._texrecRight, texrecTop, curcolor);
			ModelDataTool.AddVertex(toreturn, bottom10.X, bottom10.Y, bottom10.Z, this._texrecLeft, texrecBottom, curcolor);
			ModelDataTool.AddVertex(toreturn, top10.X, top10.Y, top10.Z, this._texrecLeft, texrecTop, curcolor);
			ModelDataTool.AddIndex(toreturn, lastelement + 0);
			ModelDataTool.AddIndex(toreturn, lastelement + 1);
			ModelDataTool.AddIndex(toreturn, lastelement + 2);
			ModelDataTool.AddIndex(toreturn, lastelement + 1);
			ModelDataTool.AddIndex(toreturn, lastelement + 3);
			ModelDataTool.AddIndex(toreturn, lastelement + 2);
		}
		{
			int sidetexture = this.TorchSideTexture;
			float texrecTop = this.terrainTexturesPerAtlasInverse * sidetexture % this.terrainTexturesPerAtlas;
			float texrecBottom = texrecTop + this._texrecHeight;
			ModelData toreturn = this.GetModelData(tt, sidetexture);
			int lastelement = toreturn.verticesCount;
			ModelDataTool.AddVertex(toreturn, bottom01.X, bottom01.Y, bottom01.Z, this._texrecLeft, texrecBottom, curcolor);
			ModelDataTool.AddVertex(toreturn, top01.X, top01.Y, top01.Z, this._texrecLeft, texrecTop, curcolor);
			ModelDataTool.AddVertex(toreturn, bottom11.X, bottom11.Y, bottom11.Z, this._texrecRight, texrecBottom, curcolor);
			ModelDataTool.AddVertex(toreturn, top11.X, top11.Y, top11.Z, this._texrecRight, texrecTop, curcolor);
			ModelDataTool.AddIndex(toreturn, lastelement + 1);
			ModelDataTool.AddIndex(toreturn, lastelement + 0);
			ModelDataTool.AddIndex(toreturn, lastelement + 2);
			ModelDataTool.AddIndex(toreturn, lastelement + 3);
			ModelDataTool.AddIndex(toreturn, lastelement + 1);
			ModelDataTool.AddIndex(toreturn, lastelement + 2);
		}
	}

	public void AddVertex(ModelData model, float x, float y, float z, float u, float v, int color)
	{
		model.xyz[model.GetXyzCount() + 0] = x;
		model.xyz[model.GetXyzCount() + 1] = y;
		model.xyz[model.GetXyzCount() + 2] = z;
		model.uv[model.GetUvCount() + 0] = u;
		model.uv[model.GetUvCount() + 1] = v;
		model.rgba[model.GetRgbaCount() + 0] = Game.IntToByte(Game.ColorR(color));
		model.rgba[model.GetRgbaCount() + 1] = Game.IntToByte(Game.ColorG(color));
		model.rgba[model.GetRgbaCount() + 2] = Game.IntToByte(Game.ColorB(color));
		model.rgba[model.GetRgbaCount() + 3] = Game.IntToByte(Game.ColorA(color));
		model.verticesCount++;
	}
	internal float AtiArtifactFix;
	internal float BlockShadow;

	void BuildBlockFace(int x, int y, int z, int tileType, float vOffsetX, float vOffsetY, float vOffsetZ, float vScaleX, float vScaleY, float vScaleZ, int[] currentChunk, int tileSide)
	{
		int xx = x % 16 + 1;
		int yy = y % 16 + 1;
		int zz = z % 16 + 1;
		VecCito3i[] vNeighbors = this.c_OcclusionNeighbors[tileSide];
		int[] shadowration = this.tmpshadowration;
		bool[] occupied = this.tmpoccupied;
		int shadowratio = this.GetShadowRatio(vNeighbors[8].x + xx, vNeighbors[8].y + yy, vNeighbors[8].z + zz);
		float[] fShadowRation = this.tmpfShadowRation;
		float shadowratiomain = this.lightlevels[shadowratio];
		fShadowRation[0] = shadowratiomain;
		fShadowRation[1] = shadowratiomain;
		fShadowRation[2] = shadowratiomain;
		fShadowRation[3] = shadowratiomain;
		if (this.EnableSmoothLight) {
			for (int i = 0; i < 9; i++) {
				int vPosX = vNeighbors[i].x + xx;
				int vPosY = vNeighbors[i].y + yy;
				int vPosZ = vNeighbors[i].z + zz;
				int nBlockType = currentChunk[(vPosZ * 18 + vPosY) * 18 + vPosX];
				if (nBlockType != 0) {
					occupied[i] = !this.IsTransparentForLight(nBlockType);
					shadowration[i] = shadowratio;
				}
				else {
					occupied[i] = false;
					shadowration[i] = this.GetShadowRatio(vPosX, vPosY, vPosZ);
				}
			}
			this.CalcShadowRation(0, 2, 4, 0, fShadowRation, occupied, shadowration);
			this.CalcShadowRation(0, 3, 5, 1, fShadowRation, occupied, shadowration);
			this.CalcShadowRation(1, 2, 6, 2, fShadowRation, occupied, shadowration);
			this.CalcShadowRation(1, 3, 7, 3, fShadowRation, occupied, shadowration);
		}
		else {
		}
		this.DrawBlockFace(x, y, z, tileType, tileSide, vOffsetX, vOffsetY, vOffsetZ, vScaleX, vScaleY, vScaleZ, vNeighbors, fShadowRation);
	}

	public void BuildBlockPolygons(int x, int y, int z)
	{
		for (int xx = 0; xx < 16; xx++) {
			for (int yy = 0; yy < 16; yy++) {
				for (int zz = 0; zz < 16; zz++) {
					if (this.currentChunkDraw16[(zz * 16 + yy) * 16 + xx] != 0) {
						int xxx = x * 16 + xx;
						int yyy = y * 16 + yy;
						int zzz = z * 16 + zz;
						this.BuildSingleBlockPolygon(xxx, yyy, zzz, this.currentChunk18);
					}
				}
			}
		}
	}

	public void BuildSingleBlockPolygon(int x, int y, int z, int[] currentChunk)
	{
		for (int i = 0; i < 4; i++) {
			this.ref_blockCornerHeight[i] = 0;
		}
		int xx = x % 16 + 1;
		int yy = y % 16 + 1;
		int zz = z % 16 + 1;
		int nToDraw = this.GetToDrawFlags(xx, yy, zz);
		int tiletype = currentChunk[(zz * 18 + yy) * 18 + xx];
		float vOffsetX = 0;
		float vOffsetY = 0;
		float vOffsetZ = 0;
		float vScaleX = 1;
		float vScaleY = 1;
		float vScaleZ = 1;
		if (!this.isvalid(tiletype)) {
			return;
		}
		if (nToDraw == 0) {
			return;
		}
		if (this.option_DoNotDrawEdges) {
			if (z == 0) {
				nToDraw &= ~2;
			}
			if (x == 0) {
				nToDraw &= ~16;
			}
			if (x == this.mapsizex - 1) {
				nToDraw &= ~32;
			}
			if (y == 0) {
				nToDraw &= ~8;
			}
			if (y == this.mapsizey - 1) {
				nToDraw &= ~4;
			}
		}
		if (this.IsFlower(tiletype)) {
			nToDraw = 20;
			vScaleX = 0.9f;
			vScaleY = 0.9f;
			vScaleZ = 1f;
			this.BuildBlockFace(x, y, z, tiletype, 0.5f, 0.05f, 0f, vScaleX, vScaleY, vScaleZ, currentChunk, 2);
			this.BuildBlockFace(x, y, z, tiletype, 0.05f, 0.5f, 0f, vScaleX, vScaleY, vScaleZ, currentChunk, 4);
			return;
		}
		else if (this.game.blocktypes[tiletype].DrawType == 13) {
			float fScale = 0.875f;
			float fOffset = (1f - fScale) / 2f;
			float vLROffsetX = fOffset;
			float vLROffsetY = 0;
			float vLROffsetZ = 0;
			float vLRScaleX = fScale;
			float vLRScaleY = 1f;
			float vLRScaleZ = 1f;
			float vFBOffsetX = 0;
			float vFBOffsetY = fOffset;
			float vFBOffsetZ = 0;
			float vFBScaleX = 1f;
			float vFBScaleY = fScale;
			float vFBScaleZ = 1f;
			this.BuildBlockFace(x, y, z, tiletype, vLROffsetX, vLROffsetY, vLROffsetZ, vLRScaleX, vLRScaleY, vLRScaleZ, currentChunk, 2);
			this.BuildBlockFace(x, y, z, tiletype, vLROffsetX, vLROffsetY, vLROffsetZ, vLRScaleX, vLRScaleY, vLRScaleZ, currentChunk, 3);
			this.BuildBlockFace(x, y, z, tiletype, vFBOffsetX, vFBOffsetY, vFBOffsetZ, vFBScaleX, vFBScaleY, vFBScaleZ, currentChunk, 5);
			this.BuildBlockFace(x, y, z, tiletype, vFBOffsetX, vFBOffsetY, vFBOffsetZ, vFBScaleX, vFBScaleY, vFBScaleZ, currentChunk, 4);
			nToDraw = nToDraw & 3;
		}
		else if (this.game.blocktypes[tiletype].DrawType == 6 || this.game.blocktypes[tiletype].DrawType == 7) {
			bool blnDrawn = false;
			float fOffset = 0.025f;
			if (currentChunk[(zz * 18 + yy) * 18 + xx - 1] == 0 && currentChunk[(zz * 18 + yy) * 18 + xx + 1] == 0) {
				nToDraw = 8;
				vOffsetX = 0;
				vOffsetY = fOffset;
				vOffsetZ = 0;
				blnDrawn = true;
			}
			if (!blnDrawn || currentChunk[(zz * 18 + yy - 1) * 18 + xx] == 0 && currentChunk[(zz * 18 + yy + 1) * 18 + xx] == 0) {
				vOffsetX = fOffset;
				vOffsetY = 0;
				vOffsetZ = 0;
				nToDraw = 16;
			}
		}
		else if (this.game.blocktypes[tiletype].DrawType == 10 || this.game.blocktypes[tiletype].DrawType == 8) {
			bool blnSideDrawn = false;
			if (currentChunk[(zz * 18 + yy) * 18 + xx - 1] != 0 || currentChunk[(zz * 18 + yy) * 18 + xx + 1] != 0) {
				this.BuildBlockFace(x, y, z, tiletype, 0, -0.5f, 0, vScaleX, vScaleY, vScaleZ, currentChunk, 5);
				blnSideDrawn = true;
			}
			if (!blnSideDrawn || currentChunk[(zz * 18 + yy - 1) * 18 + xx] != 0 || currentChunk[(zz * 18 + yy + 1) * 18 + xx] != 0) {
				this.BuildBlockFace(x, y, z, tiletype, 0.5f, 0, 0, vScaleX, vScaleY, vScaleZ, currentChunk, 2);
			}
			return;
		}
		else if (this.game.blocktypes[tiletype].DrawType == 9) {
			vOffsetX = 0.025f;
			vOffsetY = 0.025f;
			vOffsetZ = 0;
			vScaleX = 0.95f;
			vScaleY = 0.95f;
			vScaleZ = 1f;
			nToDraw = 0;
			int ladderAtPositionMatchWall = this.getBestLadderWall(xx, yy, zz, currentChunk);
			if (ladderAtPositionMatchWall < 0) {
				int ladderbelow = this.getBestLadderInDirection(xx, yy, zz, currentChunk, -1);
				int ladderabove = this.getBestLadderInDirection(xx, yy, zz, currentChunk, 1);
				if (ladderbelow != 0) {
					ladderAtPositionMatchWall = this.getBestLadderWall(xx, yy, zz + ladderbelow, currentChunk);
				}
				else if (ladderabove != 0) {
					ladderAtPositionMatchWall = this.getBestLadderWall(xx, yy, zz + ladderabove, currentChunk);
				}
			}
			switch (ladderAtPositionMatchWall) {
			case 1:
				nToDraw |= 4;
				break;
			case 2:
				nToDraw |= 16;
				break;
			case 3:
				nToDraw |= 32;
				break;
			default:
				nToDraw |= 8;
				break;
			}
		}
		else if (this.game.blocktypes[tiletype].DrawType == 11) {
			vScaleX = 1;
			vScaleY = 1;
			vScaleZ = 0.5f;
		}
		else if (this.game.blocktypes[tiletype].DrawType == 12) {
			vScaleX = 1;
			vScaleY = 1;
			vScaleZ = 0.05f;
		}
		else if (this.game.blocktypes[tiletype].DrawType == 4) {
			int type = 0;
			if (this.CanSupportTorch(currentChunk[(zz * 18 + yy) * 18 + xx - 1])) {
				type = 3;
			}
			if (this.CanSupportTorch(currentChunk[(zz * 18 + yy) * 18 + xx + 1])) {
				type = 4;
			}
			if (this.CanSupportTorch(currentChunk[(zz * 18 + yy - 1) * 18 + xx])) {
				type = 1;
			}
			if (this.CanSupportTorch(currentChunk[(zz * 18 + yy + 1) * 18 + xx])) {
				type = 2;
			}
			this.TorchSideTexture = this.TextureId(tiletype, 2);
			this.TorchTopTexture = this.TextureId(tiletype, 0);
			this.AddTorch(x, y, z, type, tiletype);
			return;
		}
		else if (tiletype == 8) {
			if (currentChunk[((zz - 1) * 18 + yy) * 18 + xx] == 8) {
				vOffsetX = 0;
				vOffsetY = 0;
				vOffsetZ = -0.1f;
			}
			else {
				vScaleX = 1;
				vScaleY = 1;
				vScaleZ = 0.9f;
			}
		}
		else {
			int rail = this.Rail(tiletype);
			if (rail != 0) {
				int slope = this.GetRailSlope(xx, yy, zz);
				float fSlopeMod = 1f;
				vScaleX = 1f;
				vScaleY = 1f;
				vScaleZ = 0.3f;
				if (slope == 2) {
					this.ref_blockCornerHeight[1] = fSlopeMod;
					this.ref_blockCornerHeight[3] = fSlopeMod;
				}
				else if (slope == 1) {
					this.ref_blockCornerHeight[0] = fSlopeMod;
					this.ref_blockCornerHeight[2] = fSlopeMod;
				}
				else if (slope == 3) {
					this.ref_blockCornerHeight[0] = fSlopeMod;
					this.ref_blockCornerHeight[1] = fSlopeMod;
				}
				else if (slope == 4) {
					this.ref_blockCornerHeight[2] = fSlopeMod;
					this.ref_blockCornerHeight[3] = fSlopeMod;
				}
			}
		}
		for (int i = 0; i < 6; i++) {
			if ((nToDraw & TileSideEnum.ToFlags(i)) != 0) {
				this.BuildBlockFace(x, y, z, tiletype, vOffsetX, vOffsetY, vOffsetZ, vScaleX, vScaleY, vScaleZ, currentChunk, i);
			}
		}
	}

	void CalcShadowRation(int nDir1, int nDir2, int nDirBetween, int nCorner, float[] fShadowRation, bool[] occupied, int[] shadowRationInt)
	{
		if (occupied[nDir1] && occupied[nDir2]) {
			fShadowRation[nCorner] *= this.halfocc;
		}
		else {
			byte facesconsidered = 1;
			if (!occupied[nDir1]) {
				fShadowRation[nCorner] += this.lightlevels[shadowRationInt[nDir1]];
				facesconsidered++;
			}
			if (!occupied[nDir2]) {
				fShadowRation[nCorner] += this.lightlevels[shadowRationInt[nDir2]];
				facesconsidered++;
			}
			if (!occupied[nDirBetween]) {
				fShadowRation[nCorner] += this.lightlevels[shadowRationInt[nDirBetween]];
				facesconsidered++;
			}
			fShadowRation[nCorner] /= facesconsidered;
			if (occupied[nDir1] || occupied[nDir2] || occupied[nDirBetween]) {
				fShadowRation[nCorner] *= this.occ;
			}
		}
	}

	public void CalculateTilingCount(int[] currentChunk, int startx, int starty, int startz)
	{
		for (int i = 0; i < 4096; i++) {
			if (this.currentChunkDrawCount16[i] == null) {
				this.currentChunkDrawCount16[i] = new byte[6];
			}
			this.currentChunkDrawCount16[i][0] = 0;
			this.currentChunkDrawCount16[i][1] = 0;
			this.currentChunkDrawCount16[i][2] = 0;
			this.currentChunkDrawCount16[i][3] = 0;
			this.currentChunkDrawCount16[i][4] = 0;
			this.currentChunkDrawCount16[i][5] = 0;
		}
		{
			int[] currentChunk_ = currentChunk;
			for (int zz = 1; zz < 17; zz++) {
				for (int yy = 1; yy < 17; yy++) {
					int pos = (zz * 18 + yy) * 18 + 0;
					for (int xx = 1; xx < 17; xx++) {
						int tt = currentChunk_[pos + xx];
						if (tt == 0) {
							continue;
						}
						int x = startx + xx - 1;
						int y = starty + yy - 1;
						int z = startz + zz - 1;
						int draw = this.currentChunkDraw16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1];
						if (draw == 0) {
							continue;
						}
						if ((draw & 1) != 0) {
							int shadowratioTop = this.GetShadowRatio(xx, yy, zz + 1);
							this.currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1][0] = 1;
						}
						if ((draw & 2) != 0) {
							int shadowratioTop = this.GetShadowRatio(xx, yy, zz - 1);
							this.currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1][1] = 1;
						}
						if ((draw & 4) != 0) {
							int shadowratioTop = this.GetShadowRatio(xx - 1, yy, zz);
							this.currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1][2] = 1;
						}
						if ((draw & 8) != 0) {
							int shadowratioTop = this.GetShadowRatio(xx + 1, yy, zz);
							this.currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1][3] = 1;
						}
						if ((draw & 16) != 0) {
							int shadowratioTop = this.GetShadowRatio(xx, yy - 1, zz);
							this.currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1][4] = 1;
						}
						if ((draw & 32) != 0) {
							int shadowratioTop = this.GetShadowRatio(xx, yy + 1, zz);
							this.currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1][5] = 1;
						}
					}
				}
			}
		}
	}

	public void CalculateVisibleFaces(int[] currentChunk)
	{
		int movez = 324;
		for (int zz = 1; zz < 17; zz++) {
			for (int yy = 1; yy < 17; yy++) {
				int posstart = (zz * 18 + yy) * 18 + 0;
				for (int xx = 1; xx < 17; xx++) {
					int pos = posstart + xx;
					int tt = currentChunk[pos];
					if (tt == 0) {
						continue;
					}
					int draw = 0;
					int[] nPos = this.tmpnPos;
					nPos[0] = pos + movez;
					nPos[1] = pos - movez;
					nPos[5] = pos + 18;
					nPos[4] = pos - 18;
					nPos[2] = pos - 1;
					nPos[3] = pos + 1;
					bool blnIsFluid = this.isFluid[tt];
					bool blnIsLowered = this.isLowered[tt];
					draw |= this.GetFaceVisibility(0, currentChunk, nPos, blnIsFluid, blnIsLowered);
					draw |= this.GetFaceVisibility(1, currentChunk, nPos, blnIsFluid, blnIsLowered);
					draw |= this.GetFaceVisibility(2, currentChunk, nPos, blnIsFluid, blnIsLowered);
					draw |= this.GetFaceVisibility(3, currentChunk, nPos, blnIsFluid, blnIsLowered);
					draw |= this.GetFaceVisibility(4, currentChunk, nPos, blnIsFluid, blnIsLowered);
					draw |= this.GetFaceVisibility(5, currentChunk, nPos, blnIsFluid, blnIsLowered);
					if (blnIsLowered && draw > 0) {
						if (!TileSideFlagsEnum.HasFlag(draw, 1)) {
							if (TileSideFlagsEnum.HasFlag(draw, 60)) {
								draw |= 1;
							}
						}
						int nRail = this.Rail(tt);
						if (nRail > 0) {
							int nSlope = this.GetRailSlope(xx, yy, zz);
							switch (nSlope) {
							case 4:
								draw |= 52;
								break;
							case 3:
								draw |= 56;
								break;
							case 1:
								draw |= 28;
								break;
							case 2:
								draw |= 44;
								break;
							}
						}
					}
					this.currentChunkDraw16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1] = Game.IntToByte(draw);
				}
			}
		}
	}

	public bool CanSupportTorch(int blocktype)
	{
		return blocktype != 0 && this.game.blocktypes[blocktype].DrawType != 4;
	}

	int ColorMultiply(int color, float fValue)
	{
		return Game.ColorFromArgb(Game.ColorA(color), this.game.platform.FloatToInt(Game.ColorR(color) * fValue), this.game.platform.FloatToInt(Game.ColorG(color) * fValue), this.game.platform.FloatToInt(Game.ColorB(color) * fValue));
	}

	void DrawBlockFace(int x, int y, int z, int tileType, int tileSide, float vOffsetX, float vOffsetY, float vOffsetZ, float vScaleX, float vScaleY, float vScaleZ, VecCito3i[] vNeighbors, float[] fShadowRation)
	{
		int color = this._colorWhite;
		if (this.option_DarkenBlockSides) {
			switch (tileSide) {
			case 1:
			case 2:
			case 3:
				color = this.ColorMultiply(color, this.BlockShadow);
				break;
			}
		}
		int sidetexture = this.TextureId(tileType, tileSide);
		ModelData toreturn = this.GetModelData(tileType, sidetexture);
		float texrecTop = this.terrainTexturesPerAtlasInverse * sidetexture % this.terrainTexturesPerAtlas + this.AtiArtifactFix * this.terrainTexturesPerAtlasInverse;
		float texrecBottom = texrecTop + this._texrecHeight;
		int lastelement = toreturn.verticesCount;
		VecCito3i v = this.tmpv;
		float fSlopeModifier = 0f;
		vNeighbors[5].Add(1, 1, 1, v);
		fSlopeModifier = this.GetCornerHeightModifier(tileSide, 1);
		float xPos = x + vOffsetX + v.x * 0.5f * vScaleX;
		float zPos = z + vOffsetZ + v.z * 0.5f * vScaleZ + fSlopeModifier;
		float yPos = y + vOffsetY + v.y * 0.5f * vScaleY;
		ModelDataTool.AddVertex(toreturn, xPos, zPos, yPos, this._texrecRight, texrecTop, this.ColorMultiply(color, fShadowRation[1]));
		vNeighbors[4].Add(1, 1, 1, v);
		fSlopeModifier = this.GetCornerHeightModifier(tileSide, 0);
		xPos = x + vOffsetX + v.x * 0.5f * vScaleX;
		zPos = z + vOffsetZ + v.z * 0.5f * vScaleZ + fSlopeModifier;
		yPos = y + vOffsetY + v.y * 0.5f * vScaleY;
		ModelDataTool.AddVertex(toreturn, xPos, zPos, yPos, this._texrecLeft, texrecTop, this.ColorMultiply(color, fShadowRation[0]));
		vNeighbors[7].Add(1, 1, 1, v);
		fSlopeModifier = this.GetCornerHeightModifier(tileSide, 3);
		xPos = x + vOffsetX + v.x * 0.5f * vScaleX;
		zPos = z + vOffsetZ + v.z * 0.5f * vScaleZ + fSlopeModifier;
		yPos = y + vOffsetY + v.y * 0.5f * vScaleY;
		ModelDataTool.AddVertex(toreturn, xPos, zPos, yPos, this._texrecRight, texrecBottom, this.ColorMultiply(color, fShadowRation[3]));
		vNeighbors[6].Add(1, 1, 1, v);
		fSlopeModifier = this.GetCornerHeightModifier(tileSide, 2);
		xPos = x + vOffsetX + v.x * 0.5f * vScaleX;
		zPos = z + vOffsetZ + v.z * 0.5f * vScaleZ + fSlopeModifier;
		yPos = y + vOffsetY + v.y * 0.5f * vScaleY;
		ModelDataTool.AddVertex(toreturn, xPos, zPos, yPos, this._texrecLeft, texrecBottom, this.ColorMultiply(color, fShadowRation[2]));
		{
			ModelDataTool.AddIndex(toreturn, lastelement + 0);
			ModelDataTool.AddIndex(toreturn, lastelement + 1);
			ModelDataTool.AddIndex(toreturn, lastelement + 2);
			ModelDataTool.AddIndex(toreturn, lastelement + 1);
			ModelDataTool.AddIndex(toreturn, lastelement + 3);
			ModelDataTool.AddIndex(toreturn, lastelement + 2);
		}
	}
	internal bool ENABLE_TEXTURE_TILING;
	internal bool EnableSmoothLight;

	float GetCornerHeightModifier(int side, int corner)
	{
		int nIndex = -1;
		switch (side) {
		case 1:
			{
				nIndex = -1;
				break;
			}
		case 3:
			switch (corner) {
			case 1:
				nIndex = 1;
				break;
			case 0:
				nIndex = 3;
				break;
			}
			break;
		case 2:
			switch (corner) {
			case 0:
				nIndex = 0;
				break;
			case 1:
				nIndex = 2;
				break;
			}
			break;
		case 5:
			switch (corner) {
			case 0:
				nIndex = 2;
				break;
			case 1:
				nIndex = 3;
				break;
			}
			break;
		case 4:
			switch (corner) {
			case 0:
				nIndex = 1;
				break;
			case 1:
				nIndex = 0;
				break;
			}
			break;
		case 0:
			nIndex = corner;
			break;
		}
		if (nIndex != -1) {
			return this.ref_blockCornerHeight[nIndex];
		}
		else {
			return 0f;
		}
	}

	int GetFaceVisibility(int nSide, int[] currentChunk, int[] nPos, bool blnIsFluid, bool blnIsLowered)
	{
		int nReturn = 0;
		int nIndex = nPos[nSide];
		int tt2 = currentChunk[nIndex];
		if (tt2 == 0 || this.istransparent[tt2] && !this.isLowered[tt2] || this.isFluid[tt2] && !blnIsFluid) {
			nReturn |= TileSideEnum.ToFlags(nSide);
		}
		else if (blnIsFluid && nSide != 1) {
			if (this.isFluid[currentChunk[nPos[1]]]) {
				if (!this.isFluid[tt2]) {
					int movez = 324;
					int nPos2 = nPos[nSide] - movez;
					if (nPos2 > 0 && this.isFluid[currentChunk[nPos2]]) {
						nReturn |= TileSideEnum.ToFlags(nSide);
					}
				}
			}
			else {
			}
		}
		if (this.isLowered[tt2] && nSide != 0) {
			if (!blnIsLowered) {
				nReturn |= TileSideEnum.ToFlags(nSide);
			}
			else if (nSide == 1) {
				nReturn |= 2;
			}
			else {
				nReturn |= 1;
			}
		}
		return nReturn;
	}

	public VerticesIndicesToLoad[] GetFinalVerticesIndices(int x, int y, int z, IntRef retCount)
	{
		VerticesIndicesToLoad[] ret = new VerticesIndicesToLoad[this.toreturnatlas1dLength + this.toreturnatlas1dLength];
		retCount.value = 0;
		for (int i = 0; i < this.toreturnatlas1dLength; i++) {
			if (this.toreturnatlas1d[i].indicesCount > 0) {
				ret[retCount.value++] = this.GetVerticesIndices(this.toreturnatlas1d[i], x, y, z, this.game.d_TerrainTextures.terrainTextures1d()[i % this.game.d_TerrainTextures.terrainTexturesPerAtlas()], false);
			}
		}
		for (int i = 0; i < this.toreturnatlas1dLength; i++) {
			if (this.toreturnatlas1dtransparent[i].indicesCount > 0) {
				ret[retCount.value++] = this.GetVerticesIndices(this.toreturnatlas1dtransparent[i], x, y, z, this.game.d_TerrainTextures.terrainTextures1d()[i % this.game.d_TerrainTextures.terrainTexturesPerAtlas()], true);
			}
		}
		return ret;
	}

	public ModelData GetModelData(int tiletype, int textureid)
	{
		if (this.isFluid[tiletype] || this.istransparent[tiletype] && !this.isLowered[tiletype]) {
			return this.toreturnatlas1dtransparent[textureid / this.game.terrainTexturesPerAtlas];
		}
		else {
			return this.toreturnatlas1d[textureid / this.game.terrainTexturesPerAtlas];
		}
	}

	public int GetRailSlope(int xx, int yy, int zz)
	{
		int tiletype = this.currentChunk18[(zz * 18 + yy) * 18 + xx];
		int rail = this.Rail(tiletype);
		int blocknear;
		{
			blocknear = this.currentChunk18[(zz * 18 + yy) * 18 + xx + 1];
			if (rail == 1 && blocknear != 0 && this.Rail(blocknear) == 0) {
				return 2;
			}
		}
		{
			blocknear = this.currentChunk18[(zz * 18 + yy) * 18 + xx - 1];
			if (rail == 1 && blocknear != 0 && this.Rail(blocknear) == 0) {
				return 1;
			}
		}
		{
			blocknear = this.currentChunk18[(zz * 18 + yy - 1) * 18 + xx];
			if (rail == 2 && blocknear != 0 && this.Rail(blocknear) == 0) {
				return 3;
			}
		}
		{
			blocknear = this.currentChunk18[(zz * 18 + yy + 1) * 18 + xx];
			if (rail == 2 && blocknear != 0 && this.Rail(blocknear) == 0) {
				return 4;
			}
		}
		return 0;
	}

	public int GetShadowRatio(int xx, int yy, int zz)
	{
		return this.currentChunkShadows18[(zz * 18 + yy) * 18 + xx];
	}

	public int GetShadowRatioOld(int xx, int yy, int zz, int globalx, int globaly, int globalz)
	{
		return this.GetShadowRatio(xx, yy, zz);
	}

	public int GetShadowRatioVec(VecCito3i v)
	{
		return this.GetShadowRatio(v.x, v.y, v.z);
	}

	public int GetTilingCount(int[] currentChunk, int xx, int yy, int zz, int tt, int x, int y, int z, int shadowratio, int dir, int dirflags)
	{
		if (!this.ENABLE_TEXTURE_TILING) {
			return 1;
		}
		if (this.istransparent[currentChunk[(zz * 18 + yy) * 18 + xx]] && !this.IsTransparentFully(currentChunk[(zz * 18 + yy) * 18 + xx])) {
			return 1;
		}
		if (dir == 0 || dir == 1) {
			int shadowz = dir == 0 ? 1 : -1;
			int newxx = xx + 1;
			for (;;) {
				if (newxx >= 17) {
					break;
				}
				if (currentChunk[(zz * 18 + yy) * 18 + newxx] != tt) {
					break;
				}
				int shadowratio2 = this.GetShadowRatioOld(newxx, yy, zz + shadowz, x + newxx - xx, y, z + shadowz);
				if (shadowratio != shadowratio2) {
					break;
				}
				if ((this.currentChunkDraw16[((zz - 1) * 16 + yy - 1) * 16 + newxx - 1] & dirflags) == 0) {
					break;
				}
				this.currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + newxx - 1][dir] = 0;
				this.currentChunkDraw16[((zz - 1) * 16 + yy - 1) * 16 + newxx - 1] &= Game.IntToByte(~dirflags);
				newxx++;
			}
			return newxx - xx;
		}
		else if (dir == 5 || dir == 4) {
			int shadowx = dir == 5 ? -1 : 1;
			int newyy = yy + 1;
			for (;;) {
				if (newyy >= 17) {
					break;
				}
				if (currentChunk[(zz * 18 + newyy) * 18 + xx] != tt) {
					break;
				}
				int shadowratio2 = this.GetShadowRatioOld(xx + shadowx, newyy, zz, x + shadowx, y + newyy - yy, z);
				if (shadowratio != shadowratio2) {
					break;
				}
				if ((this.currentChunkDraw16[((zz - 1) * 16 + newyy - 1) * 16 + xx - 1] & dirflags) == 0) {
					break;
				}
				this.currentChunkDrawCount16[((zz - 1) * 16 + newyy - 1) * 16 + xx - 1][dir] = 0;
				this.currentChunkDraw16[((zz - 1) * 16 + newyy - 1) * 16 + xx - 1] &= Game.IntToByte(~dirflags);
				newyy++;
			}
			return newyy - yy;
		}
		else {
			int shadowy = dir == 2 ? -1 : 1;
			int newxx = xx + 1;
			for (;;) {
				if (newxx >= 17) {
					break;
				}
				if (currentChunk[(zz * 18 + yy) * 18 + newxx] != tt) {
					break;
				}
				int shadowratio2 = this.GetShadowRatioOld(newxx, yy + shadowy, zz, x + newxx - xx, y + shadowy, z);
				if (shadowratio != shadowratio2) {
					break;
				}
				if ((this.currentChunkDraw16[((zz - 1) * 16 + yy - 1) * 16 + newxx - 1] & dirflags) == 0) {
					break;
				}
				this.currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + newxx - 1][dir] = 0;
				this.currentChunkDraw16[((zz - 1) * 16 + yy - 1) * 16 + newxx - 1] &= Game.IntToByte(~dirflags);
				newxx++;
			}
			return newxx - xx;
		}
	}

	int GetToDrawFlags(int xx, int yy, int zz)
	{
		int nToDraw = 0;
		byte[] drawFlags = this.currentChunkDrawCount16[((zz - 1) * 16 + yy - 1) * 16 + xx - 1];
		nToDraw = this.SetVisibleFlag(drawFlags, 0, nToDraw, 1);
		nToDraw = this.SetVisibleFlag(drawFlags, 1, nToDraw, 2);
		nToDraw = this.SetVisibleFlag(drawFlags, 2, nToDraw, 4);
		nToDraw = this.SetVisibleFlag(drawFlags, 3, nToDraw, 8);
		nToDraw = this.SetVisibleFlag(drawFlags, 4, nToDraw, 16);
		nToDraw = this.SetVisibleFlag(drawFlags, 5, nToDraw, 32);
		return nToDraw;
	}

	public VerticesIndicesToLoad GetVerticesIndices(ModelData m, int x, int y, int z, int texture, bool transparent)
	{
		VerticesIndicesToLoad v = new VerticesIndicesToLoad();
		v.modelData = m;
		v.positionX = x * 16;
		v.positionY = y * 16;
		v.positionZ = z * 16;
		v.texture = texture;
		v.transparent = transparent;
		return v;
	}

	public bool IsFlower(int tiletype)
	{
		return this.game.blocktypes[tiletype].DrawType == 5;
	}

	public bool IsTransparentForLight(int block)
	{
		Packet_BlockType b = this.game.blocktypes[block];
		return b.DrawType != 1 && b.DrawType != 8;
	}

	public bool IsTransparentFully(int p)
	{
		Packet_BlockType b = this.game.blocktypes[p];
		return b.DrawType != 1 && b.DrawType != 5 && b.DrawType != 6 && b.DrawType != 7 && b.DrawType != 8;
	}

	public VerticesIndicesToLoad[] MakeChunk(int x, int y, int z, int[] chunk18, byte[] shadows18, float[] lightlevels_, IntRef retCount)
	{
		this.currentChunk18 = chunk18;
		this.currentChunkShadows18 = shadows18;
		this.lightlevels = lightlevels_;
		for (int i = 0; i < 1024; i++) {
			Packet_BlockType b = this.game.blocktypes[i];
			if (b == null) {
				continue;
			}
			this.istransparent[i] = b.DrawType != 1 && b.DrawType != 3;
			if (b.DrawType == 11 || b.DrawType == 12 || b.GetRail() != 0) {
				this.isLowered[i] = true;
			}
			this.isFluid[i] = b.DrawType == 3;
		}
		if (x < 0 || y < 0 || z < 0) {
			retCount.value = 0;
			return new VerticesIndicesToLoad[0];
		}
		if (!this.started) {
			this.game.platform.ThrowException("not started");
		}
		if (x >= this.mapsizex / 16 || y >= this.mapsizey / 16 || z >= this.mapsizez / 16) {
			retCount.value = 0;
			return new VerticesIndicesToLoad[0];
		}
		for (int i = 0; i < this.toreturnatlas1dLength; i++) {
			this.toreturnatlas1d[i].verticesCount = 0;
			this.toreturnatlas1d[i].indicesCount = 0;
			this.toreturnatlas1dtransparent[i].verticesCount = 0;
			this.toreturnatlas1dtransparent[i].indicesCount = 0;
		}
		this.CalculateVisibleFaces(this.currentChunk18);
		this.CalculateTilingCount(this.currentChunk18, x * 16, y * 16, z * 16);
		this.BuildBlockPolygons(x, y, z);
		VerticesIndicesToLoad[] ret = this.GetFinalVerticesIndices(x, y, z, retCount);
		return ret;
	}

	int Max(int a, int b)
	{
		if (a > b) {
			return a;
		}
		else {
			return b;
		}
	}

	float Min(float a, float b)
	{
		if (a < b) {
			return a;
		}
		else {
			return b;
		}
	}

	public int Rail(int tiletype)
	{
		return this.game.blocktypes[tiletype].Rail;
	}

	int SetVisibleFlag(byte[] drawFlags, int tileSideIndex, int nCurrentFlags, int nFlagToSet)
	{
		if (drawFlags[tileSideIndex] > 0) {
			return nCurrentFlags | nFlagToSet;
		}
		else {
			return nCurrentFlags;
		}
	}

	public void Start()
	{
		this.currentChunk18 = new int[5832];
		this.currentChunkShadows18 = new byte[5832];
		this.currentChunkDraw16 = new byte[4096];
		this.currentChunkDrawCount16 = new byte[4096][];
		this.mapsizex = this.game.map.MapSizeX;
		this.mapsizey = this.game.map.MapSizeY;
		this.mapsizez = this.game.map.MapSizeZ;
		this.started = true;
		this.istransparent = new bool[1024];
		for (int i = 0; i < 1024; i++) {
			this.istransparent[i] = false;
		}
		this.isLowered = new bool[1024];
		for (int i = 0; i < 1024; i++) {
			this.isLowered[i] = false;
		}
		this.isFluid = new bool[1024];
		for (int i = 0; i < 1024; i++) {
			this.isFluid[i] = false;
		}
		this.maxlightInverse = 1f / 15;
		this.terrainTexturesPerAtlas = this.game.terrainTexturesPerAtlas;
		this.terrainTexturesPerAtlasInverse = 1f / this.game.terrainTexturesPerAtlas;
		if (this.game.platform.IsFastSystem()) {
			this.AtiArtifactFix = 1 / 32f * 0.25f;
		}
		else {
			this.AtiArtifactFix = 1 / 32f * 1.5f;
		}
		this._texrecWidth = 1 - this.AtiArtifactFix * 2;
		this._texrecHeight = this.terrainTexturesPerAtlasInverse * (1 - this.AtiArtifactFix * 2);
		this._texrecLeft = this.AtiArtifactFix;
		this._texrecRight = this._texrecLeft + this._texrecWidth;
		this.toreturnatlas1dLength = this.Max(1, 1024 / this.game.terrainTexturesPerAtlas);
		this.toreturnatlas1d = new ModelData[this.toreturnatlas1dLength];
		this.toreturnatlas1dtransparent = new ModelData[this.toreturnatlas1dLength];
		for (int i = 0; i < this.toreturnatlas1dLength; i++) {
			this.toreturnatlas1d[i] = new ModelData();
			int max = 1024;
			this.toreturnatlas1d[i].xyz = new float[max * 3];
			this.toreturnatlas1d[i].uv = new float[max * 2];
			this.toreturnatlas1d[i].rgba = new byte[max * 4];
			this.toreturnatlas1d[i].indices = new int[max];
			this.toreturnatlas1d[i].verticesMax = max;
			this.toreturnatlas1d[i].indicesMax = max;
			this.toreturnatlas1dtransparent[i] = new ModelData();
			this.toreturnatlas1dtransparent[i].xyz = new float[max * 3];
			this.toreturnatlas1dtransparent[i].uv = new float[max * 2];
			this.toreturnatlas1dtransparent[i].rgba = new byte[max * 4];
			this.toreturnatlas1dtransparent[i].indices = new int[max];
			this.toreturnatlas1dtransparent[i].verticesMax = max;
			this.toreturnatlas1dtransparent[i].indicesMax = max;
		}
	}

	public int TextureId(int tiletype, int side)
	{
		return this.game.TextureId[tiletype][side];
	}
	internal int TorchSideTexture;
	internal int TorchTopTexture;
	internal int _colorWhite;
	internal float _texrecHeight;
	internal float _texrecLeft;
	internal float _texrecRight;
	internal float _texrecWidth;
	VecCito3i[][] c_OcclusionNeighbors;
	internal int[] currentChunk18;
	internal byte[] currentChunkDraw16;
	internal byte[][] currentChunkDrawCount16;
	internal byte[] currentChunkShadows18;
	internal Game game;

	public int getBestLadderInDirection(int x, int y, int z, int[] currentChunk, int dir)
	{
		int dz = dir;
		int result = 0;
		{
			while (((z + dz) * 18 + y) * 18 + x >= 0 && ((z + dz) * 18 + y) * 18 + x < 5832 && currentChunk[((z + dz) * 18 + y) * 18 + x] == 152) {
				result = dz;
				if (this.getBestLadderWall(x, y, z + dz, currentChunk) != -1)
					return result;
				dz += dir;
			}
		}
		return 0;
	}

	public int getBestLadderWall(int x, int y, int z, int[] currentChunk)
	{
		bool front = false;
		bool back = false;
		bool left = false;
		int wallscount = 0;
		if (currentChunk[(z * 18 + y - 1) * 18 + x] != 0) {
			front = true;
			wallscount++;
		}
		if (currentChunk[(z * 18 + y + 1) * 18 + x] != 0) {
			back = true;
			wallscount++;
		}
		int c = currentChunk[(z * 18 + y) * 18 + x - 1];
		if (c != 0) {
			left = true;
			wallscount++;
		}
		if (currentChunk[(z * 18 + y) * 18 + x + 1] != 0) {
			wallscount++;
		}
		if (wallscount != 1) {
			return -1;
		}
		else {
			if (front) {
				return 0;
			}
			else if (back) {
				return 1;
			}
			else if (left) {
				return 2;
			}
			else {
				return 3;
			}
		}
	}
	internal float halfocc;
	internal bool[] isFluid;
	internal bool[] isLowered;
	internal bool[] istransparent;

	public bool isvalid(int tt)
	{
		return this.game.blocktypes[tt].Name != null;
	}
	internal float[] lightlevels;
	internal int mapsizex;
	internal int mapsizey;
	internal int mapsizez;
	internal float maxlightInverse;
	internal float occ;
	internal bool option_DarkenBlockSides;
	internal bool option_DoNotDrawEdges;
	float[] ref_blockCornerHeight;
	internal bool started;
	internal int terrainTexturesPerAtlas;
	internal float terrainTexturesPerAtlasInverse;
	float[] tmpfShadowRation;
	int[] tmpnPos;
	bool[] tmpoccupied;
	int[] tmpshadowration;
	VecCito3i tmpv;
	internal ModelData[] toreturnatlas1d;
	int toreturnatlas1dLength;
	internal ModelData[] toreturnatlas1dtransparent;
}

public class TerrainRendererCommit : Action_
{

	public static TerrainRendererCommit Create(ModDrawTerrain renderer)
	{
		TerrainRendererCommit c = new TerrainRendererCommit();
		c.renderer = renderer;
		return c;
	}

	public override void Run()
	{
		this.renderer.MainThreadCommit();
	}
	ModDrawTerrain renderer;
}

public class TerrainRendererRedraw
{
	internal Chunk c;
	internal VerticesIndicesToLoad[] data;
	internal int dataCount;
}

public enum TextAlign
{
	Left,
	Center,
	Right
}

public enum TextBaseline
{
	Top,
	Middle,
	Bottom
}

public class TextColorRenderer
{

	internal BitmapCi CreateTextTexture(Text_ t)
	{
		IntRef partsCount = new IntRef();
		TextPart[] parts = this.DecodeColors(t.text, t.color, partsCount);
		float totalwidth = 0;
		float totalheight = 0;
		int[] sizesX = new int[partsCount.value];
		int[] sizesY = new int[partsCount.value];
		for (int i = 0; i < partsCount.value; i++) {
			IntRef outWidth = new IntRef();
			IntRef outHeight = new IntRef();
			this.platform.TextSize(parts[i].text, t.fontsize, outWidth, outHeight);
			sizesX[i] = outWidth.value;
			sizesY[i] = outHeight.value;
			totalwidth += outWidth.value;
			totalheight = MathCi.MaxFloat(totalheight, outHeight.value);
		}
		int size2X = this.NextPowerOfTwo(this.platform.FloatToInt(totalwidth) + 1);
		int size2Y = this.NextPowerOfTwo(this.platform.FloatToInt(totalheight) + 1);
		BitmapCi bmp2 = this.platform.BitmapCreate(size2X, size2Y);
		int[] bmp2Pixels = new int[size2X * size2Y];
		float currentwidth = 0;
		for (int i = 0; i < partsCount.value; i++) {
			int sizeiX = sizesX[i];
			int sizeiY = sizesY[i];
			if (sizeiX == 0 || sizeiY == 0) {
				continue;
			}
			Text_ partText = new Text_();
			partText.text = parts[i].text;
			partText.color = parts[i].color;
			partText.fontsize = t.fontsize;
			partText.fontstyle = t.fontstyle;
			partText.fontfamily = t.fontfamily;
			BitmapCi partBmp = this.platform.CreateTextTexture(partText);
			int partWidth = this.platform.FloatToInt(this.platform.BitmapGetWidth(partBmp));
			int partHeight = this.platform.FloatToInt(this.platform.BitmapGetHeight(partBmp));
			int[] partBmpPixels = new int[partWidth * partHeight];
			this.platform.BitmapGetPixelsArgb(partBmp, partBmpPixels);
			for (int x = 0; x < partWidth; x++) {
				for (int y = 0; y < partHeight; y++) {
					if (x + currentwidth >= size2X) {
						continue;
					}
					if (y >= size2Y) {
						continue;
					}
					int c = partBmpPixels[MapUtilCi.Index2d(x, y, partWidth)];
					if (Game.ColorA(c) > 0) {
						bmp2Pixels[MapUtilCi.Index2d(this.platform.FloatToInt(currentwidth) + x, y, size2X)] = c;
					}
				}
			}
			currentwidth += sizeiX;
		}
		this.platform.BitmapSetPixelsArgb(bmp2, bmp2Pixels);
		return bmp2;
	}

	public TextPart[] DecodeColors(string s, int defaultcolor, IntRef retLength)
	{
		TextPart[] parts = new TextPart[256];
		int partsCount = 0;
		int currentcolor = defaultcolor;
		int[] currenttext = new int[256];
		int currenttextLength = 0;
		IntRef sLength = new IntRef();
		int[] sChars = this.platform.StringToCharArray(s, sLength);
		for (int i = 0; i < sLength.value; i++) {
			if (sChars[i] == 38) {
				if (i + 1 < sLength.value) {
					int color = this.HexToInt(sChars[i + 1]);
					if (color != -1) {
						if (currenttextLength != 0) {
							TextPart part = new TextPart();
							part.text = this.platform.CharArrayToString(currenttext, currenttextLength);
							part.color = currentcolor;
							parts[partsCount++] = part;
						}
						for (int k = 0; k < currenttextLength; k++) {
							currenttext[k] = 0;
						}
						currenttextLength = 0;
						currentcolor = this.GetColor(color);
						i++;
					}
					else {
						currenttext[currenttextLength++] = sChars[i];
					}
				}
				else {
					currenttext[currenttextLength++] = sChars[i];
				}
			}
			else {
				currenttext[currenttextLength++] = s[i];
			}
		}
		if (currenttextLength != 0) {
			TextPart part = new TextPart();
			part.text = this.platform.CharArrayToString(currenttext, currenttextLength);
			part.color = currentcolor;
			parts[partsCount++] = part;
		}
		retLength.value = partsCount;
		return parts;
	}

	int GetColor(int currentcolor)
	{
		switch (currentcolor) {
		case 0:
			{
				return Game.ColorFromArgb(255, 0, 0, 0);
			}
		case 1:
			{
				return Game.ColorFromArgb(255, 0, 0, 191);
			}
		case 2:
			{
				return Game.ColorFromArgb(255, 0, 191, 0);
			}
		case 3:
			{
				return Game.ColorFromArgb(255, 0, 191, 191);
			}
		case 4:
			{
				return Game.ColorFromArgb(255, 191, 0, 0);
			}
		case 5:
			{
				return Game.ColorFromArgb(255, 191, 0, 191);
			}
		case 6:
			{
				return Game.ColorFromArgb(255, 191, 191, 0);
			}
		case 7:
			{
				return Game.ColorFromArgb(255, 191, 191, 191);
			}
		case 8:
			{
				return Game.ColorFromArgb(255, 40, 40, 40);
			}
		case 9:
			{
				return Game.ColorFromArgb(255, 64, 64, 255);
			}
		case 10:
			{
				return Game.ColorFromArgb(255, 64, 255, 64);
			}
		case 11:
			{
				return Game.ColorFromArgb(255, 64, 255, 255);
			}
		case 12:
			{
				return Game.ColorFromArgb(255, 255, 64, 64);
			}
		case 13:
			{
				return Game.ColorFromArgb(255, 255, 64, 255);
			}
		case 14:
			{
				return Game.ColorFromArgb(255, 255, 255, 64);
			}
		case 15:
			{
				return Game.ColorFromArgb(255, 255, 255, 255);
			}
		default:
			return Game.ColorFromArgb(255, 255, 255, 255);
		}
	}

	int HexToInt(int c)
	{
		if (c == 48) {
			return 0;
		}
		if (c == 49) {
			return 1;
		}
		if (c == 50) {
			return 2;
		}
		if (c == 51) {
			return 3;
		}
		if (c == 52) {
			return 4;
		}
		if (c == 53) {
			return 5;
		}
		if (c == 54) {
			return 6;
		}
		if (c == 55) {
			return 7;
		}
		if (c == 56) {
			return 8;
		}
		if (c == 57) {
			return 9;
		}
		if (c == 97) {
			return 10;
		}
		if (c == 98) {
			return 11;
		}
		if (c == 99) {
			return 12;
		}
		if (c == 100) {
			return 13;
		}
		if (c == 101) {
			return 14;
		}
		if (c == 102) {
			return 15;
		}
		return -1;
	}

	int NextPowerOfTwo(int x)
	{
		x--;
		x |= x >> 1;
		x |= x >> 2;
		x |= x >> 4;
		x |= x >> 8;
		x++;
		return x;
	}
	internal GamePlatform platform;
}

public class TextPart
{
	internal int color;
	internal string text;
}

public class TextTexture
{
	internal float size;
	internal string text;
	internal int textheight;
	internal int texture;
	internal int textureheight;
	internal int texturewidth;
	internal int textwidth;
}

public class Text_
{

	internal bool Equals_(Text_ t)
	{
		return this.text == t.text && this.fontsize == t.fontsize && this.color == t.color && this.fontfamily == t.fontfamily && this.fontstyle == t.fontstyle;
	}

	public int GetColor()
	{
		return this.color;
	}

	public string GetFontFamily()
	{
		return this.fontfamily;
	}

	public float GetFontSize()
	{
		return this.fontsize;
	}

	public int GetFontStyle()
	{
		return this.fontstyle;
	}

	public string GetText()
	{
		return this.text;
	}

	public void SetColor(int value)
	{
		this.color = value;
	}

	public void SetFontFamily(string value)
	{
		this.fontfamily = value;
	}

	public void SetFontSize(float value)
	{
		this.fontsize = value;
	}

	public void SetFontStyle(int value)
	{
		this.fontstyle = value;
	}

	public void SetText(string value)
	{
		this.text = value;
	}
	internal int color;
	internal string fontfamily;
	internal float fontsize;
	internal int fontstyle;
	internal string text;
}

public abstract class Texture
{
}

public class TextureAtlas
{

	public static RectFRef TextureCoords2d(int textureId, int texturesPacked)
	{
		float one = 1;
		RectFRef r = new RectFRef();
		r.y = one / texturesPacked * textureId / texturesPacked;
		r.x = one / texturesPacked * textureId % texturesPacked;
		r.w = one / texturesPacked;
		r.h = one / texturesPacked;
		return r;
	}
}

public class TextureAtlasCi
{

	public static void TextureCoords2d(int textureId, int texturesPacked, RectFRef r)
	{
		float one = 1;
		r.y = one / texturesPacked * textureId / texturesPacked;
		r.x = one / texturesPacked * textureId % texturesPacked;
		r.w = one / texturesPacked;
		r.h = one / texturesPacked;
	}
}

public class TextureAtlasConverter
{

	public BitmapCi[] Atlas2dInto1d(GamePlatform p, BitmapCi atlas2d_, int tiles, int atlassizezlimit, IntRef retCount)
	{
		BitmapData_ orig = BitmapData_.CreateFromBitmap(p, atlas2d_);
		int tilesize = orig.width / tiles;
		int atlasescount = MathCi.MaxInt(1, tiles * tiles * tilesize / atlassizezlimit);
		BitmapCi[] atlases = new BitmapCi[128];
		int atlasesCount = 0;
		BitmapData_ atlas1d = null;
		for (int i = 0; i < tiles * tiles; i++) {
			int x = i % tiles;
			int y = i / tiles;
			int tilesinatlas = tiles * tiles / atlasescount;
			if (i % tilesinatlas == 0) {
				if (atlas1d != null) {
					atlases[atlasesCount++] = atlas1d.ToBitmap(p);
				}
				atlas1d = BitmapData_.Create(tilesize, atlassizezlimit);
			}
			for (int xx = 0; xx < tilesize; xx++) {
				for (int yy = 0; yy < tilesize; yy++) {
					int c = orig.GetPixel(x * tilesize + xx, y * tilesize + yy);
					atlas1d.SetPixel(xx, i % tilesinatlas * tilesize + yy, c);
				}
			}
		}
		atlases[atlasesCount++] = atlas1d.ToBitmap(p);
		retCount.value = atlasescount;
		return atlases;
	}
}

public class ThumbnailResponseCi
{
	internal byte[] data;
	internal int dataLength;
	internal bool done;
	internal bool error;
	internal string serverMessage;
}

public class TileDirectionEnum
{
	public const int Bottom = 1;
	public const int BottomLeft = 6;
	public const int BottomRight = 7;
	public const int Center = 8;
	public const int DirectionCounts = 9;
	public const int Left = 2;
	public const int Right = 3;
	public const int Top = 0;
	public const int TopLeft = 4;
	public const int TopRight = 5;
}

public class TileEnterData
{
	internal int BlockPositionX;
	internal int BlockPositionY;
	internal int BlockPositionZ;
	internal TileEnterDirection EnterDirection;
}

public enum TileEnterDirection
{
	Up,
	Down,
	Left,
	Right
}

public enum TileExitDirection
{
	Up,
	Down,
	Left,
	Right
}

public class TileSide
{
	public const int Back = 3;
	public const int Bottom = 1;
	public const int Front = 2;
	public const int Left = 4;
	public const int Right = 5;
	public const int Top = 0;
}

public class TileSideEnum
{
	public const int Back = 4;
	public const int Bottom = 1;
	public const int Front = 5;
	public const int Left = 2;
	public const int Right = 3;
	public const int SideCount = 6;

	public static int ToFlags(int nValue)
	{
		switch (nValue) {
		case 0:
			return 1;
		case 1:
			return 2;
		case 2:
			return 16;
		case 3:
			return 32;
		case 4:
			return 8;
		case 5:
			return 4;
		default:
			return 0;
		}
	}
	public const int Top = 0;
}

public class TileSideFlagsEnum
{
	public const int Back = 32;
	public const int Bottom = 2;
	public const int Front = 16;

	public static bool HasFlag(int nFlagA, int nFlagB)
	{
		return (nFlagA & nFlagB) != 0;
	}
	public const int Left = 8;
	public const int None = 0;
	public const int Right = 4;
	public const int Top = 1;
}

public class TimerCi
{
	public TimerCi()
	{
		this.interval = 1;
		this.maxDeltaTime = -1;
	}

	internal static TimerCi Create(int interval_, int maxDeltaTime_)
	{
		TimerCi timer = new TimerCi();
		timer.interval = interval_;
		timer.maxDeltaTime = maxDeltaTime_;
		return timer;
	}

	public void Reset()
	{
		this.accumulator = 0;
	}

	public int Update(float dt)
	{
		this.accumulator += dt;
		float constDt = this.interval;
		if (this.maxDeltaTime != -1 && this.accumulator > this.maxDeltaTime) {
			this.accumulator = this.maxDeltaTime;
		}
		int updates = 0;
		while (this.accumulator >= constDt) {
			updates++;
			this.accumulator -= constDt;
		}
		return updates;
	}
	internal float accumulator;
	internal float interval;
	internal float maxDeltaTime;
}

public class ToCall
{
	internal int Count;
	internal Model[] Lists;
	internal int Max;
}

public enum TorchType
{
	Normal,
	Left,
	Right,
	Front,
	Back
}

public class TorchTypeEnum
{
	public const int Back = 4;
	public const int Front = 3;
	public const int Left = 1;
	public const int Normal = 0;
	public const int Right = 2;
}

public class TouchEventArgs
{

	public bool GetHandled()
	{
		return this.handled;
	}

	public int GetId()
	{
		return this.id;
	}

	public int GetX()
	{
		return this.x;
	}

	public int GetY()
	{
		return this.y;
	}

	public void SetHandled(bool value)
	{
		this.handled = value;
	}

	public void SetId(int value)
	{
		this.id = value;
	}

	public void SetX(int value)
	{
		this.x = value;
	}

	public void SetY(int value)
	{
		this.y = value;
	}
	bool handled;
	int id;
	int x;
	int y;
}

public abstract class TouchEventHandler
{

	public abstract void OnTouchEnd(TouchEventArgs e);

	public abstract void OnTouchMove(TouchEventArgs e);

	public abstract void OnTouchStart(TouchEventArgs e);
}

public class TranslatedString
{
	internal string id;
	internal string language;
	internal string translated;
}

public enum TypingState
{
	None,
	Typing,
	Ready
}

public class UnloadRendererChunksCommit : Action_
{

	public override void Run()
	{
		if (this.unloadChunkPos != -1) {
			Chunk c = this.game.map.chunks[this.unloadChunkPos];
			for (int k = 0; k < c.rendered.idsCount; k++) {
				int loadedSubmesh = c.rendered.ids[k];
				this.game.d_Batcher.Remove(loadedSubmesh);
			}
			c.rendered.ids = null;
			c.rendered.dirty = true;
			c.rendered.light = null;
			this.unloadChunkPos = -1;
		}
	}
	internal Game game;
	internal int unloadChunkPos;
}

public class Unproject
{
	public Unproject()
	{
		this.finalMatrix = Mat4.Create();
		this.inp = new float[4];
		this.out_ = new float[4];
	}

	void MultMatrixVec(float[] matrix, float[] inp__, float[] out__)
	{
		for (int i = 0; i < 4; i = i + 1) {
			out__[i] = inp__[0] * matrix[0 + i] + inp__[1] * matrix[4 + i] + inp__[2] * matrix[8 + i] + inp__[3] * matrix[12 + i];
		}
	}

	public bool UnProject(int winX, int winY, int winZ, float[] model, float[] proj, float[] view, float[] objPos)
	{
		this.inp[0] = winX;
		this.inp[1] = winY;
		this.inp[2] = winZ;
		this.inp[3] = 1;
		Mat4.Multiply(this.finalMatrix, proj, model);
		Mat4.Invert(this.finalMatrix, this.finalMatrix);
		this.inp[0] = (this.inp[0] - view[0]) / view[2];
		this.inp[1] = (this.inp[1] - view[1]) / view[3];
		this.inp[0] = this.inp[0] * 2 - 1;
		this.inp[1] = this.inp[1] * 2 - 1;
		this.inp[2] = this.inp[2] * 2 - 1;
		this.MultMatrixVec(this.finalMatrix, this.inp, this.out_);
		if (this.out_[3] == 0) {
			return false;
		}
		this.out_[0] /= this.out_[3];
		this.out_[1] /= this.out_[3];
		this.out_[2] /= this.out_[3];
		objPos[0] = this.out_[0];
		objPos[1] = this.out_[1];
		objPos[2] = this.out_[2];
		return true;
	}
	float[] finalMatrix;
	float[] inp;
	float[] out_;
}

public class UpDown
{
	public const int Down = 2;
	public const int None = 0;
	public const int Up = 1;
}

public class UriCi
{

	public DictionaryStringString GetGet()
	{
		return this.get;
	}

	public string GetIp()
	{
		return this.ip;
	}

	public int GetPort()
	{
		return this.port;
	}

	public string GetUrl()
	{
		return this.url;
	}
	internal DictionaryStringString get;
	internal string ip;
	internal int port;
	internal string url;
}

public class Vec2
{

	/// <summary>**</summary>
	public static float[] Add(float[] output, float[] a, float[] b)
	{
		output[0] = a[0] + b[0];
		output[1] = a[1] + b[1];
		return output;
	}

	/// <summary>**</summary>
	public static float[] CloneIt(float[] a)
	{
		float[] output = new float[2];
		output[0] = a[0];
		output[1] = a[1];
		return output;
	}

	/// <summary>**</summary>
	public static float[] Copy(float[] output, float[] a)
	{
		output[0] = a[0];
		output[1] = a[1];
		return output;
	}

	/// <summary>**</summary>
	public static float[] Create()
	{
		float[] output = new float[2];
		output[0] = 0;
		output[1] = 0;
		return output;
	}

	/// <summary>**</summary>
	public static float[] Cross(float[] output, float[] a, float[] b)
	{
		float z = a[0] * b[1] - a[1] * b[0];
		output[0] = output[1] = 0;
		output[2] = z;
		return output;
	}

	/// <summary>**</summary>
	public static float Dist(float[] a, float[] b)
	{
		return Vec2.Distance(a, b);
	}

	/// <summary>**</summary>
	public static float Distance(float[] a, float[] b)
	{
		float x = b[0] - a[0];
		float y = b[1] - a[1];
		return Platform.Sqrt(x * x + y * y);
	}

	/// <summary>**</summary>
	public static float[] Div(float[] output, float[] a, float[] b)
	{
		return Vec2.Divide(output, a, b);
	}

	/// <summary>**</summary>
	public static float[] Divide(float[] output, float[] a, float[] b)
	{
		output[0] = a[0] / b[0];
		output[1] = a[1] / b[1];
		return output;
	}

	/// <summary>**</summary>
	public static float Dot(float[] a, float[] b)
	{
		return a[0] * b[0] + a[1] * b[1];
	}

	/// <summary>**</summary>
	public static float[] FromValues(float x, float y)
	{
		float[] output = new float[2];
		output[0] = x;
		output[1] = y;
		return output;
	}

	/// <summary>**</summary>
	public static float Len(float[] a)
	{
		return Vec2.Length_(a);
	}

	/// <summary>**</summary>
	public static float Length_(float[] a)
	{
		float x = a[0];
		float y = a[1];
		return Platform.Sqrt(x * x + y * y);
	}

	/// <summary>**</summary>
	public static float[] Lerp(float[] output, float[] a, float[] b, float t)
	{
		float ax = a[0];
		float ay = a[1];
		output[0] = ax + t * (b[0] - ax);
		output[1] = ay + t * (b[1] - ay);
		return output;
	}

	/// <summary>**</summary>
	public static float[] Max(float[] output, float[] a, float[] b)
	{
		output[0] = GlMatrixMath.max(a[0], b[0]);
		output[1] = GlMatrixMath.max(a[1], b[1]);
		return output;
	}

	/// <summary>**</summary>
	public static float[] Min(float[] output, float[] a, float[] b)
	{
		output[0] = GlMatrixMath.min(a[0], b[0]);
		output[1] = GlMatrixMath.min(a[1], b[1]);
		return output;
	}

	/// <summary>**</summary>
	public static float[] Mul(float[] output, float[] a, float[] b)
	{
		return Vec2.Multiply(output, a, b);
	}

	/// <summary>**</summary>
	public static float[] Multiply(float[] output, float[] a, float[] b)
	{
		output[0] = a[0] * b[0];
		output[1] = a[1] * b[1];
		return output;
	}

	/// <summary>**</summary>
	public static float[] Negate(float[] output, float[] a)
	{
		output[0] = -a[0];
		output[1] = -a[1];
		return output;
	}

	/// <summary>**</summary>
	public static float[] Normalize(float[] output, float[] a)
	{
		float x = a[0];
		float y = a[1];
		float len = x * x + y * y;
		if (len > 0) {
			len = 1 / Platform.Sqrt(len);
			output[0] = a[0] * len;
			output[1] = a[1] * len;
		}
		return output;
	}

	/// <summary>**</summary>
	public static float[] Scale(float[] output, float[] a, float b)
	{
		output[0] = a[0] * b;
		output[1] = a[1] * b;
		return output;
	}

	/// <summary>**</summary>
	public static float[] ScaleAndAdd(float[] output, float[] a, float[] b, float scale)
	{
		output[0] = a[0] + b[0] * scale;
		output[1] = a[1] + b[1] * scale;
		return output;
	}

	/// <summary>**</summary>
	public static float[] Set(float[] output, float x, float y)
	{
		output[0] = x;
		output[1] = y;
		return output;
	}

	/// <summary>**</summary>
	public static float SqrDist(float[] a, float[] b)
	{
		return Vec2.SquaredDistance(a, b);
	}

	/// <summary>**</summary>
	public static float SqrLen(float[] a)
	{
		return Vec2.SquaredLength(a);
	}

	/// <summary>**</summary>
	public static float SquaredDistance(float[] a, float[] b)
	{
		float x = b[0] - a[0];
		float y = b[1] - a[1];
		return x * x + y * y;
	}

	/// <summary>**</summary>
	public static float SquaredLength(float[] a)
	{
		float x = a[0];
		float y = a[1];
		return x * x + y * y;
	}

	/// <summary>**</summary>
	public static float[] Sub(float[] output, float[] a, float[] b)
	{
		return Vec2.Subtract(output, a, b);
	}

	/// <summary>**</summary>
	public static float[] Subtract(float[] output, float[] a, float[] b)
	{
		output[0] = a[0] - b[0];
		output[1] = a[1] - b[1];
		return output;
	}

	/// <summary>**</summary>
	public static float[] TransformMat2(float[] output, float[] a, float[] m)
	{
		float x = a[0];
		float y = a[1];
		output[0] = m[0] * x + m[2] * y;
		output[1] = m[1] * x + m[3] * y;
		return output;
	}

	/// <summary>**</summary>
	public static float[] TransformMat2d(float[] output, float[] a, float[] m)
	{
		float x = a[0];
		float y = a[1];
		output[0] = m[0] * x + m[2] * y + m[4];
		output[1] = m[1] * x + m[3] * y + m[5];
		return output;
	}

	/// <summary>**</summary>
	public static float[] TransformMat3(float[] output, float[] a, float[] m)
	{
		float x = a[0];
		float y = a[1];
		output[0] = m[0] * x + m[3] * y + m[6];
		output[1] = m[1] * x + m[4] * y + m[7];
		return output;
	}

	/// <summary>**</summary>
	public static float[] TransformMat4(float[] output, float[] a, float[] m)
	{
		float x = a[0];
		float y = a[1];
		output[0] = m[0] * x + m[4] * y + m[12];
		output[1] = m[1] * x + m[5] * y + m[13];
		return output;
	}

	/// <summary>**
	/// **</summary>
	void f()
	{
	}
}

/// <summary>3 Dimensional Vector</summary>
public class Vec3
{

	/// <summary>Adds two vec3's
	/// @returns {vec3} out</summary>
	/// <param name="output">/@param {vec3} out the receiving vector</param>
	/// <param name="a">/@param {vec3} a the first operand</param>
	/// <param name="b">/@param {vec3} b the second operand</param>
	public static float[] Add(float[] output, float[] a, float[] b)
	{
		output[0] = a[0] + b[0];
		output[1] = a[1] + b[1];
		output[2] = a[2] + b[2];
		return output;
	}

	/// <summary>Creates a new vec3 initialized with values from an existing vector
	/// Returns {vec3} a new 3D vector</summary>
	/// <param name="a">a vector to clone</param>
	public static float[] CloneIt(float[] a)
	{
		float[] output = new float[3];
		output[0] = a[0];
		output[1] = a[1];
		output[2] = a[2];
		return output;
	}

	/// <summary>Copy the values from one vec3 to another
	/// @returns {vec3} out</summary>
	/// <param name="output">/@param {vec3} out the receiving vector</param>
	/// <param name="a">/@param {vec3} a the source vector</param>
	public static float[] Copy(float[] output, float[] a)
	{
		output[0] = a[0];
		output[1] = a[1];
		output[2] = a[2];
		return output;
	}

	/// <summary>Creates a new, empty vec3
	/// Returns {vec3} a new 3D vector.</summary>
	public static float[] Create()
	{
		float[] output = new float[3];
		output[0] = 0;
		output[1] = 0;
		output[2] = 0;
		return output;
	}

	/// <summary>Computes the cross product of two vec3's
	/// @returns {vec3} out</summary>
	/// <param name="output">/@param {vec3} out the receiving vector</param>
	/// <param name="a">/@param {vec3} a the first operand</param>
	/// <param name="b">/@param {vec3} b the second operand</param>
	public static float[] Cross(float[] output, float[] a, float[] b)
	{
		float ax = a[0];
		float ay = a[1];
		float az = a[2];
		float bx = b[0];
		float by = b[1];
		float bz = b[2];
		output[0] = ay * bz - az * by;
		output[1] = az * bx - ax * bz;
		output[2] = ax * by - ay * bx;
		return output;
	}

	/// <summary>Alias for {@link vec3.distance}</summary>
	public static float Dist(float[] a, float[] b)
	{
		return Vec3.Distance(a, b);
	}

	/// <summary>Calculates the euclidian distance between two vec3's
	/// @returns {Number} distance between a and b</summary>
	/// <param name="a">/@param {vec3} a the first operand</param>
	/// <param name="b">/@param {vec3} b the second operand</param>
	public static float Distance(float[] a, float[] b)
	{
		float x = b[0] - a[0];
		float y = b[1] - a[1];
		float z = b[2] - a[2];
		return Platform.Sqrt(x * x + y * y + z * z);
	}

	/// <summary>Alias for {@link vec3.divide}</summary>
	public static float[] Div(float[] output, float[] a, float[] b)
	{
		return Vec3.Divide(output, a, b);
	}

	/// <summary>Divides two vec3's
	/// @returns {vec3} out</summary>
	/// <param name="output">/@param {vec3} out the receiving vector</param>
	/// <param name="a">/@param {vec3} a the first operand</param>
	/// <param name="b">/@param {vec3} b the second operand</param>
	public static float[] Divide(float[] output, float[] a, float[] b)
	{
		output[0] = a[0] / b[0];
		output[1] = a[1] / b[1];
		output[2] = a[2] / b[2];
		return output;
	}

	/// <summary>Calculates the dot product of two vec3's
	/// @returns {Number} dot product of a and b</summary>
	/// <param name="a">/@param {vec3} a the first operand</param>
	/// <param name="b">/@param {vec3} b the second operand</param>
	public static float Dot(float[] a, float[] b)
	{
		return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
	}

	/// <summary>Creates a new vec3 initialized with the given values
	/// Returns {vec3} a new 3D vector</summary>
	/// <param name="x">X component</param>
	/// <param name="y">Y component</param>
	/// <param name="z">Z component</param>
	public static float[] FromValues(float x, float y, float z)
	{
		float[] output = new float[3];
		output[0] = x;
		output[1] = y;
		output[2] = z;
		return output;
	}

	/// <summary>Alias for {@link vec3.length}</summary>
	public static float Len(float[] a)
	{
		return Vec3.Length_(a);
	}

	/// <summary>Calculates the length of a vec3
	/// @returns {Number} length of a</summary>
	/// <param name="a">/@param {vec3} a vector to calculate length of</param>
	public static float Length_(float[] a)
	{
		float x = a[0];
		float y = a[1];
		float z = a[2];
		return Platform.Sqrt(x * x + y * y + z * z);
	}

	/// <summary>Performs a linear interpolation between two vec3's
	/// @returns {vec3} out</summary>
	/// <param name="output">/@param {vec3} out the receiving vector</param>
	/// <param name="a">/@param {vec3} a the first operand</param>
	/// <param name="b">/@param {vec3} b the second operand</param>
	/// <param name="t">/@param {Number} t interpolation amount between the two inputs</param>
	public static float[] Lerp(float[] output, float[] a, float[] b, float t)
	{
		float ax = a[0];
		float ay = a[1];
		float az = a[2];
		output[0] = ax + t * (b[0] - ax);
		output[1] = ay + t * (b[1] - ay);
		output[2] = az + t * (b[2] - az);
		return output;
	}

	/// <summary>Returns the maximum of two vec3's
	/// @returns {vec3} out</summary>
	/// <param name="output">/@param {vec3} out the receiving vector</param>
	/// <param name="a">/@param {vec3} a the first operand</param>
	/// <param name="b">/@param {vec3} b the second operand</param>
	public static float[] Max(float[] output, float[] a, float[] b)
	{
		output[0] = GlMatrixMath.max(a[0], b[0]);
		output[1] = GlMatrixMath.max(a[1], b[1]);
		output[2] = GlMatrixMath.max(a[2], b[2]);
		return output;
	}

	/// <summary>Returns the minimum of two vec3's
	/// @returns {vec3} out</summary>
	/// <param name="output">/@param {vec3} out the receiving vector</param>
	/// <param name="a">/@param {vec3} a the first operand</param>
	/// <param name="b">/@param {vec3} b the second operand</param>
	public static float[] Min(float[] output, float[] a, float[] b)
	{
		output[0] = GlMatrixMath.min(a[0], b[0]);
		output[1] = GlMatrixMath.min(a[1], b[1]);
		output[2] = GlMatrixMath.min(a[2], b[2]);
		return output;
	}

	/// <summary>Alias for {@link vec3.multiply}</summary>
	public static float[] Mul(float[] output, float[] a, float[] b)
	{
		return Vec3.Multiply(output, a, b);
	}

	/// <summary>Multiplies two vec3's
	/// @returns {vec3} out</summary>
	/// <param name="output">/@param {vec3} out the receiving vector</param>
	/// <param name="a">/@param {vec3} a the first operand</param>
	/// <param name="b">/@param {vec3} b the second operand</param>
	public static float[] Multiply(float[] output, float[] a, float[] b)
	{
		output[0] = a[0] * b[0];
		output[1] = a[1] * b[1];
		output[2] = a[2] * b[2];
		return output;
	}

	/// <summary>Negates the components of a vec3
	/// @returns {vec3} out</summary>
	/// <param name="output">/@param {vec3} out the receiving vector</param>
	/// <param name="a">/@param {vec3} a vector to negate</param>
	public static float[] Negate(float[] output, float[] a)
	{
		output[0] = 0 - a[0];
		output[1] = 0 - a[1];
		output[2] = 0 - a[2];
		return output;
	}

	/// <summary>Normalize a vec3
	/// @returns {vec3} out</summary>
	/// <param name="output">/@param {vec3} out the receiving vector</param>
	/// <param name="a">/@param {vec3} a vector to normalize</param>
	public static float[] Normalize(float[] output, float[] a)
	{
		float x = a[0];
		float y = a[1];
		float z = a[2];
		float len = x * x + y * y + z * z;
		if (len > 0) {
			float one = 1;
			len = one / Platform.Sqrt(len);
			output[0] = a[0] * len;
			output[1] = a[1] * len;
			output[2] = a[2] * len;
		}
		return output;
	}

	/// <summary>Scales a vec3 by a scalar number
	/// @returns {vec3} out</summary>
	/// <param name="output">/@param {vec3} out the receiving vector</param>
	/// <param name="a">/@param {vec3} a the vector to scale</param>
	/// <param name="b">/@param {Number} b amount to scale the vector by</param>
	public static float[] Scale(float[] output, float[] a, float b)
	{
		output[0] = a[0] * b;
		output[1] = a[1] * b;
		output[2] = a[2] * b;
		return output;
	}

	/// <summary>Adds two vec3's after scaling the second operand by a scalar value
	/// @returns {vec3} out</summary>
	/// <param name="output">/@param {vec3} out the receiving vector</param>
	/// <param name="a">/@param {vec3} a the first operand</param>
	/// <param name="b">/@param {vec3} b the second operand</param>
	/// <param name="scale">/@param {Number} scale the amount to scale b by before adding</param>
	public static float[] ScaleAndAdd(float[] output, float[] a, float[] b, float scale)
	{
		output[0] = a[0] + b[0] * scale;
		output[1] = a[1] + b[1] * scale;
		output[2] = a[2] + b[2] * scale;
		return output;
	}

	/// <summary>Set the components of a vec3 to the given values
	/// @returns {vec3} out</summary>
	/// <param name="output">/@param {vec3} out the receiving vector</param>
	/// <param name="x">/@param {Number} x X component</param>
	/// <param name="y">/@param {Number} y Y component</param>
	/// <param name="z">/@param {Number} z Z component</param>
	public static float[] Set(float[] output, float x, float y, float z)
	{
		output[0] = x;
		output[1] = y;
		output[2] = z;
		return output;
	}

	/// <summary>Alias for {@link vec3.squaredDistance}
	/// @function</summary>
	public static float SqrDist(float[] a, float[] b)
	{
		return Vec3.SquaredDistance(a, b);
	}

	/// <summary>Alias for {@link vec3.squaredLength}</summary>
	public static float SqrLen(float[] a)
	{
		return Vec3.SquaredLength(a);
	}

	/// <summary>Calculates the squared euclidian distance between two vec3's
	/// @returns {Number} squared distance between a and b</summary>
	/// <param name="a">/@param {vec3} a the first operand</param>
	/// <param name="b">/@param {vec3} b the second operand</param>
	public static float SquaredDistance(float[] a, float[] b)
	{
		float x = b[0] - a[0];
		float y = b[1] - a[1];
		float z = b[2] - a[2];
		return x * x + y * y + z * z;
	}

	/// <summary>Calculates the squared length of a vec3
	/// @returns {Number} squared length of a</summary>
	/// <param name="a">/@param {vec3} a vector to calculate squared length of</param>
	public static float SquaredLength(float[] a)
	{
		float x = a[0];
		float y = a[1];
		float z = a[2];
		return x * x + y * y + z * z;
	}

	/// <summary>Alias for {@link vec3.subtract}
	/// @function</summary>
	public static float[] Sub(float[] output, float[] a, float[] b)
	{
		return Vec3.Substract(output, a, b);
	}

	/// <summary>Subtracts vector b from vector a
	/// @returns {vec3} out</summary>
	/// <param name="output">/@param {vec3} out the receiving vector</param>
	/// <param name="a">/@param {vec3} a the first operand</param>
	/// <param name="b">/@param {vec3} b the second operand</param>
	public static float[] Substract(float[] output, float[] a, float[] b)
	{
		output[0] = a[0] - b[0];
		output[1] = a[1] - b[1];
		output[2] = a[2] - b[2];
		return output;
	}

	/// <summary>Transforms the vec3 with a mat3.</summary>
	/// <remarks>@returns {vec3} out</remarks>
	/// <param name="output">/@param {vec3} out the receiving vector</param>
	/// <param name="a">/@param {vec3} a the vector to transform</param>
	/// <param name="m">/@param {mat4} m the 3x3 matrix to transform with</param>
	public static float[] TransformMat3(float[] output, float[] a, float[] m)
	{
		float x = a[0];
		float y = a[1];
		float z = a[2];
		output[0] = x * m[0] + y * m[3] + z * m[6];
		output[1] = x * m[1] + y * m[4] + z * m[7];
		output[2] = x * m[2] + y * m[5] + z * m[8];
		return output;
	}

	/// <summary>/Transforms the vec3 with a mat4.</summary>
	/// <remarks>/4th vector component is implicitly '1'
	/// /@returns {vec3} out</remarks>
	/// <param name="output">/@param {vec3} out the receiving vector</param>
	/// <param name="a">/@param {vec3} a the vector to transform</param>
	/// <param name="m">/@param {mat4} m matrix to transform with</param>
	public static float[] TransformMat4(float[] output, float[] a, float[] m)
	{
		float x = a[0];
		float y = a[1];
		float z = a[2];
		output[0] = m[0] * x + m[4] * y + m[8] * z + m[12];
		output[1] = m[1] * x + m[5] * y + m[9] * z + m[13];
		output[2] = m[2] * x + m[6] * y + m[10] * z + m[14];
		return output;
	}

	/// <summary>Transforms the vec3 with a quat
	/// @returns {vec3} out</summary>
	/// <param name="output">/@param {vec3} out the receiving vector</param>
	/// <param name="a">/@param {vec3} a the vector to transform</param>
	/// <param name="q">/@param {quat} q quaternion to transform with</param>
	public static float[] TransformQuat(float[] output, float[] a, float[] q)
	{
		float x = a[0];
		float y = a[1];
		float z = a[2];
		float qx = q[0];
		float qy = q[1];
		float qz = q[2];
		float qw = q[3];
		float ix = qw * x + qy * z - qz * y;
		float iy = qw * y + qz * x - qx * z;
		float iz = qw * z + qx * y - qy * x;
		float iw = (0 - qx) * x - qy * y - qz * z;
		output[0] = ix * qw + iw * (0 - qx) + iy * (0 - qz) - iz * (0 - qy);
		output[1] = iy * qw + iw * (0 - qy) + iz * (0 - qx) - ix * (0 - qz);
		output[2] = iz * qw + iw * (0 - qz) + ix * (0 - qy) - iy * (0 - qx);
		return output;
	}

	/// <summary>/Perform some operation over an array of vec3s.</summary>
	/// <remarks>/@param {Array} a the array of vectors to iterate over
	/// /@param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
	/// /@param {Number} offset Number of elements to skip at the beginning of the array
	/// /@param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
	/// /@param {Function} fn Function to call for each vector in the array
	/// /@param {Object} [arg] additional argument to pass to fn
	/// /@returns {Array} a
	/// /
	/// / Returns a string representation of a vector
	/// /
	/// / @param {vec3} vec vector to represent as a string
	/// / @returns {String} string representation of the vector</remarks>
	public static string str(float[] a)
	{
		return "";
	}
}

public class Vec4
{

	/// <summary>**</summary>
	public static float[] Add(float[] output, float[] a, float[] b)
	{
		output[0] = a[0] + b[0];
		output[1] = a[1] + b[1];
		output[2] = a[2] + b[2];
		output[3] = a[3] + b[3];
		return output;
	}

	/// <summary>**</summary>
	public static float[] CloneIt(float[] a)
	{
		float[] output = new float[4];
		output[0] = a[0];
		output[1] = a[1];
		output[2] = a[2];
		output[3] = a[3];
		return output;
	}

	/// <summary>**</summary>
	public static float[] Copy(float[] output, float[] a)
	{
		output[0] = a[0];
		output[1] = a[1];
		output[2] = a[2];
		output[3] = a[3];
		return output;
	}

	/// <summary>**</summary>
	public static float[] Create()
	{
		float[] output = new float[4];
		output[0] = 0;
		output[1] = 0;
		output[2] = 0;
		output[3] = 0;
		return output;
	}

	/// <summary>**</summary>
	public static float Dist(float[] a, float[] b)
	{
		return Vec4.Distance(a, b);
	}

	/// <summary>**</summary>
	public static float Distance(float[] a, float[] b)
	{
		float x = b[0] - a[0];
		float y = b[1] - a[1];
		float z = b[2] - a[2];
		float w = b[3] - a[3];
		return Platform.Sqrt(x * x + y * y + z * z + w * w);
	}

	/// <summary>**</summary>
	public static float[] Div(float[] output, float[] a, float[] b)
	{
		return Vec4.Divide(output, a, b);
	}

	/// <summary>**</summary>
	public static float[] Divide(float[] output, float[] a, float[] b)
	{
		output[0] = a[0] / b[0];
		output[1] = a[1] / b[1];
		output[2] = a[2] / b[2];
		output[3] = a[3] / b[3];
		return output;
	}

	/// <summary>**</summary>
	public static float Dot(float[] a, float[] b)
	{
		return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
	}

	/// <summary>**</summary>
	public static float[] FromValues(float x, float y, float z, float w)
	{
		float[] output = new float[4];
		output[0] = x;
		output[1] = y;
		output[2] = z;
		output[3] = w;
		return output;
	}

	/// <summary>**</summary>
	public static float Len(float[] a)
	{
		return Vec4.Length_(a);
	}

	/// <summary>**</summary>
	public static float Length_(float[] a)
	{
		float x = a[0];
		float y = a[1];
		float z = a[2];
		float w = a[3];
		return Platform.Sqrt(x * x + y * y + z * z + w * w);
	}

	/// <summary>**</summary>
	public static float[] Lerp(float[] output, float[] a, float[] b, float t)
	{
		float ax = a[0];
		float ay = a[1];
		float az = a[2];
		float aw = a[3];
		output[0] = ax + t * (b[0] - ax);
		output[1] = ay + t * (b[1] - ay);
		output[2] = az + t * (b[2] - az);
		output[3] = aw + t * (b[3] - aw);
		return output;
	}

	/// <summary>**</summary>
	public static float[] Max(float[] output, float[] a, float[] b)
	{
		output[0] = GlMatrixMath.max(a[0], b[0]);
		output[1] = GlMatrixMath.max(a[1], b[1]);
		output[2] = GlMatrixMath.max(a[2], b[2]);
		output[3] = GlMatrixMath.max(a[3], b[3]);
		return output;
	}

	/// <summary>**</summary>
	public static float[] Min(float[] output, float[] a, float[] b)
	{
		output[0] = GlMatrixMath.min(a[0], b[0]);
		output[1] = GlMatrixMath.min(a[1], b[1]);
		output[2] = GlMatrixMath.min(a[2], b[2]);
		output[3] = GlMatrixMath.min(a[3], b[3]);
		return output;
	}

	/// <summary>**</summary>
	public static float[] Mul(float[] output, float[] a, float[] b)
	{
		return Vec4.Multiply(output, a, b);
	}

	/// <summary>**</summary>
	public static float[] Multiply(float[] output, float[] a, float[] b)
	{
		output[0] = a[0] * b[0];
		output[1] = a[1] * b[1];
		output[2] = a[2] * b[2];
		output[3] = a[3] * b[3];
		return output;
	}

	/// <summary>**</summary>
	public static float[] Negate(float[] output, float[] a)
	{
		output[0] = -a[0];
		output[1] = -a[1];
		output[2] = -a[2];
		output[3] = -a[3];
		return output;
	}

	/// <summary>**</summary>
	public static float[] Normalize(float[] output, float[] a)
	{
		float x = a[0];
		float y = a[1];
		float z = a[2];
		float w = a[3];
		float len = x * x + y * y + z * z + w * w;
		if (len > 0) {
			float one = 1;
			len = one / Platform.Sqrt(len);
			output[0] = a[0] * len;
			output[1] = a[1] * len;
			output[2] = a[2] * len;
			output[3] = a[3] * len;
		}
		return output;
	}

	/// <summary>**</summary>
	public static float[] Scale(float[] output, float[] a, float b)
	{
		output[0] = a[0] * b;
		output[1] = a[1] * b;
		output[2] = a[2] * b;
		output[3] = a[3] * b;
		return output;
	}

	/// <summary>**</summary>
	public static float[] ScaleAndAdd(float[] output, float[] a, float[] b, float scale)
	{
		output[0] = a[0] + b[0] * scale;
		output[1] = a[1] + b[1] * scale;
		output[2] = a[2] + b[2] * scale;
		output[3] = a[3] + b[3] * scale;
		return output;
	}

	/// <summary>**</summary>
	public static float[] Set(float[] output, float x, float y, float z, float w)
	{
		output[0] = x;
		output[1] = y;
		output[2] = z;
		output[3] = w;
		return output;
	}

	/// <summary>**</summary>
	public static float SqrDist(float[] a, float[] b)
	{
		return Vec4.SquaredDistance(a, b);
	}

	/// <summary>**</summary>
	public static float SqrLen(float[] a)
	{
		return Vec4.SquaredLength(a);
	}

	/// <summary>**</summary>
	public static float SquaredDistance(float[] a, float[] b)
	{
		float x = b[0] - a[0];
		float y = b[1] - a[1];
		float z = b[2] - a[2];
		float w = b[3] - a[3];
		return x * x + y * y + z * z + w * w;
	}

	/// <summary>**</summary>
	public static float SquaredLength(float[] a)
	{
		float x = a[0];
		float y = a[1];
		float z = a[2];
		float w = a[3];
		return x * x + y * y + z * z + w * w;
	}

	/// <summary>**</summary>
	public static float[] Sub(float[] output, float[] a, float[] b)
	{
		return Vec4.Subtract(output, a, b);
	}

	/// <summary>**</summary>
	public static float[] Subtract(float[] output, float[] a, float[] b)
	{
		output[0] = a[0] - b[0];
		output[1] = a[1] - b[1];
		output[2] = a[2] - b[2];
		output[3] = a[3] - b[3];
		return output;
	}

	/// <summary>**</summary>
	public static float[] TransformMat4(float[] output, float[] a, float[] m)
	{
		float x = a[0];
		float y = a[1];
		float z = a[2];
		float w = a[3];
		output[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
		output[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
		output[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
		output[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
		return output;
	}

	/// <summary>**
	/// **</summary>
	void f()
	{
	}

	/// <summary>**</summary>
	public static float[] transformQuat(float[] output, float[] a, float[] q)
	{
		float x = a[0];
		float y = a[1];
		float z = a[2];
		float qx = q[0];
		float qy = q[1];
		float qz = q[2];
		float qw = q[3];
		float ix = qw * x + qy * z - qz * y;
		float iy = qw * y + qz * x - qx * z;
		float iz = qw * z + qx * y - qy * x;
		float iw = -qx * x - qy * y - qz * z;
		output[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
		output[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
		output[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
		return output;
	}
}

public class VecCito3i
{

	public void Add(int _x, int _y, int _z, VecCito3i result)
	{
		result.x = this.x + _x;
		result.y = this.y + _y;
		result.z = this.z + _z;
	}

	public static VecCito3i CitoCtr(int _x, int _y, int _z)
	{
		VecCito3i v = new VecCito3i();
		v.x = _x;
		v.y = _y;
		v.z = _z;
		return v;
	}
	public int x;
	public int y;
	public int z;
}

public class Vector3Float
{
	internal float value;
	internal int x;
	internal int y;
	internal int z;
}

public class Vector3IntRef
{

	internal static Vector3IntRef Create(int x, int y, int z)
	{
		Vector3IntRef v = new Vector3IntRef();
		v.X = x;
		v.Y = y;
		v.Z = z;
		return v;
	}
	internal int X;
	internal int Y;
	internal int Z;
}

public class Vector3Ref
{

	internal static Vector3Ref Create(float x, float y, float z)
	{
		Vector3Ref v = new Vector3Ref();
		v.X = x;
		v.Y = y;
		v.Z = z;
		return v;
	}

	public float GetX()
	{
		return this.X;
	}

	public float GetY()
	{
		return this.Y;
	}

	public float GetZ()
	{
		return this.Z;
	}

	internal float Length()
	{
		return Platform.Sqrt(this.X * this.X + this.Y * this.Y + this.Z * this.Z);
	}

	internal void Normalize()
	{
		float length = this.Length();
		this.X = this.X / length;
		this.Y = this.Y / length;
		this.Z = this.Z / length;
	}
	internal float X;
	internal float Y;
	internal float Z;
}

public class VectorTool
{

	public static void ToVectorInFixedSystem(float dx, float dy, float dz, float orientationx, float orientationy, Vector3Ref output)
	{
		if (dx == 0 && dy == 0 && dz == 0) {
			output.X = 0;
			output.Y = 0;
			output.Z = 0;
			return;
		}
		float xRot = orientationx;
		float yRot = orientationy;
		float x = dx * Platform.Cos(yRot) + dy * Platform.Sin(xRot) * Platform.Sin(yRot) - dz * Platform.Cos(xRot) * Platform.Sin(yRot);
		float y = dy * Platform.Cos(xRot) + dz * Platform.Sin(xRot);
		float z = dx * Platform.Sin(yRot) - dy * Platform.Sin(xRot) * Platform.Cos(yRot) + dz * Platform.Cos(xRot) * Platform.Cos(yRot);
		output.X = x;
		output.Y = y;
		output.Z = z;
	}
}

/// <summary>&lt;summary&gt;
/// Each RailDirection on tile can be traversed by train in two directions.</summary>
/// <remarks>&lt;/summary&gt;
/// &lt;example&gt;
/// RailDirection.Horizontal -&gt; VehicleDirection12.HorizontalLeft (vehicle goes left and decreases x position),
/// and VehicleDirection12.HorizontalRight (vehicle goes right and increases x position).
/// &lt;/example&gt;</remarks>
public enum VehicleDirection12
{
	HorizontalLeft,
	HorizontalRight,
	VerticalUp,
	VerticalDown,
	UpLeftUp,
	UpLeftLeft,
	UpRightUp,
	UpRightRight,
	DownLeftDown,
	DownLeftLeft,
	DownRightDown,
	DownRightRight
}

public class VehicleDirection12Flags
{
	public const int DownLeftDown = 256;
	public const int DownLeftLeft = 512;
	public const int DownRightDown = 1024;
	public const int DownRightRight = 2048;
	public const int HorizontalLeft = 1;
	public const int HorizontalRight = 2;
	public const int None = 0;
	public const int UpLeftLeft = 32;
	public const int UpLeftUp = 16;
	public const int UpRightRight = 128;
	public const int UpRightUp = 64;
	public const int VerticalDown = 8;
	public const int VerticalUp = 4;
}

public class VerticesIndicesToLoad
{
	internal ModelData modelData;
	internal float positionX;
	internal float positionY;
	internal float positionZ;
	internal int texture;
	internal bool transparent;
}

public class VisibleDialog
{
	internal string key;
	internal GameScreen screen;
	internal Packet_Dialog value;
}

public class WearPlace_
{
	public const int Boots = 2;
	public const int Gauntlet = 4;
	public const int Helmet = 3;
	public const int MainArmor = 1;
	public const int RightHand = 0;
}

public class WebSocketClient : NetClient
{
	public WebSocketClient()
	{
		this.incomingData = new byte[16384];
	}

	public override NetConnection Connect(string ip, int port)
	{
		this.p.WebSocketConnect(ip, port);
		this.c.address = this.p.StringFormat2("{0}:{1}", ip, this.p.IntToString(port));
		this.c.platform = this.p;
		return this.c;
	}

	public override NetIncomingMessage ReadMessage()
	{
		int received = this.p.WebSocketReceive(this.incomingData, 16384);
		if (received == -1) {
			return null;
		}
		else {
			NetIncomingMessage msg = new NetIncomingMessage();
			msg.message = this.incomingData;
			msg.messageLength = received;
			msg.SenderConnection = this.c;
			return msg;
		}
	}

	public override void SendMessage(INetOutgoingMessage message, MyNetDeliveryMethod method)
	{
		this.c.SendMessage(message, method, 0);
	}

	internal void SetPlatform(GamePlatform platform)
	{
		this.p = platform;
	}

	public override void Start()
	{
		this.c = new WebSocketClientConnection();
	}
	WebSocketClientConnection c;
	byte[] incomingData;
	GamePlatform p;
}

public class WebSocketClientConnection : NetConnection
{

	public override bool EqualsConnection(NetConnection connection)
	{
		return true;
	}

	public override IPEndPointCi RemoteEndPoint()
	{
		return IPEndPointCiDefault.Create(this.address);
	}

	public override void SendMessage(INetOutgoingMessage msg, MyNetDeliveryMethod method, int sequenceChannel)
	{
		this.platform.WebSocketSend(msg.message, msg.messageLength);
	}

	public override void Update()
	{
	}
	internal string address;
	internal GamePlatform platform;
}

public enum WidgetType
{
	Button,
	Textbox,
	Label
}

public enum WindowState
{
	Normal,
	Minimized,
	Maximized,
	Fullscreen
}

/// <summary>// &lt;summary&gt;
/// // Wrapper for streams that does not support the Position property
/// // &lt;/summary&gt;</summary>
public class Wire
{
	public const int Fixed32 = 5;
	public const int Fixed64 = 1;
	public const int LengthDelimited = 2;
	public const int Varint = 0;
}

public class WireframeCube
{

	static void AddVertex(ModelData model, float x, float y, float z, float u, float v, int color)
	{
		model.xyz[model.GetXyzCount() + 0] = x;
		model.xyz[model.GetXyzCount() + 1] = y;
		model.xyz[model.GetXyzCount() + 2] = z;
		model.uv[model.GetUvCount() + 0] = u;
		model.uv[model.GetUvCount() + 1] = v;
		model.rgba[model.GetRgbaCount() + 0] = Game.IntToByte(Game.ColorR(color));
		model.rgba[model.GetRgbaCount() + 1] = Game.IntToByte(Game.ColorG(color));
		model.rgba[model.GetRgbaCount() + 2] = Game.IntToByte(Game.ColorB(color));
		model.rgba[model.GetRgbaCount() + 3] = Game.IntToByte(Game.ColorA(color));
		model.verticesCount++;
	}

	static void DrawLineLoop(ModelData m, Vector3Ref p0, Vector3Ref p1, Vector3Ref p2, Vector3Ref p3)
	{
		int startVertex = m.GetVerticesCount();
		WireframeCube.AddVertex(m, p0.X, p0.Y, p0.Z, 0, 0, Game.ColorFromArgb(255, 255, 255, 255));
		WireframeCube.AddVertex(m, p1.X, p1.Y, p1.Z, 0, 0, Game.ColorFromArgb(255, 255, 255, 255));
		WireframeCube.AddVertex(m, p2.X, p2.Y, p2.Z, 0, 0, Game.ColorFromArgb(255, 255, 255, 255));
		WireframeCube.AddVertex(m, p3.X, p3.Y, p3.Z, 0, 0, Game.ColorFromArgb(255, 255, 255, 255));
		m.indices[m.indicesCount++] = startVertex + 0;
		m.indices[m.indicesCount++] = startVertex + 1;
		m.indices[m.indicesCount++] = startVertex + 1;
		m.indices[m.indicesCount++] = startVertex + 2;
		m.indices[m.indicesCount++] = startVertex + 2;
		m.indices[m.indicesCount++] = startVertex + 3;
		m.indices[m.indicesCount++] = startVertex + 3;
		m.indices[m.indicesCount++] = startVertex + 0;
	}

	public static ModelData Get()
	{
		ModelData m = new ModelData();
		m.setMode(1);
		m.xyz = new float[72];
		m.uv = new float[48];
		m.rgba = new byte[96];
		m.indices = new int[48];
		WireframeCube.DrawLineLoop(m, Vector3Ref.Create(-1, -1, -1), Vector3Ref.Create(-1, 1, -1), Vector3Ref.Create(1, 1, -1), Vector3Ref.Create(1, -1, -1));
		WireframeCube.DrawLineLoop(m, Vector3Ref.Create(-1, -1, -1), Vector3Ref.Create(1, -1, -1), Vector3Ref.Create(1, -1, 1), Vector3Ref.Create(-1, -1, 1));
		WireframeCube.DrawLineLoop(m, Vector3Ref.Create(-1, -1, -1), Vector3Ref.Create(-1, -1, 1), Vector3Ref.Create(-1, 1, 1), Vector3Ref.Create(-1, 1, -1));
		WireframeCube.DrawLineLoop(m, Vector3Ref.Create(-1, -1, 1), Vector3Ref.Create(1, -1, 1), Vector3Ref.Create(1, 1, 1), Vector3Ref.Create(-1, 1, 1));
		WireframeCube.DrawLineLoop(m, Vector3Ref.Create(-1, 1, -1), Vector3Ref.Create(-1, 1, 1), Vector3Ref.Create(1, 1, 1), Vector3Ref.Create(1, 1, -1));
		WireframeCube.DrawLineLoop(m, Vector3Ref.Create(1, -1, -1), Vector3Ref.Create(1, 1, -1), Vector3Ref.Create(1, 1, 1), Vector3Ref.Create(1, -1, 1));
		return m;
	}
}
